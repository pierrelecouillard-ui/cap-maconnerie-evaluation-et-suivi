import React, { useState, useEffect } from "react";
import { createPortal } from "react-dom";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import { Label } from "@/components/ui/label";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
// NOTE: Les menus Radix/Shadcn (Select) peuvent provoquer un "reflow"/décalage du bandeau
// selon les conteneurs (overflow/transform). Pour garantir qu'aucune liste ne pousse la page,
// on utilise des <select> natifs pour les 3 sélecteurs (Classe / Élève / Épreuve) dans l'en-tête CCF.
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import {
  DropdownMenu,
  DropdownMenuCheckboxItem,
  DropdownMenuContent,
  DropdownMenuLabel,
  DropdownMenuItem,
  DropdownMenuSeparator, DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import {
  Image as ImageIcon,
  ChevronRight,
  ChevronLeft,
  Sun,
  Moon,
  Plus,
  X,
  Trash2,
  Settings2,
  Download,
  Upload,
  Search,              // ← ajouté
} from "lucide-react";
import { appDataDir, appLocalDataDir, join } from '@tauri-apps/api/path';
import {
  ResponsiveContainer,
  BarChart,
  Bar,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  Legend,
  ReferenceArea,
  ReferenceLine,
} from "recharts";
import { RotateCcw } from "lucide-react";

// FS → plugin-fs
import {
  mkdir,
  writeTextFile,
  writeFile,
  readTextFile,
  readDir,
  exists,
  BaseDirectory,
  rename,
  remove,
  readFile,
  stat,
} from '@tauri-apps/plugin-fs';

// DIALOG → plugin-dialog
import { open, confirm, save } from '@tauri-apps/plugin-dialog';

// Excel parsing
import * as ExcelJS from "exceljs";
import JSZip from "jszip";

import { WebviewWindow } from '@tauri-apps/api/webviewWindow';
import { getCurrentWindow } from '@tauri-apps/api/window';
import FirstRunHelp from "./components/FirstRunHelp";

import { fetch as tauriFetch } from "@tauri-apps/plugin-http";
import { check } from "@tauri-apps/plugin-updater";
import { relaunch } from "@tauri-apps/plugin-process";


function classNames(...s: (string | false | null | undefined)[]) {
  return s.filter(Boolean).join(" ");
}
function parseCompetencyFamily(compLabel: string): "C1" | "C2" | "C3" | "C4" | "OTHER" {
  const m = compLabel.match(/C\s*(\d)\s*\./);
  if (!m) return "OTHER";
  const n = Number(m[1]);
  if (n === 1) return "C1";
  if (n === 2) return "C2";
  if (n === 3) return "C3";
  if (n === 4) return "C4";
  return "OTHER";
}
function compactCode(compLabel: string) {
  const m = compLabel.match(/C\s*(\d)\s*\.(\d+)/);
  if (!m) return compLabel;
  return `C${m[1]}.${m[2]}`;
}
function taskNumber(taskLabel: string) {
  const m = String(taskLabel || "").match(/T\s*0*(\d+)/i);
  return m ? Number(m[1]) : Number.MAX_SAFE_INTEGER;
}
function sortByTaskNumber(labels: string[]) {
  return labels.slice().sort((a, b) => taskNumber(a) - taskNumber(b));
}

function ensureCapLabel(title: string) {
  const t = (title || "").trim();
  if (!t) return t;
  return /^cap\b/i.test(t) ? t : `CAP ${t}`;
}
function parseScopedCritKey(key: string): { task: string | null; comp: string; item: string } {
  const [left, item] = key.split("::");
  if (left.includes("||")) {
    const [task, comp] = left.split("||");
    return { task, comp, item };
  }
  return { task: null, comp: left, item };
}


const CCF_TEMPLATES = {
  "EP1": [
    {
      "code": "C1.1",
      "title": "Compléter et transmettre des documents",
      "groupPoints": 5.0,
      "items": [
        {
          "code": "C1.1.1",
          "label": "Prendre connaissance d’une consigne, d’un document technique",
          "criteria": "La consigne, le document et leurs finalités sont compris et respectés.",
          "relative": 0.4,
          "realWeight": 10.0
        },
        {
          "code": "C1.1.2",
          "label": "Compléter et transmettre un document technique",
          "criteria": "critères d'évaluation",
          "relative": 0.6,
          "realWeight": 15.0
        }
      ]
    },
    {
      "code": "C2.1",
      "title": "Décoder un dossier technique",
      "groupPoints": 8.0,
      "items": [
        {
          "code": "C2.1.1",
          "label": "Collecter et ordonner des informations techniques",
          "criteria": "Les conditions d’intervention sur site (spécificités du chantier) sont identifiées.                                         Les données techniques nécessaires à son intervention sont identifiées.              La collecte et le classement des informations nécessaires à l’intervention\nest complète et exploitable.                                                                                          La terminologie anglaise est comprise et traduite.",
          "relative": 0.65,
          "realWeight": 26.0
        },
        {
          "code": "C2.1.2",
          "label": "Effectuer un croquis manuellement ou avec un outil digital :\n    - d’une solution technique,\n    - d’une partie d’un ouvrage.",
          "criteria": "La représentation des détails (croquis, schémas, …) permet la réalisation.                                           Les conventions de représentation et les normes de dessin technique sont\nrespectées.",
          "relative": 0.35,
          "realWeight": 14.0
        }
      ]
    },
    {
      "code": "C2.2",
      "title": "Choisir les matériels et les outillages",
      "groupPoints": 7.0,
      "items": [
        {
          "code": "C2.2.1",
          "label": "Identifier et vérifier la compatibilité du matériel et de l’outillage nécessaires à la réalisation de son intervention.",
          "criteria": "Les matériels et l’outillage nécessaires sont conformes aux préconisations.       Les règles et limites d’utilisation des matériels et de l’outillage sont respectées. Les accessoires et consommables nécessaires sont identifiés.",
          "relative": 0.6,
          "realWeight": 21.0
        },
        {
          "code": "C2.2.2",
          "label": "Inventorier, sélectionner et lister les EPC et les EPI nécessaires et adaptés à l’intervention.",
          "criteria": "L’inventaire des EPC et des EPI est complet et adapté à l’intervention.                Les éléments d’EPC et d’EPI sélectionnés sont adaptés à l’intervention.              Les listes établies sont complètes et exploitables.",
          "relative": 0.4,
          "realWeight": 14.0
        }
      ]
    }
  ],
  "EP2A1": [
    {
      "code": "C2.3",
      "title": "Déterminer des quantités de matériaux et composants",
      "groupPoints": 20.000000000000004,
      "items": [
        {
          "code": "C2.3.1",
          "label": "Identifier les matériaux et composants nécessaires à son intervention.",
          "criteria": "La nature et les caractéristiques des matériaux et composants sont conformes aux indications du dossier d’exécution.",
          "relative": 0.25,
          "realWeight": 2.0
        },
        {
          "code": "C2.3.2",
          "label": "Apprécier la qualité des matériaux.",
          "criteria": "La qualité correspond aux besoins de l’exécution.",
          "relative": 0.25,
          "realWeight": 2.0
        },
        {
          "code": "C2.3.3",
          "label": "Déterminer les quantités de matériaux et composants nécessaires à son intervention.",
          "criteria": "Les quantités nécessaires à l’exécution sont estimées.                                               Les quantités consommées et l’état des stocks de matériaux sont communiqués à sa hiérarchie.                                                                                                                            Les unités sont adaptées aux quantités estimées.",
          "relative": 0.5,
          "realWeight": 4.0
        }
      ]
    },
    {
      "code": "C3.1",
      "title": "Organiser son poste de travail",
      "groupPoints": null,
      "items": [
        {
          "code": "C3.1.1",
          "label": "Organiser son poste de travail",
          "criteria": "Les spécificités du chantier sont identifiées.                                                                                  La co-activité est prise en compte.                                                                                                     Les anomalies techniques sont repérées et signalées.                                                   Les dispositifs de sécurité sont mis en place et maintenu dans toutes les phases d’exécution.",
          "relative": 0.3333333333333333,
          "realWeight": 2.0
        },
        {
          "code": "C3.1.2",
          "label": "Adapter son poste de travail à l’évolution du chantier",
          "criteria": "L’organisation du poste de travail est adaptée à l’avancement des travaux.",
          "relative": 0.16666666666666666,
          "realWeight": 1.0
        },
        {
          "code": "C3.1.3",
          "label": "Approvisionner son poste de travail",
          "criteria": "L'approvisionnement des matériaux, matériels, outillages à proximité de la réalisation permet :\n- la réalisation rationnelle de l’intervention.                                                                           - l’avancement chronologique des travaux                                                                                                               Les matériaux et éléments approvisionnés correspondent en quantité et qualité à l’intervention.",
          "relative": 0.3333333333333333,
          "realWeight": 2.0
        }
      ]
    },
    {
      "code": "C3.2",
      "title": "Sécuriser son intervention",
      "groupPoints": null,
      "items": [
        {
          "code": "C3.2.1",
          "label": "Identifier les dangers propres à son intervention",
          "criteria": "Les dangers sont identifiés de manière exhaustive.",
          "relative": 0.4,
          "realWeight": 2.0
        },
        {
          "code": "C3.2.2",
          "label": "Appliquer les mesures de prévention prévues",
          "criteria": "Une démarche de prévention dans son environnement de travail est mise en œuvre.\nL’installation du poste de travail garantit la sécurité et la protection de la santé.\nLes EPC, et particulièrement la signalisation permanente et provisoire, et la protection du chantier sont respectés. \nLes consignes d’utilisation et de dépose de la signalisation sont respectées.\nLes EPI utilisés sont adaptés à la situation.\nLes consignes de sécurité collective et individuelle sont respectées.",
          "relative": 0.2,
          "realWeight": 1.0
        },
        {
          "code": "C3.2.3",
          "label": "Alerter en cas de situation dangereuse.",
          "criteria": "Une situation dangereuse persistante est signalée à sa hiérarchie.\nLe droit de retrait est appliqué en cas de danger grave et imminent.",
          "relative": 0.4,
          "realWeight": 0.0
        }
      ]
    },
    {
      "code": "C3.4",
      "title": "Monter, démonter et utiliser un échafaudage (En référence aux recommandation R408)",
      "groupPoints": null,
      "items": [
        {
          "code": "C3.4.1",
          "label": "Monter et démonter un échafaudage fixe (échafaudage de pied ou sur tréteaux)",
          "criteria": "Le montage et le démontage sont effectués en conformité avec la notice de montage du matériel et la règlementation.\nTout élément défectueux est signalé immédiatement.\nLes affichages, les balisages et les signalisations sont conformément installés.\nLes biens environnants sont protégés et sauvegardés.",
          "relative": 0.5,
          "realWeight": 0.0
        },
        {
          "code": "C3.4.2",
          "label": "Utiliser un échafaudage de pied fixe (échafaudage de pied ou sur tréteaux)",
          "criteria": "Les règles de déplacement et de stabilisation de l’échafaudage sont respectées.\nLes règles d’accès et de circulation sur l’échafaudage sont respectées.\nLa charge autorisée sur l’échafaudage est respectée.\nLa répartition de la charge est conforme aux préconisations du fabricant.\nL’échafaudage est maintenu en sécurité.",
          "relative": 0.5,
          "realWeight": 0.0
        }
      ]
    },
    {
      "code": "C3.6",
      "title": "Implanter et tracer des ouvrages",
      "groupPoints": null,
      "items": [
        {
          "code": "C3.6.1",
          "label": "Réaliser une implantation planimétrique et altimétrique d’un élément d’ouvrage.",
          "criteria": "Les points ou alignements de référence sont identifiés.\nLe plan d’implantation est respecté.\nLes chaises et repères d’implantation sont stables et correctement positionnées.",
          "relative": 0.7142857142857143,
          "realWeight": 5.0
        },
        {
          "code": "C3.6.2",
          "label": "Tracer des ouvrages sur différents supports.",
          "criteria": "Les tracés ou les épures respectent les plans de définition et permettent la réalisation de l’ouvrage.",
          "relative": 0.2857142857142857,
          "realWeight": 2.0
        }
      ]
    },
    {
      "code": "C3.9",
      "title": "Réaliser et mettre en place des coffrages",
      "groupPoints": null,
      "items": [
        {
          "code": "C3.9.1",
          "label": "Fabriquer, assembler, mettre en place un coffrage traditionnel réutilisable et décoffrer.",
          "criteria": "Le coffrage permet de respecter :\n-\tles formes et dimensions de l’ouvrage ;\n-\tla qualité de parement prescrit ;\n-\tla poussée du béton frais ; \n-\tl’étanchéité ;\n-\tun décoffrage  aisé ;\n-\tles dispositifs de sécurité sont mis en place et maintenu dans toutes les phases d’exécution.",
          "relative": 0.3,
          "realWeight": 3.0
        },
        {
          "code": "C3.9.2",
          "label": "Mettre en place des coffrages outils manu portables, coffrages perdus.",
          "criteria": "Le réglage et la mise en place du coffrage permettent de respecter les exigences de planéité, verticalité, aspect.                                                                                          Les inserts, réservations et négatifs sont correctement positionnés.\nLes dispositifs de sécurité sont mis en place et maintenus dans toutes les phases d’exécution.",
          "relative": 0.3,
          "realWeight": 3.0
        }
      ]
    },
    {
      "code": "C3.10",
      "title": "Mettre en place des armatures",
      "groupPoints": null,
      "items": [
        {
          "code": "C3.10.1",
          "label": "Mettre en place des armatures.",
          "criteria": "Les diamètres, les quantités, la position et le sens de pose des aciers et des cages sont respectées.                                                                                                                          Les châssis et cages d’armatures sont rigides.",
          "relative": 0.42857142857142855,
          "realWeight": 0.0
        },
        {
          "code": "C3.10.2",
          "label": "Façonner des armatures complémentaires.",
          "criteria": "Les armatures façonnées sont conformes au plan et à la nomenclature.",
          "relative": 0.2857142857142857,
          "realWeight": 0.0
        }
      ]
    },
    {
      "code": "C3.11",
      "title": "Fabriquer et mettre en œuvre des bétons courants, bio et géo-sourcés",
      "groupPoints": null,
      "items": [
        {
          "code": "C3.11.1",
          "label": "Fabriquer du béton.",
          "criteria": "La composition du béton est établie à partir d’une méthode simple et correspond aux attentes du cahier des charges.                                                                                                                                                                          La consistance du béton est conforme aux prescriptions.",
          "relative": 0.2,
          "realWeight": 2.0
        },
        {
          "code": "C3.11.2",
          "label": "Mettre en œuvre du béton.",
          "criteria": "Le choix du matériel de manutention et de transport est adapté à l’ouvrage.\nLe mode opératoire de mise en œuvre du béton est respecté.                                Les moyens de serrage sont adaptés (vibration, damage, compactage, …).\nLa tenue des coffrages est contrôlée pendant et après bétonnage.",
          "relative": 0.4,
          "realWeight": 4.0
        },
        {
          "code": "C3.11.3",
          "label": "Traiter les surfaces et assurer les finitions manuelles.",
          "criteria": "L’aspect de surfaçage est conforme aux prescriptions.                                                   Le mode opératoire est respecté.                                                                                        Le délai de cure du béton est respecté.",
          "relative": 0.2,
          "realWeight": 2.0
        }
      ]
    },
    {
      "code": "C3.12",
      "title": "Réaliser des maçonneries de petits éléments",
      "groupPoints": null,
      "items": [
        {
          "code": "C3.12.1",
          "label": "Confectionner les mortiers de hourdage ou colles en adéquation avec les matériaux à assembler.",
          "criteria": "Le mortier ou la colle réalisés correspond à l’usage et à l’aspect demandé (type de liant, plasticité, dosage des constituants y compris adjuvants).                                La quantité de mortier ou colle à gâcher est suffisante, correspond au besoin et réalisée en sécurité.",
          "relative": 0.3,
          "realWeight": 3.0
        },
        {
          "code": "C3.12.2",
          "label": "Mettre en place les repères de hauteur et d’alignement (piges,  balises, cordeaux …).",
          "criteria": "Le positionnement des repères permet le respect du calepinage.",
          "relative": 0.1,
          "realWeight": 1.0
        },
        {
          "code": "C3.12.3",
          "label": "Réaliser un appareillage courant pour des maçonneries apparentes.",
          "criteria": "Les appareillages et harpages réalisés sont conformes aux normes en vigueur et aux règles de l’art.",
          "relative": 0.2,
          "realWeight": 2.0
        },
        {
          "code": "C3.12.4",
          "label": "Réaliser des ouvrages en maçonnerie.",
          "criteria": "La mise en œuvre respecte les normes et règles en vigueur :\n- La planéité, la verticalité et l’horizontalité propres à chaque matériau respectent les exigences ;\n- L’épaisseur des joints est conforme aux règles des textes normatifs ;\n- Les règles de liaisonnement sont respectées.                                                                   Les temps d’exécution sont respectés.",
          "relative": 0.4,
          "realWeight": 4.0
        }
      ]
    },
    {
      "code": "C3.15",
      "title": "Réaliser les finitions d’un ouvrage vertical",
      "groupPoints": null,
      "items": [
        {
          "code": "C3.15.1",
          "label": "Réaliser des enduits verticaux.",
          "criteria": "La nature du support est identifiée.\nLes matériaux mis en œuvre sont adaptés au support.                                                  Les ouvrages environnants sont protégés.\nLes mortiers utilisés et leurs mises en œuvre sont conformes aux règles et normes en vigueur, aux avis techniques et ou aux prescriptions du fabricant.",
          "relative": 0.25,
          "realWeight": 2.0
        },
        {
          "code": "C3.15.2",
          "label": "Réaliser des jointoiements ou rejointoiements.",
          "criteria": "La nature du support est identifiée.\nLes ouvrages environnants sont protégés.\nLes mortiers utilisés sont compatibles avec les supports et leur mise en œuvre sont conformes aux règles et normes en vigueur, aux avis techniques et ou aux prescriptions du fabricant.                                                                                                L’aspect est conforme aux prescriptions.",
          "relative": 0.375,
          "realWeight": 3.0
        }
      ]
    },
    {
      "code": "C3.16",
      "title": "Réaliser les finitions d’un ouvrage horizontal",
      "groupPoints": null,
      "items": [
        {
          "code": "C3.16.1",
          "label": "Réaliser des ouvrages de finition en béton.",
          "criteria": "La composition et la consistance des bétons et mortiers sont adaptées à la destination de l’ouvrage.                                                                                                           Les états de surface et les arêtes sont traités conformément aux prescriptions. Les caractéristiques dimensionnelles et fonctionnelles des ouvrages sont respectées.                                                                                                                                        Le positionnement altimétrique est conforme au plan.",
          "relative": 0.375,
          "realWeight": 3.0
        },
        {
          "code": "C3.16.2",
          "label": "Réaliser des chapes.",
          "criteria": "La nature du support est identifiée.                                                                                       Les ouvrages environnants sont protégés.                                                                        Les matériaux mis en œuvre sont adaptés au support.                                                     Les mortiers utilisés et leur mise en œuvre sont conformes aux règles et normes en vigueur, aux avis techniques et ou aux prescriptions du fabricant.",
          "relative": 0.375,
          "realWeight": 3.0
        }
      ]
    },
    {
      "code": "C3.17",
      "title": "Préparer, utiliser et entretenir les matériels et outillages",
      "groupPoints": null,
      "items": [
        {
          "code": "C3.17.1",
          "label": "Contrôler, avant utilisation, l’état :\n- du matériel et de ses protections ;\n- des outils et accessoires.",
          "criteria": "Tout manquement ou anomalie est signalé à la hiérarchie.",
          "relative": 0.25,
          "realWeight": 1.0
        },
        {
          "code": "C3.17.2",
          "label": "Mettre en place le matériel ou l’outillage en fonction de la tâche à réaliser.",
          "criteria": "Le montage ou l’installation respecte scrupuleusement les indications du fabricant.                                                                                                                             La configuration retenue permet une utilisation aisée et en toute sécurité.",
          "relative": 0.25,
          "realWeight": 1.0
        },
        {
          "code": "C3.17.3",
          "label": "Vérifier et assurer la maintenance courante du matériel et de l’outillage.",
          "criteria": "Les éventuelles anomalies sont signalées à la hiérarchie.",
          "relative": 0.25,
          "realWeight": 1.0
        },
        {
          "code": "C3.17.4",
          "label": "Replier le matériel ou l’outillage en vue d’une utilisation ultérieure.",
          "criteria": "Le matériel ou l’outillage est mis en état (prêt à servir) et rangé aux endroits dédiés.",
          "relative": 0.25,
          "realWeight": 1.0
        }
      ]
    },
    {
      "code": "C4.1",
      "title": "Contrôler la nature et la conformité des supports",
      "groupPoints": null,
      "items": [
        {
          "code": "C4.1.1",
          "label": "Identifier la nature du support.",
          "criteria": "La nature du support est identifiée ou renseignée.",
          "relative": 0.3333333333333333,
          "realWeight": 1.0
        },
        {
          "code": "C4.1.2",
          "label": "Contrôler l’état des supports.",
          "criteria": "Les contrôles de cohésion, planimétrie, propreté, aplombs, équerrage sont effectués conformément aux procédures techniques ou normatives.\nLes données relevées sont comparées avec les exigences imposées par les textes normatifs et réglementaires. \nLes écarts à la conformité constatés sont signalés.",
          "relative": 0.6666666666666666,
          "realWeight": 2.0
        }
      ]
    },
    {
      "code": "C4.2",
      "title": "Contrôler le travail réalisé en cours d’exécution et en fin de travaux",
      "groupPoints": null,
      "items": [
        {
          "code": "C4.2.1",
          "label": "Préparer les moyens de contrôle",
          "criteria": "Les moyens sont adaptés aux contrôles à réaliser.",
          "relative": 0.25,
          "realWeight": 1.0
        },
        {
          "code": "C4.2.2",
          "label": "Réaliser les contrôles en cours de réalisation et en fin de travaux.",
          "criteria": "Les protocoles de contrôle et les techniques d’utilisation des matériels sont respectés.                                                                                                                                         Les contrôles permettent les corrections éventuelles et la poursuite des travaux puis la réception.",
          "relative": 0.25,
          "realWeight": 1.0
        },
        {
          "code": "C4.2.3",
          "label": "Mettre en œuvre une méthode d’autocontrôle de son travail.",
          "criteria": "Les points de contrôle sont identifiés et judicieux.                                                            Les contrôles permettent de vérifier la conformité du travail confié.\nLa fréquence des contrôles est adaptée au travail réalisé.                                      Les résultats des contrôles garantissent la conformité du travail confié.\nLes défauts sont repérés, corrigés ou communiqués à la hiérarchie.",
          "relative": 0.25,
          "realWeight": 1.0
        },
        {
          "code": "C4.2.4",
          "label": "Appliquer une procédure d’autocontrôle établie.",
          "criteria": "La procédure établie pour les autocontrôles est respectée.                                               Les fiches d’autocontrôles sont renseignées et transmises.",
          "relative": 0.25,
          "realWeight": 1.0
        }
      ]
    }
  ],
  "EP2A2": [
    {
      "code": "C2.3",
      "title": "Déterminer des quantités de matériaux et composants",
      "groupPoints": 20.000000000000004,
      "items": [
        {
          "code": "C2.3.1",
          "label": "Identifier les matériaux et composants nécessaires à son intervention.",
          "criteria": "La nature et les caractéristiques des matériaux et composants sont conformes aux indications du dossier d’exécution.",
          "relative": 0.25,
          "realWeight": 2.0
        },
        {
          "code": "C2.3.2",
          "label": "Apprécier la qualité des matériaux.",
          "criteria": "La qualité correspond aux besoins de l’exécution.",
          "relative": 0.25,
          "realWeight": 2.0
        },
        {
          "code": "C2.3.3",
          "label": "Déterminer les quantités de matériaux et composants nécessaires à son intervention.",
          "criteria": "Les quantités nécessaires à l’exécution sont estimées.                                               Les quantités consommées et l’état des stocks de matériaux sont communiqués à sa hiérarchie.                                                                                                                            Les unités sont adaptées aux quantités estimées.",
          "relative": 0.5,
          "realWeight": 4.0
        }
      ]
    },
    {
      "code": "C3.1",
      "title": "Organiser son poste de travail",
      "groupPoints": null,
      "items": [
        {
          "code": "C3.1.1",
          "label": "Organiser son poste de travail",
          "criteria": "Les spécificités du chantier sont identifiées.                                                                                  La co-activité est prise en compte.                                                                                                     Les anomalies techniques sont repérées et signalées.                                                   Les dispositifs de sécurité sont mis en place et maintenu dans toutes les phases d’exécution.",
          "relative": 0.3333333333333333,
          "realWeight": 2.0
        },
        {
          "code": "C3.1.2",
          "label": "Adapter son poste de travail à l’évolution du chantier",
          "criteria": "L’organisation du poste de travail est adaptée à l’avancement des travaux.",
          "relative": 0.16666666666666666,
          "realWeight": 1.0
        },
        {
          "code": "C3.1.3",
          "label": "Approvisionner son poste de travail",
          "criteria": "L'approvisionnement des matériaux, matériels, outillages à proximité de la réalisation permet :\n- la réalisation rationnelle de l’intervention.                                                                           - l’avancement chronologique des travaux                                                                                                               Les matériaux et éléments approvisionnés correspondent en quantité et qualité à l’intervention.",
          "relative": 0.3333333333333333,
          "realWeight": 2.0
        }
      ]
    },
    {
      "code": "C3.2",
      "title": "Sécuriser son intervention",
      "groupPoints": null,
      "items": [
        {
          "code": "C3.2.1",
          "label": "Identifier les dangers propres à son intervention",
          "criteria": "Les dangers sont identifiés de manière exhaustive.",
          "relative": 0.4,
          "realWeight": 2.0
        },
        {
          "code": "C3.2.2",
          "label": "Appliquer les mesures de prévention prévues",
          "criteria": "Une démarche de prévention dans son environnement de travail est mise en œuvre.\nL’installation du poste de travail garantit la sécurité et la protection de la santé.\nLes EPC, et particulièrement la signalisation permanente et provisoire, et la protection du chantier sont respectés. \nLes consignes d’utilisation et de dépose de la signalisation sont respectées.\nLes EPI utilisés sont adaptés à la situation.\nLes consignes de sécurité collective et individuelle sont respectées.",
          "relative": 0.2,
          "realWeight": 1.0
        },
        {
          "code": "C3.2.3",
          "label": "Alerter en cas de situation dangereuse.",
          "criteria": "Une situation dangereuse persistante est signalée à sa hiérarchie.\nLe droit de retrait est appliqué en cas de danger grave et imminent.",
          "relative": 0.4,
          "realWeight": 2.0
        }
      ]
    },
    {
      "code": "C3.4",
      "title": "Monter, démonter et utiliser un échafaudage (En référence aux recommandation R408)",
      "groupPoints": null,
      "items": [
        {
          "code": "C3.4.1",
          "label": "Monter et démonter un échafaudage fixe (échafaudage de pied ou sur tréteaux)",
          "criteria": "Le montage et le démontage sont effectués en conformité avec la notice de montage du matériel et la règlementation.\nTout élément défectueux est signalé immédiatement.\nLes affichages, les balisages et les signalisations sont conformément installés.\nLes biens environnants sont protégés et sauvegardés.",
          "relative": 0.5,
          "realWeight": 2.5
        },
        {
          "code": "C3.4.2",
          "label": "Utiliser un échafaudage de pied fixe (échafaudage de pied ou sur tréteaux)",
          "criteria": "Les règles de déplacement et de stabilisation de l’échafaudage sont respectées.\nLes règles d’accès et de circulation sur l’échafaudage sont respectées.\nLa charge autorisée sur l’échafaudage est respectée.\nLa répartition de la charge est conforme aux préconisations du fabricant.\nL’échafaudage est maintenu en sécurité.",
          "relative": 0.5,
          "realWeight": 2.5
        }
      ]
    },
    {
      "code": "C3.6",
      "title": "Implanter et tracer des ouvrages",
      "groupPoints": null,
      "items": [
        {
          "code": "C3.6.1",
          "label": "Réaliser une implantation planimétrique et altimétrique d’un élément d’ouvrage.",
          "criteria": "Les points ou alignements de référence sont identifiés.\nLe plan d’implantation est respecté.\nLes chaises et repères d’implantation sont stables et correctement positionnées.",
          "relative": 0.7142857142857143,
          "realWeight": 5.0
        },
        {
          "code": "C3.6.2",
          "label": "Tracer des ouvrages sur différents supports.",
          "criteria": "Les tracés ou les épures respectent les plans de définition et permettent la réalisation de l’ouvrage.",
          "relative": 0.2857142857142857,
          "realWeight": 2.0
        }
      ]
    },
    {
      "code": "C3.9",
      "title": "Réaliser et mettre en place des coffrages",
      "groupPoints": null,
      "items": [
        {
          "code": "C3.9.1",
          "label": "Fabriquer, assembler, mettre en place un coffrage traditionnel réutilisable et décoffrer.",
          "criteria": "Le coffrage permet de respecter :\n-\tles formes et dimensions de l’ouvrage ;\n-\tla qualité de parement prescrit ;\n-\tla poussée du béton frais ; \n-\tl’étanchéité ;\n-\tun décoffrage  aisé ;\n-\tles dispositifs de sécurité sont mis en place et maintenu dans toutes les phases d’exécution.",
          "relative": 0.3,
          "realWeight": 3.0
        },
        {
          "code": "C3.9.2",
          "label": "Mettre en place des coffrages outils manu portables, coffrages perdus.",
          "criteria": "Le réglage et la mise en place du coffrage permettent de respecter les exigences de planéité, verticalité, aspect.                                                                                          Les inserts, réservations et négatifs sont correctement positionnés.\nLes dispositifs de sécurité sont mis en place et maintenus dans toutes les phases d’exécution.",
          "relative": 0.3,
          "realWeight": 3.0
        }
      ]
    },
    {
      "code": "C3.10",
      "title": "Mettre en place des armatures",
      "groupPoints": null,
      "items": [
        {
          "code": "C3.10.1",
          "label": "Mettre en place des armatures.",
          "criteria": "Les diamètres, les quantités, la position et le sens de pose des aciers et des cages sont respectées.                                                                                                                          Les châssis et cages d’armatures sont rigides.",
          "relative": 0.42857142857142855,
          "realWeight": 3.0
        },
        {
          "code": "C3.10.2",
          "label": "Façonner des armatures complémentaires.",
          "criteria": "Les armatures façonnées sont conformes au plan et à la nomenclature.",
          "relative": 0.2857142857142857,
          "realWeight": 2.0
        }
      ]
    },
    {
      "code": "C3.11",
      "title": "Fabriquer et mettre en œuvre des bétons courants, bio et géo-sourcés",
      "groupPoints": null,
      "items": [
        {
          "code": "C3.11.1",
          "label": "Fabriquer du béton.",
          "criteria": "La composition du béton est établie à partir d’une méthode simple et correspond aux attentes du cahier des charges.                                                                                                                                                                          La consistance du béton est conforme aux prescriptions.",
          "relative": 0.2,
          "realWeight": 2.0
        },
        {
          "code": "C3.11.2",
          "label": "Mettre en œuvre du béton.",
          "criteria": "Le choix du matériel de manutention et de transport est adapté à l’ouvrage.\nLe mode opératoire de mise en œuvre du béton est respecté.                                Les moyens de serrage sont adaptés (vibration, damage, compactage, …).\nLa tenue des coffrages est contrôlée pendant et après bétonnage.",
          "relative": 0.4,
          "realWeight": 4.0
        },
        {
          "code": "C3.11.3",
          "label": "Traiter les surfaces et assurer les finitions manuelles.",
          "criteria": "L’aspect de surfaçage est conforme aux prescriptions.                                                   Le mode opératoire est respecté.                                                                                        Le délai de cure du béton est respecté.",
          "relative": 0.2,
          "realWeight": 2.0
        }
      ]
    },
    {
      "code": "C3.12",
      "title": "Réaliser des maçonneries de petits éléments",
      "groupPoints": null,
      "items": [
        {
          "code": "C3.12.1",
          "label": "Confectionner les mortiers de hourdage ou colles en adéquation avec les matériaux à assembler.",
          "criteria": "Le mortier ou la colle réalisés correspond à l’usage et à l’aspect demandé (type de liant, plasticité, dosage des constituants y compris adjuvants).                                La quantité de mortier ou colle à gâcher est suffisante, correspond au besoin et réalisée en sécurité.",
          "relative": 0.3,
          "realWeight": 3.0
        },
        {
          "code": "C3.12.2",
          "label": "Mettre en place les repères de hauteur et d’alignement (piges,  balises, cordeaux …).",
          "criteria": "Le positionnement des repères permet le respect du calepinage.",
          "relative": 0.1,
          "realWeight": 1.0
        },
        {
          "code": "C3.12.3",
          "label": "Réaliser un appareillage courant pour des maçonneries apparentes.",
          "criteria": "Les appareillages et harpages réalisés sont conformes aux normes en vigueur et aux règles de l’art.",
          "relative": 0.2,
          "realWeight": 2.0
        },
        {
          "code": "C3.12.4",
          "label": "Réaliser des ouvrages en maçonnerie.",
          "criteria": "La mise en œuvre respecte les normes et règles en vigueur :\n- La planéité, la verticalité et l’horizontalité propres à chaque matériau respectent les exigences ;\n- L’épaisseur des joints est conforme aux règles des textes normatifs ;\n- Les règles de liaisonnement sont respectées.                                                                   Les temps d’exécution sont respectés.",
          "relative": 0.4,
          "realWeight": 4.0
        }
      ]
    },
    {
      "code": "C3.15",
      "title": "Réaliser les finitions d’un ouvrage vertical",
      "groupPoints": null,
      "items": [
        {
          "code": "C3.15.1",
          "label": "Réaliser des enduits verticaux.",
          "criteria": "La nature du support est identifiée.\nLes matériaux mis en œuvre sont adaptés au support.                                                  Les ouvrages environnants sont protégés.\nLes mortiers utilisés et leurs mises en œuvre sont conformes aux règles et normes en vigueur, aux avis techniques et ou aux prescriptions du fabricant.",
          "relative": 0.25,
          "realWeight": 2.0
        },
        {
          "code": "C3.15.2",
          "label": "Réaliser des jointoiements ou rejointoiements.",
          "criteria": "La nature du support est identifiée.\nLes ouvrages environnants sont protégés.\nLes mortiers utilisés sont compatibles avec les supports et leur mise en œuvre sont conformes aux règles et normes en vigueur, aux avis techniques et ou aux prescriptions du fabricant.                                                                                                L’aspect est conforme aux prescriptions.",
          "relative": 0.375,
          "realWeight": 3.0
        }
      ]
    },
    {
      "code": "C3.16",
      "title": "Réaliser les finitions d’un ouvrage horizontal",
      "groupPoints": null,
      "items": [
        {
          "code": "C3.16.1",
          "label": "Réaliser des ouvrages de finition en béton.",
          "criteria": "La composition et la consistance des bétons et mortiers sont adaptées à la destination de l’ouvrage.                                                                                                           Les états de surface et les arêtes sont traités conformément aux prescriptions. Les caractéristiques dimensionnelles et fonctionnelles des ouvrages sont respectées.                                                                                                                                        Le positionnement altimétrique est conforme au plan.",
          "relative": 0.375,
          "realWeight": 3.0
        },
        {
          "code": "C3.16.2",
          "label": "Réaliser des chapes.",
          "criteria": "La nature du support est identifiée                                                                                       Les ouvrages environnants sont protégés.                                                                        Les matériaux mis en œuvre sont adaptés au support.                                                     Les mortiers utilisés et leur mise en œuvre sont conformes aux règles et normes en vigueur, aux avis techniques et ou aux prescriptions du fabricant.",
          "relative": 0.375,
          "realWeight": 3.0
        }
      ]
    },
    {
      "code": "C3.17",
      "title": "Préparer, utiliser et entretenir les matériels et outillages",
      "groupPoints": null,
      "items": [
        {
          "code": "C3.17.1",
          "label": "Contrôler, avant utilisation, l’état :\n- du matériel et de ses protections ;\n- des outils et accessoires.",
          "criteria": "Tout manquement ou anomalie est signalé à la hiérarchie.",
          "relative": 0.25,
          "realWeight": 1.0
        },
        {
          "code": "C3.17.2",
          "label": "Mettre en place le matériel ou l’outillage en fonction de la tâche à réaliser.",
          "criteria": "Le montage ou l’installation respecte scrupuleusement les indications du fabricant.                                                                                                                              La configuration retenue permet une utilisation aisée et en toute sécurité.",
          "relative": 0.25,
          "realWeight": 1.0
        },
        {
          "code": "C3.17.3",
          "label": "Vérifier et assurer la maintenance courante du matériel et de l’outillage.",
          "criteria": "Les éventuelles anomalies sont signalées à la hiérarchie.",
          "relative": 0.25,
          "realWeight": 1.0
        },
        {
          "code": "C3.17.4",
          "label": "Replier le matériel ou l’outillage en vue d’une utilisation ultérieure.",
          "criteria": "Le matériel ou l’outillage est mis en état (prêt à servir) et rangé aux endroits dédiés.",
          "relative": 0.25,
          "realWeight": 1.0
        }
      ]
    },
    {
      "code": "C4.1",
      "title": "Contrôler la nature et la conformité des supports",
      "groupPoints": null,
      "items": [
        {
          "code": "C4.1.1",
          "label": "Identifier la nature du support.",
          "criteria": "La nature du support est identifiée ou renseignée.",
          "relative": 0.3333333333333333,
          "realWeight": 1.0
        },
        {
          "code": "C4.1.2",
          "label": "Contrôler l’état des supports.",
          "criteria": "Les contrôles de cohésion, planimétrie, propreté, aplombs, équerrage sont effectués conformément aux procédures techniques ou normatives.\nLes données relevées sont comparées avec les exigences imposées par les textes normatifs et réglementaires. \nLes écarts à la conformité constatés sont signalés.",
          "relative": 0.6666666666666666,
          "realWeight": 2.0
        }
      ]
    },
    {
      "code": "C4.2",
      "title": "Contrôler le travail réalisé en cours d’exécution et en fin de travaux",
      "groupPoints": null,
      "items": [
        {
          "code": "C4.2.1",
          "label": "Préparer les moyens de contrôle",
          "criteria": "Les moyens sont adaptés aux contrôles à réaliser.",
          "relative": 0.25,
          "realWeight": 1.0
        },
        {
          "code": "C4.2.2",
          "label": "Réaliser les contrôles en cours de réalisation et en fin de travaux.",
          "criteria": "Les protocoles de contrôle et les techniques d’utilisation des matériels sont respectés.                                                                                                                                         Les contrôles permettent les corrections éventuelles et la poursuite des travaux puis la réception.",
          "relative": 0.25,
          "realWeight": 1.0
        },
        {
          "code": "C4.2.3",
          "label": "Mettre en œuvre une méthode d’autocontrôle de son travail.",
          "criteria": "Les points de contrôle sont identifiés et judicieux.                                                            Les contrôles permettent de vérifier la conformité du travail confié.\nLa fréquence des contrôles est adaptée au travail réalisé.                                      Les résultats des contrôles garantissent la conformité du travail confié.\nLes défauts sont repérés, corrigés ou communiqués à la hiérarchie.",
          "relative": 0.25,
          "realWeight": 1.0
        },
        {
          "code": "C4.2.4",
          "label": "Appliquer une procédure d’autocontrôle établie.",
          "criteria": "La procédure établie pour les autocontrôles est respectée.                                               Les fiches d’autocontrôles sont renseignées et transmises.",
          "relative": 0.25,
          "realWeight": 1.0
        }
      ]
    }
  ],
  "EP3": [
    {
      "code": "C1.2",
      "title": "Échanger et rendre compte oralement",
      "groupPoints": 20.0,
      "items": [
        {
          "code": "C1.2.1",
          "label": "Rendre compte oralement d’une situation professionnelle",
          "criteria": "L’interlocuteur est écouté et compris.                                                                         Le contenu de l’échange (champ lexical, structure …) est adapté à l’interlocuteur.                                                                                                                    Le propos est clair, précis et concis. L’information transmise est conforme aux règles de l’entreprise.                                                                                                       Toute situation à risque professionnel est signalée à sa hiérarchie.",
          "relative": 0.6666666666666666,
          "realWeight": 12.0
        },
        {
          "code": "C1.2.2",
          "label": "Reformuler des consignes transmises par la hiérarchie",
          "criteria": "La reformulation atteste de la compréhension de la consigne.",
          "relative": 0.3333333333333333,
          "realWeight": 6.0
        }
      ]
    },
    {
      "code": "C3.3",
      "title": "Intervenir à proximité des réseaux",
      "groupPoints": null,
      "items": [
        {
          "code": "C3.3.1",
          "label": "Situer son rôle et expliciter sa mission et ses responsabilités",
          "criteria": "Les critères d’évaluation des compétences du « profil opérateur » sont définis sous forme de « résultats attendus » dans l’annexe II de l’arrêté du 15-1-2019 (J.O. du 28-2-2019, BO n°12 du 21-3-19) : délivrance de l’AIPR",
          "relative": 0.0909090909090909,
          "realWeight": 0.0
        },
        {
          "code": "C3.3.2",
          "label": "Identifier les différents types de réseaux : souterrains, aériens et subaquatiques",
          "criteria": "",
          "relative": 0.0909090909090909,
          "realWeight": 0.0
        },
        {
          "code": "C3.3.3",
          "label": "Identifier l’ensemble des risques liés aux réseaux sensibles et non sensibles",
          "criteria": "",
          "relative": 0.0909090909090909,
          "realWeight": 0.0
        },
        {
          "code": "C3.3.4",
          "label": "Mettre en œuvre et adapter les mesures de protection collective et individuelle applicable à la situation",
          "criteria": "",
          "relative": 0.0909090909090909,
          "realWeight": 0.0
        },
        {
          "code": "C3.3.5",
          "label": "Identifier les affleurants des réseaux, le marquage-piquetage et les dispositifs avertisseurs",
          "criteria": "",
          "relative": 0.0909090909090909,
          "realWeight": 0.0
        },
        {
          "code": "C3.3.6",
          "label": "Identifier une situation à risque ou non conforme et alerter son responsable",
          "criteria": "",
          "relative": 0.0909090909090909,
          "realWeight": 0.0
        },
        {
          "code": "C3.3.7",
          "label": "Adapter es moyens et techniques d’exécution aux zones d’incertitudes de localisation des réseaux",
          "criteria": "",
          "relative": 0.0909090909090909,
          "realWeight": 0.0
        },
        {
          "code": "C3.3.8",
          "label": "Maintenir en état le marquage piquetage des réseaux pendant toute la durée du chantier",
          "criteria": "",
          "relative": 0.0909090909090909,
          "realWeight": 0.0
        },
        {
          "code": "C3.3.9",
          "label": "Appliquer les procédures en cas d’incident ou d’accident.                                  Appliquer la règle des 4A",
          "criteria": "",
          "relative": 0.0909090909090909,
          "realWeight": 0.0
        },
        {
          "code": "C3.3.10",
          "label": "Appliquer les règles relatives aux interventions à proximité de câbles électriques",
          "criteria": "",
          "relative": 0.0909090909090909,
          "realWeight": 0.0
        },
        {
          "code": "C3.3.11",
          "label": "Appliquer les règles relatives aux opérations nécessitant d’entrer en contact avec les câbles électriques souterrains laissés sous tension, ou leurs fourreaux",
          "criteria": "",
          "relative": 0.0909090909090909,
          "realWeight": 0.0
        }
      ]
    },
    {
      "code": "C3.5",
      "title": "Mettre en place et démonter un étaiement",
      "groupPoints": null,
      "items": [
        {
          "code": "C3.5.1",
          "label": "Mettre en place un étaiement",
          "criteria": "L’implantation des étais est conforme au plan de calepinage.                                         Le réglage altimétrique est conforme au plan d’exécution.                                          La stabilité de l’ensemble est assurée : assises, aplomb, contreventement… L’installation et la dépose des étais sont effectuées en sécurité et selon les consignes données.",
          "relative": 0.75,
          "realWeight": 0.0
        },
        {
          "code": "C3.5.2",
          "label": "Démonter, nettoyer, assurer la maintenance et conditionner le matériel pour son repliement (enlèvement)",
          "criteria": "Le matériel est maintenu en état de fonctionnement, les éléments défectueux sont signalés et écartés.                                                                                                             Le stockage est rationnel et effectué dans la zone dédiée.",
          "relative": 0.25,
          "realWeight": 0.0
        }
      ]
    },
    {
      "code": "C3.7",
      "title": "Réaliser des terrassements complémentaires",
      "groupPoints": null,
      "items": [
        {
          "code": "C3.7.1",
          "label": "Terrasser et régler manuellement le fond de fouille et les formes",
          "criteria": "La signalisation et le balisage sont mis en place et maintenu dans toutes les phases d’exécution.                                                                                                                 La cote hors gel est respectée.                                                                                               Les déblais et remblais sont gérés rationnellement.                                                        Les points mous sont purgés                                                                                                  Le fond de fouille est régalé.                                                                                                   La terre végétale est stockée séparément.                                                                         Les formes en remblais sont correctement compactées",
          "relative": 1.0,
          "realWeight": 0.0
        }
      ]
    },
    {
      "code": "C3.8",
      "title": "Réaliser des réseaux enterrés",
      "groupPoints": null,
      "items": [
        {
          "code": "C3.8.1",
          "label": "Réaliser le lit de pose",
          "criteria": "Le lit de pose respecte la pente prescrite.                                                                              Il est homogène et composé de matériaux conformes aux prescriptions.",
          "relative": 0.2777777777777778,
          "realWeight": 0.0
        },
        {
          "code": "C3.8.2",
          "label": "Poser, assembler, coller, sceller les canalisations, les regards, les siphons et les accessoires",
          "criteria": "Les pentes sont respectées, l’écoulement est continu.                                                   La cote fil d’eau est respectée. Le réseau est étanche.",
          "relative": 0.3888888888888889,
          "realWeight": 0.0
        },
        {
          "code": "C3.8.3",
          "label": "Exécuter le remblaiement sur canalisation",
          "criteria": "Le matériau de remblai est purgé de gros éléments jusqu'à 15 cm au-dessus de la génératrice supérieure.                                                                                                               Le grillage avertisseur, de couleur réglementaire selon la nature du réseau, est mis en place.                                                                                                                                    Le remblaiement est effectué par couches de 20 cm, soigneusement compactées.",
          "relative": 0.3333333333333333,
          "realWeight": 0.0
        }
      ]
    },
    {
      "code": "C3.13",
      "title": "Intervenir sur le bâti existant",
      "groupPoints": null,
      "items": [
        {
          "code": "C3.13.1",
          "label": "Identifier les éléments porteurs, l’environnement (ouvrages mitoyens)",
          "criteria": "Les éléments porteurs sont identifiés.                                                                              Les désordres éventuels sont repérés et l’information est transmise à la hiérarchie et repérés.                                                                                                              Les liaisons avec les ouvrages mitoyens sont identifiées.",
          "relative": 0.3333333333333333,
          "realWeight": 6.0
        },
        {
          "code": "C3.13.2",
          "label": "Créer ou modifier une ouverture dans un mur porteur",
          "criteria": "La zone de travail, l’environnement sont sécurisés et les dispositifs de sécurité sont maintenus dans toutes les phases d’exécution.                                              L’étaiement est conforme au mode opératoire.                                                            Les éléments conservés sont protégés.                                                                               Les dimensions correspondent aux attendus.                                                                 Les consignes sont respectées.                                                                                                  Les finitions sont réalisées et conforme aux prescriptions.",
          "relative": 0.6666666666666666,
          "realWeight": 0.0
        }
      ]
    },
    {
      "code": "C3.14",
      "title": "Poser des éléments préfabriqués",
      "groupPoints": null,
      "items": [
        {
          "code": "C3.14.1",
          "label": "ldentifier le composant préfabriqué à poser",
          "criteria": "Le composant est correctement identifié.",
          "relative": 0.11764705882352941,
          "realWeight": 2.0
        },
        {
          "code": "C3.14.2",
          "label": "Préparer la pose des composants",
          "criteria": "Les équipements et accessoires mis à disposition sont contrôlés.                    L’élingage est conforme aux consignes.                                                                                    Les gestes de commandement des appareils de levage sont correctement utilisés.                                                                                                                                      L’étaiement, les dispositifs de stabilisation et de blocage respectent les consignes.                                                                                                                                       Les dispositifs de sécurité sont mis en place et maintenus dans toutes les phases d’exécution.                                                                                                                              L’ouvrage est conforme aux prescriptions de positionnement (altimétrie, alignement, horizontalité, verticalité…).",
          "relative": 0.5882352941176471,
          "realWeight": 10.0
        },
        {
          "code": "C3.14.3",
          "label": "Réaliser les liaisons",
          "criteria": "Les clavetages sont réalisés conformément au plan d’exécution (dosage liants, positionnement des armatures).                                                                                    La continuité de l’aspect des parements au niveau des zones de clavetage est assurée (qualité du coffrage).                                                                                             Les joints sont traités selon leur nature.",
          "relative": 0.29411764705882354,
          "realWeight": 5.0
        }
      ]
    }
  ]
} as const;


function TrafficLightPicker(props: {
  value: TrafficLightColor;
  onChange: (v: TrafficLightColor) => void;
  className?: string;
}) {
  const { value, onChange, className } = props;
  const items: Array<{ v: Exclude<TrafficLightColor, "none">; colorClass: string; label: string }> = [
    // Inversé: Vert en haut, Rouge en bas
    { v: "green", colorClass: "bg-emerald-500", label: "Vert" },
    { v: "yellow", colorClass: "bg-amber-400", label: "Orange" },
    { v: "red", colorClass: "bg-red-500", label: "Rouge" },
  ];

  return (
    <div className={classNames("inline-flex flex-col items-center gap-0.5 rounded-md border border-neutral-200 dark:border-sky-400/35 bg-white dark:bg-[#1f2d42] px-0.5 py-0.5", className)}>
      {items.map((it) => {
        const active = value === it.v;
        return (
          <button
            key={it.v}
            type="button"
            onClick={() => onChange(active ? "none" : it.v)}
            className="rounded-full p-0 focus:outline-none focus-visible:ring-2 focus-visible:ring-neutral-900/30"
            aria-label={it.label}
            title={it.label}
          >
            <span
              className={classNames(
                "block h-3 w-3 rounded-full border border-neutral-300 dark:border-sky-400/35",
                it.colorClass,
                active ? "opacity-100 ring-2 ring-inset ring-neutral-900/30" : "opacity-30"
              )}
            />
          </button>
        );
      })}
    </div>
  );
}

function formatEvalLabel(task: string, _comp: string): string {
  return task;
}


// =====================
// Année de formation (1ère / 2ème année) — séparation des fichiers & dossiers
// =====================
type TrainingYear = "premiere" | "deuxieme";

type PreviewTargetOptions = { mode?: "modal" | "popup"; autoPrint?: boolean; target?: "preview" | "print" | "printWindow" };
type PrintHeaderMeta = {
  viewTitle: string;
  studentName?: string;
  classId?: string;
  trainingYear?: "premiere" | "deuxieme";
  schoolYear?: string;
};

function trainingYearLabel(year?: "premiere" | "deuxieme") {
  if (year === "deuxieme") return "2ème année";
  if (year === "premiere") return "1ère année";
  return "";
}

// Utilise une fonction d’échappement fournie par l’appelant (esc/escapeHtml)
function buildPrintHeaderHtml(esc: (s: string) => string, meta: PrintHeaderMeta) {
  const titleRightParts = [
    meta.classId ? `Classe : ${meta.classId}` : "",
    meta.trainingYear ? `Année de formation : ${trainingYearLabel(meta.trainingYear)}` : "",
  ].filter(Boolean);

  const displayTitle = meta.studentName
    ? `${meta.viewTitle} — Suivi de ${meta.studentName}`
    : meta.viewTitle;

  return `
    <div class="print-header" style="
      font-family: ui-sans-serif, system-ui;
      border-radius:10px;
      padding:10px 12px;
      margin:0 0 4px 0;
      background:#fff;
    ">
      <div style="display:flex;align-items:baseline;justify-content:space-between;gap:12px;">
        <div style="font-size:16px;font-weight:800;color:#111827;">
          ${esc(displayTitle)}
        </div>
        ${titleRightParts.length ? `
          <div style="font-size:12px;color:#6b7280;text-align:right;white-space:nowrap;">
            ${esc(titleRightParts.join(" • "))}
          </div>
        ` : ""}
      </div>
    </div>
  `;
}

// ✅ Fichiers séparés par année (avec fallback sur l'ancien fichier "unique")
const LEGACY_SKILLS_FILE = "skills_db.json";
const LEGACY_SKILLS_CACHE = "skills_db";
const LEGACY_NOTATION_FILE = "notation_db.json";
const LEGACY_NOTATION_CACHE = "notation_db";
const LEGACY_EVALMETA_FILE = "evaluations_db.json";
const LEGACY_EVALMETA_CACHE = "evaluations_db_cache";

const skillsDbFileName = (year: TrainingYear) =>
  year === "premiere" ? "skills_db_premiere.json" : "skills_db_deuxieme.json";
const skillsDbCacheKey = (year: TrainingYear) =>
  year === "premiere" ? "skills_db_premiere" : "skills_db_deuxieme";

const notationDbFileName = (year: TrainingYear) =>
  year === "premiere" ? "notation_db_premiere.json" : "notation_db_deuxieme.json";
const notationDbCacheKey = (year: TrainingYear) =>
  year === "premiere" ? "notation_db_premiere" : "notation_db_deuxieme";

const evalMetaFileName = (year: TrainingYear) =>
  year === "premiere" ? "evaluations_db_premiere.json" : "evaluations_db_deuxieme.json";
const evalMetaCacheKey = (year: TrainingYear) =>
  year === "premiere" ? "evaluations_db_cache_premiere" : "evaluations_db_cache_deuxieme";
const absencesDbFileName = (year: TrainingYear) =>
  year === "premiere" ? "absences_retards_premiere.json" : "absences_retards_deuxieme.json";
const absencesDbCacheKey = (year: TrainingYear) =>
  year === "premiere" ? "absences_retards_premiere" : "absences_retards_deuxieme";

type AttendanceStatus = "AB" | "RT";
type AttendanceByDate = Record<string, AttendanceStatus>; // dateYmd -> status
// schoolYear -> classId -> studentName -> (dateYmd -> status)
type AttendanceDB = Record<string, Record<string, Record<string, AttendanceByDate>>>;

type PlanningZone = "A" | "B" | "C" | "CORSE";
type PlanningWeekdays = { mon: boolean; tue: boolean; wed: boolean; thu: boolean; fri: boolean; sat: boolean; sun: boolean };
type DateRange = { startYmd: string; endYmd: string; label?: string }; // endYmd inclusif
type PlanningSettings = {
  schoolYear: string;
  startYmd: string;
  endYmd: string;
  zone: PlanningZone;
  courseDays: PlanningWeekdays;
  vacationsMode: "auto" | "manual";
  vacationsManual: DateRange[];
  stages: DateRange[];
};
type AbsencesRetardsStore = {
  records: AttendanceDB;
  planning: Record<string, Record<string, PlanningSettings>>; // schoolYear -> classId -> settings
};

type VacationRange = { startYmd: string; endYmdExclusive: string; label: string };

const devoirDirName = (_year: TrainingYear) => "devoir";
const devoirTrashDirName = (_year: TrainingYear) => "devoir_corbeille";

// ---- Helpers export (nom de fichier + horodatage) ----
function sanitizeFileNamePart(input: string): string {
  const safe = String(input || "")
    .normalize("NFKD")
    .replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-zA-Z0-9 _-]/g, "")
    .trim()
    .replace(/\s+/g, "_");
  return safe.length ? safe.slice(0, 80) : "classe";
}
function tsForFileName(d: Date = new Date()): string {
  const pad = (n: number) => String(n).padStart(2, "0");
  return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())}_${pad(d.getHours())}${pad(d.getMinutes())}${pad(d.getSeconds())}`;
}
function ensureJsonFileName(nameOrPath: string): string {
  const s = String(nameOrPath || "");
  return s.toLowerCase().endsWith(".json") ? s : `${s}.json`;
}

// ---- Safe JSON stringify (évite crash BigInt / cycles) ----
function safeJsonStringify(value: any, space: number = 2): string {
  const seen = new WeakSet<object>();
  return JSON.stringify(
    value,
    (_k, v) => {
      if (typeof v === "bigint") return String(v);
      if (v && typeof v === "object") {
        if (seen.has(v)) return "[Circular]";
        seen.add(v);
      }
      return v;
    },
    space
  );
}


// -- Helpers de normalisation pour lier la DB (clé normalisée "Compétence II Sous-critère")
const SEP_NORMALIZED = ' II ';
function normalizeCompItem(comp: string, item: string): string {
  const compClean = comp.trim().replace(/\s+/g, ' ');
  const itemClean = item.trim().replace(/\s+/g, ' ');
  return `${compClean} ${SEP_NORMALIZED} ${itemClean}`;
}
function normalizeKeyFromCritKey(critKey: string): string {
  const { comp, item } = parseScopedCritKey(critKey);
  return normalizeCompItem(comp, item);
}

// ==== Exigences Index Helpers (code+item normalisé) ====
function __norm(s) {
  return String(s || '')
    .normalize('NFKD')
    .replace(/[\u0300-\u036f]/g, '')
    .toLowerCase()
    .replace(/[;:–—\-]/g, '')
    .replace(/\s+/g, '')
    .replace(/[^a-z0-9.]/g, '');
}
function __extractCode(raw) {
  const s = String(raw || '').replace(/\s+/g, ' ');
  const m = s.match(/\bC\s*\.?\s*\d+\.\d+\b/i);
  return m ? m[0] : null;
}
function __cleanItem(raw) {
  return String(raw || '').replace(/\s*[:;]+\s*$/, '').trim();
}
function buildExigencesIndex(db) {
  const idx = {};
  for (const [rawKey, list] of Object.entries(db || {})) {
    const k = String(rawKey || '').trim().replace(/\s+/g, ' ');
    const parts = k.split(' II ');
    const left = parts[0] || '';
    const right = parts[1] || k;
    const code = __extractCode(left);
    const item = __cleanItem(right);
    if (!code || !item) continue;
    const codeKey = __norm(code);
    const itemKey = __norm(item);
    if (!idx[codeKey]) idx[codeKey] = {};
    idx[codeKey][itemKey] = Array.isArray(list) ? list : [];
  }
  return idx;
}

// ==== Couleur de notation ====
function getMarkCellBg4Classes(mark: number | null | undefined): string {
  if (typeof mark !== "number" || Number.isNaN(mark)) return "";

  // 4 couleurs (rouge -> orange -> vert clair -> vert foncé)
  if (mark < 5) return "bg-red-50 dark:bg-red-950/25";
  if (mark < 10) return "bg-orange-50 dark:bg-orange-950/25";
  if (mark < 15) return "bg-emerald-50 dark:bg-emerald-950/20";
  return "bg-emerald-100 dark:bg-emerald-950/35";
}

// ---- Robust seed loader: tries /api/exigences, then /data/exigences_db.json (public) ----
async function __fetchExigencesSeed() {
  const tryFetch = async (url: string): Promise<any> => {
    const res = await tauriFetch(url, { method: "GET" });
    const ct = (res.headers.get('content-type') || '').toLowerCase();
    const text = await res.text();
    // guard against HTML responses (dev server 404 / index.html)
    const trimmed = text.trim();
    if (ct.includes('application/json') || trimmed.startsWith('{') || trimmed.startsWith('[')) {
      try {
        return JSON.parse(trimmed);
      } catch (e) {
        console.warn('Seed JSON parse failed for', url, e, 'payload head=', trimmed.slice(0,120));
        throw e;
      }
    } else {
      throw new Error(`Not JSON from ${url}: ${trimmed.slice(0,120)}`);
    }
  };
  try {
    return await tryFetch('/api/exigences');
  } catch (e1) {
    console.warn('API /api/exigences failed, falling back to static /data/exigences_db.json', e1);
    try {
      return await tryFetch('/data/exigences_db.json');
    } catch (e2) {
      console.error('Both seed endpoints failed.', { e1, e2 });
      throw e2;
    }
  }
}

interface DrawerProps {
  open: boolean;
  onClose: () => void;
  side?: 'left' | 'right';
  className?: string;
  children?: React.ReactNode;
}

const Drawer: React.FC<DrawerProps> = ({ open, onClose, side = 'left', className = '', children }) => {
  React.useEffect(() => {
    const root = document.documentElement as HTMLElement & { dataset: any };
    if (open) {
      const c = +(root.dataset.scrollLockCount || 0) + 1;
      root.dataset.scrollLockCount = String(c);
      if (c === 1) root.classList.add('overflow-hidden');
    }
    return () => {
      if (!open) return;
      const c = Math.max(0, +(root.dataset.scrollLockCount || 0) - 1);
      root.dataset.scrollLockCount = String(c);
      if (c === 0) root.classList.remove('overflow-hidden');
    };
  }, [open]);

  React.useEffect(() => {
    if (!open) return;
    const onKey = (e: KeyboardEvent) => { if (e.key === 'Escape') onClose(); };
    window.addEventListener('keydown', onKey);
    return () => window.removeEventListener('keydown', onKey);
  }, [open, onClose]);

  if (!open) return null;

  const align = side === 'left' ? 'left-0' : 'right-0';
  const borderSide = side === 'left' ? 'border-r' : 'border-l';
  return createPortal(
    <div className="fixed inset-0 z-50">
      <div className="absolute inset-0 bg-black/30" onClick={onClose} />
      <div
        className={classNames(
          `absolute inset-y-0 ${align} h-full bg-white dark:bg-[#1f2d42] ${borderSide} border-neutral-200 dark:border-[#1b467a] overflow-y-auto`,
          className
        )}
        style={{ overscrollBehavior: 'contain', WebkitOverflowScrolling: 'touch' as any, touchAction: 'pan-y' }}
        onWheel={(e) => e.stopPropagation()}
      >
        {children}
      </div>
    </div>,
    document.body
  );
};

interface TCMap { [task: string]: string[] }
interface CriteresResultsDB {
  [competency: string]: {
    [item: string]: { resultats: string[]; exigences: string[] }
  }
}
interface ClassGroup {
  id: string;
  name: string;
  students: string; // un élève par ligne
}
type SemesterKey = "Ne pas utiliser de semestre" | "S1" | "S2";


type GeneralSettings = {
  establishmentName: string;
  establishmentLocation: string; // ex: "Ville" ou "Adresse courte"
  defaultReferents: string;      // si aucune valeur n’est définie pour la classe
  classReferents: Record<string, string>; // clé = nom de classe
};

const DEFAULT_GENERAL_SETTINGS: GeneralSettings = {
  establishmentName: "",
  establishmentLocation: "",
  defaultReferents: "",
  classReferents: {},
};

const GENERAL_SETTINGS_FILE = "parametres_generaux.json";
const GENERAL_SETTINGS_CACHE_KEY = "parametres_generaux_cache";


type EvaluationCategory = "Découverte professionnel" | "Apprentissage des fondamentaux" | "Professionnalisation de niveau 3";
type Level1to4 = 0 | 1 | 2 | 3 | 4;
type EngagementLevel = "volontaire" | "engage" | "normal" | "attente" | "absence";

type TrafficLightColor = "none" | "green" | "yellow" | "red";

const ENGAGEMENT_FACTORS: Record<EngagementLevel, number> = {
  volontaire: 1.1,  
  engage: 1.05,     
  normal: 1,         
  attente: 0.95,    
  absence: 0.9,     
};

function computeEngagementFactor(level: EngagementLevel | null | undefined): number {
  if (!level) return 1;
  return ENGAGEMENT_FACTORS[level];
}

function getEngagementCellClasses(level: EngagementLevel | null | undefined): string {
  if (!level) return "";

  switch (level) {
    case "volontaire":
      return "bg-emerald-100";
    case "engage":
      return "bg-green-100";
    case "normal":
      return "bg-sky-50 dark:bg-sky-950/35";
    case "attente":
      return "bg-yellow-100";
    case "absence":
      return "bg-red-100";
    default:
      return "";
  }
}

// ==== Helpers : Bilan périodique (moyennes compétences / motivation) ====
type SemesterAgg = Record<string, { label: string; S1Vals: number[]; S2Vals: number[] }>;

function mean(nums: number[]): number {
  if (!nums.length) return 0;
  let s = 0;
  for (const n of nums) s += n;
  return s / nums.length;
}

function round1(n: number): number {
  return Math.round(n * 10) / 10;
}

function levelFromAvg(avg: number): Level1to4 {
  if (!isFinite(avg) || avg <= 0) return 0;
  if (avg < 1.5) return 1;
  if (avg < 2.5) return 2;
  if (avg < 3.5) return 3;
  return 4;
}

function levelBadge(level: Level1to4): { text: string; className: string; title: string } {
  switch (level) {
    case 0:
      return { text: "Non évaluée", className: "bg-neutral-100 text-neutral-700 border-neutral-200 dark:bg-[#1f2d42] dark:text-neutral-300 dark:border-sky-400/35", title: "Aucun niveau enregistré" };
    case 1:
      return { text: "Non acquise", className: "bg-red-100 text-red-900 border-red-200 dark:bg-red-500/20 dark:text-red-100 dark:border-red-400/40", title: "Niveau 1" };
    case 2:
      return { text: "En voie", className: "bg-amber-100 dark:bg-amber-950/45 text-amber-900 border-amber-200 dark:bg-amber-500/20 dark:text-amber-100 dark:border-amber-400/40", title: "Niveau 2" };
    case 3:
      return { text: "Acquise", className: "bg-emerald-100 text-emerald-900 border-emerald-200 dark:bg-emerald-500/20 dark:text-emerald-100 dark:border-emerald-400/40", title: "Niveau 3" };
    case 4:
      return { text: "Maîtrisée", className: "bg-green-200 text-green-950 border-green-300 dark:bg-green-500/20 dark:text-green-100 dark:border-green-400/40", title: "Niveau 4" };
    default:
      return { text: "—", className: "bg-neutral-100 text-neutral-700 border-neutral-200 dark:bg-[#1f2d42] dark:text-neutral-300 dark:border-sky-400/35", title: "" };
  }
}

function levelRowTint(level: Level1to4): string {
  switch (level) {
    case 0:
      return "bg-neutral-50 text-neutral-700 border-neutral-200 dark:bg-[#1f2d42] dark:text-neutral-300 dark:border-neutral-700/40";
    case 1:
      return "bg-red-50 text-red-900 border-red-200 dark:bg-red-500/10 dark:text-red-100 dark:border-red-400/25";
    case 2:
      return "bg-amber-50 dark:bg-amber-950/35 text-amber-900 border-amber-200 dark:bg-amber-500/10 dark:text-amber-100 dark:border-amber-400/25";
    case 3:
      return "bg-emerald-50 text-emerald-900 border-emerald-200 dark:bg-emerald-500/10 dark:text-emerald-100 dark:border-emerald-400/25";
    case 4:
      return "bg-green-50 text-green-950 border-green-200 dark:bg-green-500/10 dark:text-green-100 dark:border-green-400/25";
    default:
      return "bg-neutral-50 text-neutral-700 border-neutral-200 dark:bg-[#1f2d42] dark:text-neutral-300 dark:border-neutral-700/40";
  }
}

function libelleChipMeta(title: string): { bubble: string; dot: string; border: string; line: string; headerBg: string; cardBorder: string } {
  const n = __norm(title);

  // Pôles attendus : Communiquer (bleu), Préparer (orange), Réaliser (vert), Contrôler (violet)
  if (n.includes("communiquer") || n.includes("communication")) {
    return {
      bubble: "bg-sky-50 dark:bg-sky-950/35 text-sky-900 border-sky-200 dark:bg-sky-950/20 dark:text-sky-200 dark:border-sky-800/50",
      dot: "bg-sky-500",
      border: "border-sky-200 dark:border-sky-800/50",
      line: "border-sky-200 dark:border-sky-800/50",
      headerBg: "bg-sky-50/70 dark:bg-sky-950/20",
      cardBorder: "border-sky-200/80 dark:border-sky-800/40",
    };
  }
  if (n.includes("preparer") || n.includes("preparation")) {
    return {
      bubble: "bg-amber-50 dark:bg-amber-950/35 text-amber-900 border-amber-200 dark:bg-amber-950/20 dark:text-amber-200 dark:border-amber-800/50",
      dot: "bg-amber-500",
      border: "border-amber-200 dark:border-amber-800/50",
      line: "border-amber-200 dark:border-amber-800/50",
      headerBg: "bg-amber-50/70 dark:bg-amber-950/20",
      cardBorder: "border-amber-200/80 dark:border-amber-800/40",
    };
  }
  if (n.includes("realiser") || n.includes("realisation")) {
    return {
      bubble: "bg-emerald-50 text-emerald-900 border-emerald-200 dark:bg-emerald-950/20 dark:text-emerald-200 dark:border-emerald-800/50",
      dot: "bg-emerald-500",
      border: "border-emerald-200 dark:border-emerald-800/50",
      line: "border-emerald-200 dark:border-emerald-800/50",
      headerBg: "bg-emerald-50/70 dark:bg-emerald-950/20",
      cardBorder: "border-emerald-200/80 dark:border-emerald-800/40",
    };
  }
  if (n.includes("controler") || n.includes("controle")) {
    return {
      bubble: "bg-violet-50 dark:bg-violet-950/35 text-violet-900 border-violet-200 dark:bg-violet-950/20 dark:text-violet-200 dark:border-violet-800/50",
      dot: "bg-violet-500",
      border: "border-violet-200 dark:border-violet-800/50",
      line: "border-violet-200 dark:border-violet-800/50",
      headerBg: "bg-violet-50/70 dark:bg-violet-950/20",
      cardBorder: "border-violet-200/80 dark:border-violet-800/40",
    };
  }

  return {
    bubble: "bg-neutral-100 dark:bg-[#1f2d42] text-neutral-800 dark:text-neutral-300 border-neutral-200 dark:border-sky-400/35 dark:bg-neutral-900/30 dark:text-neutral-300 dark:border-sky-400/35",
    dot: "bg-neutral-50 dark:bg-[#1f2d42]0",
    border: "border-neutral-200 dark:border-sky-400/35 dark:border-sky-400/35",
    line: "border-neutral-200 dark:border-sky-400/35 dark:border-sky-400/35",
    headerBg: "bg-neutral-50/80 dark:bg-[#1f2d42]/80 dark:bg-neutral-900/30",
    cardBorder: "border-neutral-200 dark:border-sky-400/35/80 dark:border-sky-400/35",
  };
}


function buildSemesterAggFromStudentRecord(
  studentRecord: StudentSkillRecord,
  allowedEvalIds: Set<string>,
  allowedEvalNames: Set<string>
): SemesterAgg {
  const semesterAgg: SemesterAgg = {};

  Object.entries(studentRecord || {}).forEach(([rawLabel, semLevels]) => {
    let compPart = rawLabel;
    if (rawLabel.includes("||")) {
      const [idOrName, compMaybe] = rawLabel.split("||");
      if (!idOrName || !compMaybe) return;
      if (!allowedEvalIds.has(idOrName) && !allowedEvalNames.has(idOrName)) return;
      compPart = compMaybe;
    }

    const code = compactCode(compPart);
    const text = String(compPart)
      .replace(/^C\s*\d\s*\.\s*\d+\s*:\s*/i, "")
      .trim();
    if (!code) return;

    if (!semesterAgg[code]) semesterAgg[code] = { label: text, S1Vals: [], S2Vals: [] };

    // Valeur directe (legacy)
    if (typeof (semLevels as any) === "number") {
      const v = semLevels as any;
      semesterAgg[code].S1Vals.push(v);
      semesterAgg[code].S2Vals.push(v);
      return;
    }

    const s1 = (semLevels as any)?.S1;
    const s2 = (semLevels as any)?.S2;
    if (typeof s1 === "number") semesterAgg[code].S1Vals.push(s1);
    if (typeof s2 === "number") semesterAgg[code].S2Vals.push(s2);
  });

  return semesterAgg;
}

const ENGAGEMENT_SCORE: Record<EngagementLevel, number> = {
  volontaire: 5,
  engage: 4,
  normal: 3,
  attente: 2,
  absence: 1,
};

function engagementLabelFromAvg(avg: number): string {
  if (!isFinite(avg) || avg <= 0) return "—";
  if (avg >= 4.5) return "Très engagé";
  if (avg >= 3.5) return "Engagé";
  if (avg >= 2.5) return "Normal";
  if (avg >= 1.5) return "En attente";
  return "Peu engagé";
}

type StudentSkillRecord = {
  [competenceLabel: string]: {
    [semester in SemesterKey]?: Level1to4;
  };
};

type SkillsDB = {
  [classId: string]: {
    [studentName: string]: StudentSkillRecord;
  };
};
interface SavedDevoirMeta {
  fileName: string;        // nom du fichier JSON (ex: devoir-123.json)
  title: string;           // titre de l'évaluation
  group?: string;          // classe (CAP1, CAP2, ...)
  evaluationType?: string; // type d'évaluation (auto, critérié, ...)
}

interface EvalMeta {
  id: string;         // identifiant interne de l'évaluation
  name: string;       // titre de l'évaluation
  fileName: string;   // nom du fichier JSON (devoir-123.json)
  group: string;      // ex : "GROUPE"
  semester: SemesterKey; // "Ne pas utiliser de semestre" = pas utilisé, sinon "S1" ou "S2"
  createdAt: string;  // date de création (ISO)
}
type NotationEntry = {
  markOn20: number;
  totalWeightForStudent: number;
  semester: SemesterKey;
  evalId: string;
  evalName: string;
  className: string;
  studentName: string;
  savedAt: string;
    // 🔹 Nouveau : scores détaillés par critère (clé = critKey, valeur = 0..4)
  scoresByCriteria?: Record<string, number>;
  engagementLevel?: EngagementLevel;
  status?: "OK" | "AB" | "N.NOT";
};

type NotationDB = {
  [schoolYear: string]: {
    [className: string]: {
      [evalId: string]: {
        [studentName: string]: NotationEntry;
      };
    };
  };
};

function getCurrentSchoolYear(): string {
  const today = new Date();
  const year = today.getFullYear();
  const month = today.getMonth(); // 0 = janvier

  // Année scolaire = septembre -> août
  if (month >= 8) {
    // septembre à décembre
    return `${year}-${year + 1}`;
  } else {
    // janvier à août
    return `${year - 1}-${year}`;
  }
}

// Retourne l'année scolaire la plus récente présente dans une base de notation.
// Permet d'afficher correctement les données d'une année passée (ex : 1ère année)
// même si la date courante est déjà sur l'année scolaire suivante.
function pickLatestSchoolYearFromNotationDB(ndb: NotationDB | null | undefined, fallback?: string): string {
  const keys = Object.keys((ndb as any) || {});
  if (!keys.length) return fallback || getCurrentSchoolYear();
  const scoreKey = (k: string) => {
    const m = String(k || "").match(/^(\d{4})/);
    return m ? parseInt(m[1], 10) : 0;
  };
  return keys.slice().sort((a, b) => scoreKey(b) - scoreKey(a))[0];
}


function toYmd(d: Date): string {
  const pad = (n: number) => String(n).padStart(2, "0");
  return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())}`;
}

function fromYmd(ymd: string): Date | null {
  const m = String(ymd || "").match(/^(\d{4})-(\d{2})-(\d{2})$/);
  if (!m) return null;
  const y = parseInt(m[1], 10);
  const mo = parseInt(m[2], 10) - 1;
  const da = parseInt(m[3], 10);
  const d = new Date(y, mo, da);
  // validation simple
  if (d.getFullYear() !== y || d.getMonth() !== mo || d.getDate() !== da) return null;
  return d;
}

function addDays(d: Date, days: number): Date {
  const out = new Date(d.getTime());
  out.setDate(out.getDate() + days);
  return out;
}

function addDaysYmd(ymd: string, days: number): string {
  const d = fromYmd(ymd);
  if (!d) return ymd;
  return toYmd(addDays(d, days));
}

const MONTHS_FR = [
  "janvier", "février", "mars", "avril", "mai", "juin",
  "juillet", "août", "septembre", "octobre", "novembre", "décembre",
];

const WEEKDAYS_FR_SHORT = ["Lun", "Mar", "Mer", "Jeu", "Ven", "Sam", "Dim"];

function formatYmdFr(ymd: string): string {
  const m = String(ymd || "").match(/^(\d{4})-(\d{2})-(\d{2})$/);
  if (!m) return ymd;
  return `${m[3]}/${m[2]}/${m[1]}`;
}

function weekdayIndexMon0(d: Date): number {
  // JS: 0=dim,1=lun,...6=sam -> Mon=0..Sun=6
  return (d.getDay() + 6) % 7;
}

function weekdayKeyFromDate(d: Date): keyof PlanningWeekdays {
  const js = d.getDay(); // 0 dim
  switch (js) {
    case 1: return "mon";
    case 2: return "tue";
    case 3: return "wed";
    case 4: return "thu";
    case 5: return "fri";
    case 6: return "sat";
    default: return "sun";
  }
}

function isYmdBetweenInclusive(ymd: string, startYmd: string, endYmd: string): boolean {
  return ymd >= startYmd && ymd <= endYmd;
}

function monthsBetweenYmd(startYmd: string, endYmd: string): Array<{ year: number; month0: number }> {
  const s = fromYmd(startYmd);
  const e = fromYmd(endYmd);
  if (!s || !e) return [];
  const out: Array<{ year: number; month0: number }> = [];
  let y = s.getFullYear();
  let m = s.getMonth();
  const endY = e.getFullYear();
  const endM = e.getMonth();

  while (y < endY || (y === endY && m <= endM)) {
    out.push({ year: y, month0: m });
    m += 1;
    if (m > 11) { m = 0; y += 1; }
    // garde-fou
    if (out.length > 36) break;
  }
  return out;
}

function findLabelInRanges(ymd: string, ranges: VacationRange[]): string | null {
  for (const r of ranges || []) {
    if (ymd >= r.startYmd && ymd < r.endYmdExclusive) return r.label || "";
  }
  return null;
}

function parseSchoolYearString(schoolYear: string): { startYear: number; endYear: number } | null {
  // Accepte : "2025-2026", "2025 – 2026", "2025/2026", "2025 - 2026", "2025-26"
  const raw = String(schoolYear || "").trim();
  const norm = raw
    .replace(/[–—]/g, "-")
    .replace(/\//g, "-")
    .replace(/\s+/g, "");

  // 2025-2026
  let m = norm.match(/^(\d{4})-(\d{4})$/);
  if (m) {
    const a = parseInt(m[1], 10);
    const b = parseInt(m[2], 10);
    if (!a || !b) return null;
    return { startYear: a, endYear: b };
  }

  // 2025-26
  m = norm.match(/^(\d{4})-(\d{2})$/);
  if (m) {
    const a = parseInt(m[1], 10);
    const yy = parseInt(m[2], 10);
    if (!a || Number.isNaN(yy)) return null;
    const century = Math.floor(a / 100) * 100;
    let b = century + yy;
    if (b < a) b += 100; // sécurité (ex: 1999-00)
    return { startYear: a, endYear: b };
  }

  return null;
}

function defaultPlanningSettings(schoolYear: string, zone: PlanningZone = "B"): PlanningSettings {
  const parsed = parseSchoolYearString(schoolYear);
  const startYear = parsed?.startYear ?? new Date().getFullYear();
  const endYear = parsed?.endYear ?? startYear + 1;

  return {
    schoolYear,
    startYmd: `${startYear}-09-01`,
    endYmd: `${endYear}-08-31`,
    zone,
    courseDays: { mon: true, tue: true, wed: true, thu: true, fri: true, sat: false, sun: false },
    vacationsMode: "auto",
    vacationsManual: [],
    stages: [],
  };
}

function getIcsUrlForZone(zone: PlanningZone): string {
  // Source officielle OpenDataSoft (Ministère) – ICS par zone
  // Exemples : Zone-B.ics / Corse.ics
  const base = "https://fr.ftp.opendatasoft.com/openscol/fr-en-calendrier-scolaire";
  if (zone === "CORSE") return `${base}/Corse.ics`;
  return `${base}/Zone-${zone}.ics`;
}

function parseIcsDateLineValue(value: string): string | null {
  // Accepte VALUE=DATE:YYYYMMDD ou YYYYMMDDT...Z
  const v = String(value || "").trim();
  const m = v.match(/(\d{4})(\d{2})(\d{2})/);
  if (!m) return null;
  return `${m[1]}-${m[2]}-${m[3]}`;
}

async function fetchVacationsForSchoolYearFromIcs(zone: PlanningZone, schoolYear: string): Promise<VacationRange[]> {
  const sy = parseSchoolYearString(schoolYear);
  if (!sy) return [];

  const schoolStart = `${sy.startYear}-09-01`;
  const schoolEndExclusive = addDaysYmd(`${sy.endYear}-08-31`, 1);

  const url = getIcsUrlForZone(zone) + `?_=${Date.now()}`;

  const res = isTauriRuntime()
    ? await tauriFetch(url, { method: "GET" })
    : await fetch(url, { method: "GET" });

  if (!res.ok) throw new Error(`ICS fetch failed: ${res.status}`);

  const ics = await res.text();

  // RFC5545: "unfold" (lignes repliées qui commencent par espace / tab)
  const rawLines = ics.replace(/\r\n/g, "\n").split("\n");
  const lines: string[] = [];
  for (const ln of rawLines) {
    if (!ln) continue;
    if ((ln.startsWith(" ") || ln.startsWith("\t")) && lines.length) {
      lines[lines.length - 1] += ln.slice(1);
    } else {
      lines.push(ln.trimEnd());
    }
  }

  const out: VacationRange[] = [];

  let inEvent = false;
  let dtStart: string | null = null;
  let dtEndExcl: string | null = null;
  let summary = "";

  const flush = () => {
    if (!dtStart || !dtEndExcl) return;

    const label = (summary || "").trim();

    // On garde surtout les vacances (et les "ponts" si présents dans l'ICS)
    const keep = /vacances/i.test(label) || /pont/i.test(label);
    if (!keep) return;

    // Overlap année scolaire
    if (dtEndExcl <= schoolStart) return;
    if (dtStart >= schoolEndExclusive) return;

    const start = dtStart < schoolStart ? schoolStart : dtStart;
    const end = dtEndExcl > schoolEndExclusive ? schoolEndExclusive : dtEndExcl;

    if (start < end) {
      out.push({
        startYmd: start,
        endYmdExclusive: end,
        label: label || "Vacances",
      });
    }
  };

  for (const line of lines) {
    if (line === "BEGIN:VEVENT") {
      inEvent = true;
      dtStart = null;
      dtEndExcl = null;
      summary = "";
      continue;
    }
    if (line === "END:VEVENT") {
      if (inEvent) flush();
      inEvent = false;
      continue;
    }
    if (!inEvent) continue;

    if (line.startsWith("DTSTART")) {
      const value = line.split(":").pop() || "";
      dtStart = parseIcsDateLineValue(value);
      continue;
    }
    if (line.startsWith("DTEND")) {
      const value = line.split(":").pop() || "";
      dtEndExcl = parseIcsDateLineValue(value);
      continue;
    }
    if (line.startsWith("SUMMARY")) {
      const idx = line.indexOf(":");
      summary = idx >= 0 ? line.slice(idx + 1) : "";
      continue;
    }
  }

  out.sort((a, b) => (a.startYmd < b.startYmd ? -1 : a.startYmd > b.startYmd ? 1 : 0));
  return out;
}

const DEFAULT_TACHES_COMPETENCES: TCMap = {
  "T1 — Prendre connaissance des informations liées à son intervention": [
    "C 1.01 : Compléter et transmettre des documents",
    "C 1.02 : Échanger et rendre compte oralement",
    "C 2.01 : Décoder un dossier technique",
    "C 3.03 : Intervenir à proximité des réseaux",
  ],
  "T10 — Réaliser des ouvrages en maçonnerie de petits éléments": [
    "C 1.02 : Échanger et rendre compte oralement",
    "C 2.01 : Décoder un dossier technique",
    "C 2.02 : Choisir les matériels et les outillages",
    "C 2.03 : Déterminer des quantités de matériaux et composants",
    "C 3.01 : Organiser son poste de travail",
    "C 3.02 : Sécuriser son intervention",
    "C 3.04 : Monter, démonter et utiliser un échafaudage",
    "C 3.12 : Réaliser des maçonneries de petits éléments",
    "C 3.13 : Intervenir sur le bâti existant",
  ],
};

const GROUPS = [
  { key: "G1", title: "COMMUNIQUER / PRÉPARER", range: [1, 6] },
  { key: "G2", title: "RÉALISER / CONTRÔLER (OUVRAGE COURANT)", range: [7, 13] },
  { key: "G3", title: "RÉALISER (TRAVAUX SPÉCIFIQUES)", range: [14, 17] },
] as const;

type GroupKey = typeof GROUPS[number]["key"];
const GROUP_STYLES: Record<GroupKey, { accentBorder: string; headerBg: string; headerText: string; buttonSelected: string; buttonHover: string; chipBg: string; chipText: string; bullet: string; }> = {
  G1: {
    accentBorder: "border-l-4 border-sky-400",
    headerBg: "bg-sky-50 dark:bg-sky-950/35",
    headerText: "text-sky-800 dark:text-sky-100",
    buttonSelected: "bg-sky-600 border-sky-600 text-white shadow-sm ring-2 ring-sky-200/50 ring-offset-1 ring-offset-white dark:bg-sky-400/30 dark:border-sky-400/35/60 dark:text-sky-50 dark:ring-sky-300/45 dark:ring-offset-[#0b1220]",
    buttonHover: "hover:bg-sky-50 dark:hover:bg-sky-400/15",
    chipBg: "bg-sky-100 dark:bg-sky-950/45",
    chipText: "text-sky-700 dark:text-sky-200",
    bullet: "bg-sky-400",
  },
  G2: {
    accentBorder: "border-l-4 border-amber-400",
    headerBg: "bg-amber-50 dark:bg-amber-950/35",
    headerText: "text-amber-800 dark:text-amber-100",
    buttonSelected: "bg-amber-600 border-amber-600 text-white shadow-sm ring-2 ring-amber-200/50 ring-offset-1 ring-offset-white dark:bg-amber-400/25 dark:border-amber-300/60 dark:text-amber-50 dark:ring-amber-300/40 dark:ring-offset-[#0b1220]",
    buttonHover: "hover:bg-amber-50 dark:hover:bg-amber-400/15",
    chipBg: "bg-amber-100 dark:bg-amber-950/45",
    chipText: "text-amber-700 dark:text-amber-200",
    bullet: "bg-amber-400",
  },
  G3: {
    accentBorder: "border-l-4 border-violet-400",
    headerBg: "bg-violet-50 dark:bg-violet-950/35",
    headerText: "text-violet-800 dark:text-violet-100",
    buttonSelected: "bg-violet-600 border-violet-600 text-white shadow-sm ring-2 ring-violet-200/50 ring-offset-1 ring-offset-white dark:bg-violet-400/25 dark:border-violet-300/60 dark:text-violet-50 dark:ring-violet-300/40 dark:ring-offset-[#0b1220]",
    buttonHover: "hover:bg-violet-50 dark:hover:bg-violet-400/15",
    chipBg: "bg-violet-100 dark:bg-violet-950/45",
    chipText: "text-violet-700 dark:text-violet-200",
    bullet: "bg-violet-400",
  },
};

// --- Groupes par épreuves (option "EP1/EP2/EP3" dans la vue Évolutions) ---
const EP_GROUP_ORDER = [
  { key: "EP1", title: "ÉPREUVE EP1" },
  { key: "EP2", title: "ÉPREUVE EP2" },
  { key: "EP3", title: "ÉPREUVE EP3" },
  { key: "OTHER", title: "AUTRES" },
] as const;

const EP_GROUP_STYLES: Record<string, { accentBorder: string; headerBg: string; headerText: string }> = {
  EP1: { accentBorder: "border-l-4 border-emerald-400", headerBg: "bg-emerald-50 dark:bg-emerald-950/35", headerText: "text-emerald-800 dark:text-emerald-100" },
  EP2: { accentBorder: "border-l-4 border-amber-400", headerBg: "bg-amber-50 dark:bg-amber-950/35", headerText: "text-amber-800 dark:text-amber-100" },
  EP3: { accentBorder: "border-l-4 border-violet-400", headerBg: "bg-violet-50 dark:bg-violet-950/35", headerText: "text-violet-800 dark:text-violet-100" },
  OTHER: { accentBorder: "border-l-4 border-neutral-300 dark:border-sky-400/35", headerBg: "bg-neutral-50 dark:bg-[#1f2d42]", headerText: "text-neutral-700 dark:text-neutral-300" },
};

const FAMILY_STYLES: Record<'C1'|'C2'|'C3'|'C4', {
  headerText: string; chipBg: string; chipText: string; bullet: string; selectedBg: string; hoverBg: string; border: string; hoverBorder: string; ring: string; accentBorder?: string;
  codeSelectedBg: string; codeSelectedText: string; selectedDarkBg: string; selectedDarkText: string;
}> = {
  C1: { headerText:"text-sky-700 dark:text-sky-300", chipBg:"bg-sky-50 dark:bg-sky-950/35", chipText:"text-sky-700", bullet:"bg-sky-400", selectedBg:"bg-sky-100 text-sky-800", hoverBg:"hover:bg-sky-100", border:"border-sky-300", hoverBorder:"hover:border-sky-400", ring:"ring-sky-400", accentBorder:"border-l-4 border-sky-400", codeSelectedBg:"bg-sky-600", codeSelectedText:"text-white-900", selectedDarkBg:"bg-sky-600", selectedDarkText:"text-white" },
  C2: { headerText:"text-amber-700 dark:text-amber-300", chipBg:"bg-amber-50 dark:bg-amber-950/35", chipText:"text-amber-700", bullet:"bg-amber-400", selectedBg:"bg-amber-100 dark:bg-amber-950/45 text-amber-800", hoverBg:"hover:bg-amber-100 dark:bg-amber-950/45", border:"border-amber-300", hoverBorder:"hover:border-amber-400", ring:"ring-amber-400", accentBorder:"border-l-4 border-amber-400", codeSelectedBg:"bg-amber-600", codeSelectedText:"text-white-900", selectedDarkBg:"bg-amber-600", selectedDarkText:"text-white" },
  C3: { headerText:"text-lime-700 dark:text-lime-300", chipBg:"bg-lime-50 dark:bg-lime-950/35", chipText:"text-lime-700", bullet:"bg-lime-400", selectedBg:"bg-lime-100 dark:bg-lime-950/45 text-lime-800", hoverBg:"hover:bg-lime-100 dark:bg-lime-950/45", border:"border-lime-300", hoverBorder:"hover:border-lime-400", ring:"ring-lime-400", accentBorder:"border-l-4 border-lime-400", codeSelectedBg:"bg-lime-600", codeSelectedText:"text-white-900", selectedDarkBg:"bg-lime-600", selectedDarkText:"text-white" },
  C4: { headerText:"text-fuchsia-700 dark:text-fuchsia-300", chipBg:"bg-fuchsia-50 dark:bg-fuchsia-950/35", chipText:"text-fuchsia-700", bullet:"bg-fuchsia-400", selectedBg:"bg-fuchsia-100 text-fuchsia-800", hoverBg:"hover:bg-fuchsia-100", border:"border-fuchsia-300", hoverBorder:"hover:border-fuchsia-400", ring:"ring-fuchsia-400", accentBorder:"border-l-4 border-fuchsia-400", codeSelectedBg:"bg-fuchsia-600", codeSelectedText:"text-white-900", selectedDarkBg:"bg-fuchsia-600", selectedDarkText:"text-white" },
};
const CLASS_BUBBLE_STYLES: Array<{ bubble: string; dot: string }> = [
  { bubble: "bg-sky-100 text-sky-900 border-sky-200 dark:bg-sky-500/20 dark:text-sky-100 dark:border-sky-400/40", dot: "bg-sky-500" },
  { bubble: "bg-amber-100 text-amber-900 border-amber-200 dark:bg-amber-500/20 dark:text-amber-100 dark:border-amber-400/40", dot: "bg-amber-500" },
  { bubble: "bg-emerald-100 text-emerald-900 border-emerald-200 dark:bg-emerald-500/20 dark:text-emerald-100 dark:border-emerald-400/40", dot: "bg-emerald-500" },
  { bubble: "bg-violet-100 text-violet-900 border-violet-200 dark:bg-violet-500/20 dark:text-violet-100 dark:border-violet-400/40", dot: "bg-violet-500" },
  { bubble: "bg-rose-100 text-rose-900 border-rose-200 dark:bg-rose-500/20 dark:text-rose-100 dark:border-rose-400/40", dot: "bg-rose-500" },
];


// ---- Tauri FS resolver (v1/v2) ----
type FsModule = {
  readTextFile: (...args: any[]) => Promise<string>;
  writeTextFile: (...args: any[]) => Promise<void>;
  mkdir?: (...args: any[]) => Promise<void>;
  stat?: (...args: any[]) => Promise<any>;
  exists?: (...args: any[]) => Promise<boolean>;
};

// --- Helpers d'import opaques (Vite ne les pré-bundle pas)
const importDyn = (m: string) => (new Function('m', 'return import(m)'))(m);

async function getTauriFs(): Promise<FsModule | null> {
  try { return await importDyn(['@tauri-apps','plugin-fs'].join('/')) as any; } catch {}
  try { return await importDyn(['@tauri-apps','api','fs'].join('/')) as any; } catch {}
  return null;
}

function isTauriRuntime(): boolean {
  const w = window as any;
  return !!(w.__TAURI__ || w.__TAURI_INTERNALS__);
}

// Récupère BaseDirectory depuis @tauri-apps/api/path (compatible v1/v2)
async function getBaseDirectory() {
  try {
    const p = await importDyn(['@tauri-apps', 'api', 'path'].join('/'));
    return p?.BaseDirectory ?? null;
  } catch {
    return null;
  }
}

// --- Dialog (Tauri v2 plugin ou v1 api)
async function getTauriDialogOpen(): Promise<((opts: any) => Promise<string | string[] | null>) | null> {
  try { const m = await importDyn(['@tauri-apps','plugin-dialog'].join('/')); return (m as any).open ?? null; } catch {}
  try { const m = await importDyn(['@tauri-apps','api','dialog'].join('/'));   return (m as any).open ?? null; } catch {}
  return null;
}

// --- Paths absolus vers AppData/devoir
async function getPathHelpers() {
  try {
    const p = await importDyn('@tauri-apps/api/path');
    return {
      join: (p as any).join as (...parts: string[]) => Promise<string>,
      appDataDir: (p as any).appDataDir as () => Promise<string>,
    };
  } catch {
    // Fallback neutre (non-Tauri)
    return { join: async (...parts: string[]) => parts.join('/'), appDataDir: async () => '' };
  }
}

async function loadExigencesFromTauri(): Promise<Record<string, string[]>> {
  try {
    const fs = await getTauriFs(); if (!fs) return {};
    const BD = await getBaseDirectory();

    const file = 'exigences_db.json';
    const optsV2 = BD ? { baseDir: BD.AppData } : undefined; // plugin-fs (v2)
    const optsV1 = BD ? { dir: BD.AppData } : undefined;     // api/fs (v1)

    // exists()
    let exists = false;
    if (fs.exists) {
      try { exists = await fs.exists(file, optsV1 ?? optsV2); } catch {}
    }
    if (!exists) {
      try { await fs.readTextFile(file, optsV2); exists = true; } catch {}
      if (!exists) { try { await fs.readTextFile(file, optsV1); exists = true; } catch {} }
    }
    if (!exists) return {};

    // read
    let txt = '';
    try { txt = await (fs as any).readTextFile(file, optsV2); }
    catch { txt = await (fs as any).readTextFile(file, optsV1); }

    const data = JSON.parse(txt);
    return (data && typeof data === 'object') ? data as Record<string, string[]> : {};
  } catch { return {}; }
}

async function saveExigencesToTauri(data: Record<string, string[]>): Promise<void> {
  try {
    const fs = await getTauriFs(); if (!fs) return;
    const BD = await getBaseDirectory();
    const file = 'exigences_db.json';
    const payload = JSON.stringify(data, null, 2);
    const optsV2 = BD ? { baseDir: BD.AppData } : undefined;
    const optsV1 = BD ? { dir: BD.AppData } : undefined;

    // write v2 d'abord, puis fallback v1
    try { await (fs as any).writeTextFile(file, payload, optsV2); }
    catch { await (fs as any).writeTextFile({ path: file, contents: payload }, optsV1); }
  } catch {}
}

// === Gestion globale des classes / élèves (eleves.json) ===

async function loadElevesFromStore(): Promise<ClassGroup[]> {
  // 1) Mode Tauri : on tente de lire eleves.json dans AppLocalData
  if (isTauriRuntime()) {
    try {
      const txt = await readTextFile('eleves.json', {
        baseDir: BaseDirectory.AppLocalData,
      });

      if (txt && txt.trim().length > 0) {
        const parsed = JSON.parse(txt);
        if (Array.isArray(parsed)) {
          console.log('[TAURI] eleves.json chargé depuis AppLocalData');
          return parsed as ClassGroup[];
        }
      }
    } catch (e) {
      // Fichier absent au 1er lancement ou autre → on laisse filer et on passe aux fallbacks
      console.warn('loadElevesFromStore (Tauri) a échoué :', e);
    }
  } else {
    console.log(
      '[WEB] Pas de runtime Tauri : on ne regarde pas eleves.json, uniquement localStorage / seed.'
    );
  }

  // 2) Fallback : cache navigateur (utile en dev ou en pur web)
  try {
    const cache = localStorage.getItem('eleves_json_cache');
    if (cache) {
      const parsed = JSON.parse(cache);
      if (Array.isArray(parsed)) {
        console.log('[WEB] Classes/élèves chargés depuis localStorage');
        return parsed as ClassGroup[];
      }
    }
  } catch (e) {
    console.warn('loadElevesFromStore (localStorage) a échoué :', e);
  }

  // 3) Dernier fallback : seed initial depuis public/data/eleves.json
  try {
    const res = await fetch('/data/eleves.json');
    if (res.ok) {
      const text = await res.text();
      const trimmed = text.trim();
      if (trimmed) {
        const parsed = JSON.parse(trimmed);
        if (Array.isArray(parsed)) {
          console.log('[SEED] Classes/élèves initialisés depuis /data/eleves.json');
          return parsed as ClassGroup[];
        }
      }
    }
  } catch (e) {
    console.warn('Impossible de charger /data/eleves.json :', e);
  }

  return [];
}

async function saveElevesToStore(groups: ClassGroup[]): Promise<void> {
  const payload = JSON.stringify(groups, null, 2);

  // 1) Mode Tauri : on écrit eleves.json dans AppLocalData
  if (isTauriRuntime()) {
    try {
      await writeTextFile('eleves.json', payload, {
        baseDir: BaseDirectory.AppLocalData,
      });
      console.log('[TAURI] eleves.json sauvegardé dans AppLocalData');
    } catch (e) {
      console.warn('saveElevesToStore (Tauri) a échoué :', e);
    }
  } else {
    console.log(
      '[WEB] Pas de runtime Tauri : sauvegarde uniquement dans localStorage (aucun eleves.json sur le disque).'
    );
  }

  // 2) Toujours : copie dans localStorage (pratique en dev)
  try {
    localStorage.setItem('eleves_json_cache', payload);
  } catch {
    // ignore
  }
}

// === Paramètres généraux (parametres_generaux.json) ===
function normalizeGeneralSettings(raw: any): GeneralSettings {
  const r = (raw && typeof raw === "object") ? raw : {};
  const classReferents = (r.classReferents && typeof r.classReferents === "object") ? r.classReferents : {};
  return {
    establishmentName: typeof r.establishmentName === "string" ? r.establishmentName : "",
    establishmentLocation: typeof r.establishmentLocation === "string" ? r.establishmentLocation : "",
    defaultReferents: typeof r.defaultReferents === "string" ? r.defaultReferents : "",
    classReferents: classReferents as Record<string, string>,
  };
}

async function loadGeneralSettingsFromStore(): Promise<GeneralSettings> {
  // 1) Mode Tauri : on tente de lire parametres_generaux.json dans AppLocalData
  if (isTauriRuntime()) {
    try {
      const txt = await readTextFile(GENERAL_SETTINGS_FILE, { baseDir: BaseDirectory.AppLocalData });
      if (txt && txt.trim().length > 0) {
        const parsed = JSON.parse(txt);
        console.log("[TAURI] parametres_generaux.json chargé depuis AppLocalData");
        return normalizeGeneralSettings(parsed);
      }
    } catch (e) {
      console.warn("loadGeneralSettingsFromStore (Tauri) a échoué :", e);
    }
  }

  // 2) Fallback : cache navigateur
  try {
    const cache = localStorage.getItem(GENERAL_SETTINGS_CACHE_KEY);
    if (cache) return normalizeGeneralSettings(JSON.parse(cache));
  } catch (e) {
    console.warn("loadGeneralSettingsFromStore (localStorage) a échoué :", e);
  }

  return { ...DEFAULT_GENERAL_SETTINGS };
}

async function saveGeneralSettingsToStore(settings: GeneralSettings): Promise<void> {
  const payload = JSON.stringify(settings, null, 2);

  // 1) Mode Tauri : écrit sur disque
  if (isTauriRuntime()) {
    try {
      await writeTextFile(GENERAL_SETTINGS_FILE, payload, { baseDir: BaseDirectory.AppLocalData });
      console.log("[TAURI] parametres_generaux.json sauvegardé dans AppLocalData");
    } catch (e) {
      console.warn("saveGeneralSettingsToStore (Tauri) a échoué :", e);
    }
  }

  // 2) Toujours : localStorage (utile en dev)
  try { localStorage.setItem(GENERAL_SETTINGS_CACHE_KEY, payload); } catch {}
}



// === Base des évaluations (evaluations_db.json) ===
async function loadEvalMetaFromStore(year: TrainingYear): Promise<EvalMeta[]> {
  const file = evalMetaFileName(year);
  const cacheKey = evalMetaCacheKey(year);

  // Petit helper (évite de dépendre de ensureJsonName qui est défini plus bas)
  const safeJsonName = (name: string) =>
    String(name || "").toLowerCase().endsWith(".json") ? String(name) : `${name}.json`;

  const filterByExistingDevoirFiles = async (list: EvalMeta[]) => {
    // En mode Web (sans FS), on ne peut pas vérifier l'existence des fichiers.
    if (!isTauriRuntime()) return list;

    const dir = devoirDirName(year);
    const checks = await Promise.all(
      list.map(async (ev) => {
        try {
          const p = `${dir}/${safeJsonName(ev.fileName)}`;
          return await exists(p, { baseDir: BaseDirectory.AppLocalData });
        } catch {
          // En cas d'erreur FS, on garde l'item (on évite de "perdre" des données)
          return true;
        }
      })
    );

    return list.filter((_, i) => checks[i]);
  };

  // 1) Mode Tauri : fichier sur le disque
  if (isTauriRuntime()) {
    try {
      const txt = await readTextFile(file, {
        baseDir: BaseDirectory.AppLocalData,
      });

      if (txt && txt.trim().length > 0) {
        const parsed = JSON.parse(txt);
        if (Array.isArray(parsed)) {
          return await filterByExistingDevoirFiles(parsed as EvalMeta[]);
        }
      }
    } catch (e) {
      console.warn("loadEvalMetaFromStore (Tauri) a échoué :", e);
    }

    // 🧩 Migration/fallback : ancien fichier unique
    try {
      const legacyTxt = await readTextFile(LEGACY_EVALMETA_FILE, {
        baseDir: BaseDirectory.AppLocalData,
      });
      if (legacyTxt && legacyTxt.trim().length > 0) {
        const parsed = JSON.parse(legacyTxt);
        if (Array.isArray(parsed)) {
          return await filterByExistingDevoirFiles(parsed as EvalMeta[]);
        }
      }
    } catch {
      // ignore
    }
  }

  // 2) Fallback : cache navigateur (localStorage)
  try {
    const cache = localStorage.getItem(cacheKey);
    if (cache) {
      const parsed = JSON.parse(cache);
      if (Array.isArray(parsed)) {
        return await filterByExistingDevoirFiles(parsed as EvalMeta[]);
      }
    }
  } catch (e) {
    console.warn("loadEvalMetaFromStore (localStorage) a échoué :", e);
  }

  // 🧩 Migration/fallback : ancien cache unique
  try {
    const legacyCache = localStorage.getItem(LEGACY_EVALMETA_CACHE);
    if (legacyCache) {
      const parsed = JSON.parse(legacyCache);
      if (Array.isArray(parsed)) {
        return await filterByExistingDevoirFiles(parsed as EvalMeta[]);
      }
    }
  } catch {
    // ignore
  }

  return [];
}

// === Suivi des compétences (skills_db.json) ===

async function loadSkillsFromStore(year: TrainingYear): Promise<SkillsDB> {
  const file = skillsDbFileName(year);
  const cacheKey = skillsDbCacheKey(year);

  // 1) Mode Tauri : on tente de lire le bon fichier dans AppLocalData
  if (isTauriRuntime()) {
    try {
      const txt = await readTextFile(file, {
        baseDir: BaseDirectory.AppLocalData,
      });

      if (txt && txt.trim().length > 0) {
        const parsed = JSON.parse(txt);
        if (parsed && typeof parsed === "object") {
          console.log(`[TAURI] ${file} chargé depuis AppLocalData`);
          return parsed as SkillsDB;
        }
      }
    } catch (e) {
      console.warn("loadSkillsFromStore (Tauri) a échoué :", e);
    }

    // 🧩 Migration/fallback : ancien fichier unique
    try {
      const legacyTxt = await readTextFile(LEGACY_SKILLS_FILE, {
        baseDir: BaseDirectory.AppLocalData,
      });
      if (legacyTxt && legacyTxt.trim().length > 0) {
        const parsed = JSON.parse(legacyTxt);
        if (parsed && typeof parsed === "object") {
          console.log(`[TAURI] ${LEGACY_SKILLS_FILE} chargé (fallback legacy)`);
          return parsed as SkillsDB;
        }
      }
    } catch {
      // ignore
    }
  } else {
    console.log(
      "[WEB] Pas de runtime Tauri : on ne regarde pas le disque, uniquement localStorage."
    );
  }

  // 2) Fallback : cache navigateur
  try {
    const cache = localStorage.getItem(cacheKey);
    if (cache) {
      const parsed = JSON.parse(cache);
      if (parsed && typeof parsed === "object") {
        console.log(`[WEB] ${cacheKey} chargé depuis localStorage`);
        return parsed as SkillsDB;
      }
    }
  } catch (e) {
    console.warn("loadSkillsFromStore (localStorage) a échoué :", e);
  }

  // 🧩 Migration/fallback : ancien cache unique
  try {
    const legacyCache = localStorage.getItem(LEGACY_SKILLS_CACHE);
    if (legacyCache) {
      const parsed = JSON.parse(legacyCache);
      if (parsed && typeof parsed === "object") {
        console.log(`[WEB] ${LEGACY_SKILLS_CACHE} chargé (fallback legacy)`);
        return parsed as SkillsDB;
      }
    }
  } catch {
    // ignore
  }

  return {};
}

async function saveSkillsToStore(db: SkillsDB, year: TrainingYear): Promise<void> {
  const payload = JSON.stringify(db, null, 2);
  const file = skillsDbFileName(year);
  const cacheKey = skillsDbCacheKey(year);

  // 1) Mode Tauri : on écrit le bon fichier dans AppLocalData
  if (isTauriRuntime()) {
    try {
      await writeTextFile(file, payload, {
        baseDir: BaseDirectory.AppLocalData,
      });
      console.log(`[TAURI] ${file} sauvegardé dans AppLocalData`);
    } catch (e) {
      console.warn("saveSkillsToStore (Tauri) a échoué :", e);
    }
  } else {
    console.log(
      "[WEB] Pas de runtime Tauri : sauvegarde du suivi uniquement dans localStorage."
    );
  }

  // 2) Toujours : copie dans localStorage
  try {
    localStorage.setItem(cacheKey, payload);
  } catch {
    // ignore
  }
}

async function saveEvalMetaToStore(list: EvalMeta[], year: TrainingYear): Promise<void> {
  const payload = JSON.stringify(list, null, 2);
  const file = evalMetaFileName(year);
  const cacheKey = evalMetaCacheKey(year);

  // 1) Tauri : on écrit le bon fichier dans AppLocalData
  if (isTauriRuntime()) {
    try {
      await writeTextFile(file, payload, {
        baseDir: BaseDirectory.AppLocalData,
      });
      console.log(`[TAURI] ${file} sauvegardé dans AppLocalData`);
    } catch (e) {
      console.warn("saveEvalMetaToStore (Tauri) a échoué :", e);
    }
  } else {
    console.log(
      "[WEB] Pas de runtime Tauri : sauvegarde des évaluations uniquement dans localStorage."
    );
  }

  // 2) Toujours : copie dans localStorage (pratique en dev)
  try {
    localStorage.setItem(cacheKey, payload);
  } catch (e) {
    console.warn("saveEvalMetaToStore (localStorage) a échoué :", e);
  }
}
// === Notation des élèves (notation_db.json) === (notation_db.json) ===
async function loadNotationFromStore(year: TrainingYear): Promise<NotationDB> {
  const file = notationDbFileName(year);
  const cacheKey = notationDbCacheKey(year);

  // 1) Mode Tauri : fichier sur le disque
  if (isTauriRuntime()) {
    try {
      const txt = await readTextFile(file, {
        baseDir: BaseDirectory.AppLocalData,
      });

      if (txt && txt.trim().length > 0) {
        const parsed = JSON.parse(txt);
        if (parsed && typeof parsed === "object") {
          console.log(`[TAURI] ${file} chargé depuis AppLocalData`);
          return parsed as NotationDB;
        }
      }
    } catch (e) {
      console.warn("loadNotationFromStore (Tauri) a échoué :", e);
    }

    // 🧩 Migration/fallback : ancien fichier unique
    try {
      const legacyTxt = await readTextFile(LEGACY_NOTATION_FILE, {
        baseDir: BaseDirectory.AppLocalData,
      });
      if (legacyTxt && legacyTxt.trim().length > 0) {
        const parsed = JSON.parse(legacyTxt);
        if (parsed && typeof parsed === "object") {
          console.log(`[TAURI] ${LEGACY_NOTATION_FILE} chargé (fallback legacy)`);
          return parsed as NotationDB;
        }
      }
    } catch {
      // ignore
    }
  } else {
    console.log(
      "[WEB] Pas de runtime Tauri : on ne regarde pas le disque, uniquement localStorage."
    );
  }

  // 2) Fallback : cache navigateur
  try {
    const cache = localStorage.getItem(cacheKey);
    if (cache) {
      const parsed = JSON.parse(cache);
      if (parsed && typeof parsed === "object") {
        console.log(`[WEB] ${cacheKey} chargé depuis localStorage`);
        return parsed as NotationDB;
      }
    }
  } catch (e) {
    console.warn("loadNotationFromStore (localStorage) a échoué :", e);
  }

  // 🧩 Migration/fallback : ancien cache unique
  try {
    const legacyCache = localStorage.getItem(LEGACY_NOTATION_CACHE);
    if (legacyCache) {
      const parsed = JSON.parse(legacyCache);
      if (parsed && typeof parsed === "object") {
        console.log(`[WEB] ${LEGACY_NOTATION_CACHE} chargé (fallback legacy)`);
        return parsed as NotationDB;
      }
    }
  } catch {
    // ignore
  }

  return {};
}

async function saveNotationToStore(db: NotationDB, year: TrainingYear): Promise<void> {
  const payload = JSON.stringify(db, null, 2);
  const file = notationDbFileName(year);
  const cacheKey = notationDbCacheKey(year);

  // 1) Mode Tauri : écriture sur le disque
  if (isTauriRuntime()) {
    try {
      await writeTextFile(file, payload, {
        baseDir: BaseDirectory.AppLocalData,
      });
      console.log(`[TAURI] ${file} sauvegardé dans AppLocalData`);
    } catch (e) {
      console.warn("saveNotationToStore (Tauri) a échoué :", e);
    }
  } else {
    console.log(
      "[WEB] Pas de runtime Tauri : sauvegarde de notation_db uniquement dans localStorage."
    );
  }

  // 2) Toujours : copie dans localStorage
  try {
    localStorage.setItem(cacheKey, payload);
  } catch {
    // ignore
  }
}

// === Absences / Retards (absences_retards_*.json) ===
async function loadAbsencesRetardsFromStore(year: TrainingYear): Promise<AbsencesRetardsStore> {
  const file = absencesDbFileName(year);
  const cacheKey = absencesDbCacheKey(year);

  if (isTauriRuntime()) {
    try {
      const txt = await readTextFile(file, { baseDir: BaseDirectory.AppLocalData });
      if (txt && txt.trim().length > 0) {
        const parsed = JSON.parse(txt);
        if (parsed && typeof parsed === "object") {
          return {
            records: (parsed as any).records && typeof (parsed as any).records === "object" ? (parsed as any).records : {},
            planning: (parsed as any).planning && typeof (parsed as any).planning === "object" ? (parsed as any).planning : {},
          } as AbsencesRetardsStore;
        }
      }
    } catch (e) {
      console.warn("loadAbsencesRetardsFromStore (Tauri) a échoué :", e);
    }
  }

  try {
    const cache = localStorage.getItem(cacheKey);
    if (cache) {
      const parsed = JSON.parse(cache);
      if (parsed && typeof parsed === "object") {
        return {
          records: (parsed as any).records && typeof (parsed as any).records === "object" ? (parsed as any).records : {},
          planning: (parsed as any).planning && typeof (parsed as any).planning === "object" ? (parsed as any).planning : {},
        } as AbsencesRetardsStore;
      }
    }
  } catch {
    // ignore
  }

  return { records: {}, planning: {} };
}

async function saveAbsencesRetardsToStore(store: AbsencesRetardsStore, year: TrainingYear): Promise<void> {
  const payload = JSON.stringify(store, null, 2);
  const file = absencesDbFileName(year);
  const cacheKey = absencesDbCacheKey(year);

  if (isTauriRuntime()) {
    try {
      await writeTextFile(file, payload, { baseDir: BaseDirectory.AppLocalData });
    } catch (e) {
      console.warn("saveAbsencesRetardsToStore (Tauri) a échoué :", e);
    }
  }

  try {
    localStorage.setItem(cacheKey, payload);
  } catch {
    // ignore
  }
}
// -- Version robuste Tauri v2/v1 : utilise d'abord plugin-dialog + plugin-fs, puis bascule vers api/dialog + api/fs v2/v1 : utilise d'abord plugin-dialog + plugin-fs, puis bascule vers api/dialog + api/fs
async function saveEvaluationToLocalFolder(
  filename: string,
  data: unknown,
  year: TrainingYear
) {
  try {
    if (!isTauriRuntime()) {
      console.warn("Hors runtime Tauri, pas de sauvegarde disque.");
      return;
    }

    const dir = devoirDirName(year);

    // 📁 Crée le dossier année dans AppLocalData
    await mkdir(dir, {
      baseDir: BaseDirectory.AppLocalData,
    }).catch(() => {
      // si le dossier existe déjà, on ignore l'erreur
    });

    const safeName = filename.endsWith(".json") ? filename : `${filename}.json`;
    const json = JSON.stringify(data, null, 2);

    // 🔒 On écrit TOUJOURS dans AppLocalData/<dir>/<nom>.json
    await writeTextFile(`${dir}/${safeName}`, json, {
      baseDir: BaseDirectory.AppLocalData,
    });

    alert("💾 Devoir enregistré avec succès !");
  } catch (err) {
    console.error("Erreur sauvegarde (Tauri):", err);
    alert("❌ Impossible d'enregistrer le devoir.");
  }
}



function parsePrintWindowParams() {
  try {
    const search = new URLSearchParams(window.location.search);
    const hash = window.location.hash || "";
    // Accept formats:
    //  - "#/?printWindow=1&job=...&autoPrint=1"
    //  - "#printWindow=1&job=...&autoPrint=1"
    //  - "?printWindow=1&job=...&autoPrint=1"
    let hashParams = new URLSearchParams();
    if (hash.startsWith("#")) {
      const raw = hash.slice(1);
      const qIdx = raw.indexOf("?");
      const qs = qIdx >= 0 ? raw.slice(qIdx + 1) : raw.replace(/^\/?/, "");
      hashParams = new URLSearchParams(qs);
    }
    const isPrintWindow = search.get("printWindow") === "1" || hashParams.get("printWindow") === "1";
    const job = search.get("job") || hashParams.get("job") || "";
    const autoPrint = (search.get("autoPrint") || hashParams.get("autoPrint")) === "1";
    return { isPrintWindow, job, autoPrint };
  } catch {
    return { isPrintWindow: false, job: "", autoPrint: false };
  }
}

function parseUrlPreviewParams() {
  try {
    const search = new URLSearchParams(window.location.search);
    const hash = window.location.hash || "";
    // Accept formats:
    //  - "#/?urlPreview=1&src=..."
    //  - "#urlPreview=1&src=..."
    //  - "?urlPreview=1&src=..."
    let hashParams = new URLSearchParams();
    if (hash.startsWith("#")) {
      const raw = hash.slice(1);
      const qIdx = raw.indexOf("?");
      const qs = qIdx >= 0 ? raw.slice(qIdx + 1) : raw.replace(/^\/?/, "");
      hashParams = new URLSearchParams(qs);
    }

    const isUrlPreviewWindow =
      search.get("urlPreview") === "1" || hashParams.get("urlPreview") === "1";

    const src = search.get("src") || hashParams.get("src") || "";

    return {
      isUrlPreviewWindow,
      src: src ? decodeURIComponent(src) : "",
    };
  } catch {
    return { isUrlPreviewWindow: false, src: "" };
  }
}

function StandaloneUrlPreviewWindow(props: { src: string }) {
  const { src } = props;

  const handleClose = async () => {
    try {
      await getCurrentWindow().close();
    } catch {
      try {
        window.close();
      } catch {}
    }
  };

  return (
    <div className="h-screen w-screen bg-white dark:bg-[#0f1b2d] flex flex-col">
      <div className="p-2 border-b border-neutral-200 dark:border-sky-400/35 flex items-center justify-between">
        <div className="text-xs truncate pr-2 text-neutral-700 dark:text-neutral-200">
          Aperçu : {src || "—"}
        </div>
        <Button className="h-8 px-3 text-xs" onClick={handleClose}>
          Fermer
        </Button>
      </div>

      {!src ? (
        <div className="p-4 text-sm text-neutral-600 dark:text-neutral-300">
          Aucune URL à afficher.
        </div>
      ) : (
        <iframe title="Aperçu référentiel" src={src} className="flex-1 w-full" />
      )}
    </div>
  );
}

async function openUrlPreviewWindow(src: string) {
  if (!src) return;

  // Hors Tauri : on ouvre directement dans le navigateur
  if (!isTauriRuntime()) {
    window.open(src, "_blank", "noopener,noreferrer");
    return;
  }

  const label = `url_preview_${Date.now()}`;
  // IMPORTANT : ouvrir directement l'URL dans une nouvelle WebviewWindow,
  // sinon on risque d'avoir un "aperçu" qui affiche l'app + l'URL (double page).
  const w = new WebviewWindow(label, {
    url: src,
    title: "Aperçu référentiel",
    width: 1200,
    height: 850,
    resizable: true,
    decorations: true,
  });

  w.once("tauri://created", async () => {
    try {
      await w.center();
    } catch {}
    try {
      await w.setFocus();
    } catch {}
  });
}

function StandalonePrintWindow(props: { job: string; autoPrint: boolean }) {
  const { job, autoPrint } = props;
  const iframeRef = React.useRef<HTMLIFrameElement | null>(null);
  const [html, setHtml] = React.useState<string>("");
  const [error, setError] = React.useState<string | null>(null);

  React.useEffect(() => {
    let cancelled = false;
    (async () => {
      try {
        if (!job) {
          setError("Aucun contenu d'impression à afficher (job manquant).");
          return;
        }
        const content = await readTextFile(job, { baseDir: BaseDirectory.AppLocalData });
        if (!cancelled) {
          setHtml(content);
          setError(null);
        }
      } catch (e) {
        console.error("StandalonePrintWindow readTextFile failed:", e);
        if (!cancelled) setError("Impossible de charger le contenu d'impression.");
      }
    })();
    return () => { cancelled = true; };
  }, [job]);

  const handleClose = async () => {
    try {
      await getCurrentWindow().close();
    } catch (e) {
      try { window.close(); } catch {}
    }
  };

  const handlePrint = () => {
    const iframe = iframeRef.current;
    if (!iframe) return;
    try {
      const win = iframe.contentWindow;
      if (win) {
        win.focus();
        win.print();
      }
    } catch (e) {
      console.warn("StandalonePrintWindow print failed:", e);
    }
  };

  React.useEffect(() => {
    if (!autoPrint || !html) return;
    const iframe = iframeRef.current;
    if (!iframe) return;

    const doPrint = () => {
      // Laisser un petit délai pour que la page soit bien rendue
      setTimeout(() => {
        handlePrint();
      }, 250);
    };

    // Si déjà chargé, imprimer; sinon attendre l'event load
    const doc = iframe.contentDocument;
    if (doc && doc.readyState === "complete") {
      doPrint();
      return;
    }
    iframe.addEventListener("load", doPrint, { once: true });
  }, [autoPrint, html]);

  return (
    <div style={{ height: "100vh", width: "100vw", display: "flex", flexDirection: "column", background: "#fff" }}>
      {/* Barre haute blanche dédiée à la fenêtre d'impression */}
      <div style={{ height: 44, borderBottom: "1px solid #e5e7eb", display: "flex", alignItems: "center", justifyContent: "space-between", padding: "0 12px", background: "#fff" }}>
        <div style={{ fontSize: 13, fontWeight: 600, color: "#111827" }}>Impression</div>
        <div style={{ display: "flex", gap: 8 }}>
          <button
            type="button"
            onClick={handlePrint}
            style={{ height: 30, padding: "0 10px", borderRadius: 8, border: "1px solid #d1d5db", background: "#fff", fontSize: 12 }}
          >
            Imprimer
          </button>
          <button
            type="button"
            onClick={handleClose}
            style={{ height: 30, padding: "0 10px", borderRadius: 8, border: "1px solid #d1d5db", background: "#fff", fontSize: 12 }}
          >
            Fermer
          </button>
        </div>
      </div>

      <div style={{ flex: 1, minHeight: 0, background: "#f3f4f6", padding: 12 }}>
        {error ? (
          <div style={{ color: "#b91c1c", fontSize: 13 }}>{error}</div>
        ) : (
          <iframe
            ref={iframeRef}
            title="print"
            style={{ width: "100%", height: "100%", border: "0", background: "#fff" }}
            srcDoc={html}
          />
        )}
      </div>
    </div>
  );
}


export default function App() {
  const __up = parseUrlPreviewParams();
  if (__up.isUrlPreviewWindow) {
    return <StandaloneUrlPreviewWindow src={__up.src} />;
  }
  const __pw = parsePrintWindowParams();
  if (__pw.isPrintWindow) {
    return <StandalonePrintWindow job={__pw.job} autoPrint={__pw.autoPrint} />;
  }
  // --- Initial synchronous hydration from cache (improves first-render display) ---
  let __initPersistedExigences: Record<string, string[]> = {};
  try {
    const cache = localStorage.getItem('exigences_db_cache');
    if (cache) __initPersistedExigences = JSON.parse(cache);
  } catch (e) { /* ignore */ }
  let __initTrainingYear: TrainingYear = "premiere";
  try {
    const y = localStorage.getItem("training_year");
    if (y === "premiere" || y === "deuxieme") __initTrainingYear = y as TrainingYear;
  } catch {}

  let __initEvalMeta: EvalMeta[] = [];
  try {
    const cacheEval =
      localStorage.getItem(evalMetaCacheKey(__initTrainingYear)) ||
      localStorage.getItem(LEGACY_EVALMETA_CACHE);
    if (cacheEval) __initEvalMeta = JSON.parse(cacheEval);
  } catch (e) { /* ignore */ }

  // --- États de persistance & données ---
  const [trainingYear, setTrainingYear] = React.useState<TrainingYear>(__initTrainingYear);
  const trainingYearRef = React.useRef<TrainingYear>(trainingYear);
  React.useEffect(() => {
    trainingYearRef.current = trainingYear;
  }, [trainingYear]);

  const [evalMetaBootstrapped, setEvalMetaBootstrapped] = React.useState(false);
  const DEVOIR_DIR = devoirDirName(trainingYear);
  const DEVOIR_TRASH_DIR = devoirTrashDirName(trainingYear);

  // Persistance du choix d'année (utile pour retrouver la même vue au redémarrage)
  React.useEffect(() => {
    try {
      localStorage.setItem("training_year", trainingYear);
    } catch {}
  }, [trainingYear]);


  const [persistedExigencesDB, setPersistedExigencesDB] = React.useState<Record<string, string[]>>(__initPersistedExigences);
  const [exigencesIndex, setExigencesIndex] = React.useState<Record<string, Record<string, string[]>>>(() => buildExigencesIndex(__initPersistedExigences));
  const [customExigences, setCustomExigences] = React.useState<Record<string, string[]>>({});
  const [selectedExigence, setSelectedExigence] = React.useState<Record<string, string[]>>({});
  const [critResDB, setCritResDB] = React.useState<CriteresResultsDB | null>(() => {
    try {
      const c = localStorage.getItem("criteres_resultats_cache");
      if (c) return JSON.parse(c) as CriteresResultsDB;
    } catch {}
    return null;
  });
  const [tcMap, setTcMap] = useState<TCMap>(DEFAULT_TACHES_COMPETENCES);
    // Toutes les compétences du référentiel (utilisées dans la vue "classe")
  const allCompetencesForSuivi = React.useMemo(
    () => (critResDB ? Object.keys(critResDB) : []),
    [critResDB]
  );

  const autosaveTimer = React.useRef<number | null>(null);
  const previewIframeRef = React.useRef<HTMLIFrameElement | null>(null);
  const printIframeRef = React.useRef<HTMLIFrameElement | null>(null);
  const printJobIframeRef = React.useRef<HTMLIFrameElement | null>(null);

  // Impression (mise en page spécifique, ex. bilan périodique)
  const [isPrinting, setIsPrinting] = React.useState(false);
  React.useEffect(() => {
    if (typeof window === "undefined" || typeof window.matchMedia !== "function") return;

    const mql = window.matchMedia("print");
    const onChange = (e: MediaQueryListEvent | MediaQueryList) => {
      // Safari peut appeler avec MediaQueryList
      const matches = "matches" in e ? (e as any).matches : (mql as any).matches;
      setIsPrinting(!!matches);
    };

    const before = () => setIsPrinting(true);
    const after = () => setIsPrinting(false);

    try {
      mql.addEventListener("change", onChange as any);
    } catch {
      // Safari < 14
      (mql as any).addListener?.(onChange);
    }

    window.addEventListener("beforeprint", before);
    window.addEventListener("afterprint", after);

    setIsPrinting(!!mql.matches);

    return () => {
      try {
        mql.removeEventListener("change", onChange as any);
      } catch {
        (mql as any).removeListener?.(onChange);
      }
      window.removeEventListener("beforeprint", before);
      window.removeEventListener("afterprint", after);
    };
  }, []);

  const [evalMetaList, setEvalMetaList] = React.useState<EvalMeta[]>(__initEvalMeta);
    // Notation par élève / devoir / année scolaire
  const [notationDB, setNotationDB] = React.useState<NotationDB>({});
  const [notationBootstrapped, setNotationBootstrapped] = React.useState(false);

  // 🔒 Réfs pour éviter les pertes de données (ex: l'utilisateur saisit une note avant la fin du chargement)
  const notationDBRef = React.useRef<NotationDB>({});
  const notationDirtyRef = React.useRef(false);
  const notationLoadTokenRef = React.useRef(0);

  // Toujours garder une copie à jour



// Absences / retards (par classe / année scolaire)
const [absencesStore, setAbsencesStore] = React.useState<AbsencesRetardsStore>({ records: {}, planning: {} });
const [absencesBootstrapped, setAbsencesBootstrapped] = React.useState(false);
const absencesStoreRef = React.useRef<AbsencesRetardsStore>({ records: {}, planning: {} });
const absencesLoadTokenRef = React.useRef(0);
const absencesSaveTimerRef = React.useRef<number | null>(null);

React.useEffect(() => {
  absencesStoreRef.current = absencesStore;
}, [absencesStore]);

// Charger la base Absences/Retards au démarrage + à chaque changement d'année de formation
React.useEffect(() => {
  let mounted = true;
  const token = ++absencesLoadTokenRef.current;
  setAbsencesBootstrapped(false);

  (async () => {
    try {
      const db = await loadAbsencesRetardsFromStore(trainingYear);
      if (!mounted || absencesLoadTokenRef.current !== token) return;
      setAbsencesStore(db);
    } finally {
      if (!mounted || absencesLoadTokenRef.current !== token) return;
      setAbsencesBootstrapped(true);
    }
  })();

  return () => {
    mounted = false;
  };
}, [trainingYear]);

// Autosave (debounce)
React.useEffect(() => {
  if (!absencesBootstrapped) return;
  if (absencesSaveTimerRef.current) window.clearTimeout(absencesSaveTimerRef.current);
  absencesSaveTimerRef.current = window.setTimeout(() => {
    saveAbsencesRetardsToStore(absencesStoreRef.current, trainingYear);
  }, 500);
  return () => {
    if (absencesSaveTimerRef.current) window.clearTimeout(absencesSaveTimerRef.current);
  };
}, [absencesBootstrapped, absencesStore, trainingYear]);



  React.useEffect(() => {
    notationDBRef.current = notationDB;
  }, [notationDB]);

   // -- Expose debug helpers on window for DevTools --
  React.useEffect(() => {
    (window as any).__APP_DEBUG__ = {
      getPersistedExigencesFor,
      exigencesIndex,
      persistedExigencesDB,
      upsert: upsertPersonalExigences,
    };
    console.info('[DEBUG] __APP_DEBUG__ available: __APP_DEBUG__.getPersistedExigencesFor(code, item)');
  }, [exigencesIndex, persistedExigencesDB]);

// Charger la base des notations (selon l'année) au démarrage + à chaque changement d'année
React.useEffect(() => {
  let mounted = true;
  const token = ++notationLoadTokenRef.current;
  setNotationBootstrapped(false);

  // Changement d'année → on repart sur un état "non modifié".
  notationDirtyRef.current = false;

  (async () => {
    try {
      const db = await loadNotationFromStore(trainingYear);
      // Si un autre chargement a été lancé entre-temps, on ignore celui-ci
      if (!mounted || notationLoadTokenRef.current !== token) return;

      // Si l'utilisateur a déjà modifié des notes avant la fin du chargement,
      // on ne doit surtout pas écraser ses saisies.
      if (notationDirtyRef.current) {
        console.warn(
          "[NOTE] Chargement notation ignoré (l'utilisateur a déjà modifié des notes)."
        );
        return;
      }

      if (db && typeof db === "object") {
        setNotationDB(db);
      } else {
        setNotationDB({});
      }
    } finally {
      if (mounted && notationLoadTokenRef.current === token) {
        setNotationBootstrapped(true);
      }
    }
  })();

  return () => {
    mounted = false;
  };
}, [trainingYear]);

// Sauvegarder la base des notations dès qu'elle change,
// mais seulement après le premier chargement (et dans le fichier de l'année courante)
React.useEffect(() => {
  if (!notationBootstrapped) return;
  const y = trainingYearRef.current;
  saveNotationToStore(notationDB, y);
}, [notationBootstrapped, notationDB]);

  // --- Lookup persistant normalisé par code (C2.01) + item ---
  const getPersistedExigencesFor = React.useCallback((comp, item) => {
    const code = __extractCode(comp) || comp;
    const codeKey = __norm(code);
    const itemKey = __norm(__cleanItem(item));
    const bucket = exigencesIndex[codeKey] || {};
    return bucket[itemKey] || [];
  }, [exigencesIndex]);
  // --- Map (code,item) -> rawKey from persisted DB, to preserve existing keys when saving ---
  const rawKeyByPairRef = React.useRef<Record<string, string>>({});
  React.useEffect(() => {
    const map: Record<string, string> = {};
    for (const rawKey of Object.keys(persistedExigencesDB || {})) {
      const k = String(rawKey || '').trim().replace(/\s+/g, ' ');
      const parts = k.split(' II ');
      const left = parts[0] || '';
      const right = parts[1] || k;
      const code = __extractCode(left) || left;
      const item = __cleanItem(right);
      const codeKey = __norm(code);
      const itemKey = __norm(item);
      map[codeKey + '::' + itemKey] = rawKey;
    }
    rawKeyByPairRef.current = map;
  }, [persistedExigencesDB]);

  // --- Upsert: merges values and writes under existing rawKey when available, else canonical "CODE II item :" ---
  const upsertPersonalExigences = React.useCallback((code: string, item: string, values: string[]) => {
    const codeKey = __norm(code);
    const itemKey = __norm(__cleanItem(item));
    const pair = codeKey + '::' + itemKey;
    const rawKey = rawKeyByPairRef.current[pair] || `${code} II ${__cleanItem(item)} :`;
    const current = Array.isArray((persistedExigencesDB as any)?.[rawKey]) ? (persistedExigencesDB as any)[rawKey] as string[] : [];
    const merged = Array.from(new Set([...(current || []), ...(values || [])])).filter(Boolean);
    const next = { ...(persistedExigencesDB || {}) , [rawKey]: merged };
    setPersistedExigencesDB(next);
    setExigencesIndex(buildExigencesIndex(next));
    try { localStorage.setItem('exigences_db_cache', JSON.stringify(next)); } catch {}
    (async () => {
      try {
        if (isTauriRuntime() && await getTauriFs()) {
          await saveExigencesToTauri(next);
        }
      } catch (e) {
        console.warn('saveExigencesToTauri failed', e);
      }
    })();
  }, [persistedExigencesDB]);


  // --- États UI / config ---
  const [step, setStep] = useState<"params" | 1 | 2 | 3 | 4>(1);
  const [updateBusy, setUpdateBusy] = useState(false);
  const [theme, setTheme] = useState<'light' | 'dark'>(() =>
    (typeof window !== 'undefined' ? (localStorage.getItem('theme') as 'light' | 'dark') || 'light' : 'light')
  );
  const [title, setTitle] = useState("Évaluation CAP Maçonnerie");
  const [project, setProject] = useState("");
  const [professionalSituation, setProfessionalSituation] = useState("");
  const [evaluator, setEvaluator] = useState("");
  const [group, setGroup] = useState("GROUPE");
  const [objectives, setObjectives] = useState("");
  const [logoDataUrl, setLogoDataUrl] = useState<string | null>(null);
  // Doit correspondre aux valeurs utilisées dans l'app :
  // "Auto-évaluation" | "code-couleur" | "criterie"
  const [evaluationType, setEvaluationType] = useState<string>("criterie")
  const [evaluationId, setEvaluationId] = useState<string>(() =>
    `${Date.now()}-${Math.random().toString(16).slice(2)}`
  );
  const [evaluationSemester, setEvaluationSemester] = useState<SemesterKey>("Ne pas utiliser de semestre");
  const [loadedDevoirFileName, setLoadedDevoirFileName] = useState<string | null>(null);


  const [evaluationCategory, setEvaluationCategory] = useState<EvaluationCategory>("Découverte professionnel");
  const [selectedCompetences, setSelectedCompetences] = useState<string[]>([]);
  const [selectedCriteres, setSelectedCriteres] = useState<string[]>([]);
  const [selectedSubCrit, setSelectedSubCrit] = useState<string[]>([]);
  const [expandedTasks, setExpandedTasks] = useState<Record<string, boolean>>({});
  const [expandedCompetences, setExpandedCompetences] = useState<Record<string, boolean>>({});
  const [manageKey, setManageKey] = useState<string | null>(null);
  const [drawerInput, setDrawerInput] = useState<string>("");
  const [inlineAddKey, setInlineAddKey] = useState<string | null>(null);
  const [inlineAddValue, setInlineAddValue] = useState<string>("");
  const [activeTask, setActiveTask] = useState<string | null>(null);
  const [selectedTasks, setSelectedTasks] = useState<string[]>([]);
  const [previewOpen, setPreviewOpen] = useState(false);
  const [previewHtml, setPreviewHtml] = useState<string | null>(null);
  const [previewEvaluationType, setPreviewEvaluationType] = useState<string>(evaluationType);
  const [printOpen, setPrintOpen] = useState(false);
  const [printHtml, setPrintHtml] = useState<string | null>(null);
  const [printEvaluationType, setPrintEvaluationType] = useState<string>(evaluationType);
  const [autoPrintAfterPreview, setAutoPrintAfterPreview] = useState(false);
  const [autoPrintAfterPrint, setAutoPrintAfterPrint] = useState(false);
  const [printJobHtml, setPrintJobHtml] = useState<string | null>(null);
const closePreviewModal = () => {
  setAutoPrintAfterPreview(false);
  setPreviewOpen(false);
  setPreviewHtml(null);
};

const closePrintModal = () => {
  setAutoPrintAfterPrint(false);
  setPrintOpen(false);
  setPrintHtml(null);
  setPrintJobHtml(null);
};

const startPrintJob = (html: string | null) => {
  if (!html) return;
  // Éviter tout contenu "derrière" pendant le dialogue d'impression (système / WebView)
  closePreviewModal();
  setPrintOpen(false); // masquer la vue Impression avant d'ouvrir le dialogue système
  setPrintJobHtml(html);
};


  // Garder le type d'impression aligné avec le type d'évaluation courant
  // (sans écraser le choix manuel lorsque l'aperçu est ouvert).
  useEffect(() => {
    if (!previewOpen && !printOpen) {
      setPrintEvaluationType(evaluationType);
      setPreviewEvaluationType(evaluationType);
    }
  }, [evaluationType, previewOpen, printOpen]);

  // Impression automatique (utilisée par le bouton 🖨️ IMPRIMER du bandeau)
  useEffect(() => {
    if (!autoPrintAfterPreview || !previewOpen) return;

    const iframe = previewIframeRef.current;
    if (!iframe) return;

    const doPrint = () => {
      try {
        const win = iframe.contentWindow;
        if (win) {
          win.focus();
          win.print();
        }
      } catch (e) {
        console.warn("Auto print failed:", e);
      } finally {
        setAutoPrintAfterPreview(false);
      }
    };

    const doc = iframe.contentDocument;
    if (doc && doc.readyState === "complete") {
      setTimeout(doPrint, 0);
      return;
    }

    iframe.addEventListener("load", doPrint, { once: true });
  }, [autoPrintAfterPreview, previewOpen, previewHtml]);

  // Impression automatique — fenêtre Impression
  useEffect(() => {
    if (!autoPrintAfterPrint || !printOpen || !printHtml) return;
    setAutoPrintAfterPrint(false);
    startPrintJob(printHtml);
  }, [autoPrintAfterPrint, printOpen, printHtml]);

// Lancement de l'impression via un iframe caché (évite l'ouverture d'une "fenêtre" derrière la vue Impression)
useEffect(() => {
  if (!printJobHtml) return;

  const iframe = printJobIframeRef.current;
  if (!iframe) return;

  const doPrint = () => {
    try {
      const win = iframe.contentWindow;
      if (!win) return;

      const cleanup = () => {
        try {
          closePrintModal();
        } catch {}
      };

      // afterprint se déclenche en cas d'impression OU d'annulation
      try {
        win.addEventListener("afterprint", cleanup, { once: true });
      } catch {}

      win.focus();
      win.print();
    } catch (e) {
      console.warn("Print job failed:", e);
      try {
        closePrintModal();
      } catch {}
    }
  };

  const doc = iframe.contentDocument;
  if (doc && doc.readyState === "complete") {
    setTimeout(doPrint, 0);
    return;
  }

  iframe.addEventListener("load", doPrint, { once: true });
}, [printJobHtml]);





  // Fenêtre unique : si l'utilisateur clique sur la croix (fermeture fenêtre),
// on ferme d'abord la fenêtre Impression ou Aperçu au lieu de fermer l'application.
  const previewOpenRef = React.useRef(previewOpen);
  const printOpenRef = React.useRef(printOpen);
  useEffect(() => {
    previewOpenRef.current = previewOpen;
  }, [previewOpen]);
  useEffect(() => {
    printOpenRef.current = printOpen;
  }, [printOpen]);


  useEffect(() => {
    if (!isTauriRuntime()) return;

    let unlisten: any = null;
    let cancelled = false;

    const handler = (e: any) => {
      if (!previewOpenRef.current && !printOpenRef.current) return;
      try { e.preventDefault(); } catch {}
      try {
        if (printOpenRef.current) closePrintModal();
        else closePreviewModal();
      } catch {}
    };

    (async () => {
      // v1: appWindow
      try {
        const m1: any = await importDyn(['@tauri-apps','api','window'].join('/'));
        const w = m1?.appWindow;
        if (w?.onCloseRequested) {
          const u = await w.onCloseRequested(handler);
          if (!cancelled) unlisten = u;
          return;
        }
      } catch {}

      // v2: getCurrentWebviewWindow()
      try {
        const m2: any = await importDyn(['@tauri-apps','api','webviewWindow'].join('/'));
        const w =
          (typeof m2?.getCurrentWebviewWindow === "function" ? m2.getCurrentWebviewWindow() :
          (typeof m2?.getCurrent === "function" ? m2.getCurrent() : null));
        if (w?.onCloseRequested) {
          const u = await w.onCloseRequested(handler);
          if (!cancelled) unlisten = u;
        }
      } catch {}
    })();

    return () => {
      cancelled = true;
      try { if (typeof unlisten === "function") unlisten(); } catch {}
    };
  }, []);

  
  // Tauri : masquer temporairement le bandeau supérieur (décorations de fenêtre) quand l'aperçu est ouvert
  // afin d'éviter la confusion avec la croix de fermeture de l'application pendant l'impression.
  const tauriMainWindowRef = React.useRef<any>(null);

  const setTauriMainDecorations = async (decorations: boolean) => {
    if (!isTauriRuntime()) return;
    try {
      if (!tauriMainWindowRef.current) {
        // v1: appWindow
        try {
          const m1: any = await importDyn(['@tauri-apps','api','window'].join('/'));
          if (m1?.appWindow) tauriMainWindowRef.current = m1.appWindow;
        } catch {}
        // v2: getCurrentWebviewWindow()
        if (!tauriMainWindowRef.current) {
          try {
            const m2: any = await importDyn(['@tauri-apps','api','webviewWindow'].join('/'));
            if (typeof m2?.getCurrentWebviewWindow === 'function') tauriMainWindowRef.current = m2.getCurrentWebviewWindow();
            else if (typeof m2?.getCurrent === 'function') tauriMainWindowRef.current = m2.getCurrent();
          } catch {}
        }
      }

      const w = tauriMainWindowRef.current;
      if (w && typeof w.setDecorations === 'function') {
        await w.setDecorations(decorations);
      }
    } catch (e) {
      // ignore
    }
  };


  const setTauriMainClosable = async (closable: boolean) => {
    if (!isTauriRuntime()) return;
    try {
      if (!tauriMainWindowRef.current) {
        // v1: appWindow
        try {
          const m1: any = await importDyn(['@tauri-apps','api','window'].join('/'));
          if (m1?.appWindow) tauriMainWindowRef.current = m1.appWindow;
        } catch {}
        // v2: getCurrentWebviewWindow()
        if (!tauriMainWindowRef.current) {
          try {
            const m2: any = await importDyn(['@tauri-apps','api','webviewWindow'].join('/'));
            if (typeof m2?.getCurrentWebviewWindow === 'function') tauriMainWindowRef.current = m2.getCurrentWebviewWindow();
            else if (typeof m2?.getCurrent === 'function') tauriMainWindowRef.current = m2.getCurrent();
          } catch {}
        }
      }

      const w = tauriMainWindowRef.current;
      if (w && typeof w.setClosable === 'function') {
        await w.setClosable(closable);
      }
    } catch {
      // ignore
    }
  };

  React.useEffect(() => {
    if (!isTauriRuntime()) return;
    const lock = previewOpen || printOpen;

    if (lock) {
      setTauriMainDecorations(false);
      try { setTauriMainClosable(false); } catch {}
    } else {
      setTauriMainDecorations(true);
      try { setTauriMainClosable(true); } catch {}
    }
  }, [previewOpen, printOpen]);


  // Helpers pour ouvrir l'aperçu en modal (dans l'app) ou dans une fenêtre détachée (popup)
  const injectAutoPrintScript = (html: string) => {
    const script = `
<script>
  (function () {
    function doPrint() {
      try { window.focus(); } catch (e) {}
      try { window.print(); } catch (e) {}
    }
    window.addEventListener('load', function () {
      setTimeout(doPrint, 250);
    });
    window.addEventListener('afterprint', function () {
      try { window.close(); } catch (e) {}
    });
  })();
</script>`;
    if (html.includes("</body>")) return html.replace("</body>", `${script}\n</body>`);
    return html + script;
  };

  const openDetachedHtmlWindow = (innerHtml: string, opts?: PreviewTargetOptions): boolean => {
    // Mode "fenêtre unique" : on n'ouvre jamais de seconde fenêtre.
    // On route vers Aperçu ou Impression selon opts.target.
    try {
      const target = opts?.target || "preview";

      if (target === "print") {
        // Assurer l’indépendance : on ne garde pas l’Aperçu ouvert quand on imprime
        closePreviewModal();

        setPrintHtml(innerHtml);
        setPrintOpen(true);
        if (opts?.autoPrint) setAutoPrintAfterPrint(true);
        return true;
      }

      // Assurer l’indépendance : on ne garde pas la fenêtre Impression ouverte quand on ouvre l’Aperçu
      closePrintModal();

      setPreviewHtml(innerHtml);
      setPreviewOpen(true);
      if (opts?.autoPrint) setAutoPrintAfterPreview(true);
      return true;
    } catch (e) {
      console.warn("openDetachedHtmlWindow fallback failed:", e);
      return false;
    }
  };

  const openHtmlInPrintWebviewWindow = async (innerHtml: string, opts?: PreviewTargetOptions) => {
    // Impression dans une vraie fenêtre du logiciel (Tauri), indépendante de l'aperçu.
    const autoPrint = !!opts?.autoPrint;

    // Hors Tauri (mode navigateur) : fallback simple
    if (!isTauriRuntime()) {
      const w = window.open("", "_blank");
      if (!w) {
        alert("Impossible d'ouvrir la fenêtre d'impression.");
        return false;
      }
      w.document.open();
      w.document.write(innerHtml);
      w.document.close();
      if (autoPrint) {
        setTimeout(() => {
          try { w.focus(); } catch {}
          try { w.print(); } catch {}
        }, 250);
      }
      return true;
    }

    try {
      await mkdir("print_jobs", { baseDir: BaseDirectory.AppLocalData, recursive: true });
      const jobId = `${Date.now()}-${Math.random().toString(16).slice(2)}`;
      const jobFile = `print_jobs/${jobId}.html`;
      await writeTextFile(jobFile, innerHtml, { baseDir: BaseDirectory.AppLocalData });

      const label = `print_${jobId}`;
      // IMPORTANT: passer les paramètres dans le hash (évite les soucis d'assets avec querystring)
      const url = `index.html#/?printWindow=1&job=${encodeURIComponent(jobFile)}&autoPrint=${autoPrint ? "1" : "0"}`;

      const w = new WebviewWindow(label, {
        url,
        title: "Impression",
        width: 1200,
        height: 850,
        resizable: true,
        decorations: true,
      });

      w.once("tauri://created", async () => {
        try { await w.center(); } catch {}
        try { await w.setAlwaysOnTop(true); } catch {}
        try { await w.setFocus(); } catch {}
      });

      w.once("tauri://error", (e) => {
        console.error("Print window creation error:", e);
        alert("Impossible d'ouvrir la fenêtre d'impression (vérifie les permissions Tauri).");
      });

      return true;
    } catch (e) {
      console.error("openHtmlInPrintWebviewWindow failed:", e);
      alert("Impossible d'ouvrir la fenêtre d'impression (vérifie les permissions Tauri).");
      return false;
    }
  };

  const pushPreview = (html: string, opts?: PreviewTargetOptions) => {
    // Mode "fenêtre unique" : par défaut on ouvre dans l'app.
    // target = "preview"     => bouton 👁️ APERCU
    // target = "print"       => ancienne fenêtre Impression (modal interne)
    // target = "printWindow" => fenêtre d'impression Tauri indépendante
    const target = opts?.target || "preview";

    if (target === "printWindow") {
      // Ne jamais révéler un Aperçu derrière l’impression
      closePreviewModal();
      closePrintModal();
      void openHtmlInPrintWebviewWindow(html, opts);
      return;
    }

    if (target === "print") {
      // Ne jamais révéler un Aperçu derrière l’impression (source de confusion)
      closePreviewModal();

      setPrintHtml(html);
      setPrintOpen(true);
      if (opts?.autoPrint) setAutoPrintAfterPrint(true);
      return;
    }

    // Ouvrir l’Aperçu => on ferme l’impression si elle est ouverte
    closePrintModal();

    setPreviewHtml(html);
    setPreviewOpen(true);
    if (opts?.autoPrint) setAutoPrintAfterPreview(true);
  };

  const [classGroups, setClassGroups] = useState<ClassGroup[]>([]);
  const [elevesBootstrapped, setElevesBootstrapped] = useState(false);
  const [classDrawerOpen, setClassDrawerOpen] = useState(false);

const [referentielDrawerOpen, setReferentielDrawerOpen] = useState(false);

type CapCatalogEntry = { title: string; url: string };
type FoundResource = { title: string; url: string; kind: "pdf" | "html" | "other"; score: number };

const [capCatalog, setCapCatalog] = useState<CapCatalogEntry[]>([]);
const [capCatalogLoading, setCapCatalogLoading] = useState(false);
const [capCatalogError, setCapCatalogError] = useState<string | null>(null);

const [capSearchQuery, setCapSearchQuery] = useState("");
const [capPdfOnly, setCapPdfOnly] = useState(true);

const [referentielName, setReferentielName] = useState("");
const [referentielSourceUrl, setReferentielSourceUrl] = useState("");
const [referentielItemsJson, setReferentielItemsJson] = useState("");
const [foundResources, setFoundResources] = useState<FoundResource[]>([]);
const [analyzeBusy, setAnalyzeBusy] = useState(false);
const [referentielMessage, setReferentielMessage] = useState<string | null>(null);

// --- Page dédiée : Ajouter mon référentiel (étapes 1→3) ---
type RefSearchSource = "referentiels" | "legifrance";
type RefSearchResult = {
  title: string;
  source: RefSearchSource;
  pageUrl: string;
  pdfUrl?: string;
};

const [refAddStep, setRefAddStep] = useState<1 | 2 | 3>(1);
const [refAddDiplome, setRefAddDiplome] = useState<CapCatalogEntry | null>(null);
const [refAddQuery, setRefAddQuery] = useState("");
const [refAddBusy, setRefAddBusy] = useState(false);
const [refAddError, setRefAddError] = useState<string | null>(null);
const [refAddResults, setRefAddResults] = useState<RefSearchResult[]>([]);
const [refAddSelectedUrl, setRefAddSelectedUrl] = useState<string>("");



const [stiSearchTerms, setStiSearchTerms] = useState("");
const [stiSearchUrl, setStiSearchUrl] = useState("");
const [stiArreteCandidates, setStiArreteCandidates] = useState<_StiHit[]>([]);

// --- Modal : choisir un référentiel (liens + dates d'arrêtés) ---
type CapRefChoice = {
  title: string;
  url: string;
  source: "eduscol" | "sti" | "other";
  dateISO?: string;
  isPdf: boolean;
  score: number;
};

const [capRefPickerOpen, setCapRefPickerOpen] = useState(false);
const [capRefPickerBusy, setCapRefPickerBusy] = useState(false);
const [capRefPickerTitle, setCapRefPickerTitle] = useState<string>("");
const [capRefPickerCapUrl, setCapRefPickerCapUrl] = useState<string>("");
const [capRefPickerError, setCapRefPickerError] = useState<string | null>(null);
const [capRefChoices, setCapRefChoices] = useState<CapRefChoice[]>([]);

function normalizeEduscolUrl(u: string) {
  try {
    const url = new URL(u);

    // ✅ Ne jamais normaliser les URLs STI
    if (url.hostname === "sti.eduscol.education.fr") return url.toString();

    // Forcer HTTPS pour éviter les blocages de whitelist/redirect
    if (url.protocol === "http:" && url.hostname.endsWith("eduscol.education.fr")) {
      url.protocol = "https:";
    }
    if (url.hostname === "referentiels-professionnels.eduscol.education.fr") {
      url.hostname = "eduscol.education.fr";
      if (!url.pathname.startsWith("/referentiels-professionnels/")) {
        url.pathname = "/referentiels-professionnels/" + url.pathname.replace(/^\//, "");
      }
    }
    return url.toString();
  } catch {
    return u;
  }
}


async function fetchCapCatalog() {
  setCapCatalogLoading(true);
  setCapCatalogError(null);
  try {
    const pageUrl = "https://eduscol.education.fr/1923/le-certificat-d-aptitude-professionnelle-cap";
    const res = await tauriFetch(pageUrl, { method: "GET" });
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    const html = await res.text();
    const doc = new DOMParser().parseFromString(html, "text/html");
    const anchors = Array.from(doc.querySelectorAll("a[href]")) as HTMLAnchorElement[];

    const out: CapCatalogEntry[] = [];
    const seen = new Set<string>();

    for (const a of anchors) {
      const href = a.getAttribute("href") || "";
      if (!href) continue;
      if (!href.includes("referentiels-professionnels.eduscol.education.fr") && !href.includes("/referentiels-professionnels/")) continue;

      const title = (a.textContent || "").trim().replace(/\s+/g, " ");
      if (!title || title.length < 2) continue;

      let abs = "";
      try {
        abs = new URL(href, pageUrl).toString();
        abs = normalizeEduscolUrl(abs);
      } catch {
        continue;
      }

      if (!abs.toLowerCase().includes(".html")) continue;

      if (!seen.has(abs)) {
        seen.add(abs);
        out.push({ title, url: abs });
      }
    }

    out.sort((a, b) => a.title.localeCompare(b.title, "fr", { sensitivity: "base" }));
    setCapCatalog(out);
    setReferentielMessage(`Catalogue CAP chargé (${out.length} entrées).`);
  } catch (e: any) {
    setCapCatalogError(e?.message || "Erreur inconnue");
  } finally {
    setCapCatalogLoading(false);
  }
}

function scoreResource(title: string, url: string) {
  const t = (title || "").toLowerCase();
  const u = (url || "").toLowerCase();
  let score = 0;
  if (u.includes(".pdf")) score += 6;
  if (u.includes("annexes")) score += 5;
  if (t.includes("annexes")) score += 5;
  if (t.includes("référentiel") || t.includes("referentiel")) score += 3;
  if (t.includes("cap")) score += 1;
  if (u.includes("arrete") || t.includes("arrêté") || t.includes("arrete")) score += 1;
  return score;
}


// --- STI Eduscol: rechercher le dernier "arrêté de création et référentiel" (CAP) ---
function extractCapCodeFromUrl(u: string): string | null {
  // Supporte plusieurs formes :
  // - https://referentiels-professionnels.eduscol.education.fr/CAP_MACON.html
  // - https://referentiels-professionnels.eduscol.education.fr/CAP_MACON/Annexes_....pdf
  // - .../cap_par.html (anciennes variantes)
  const s = String(u || "").trim();
  if (!s) return null;

  // CAP_XXXX dans le chemin
  const m1 = s.match(/\/(CAP_[A-Z0-9]{2,10})(?:\/|\.|\?|#|$)/i);
  if (m1?.[1]) return m1[1].toUpperCase();

  // cap_xxx.html
  const m2 = s.match(/\/cap_([a-z0-9]{2,10})\.html(?:\?|#|$)/i);
  if (m2?.[1]) return `CAP_${m2[1].toUpperCase()}`;

  return null;
}

// Heuristique : dérive un code CAP_XXX à partir du libellé (ex: "CAP Peintre applicateur de revêtements" -> CAP_PAR)
function deriveCapCodeFromTitle(title: string): string | null {
  const t = _normSpaces(title || "");
  if (!t) return null;

  // Retire "CAP" au début
  const core = t.replace(/^\s*cap\s+/i, "");
  const tokens = core
    .replace(/['’]/g, " ")
    .split(/\s+/)
    .map((x) => x.trim())
    .filter(Boolean);

  // stopwords FR courants
  const stop = new Set(["de", "du", "des", "la", "le", "les", "d", "l", "et", "en", "aux", "au", "à"]);
  const sig = tokens.filter((w) => !stop.has(w.toLowerCase()));

  // Prend les 3 premiers mots significatifs
  const letters = sig.slice(0, 3).map((w) => w[0]?.toUpperCase()).filter(Boolean);
  if (letters.length >= 2) {
    const code = letters.join("");
    return `CAP_${code}`;
  }
  return null;
}

function _normalizeEduscolPdfUrl(u: string): string {
  let url = String(u || "").trim();
  if (!url) return url;

  // Corrige la forme erronée : https://eduscol.education.fr/referentiels-professionnels/...
  url = url.replace(
    /^https?:\/\/eduscol\.education\.fr\/referentiels-professionnels\//i,
    "https://referentiels-professionnels.eduscol.education.fr/"
  );

  // Corrige les caractères cassés (U+FFFD -> %EF%BF%BD) rencontrés dans certains liens (ex: consolidé)
  url = url.replace(/%EF%BF%BD/gi, "%C3%A9");

  // Normalise l'encodage si possible
  try {
    url = encodeURI(decodeURI(url));
  } catch {
    // ignore
  }
  return url;
}

function _normSpaces(s: string) {
  return (s || "").replace(/\s+/g, " ").trim();
}

function _extractISODateFromText(s: string): string | undefined {
  // dd/mm/yy ou dd/mm/yyyy
  const m = (s || "").match(/\b([0-3]\d)\/([01]\d)\/(\d{2}|\d{4})\b/);
  if (!m) return;
  const dd = m[1];
  const mm = m[2];
  let yy = m[3];
  if (yy.length === 2) yy = Number(yy) >= 70 ? `19${yy}` : `20${yy}`;
  return `${yy}-${mm}-${dd}`;
}

function _extractISODateFromSlug(url: string): string | undefined {
  // suffixe -ddmmyy ou -ddmmyyyy
  const clean = (url || "").split("?")[0].replace(/\/$/, "");
  const m6 = clean.match(/-(\d{6})$/);
  if (m6) {
    const d = m6[1];
    const dd = d.slice(0, 2);
    const mm = d.slice(2, 4);
    const yy = d.slice(4, 6);
    const yyyy = Number(yy) >= 70 ? `19${yy}` : `20${yy}`;
    return `${yyyy}-${mm}-${dd}`;
  }
  const m8 = clean.match(/-(\d{8})$/);
  if (m8) {
    const d = m8[1];
    const dd = d.slice(0, 2);
    const mm = d.slice(2, 4);
    const yyyy = d.slice(4, 8);
    return `${yyyy}-${mm}-${dd}`;
  }
  return;
}

function _maxISO(a?: string, b?: string) {
  if (!a) return b;
  if (!b) return a;
  return a >= b ? a : b;
}

async function _decodeResponseToText(r: any) {
  try {
    const ab = await r.arrayBuffer();
    const tdUtf8 = new TextDecoder("utf-8", { fatal: false });
    const utf8 = tdUtf8.decode(ab);
    const replacementCount = (utf8.match(/\uFFFD/g) || []).length;
    if (replacementCount > 10) {
      const td1252 = new TextDecoder("windows-1252", { fatal: false } as any);
      return td1252.decode(ab);
    }
    return utf8;
  } catch {
    return await r.text();
  }
}

type _StiHit = { pageUrl: string; title: string; dateISO?: string; pdfUrl?: string };

function _parseStiSearchResults(html: string): Array<{ title: string; url: string; dateISO?: string }> {
  const doc = new DOMParser().parseFromString(html, "text/html");
  const anchors = Array.from(doc.querySelectorAll("a[href]")) as HTMLAnchorElement[];
  const hits: Array<{ title: string; url: string; dateISO?: string }> = [];
  for (const a of anchors) {
    const href = (a.getAttribute("href") || "").trim();
    if (!href) continue;

    // On privilégie les pages /textes/ (elles contiennent généralement le PDF associé)
    const isTextes = href.startsWith("/textes/") || href.includes("sti.eduscol.education.fr/textes/");
    if (!isTextes) continue;

    const abs = href.startsWith("http") ? href : `https://sti.eduscol.education.fr${href}`;
    const url = abs.split("?")[0].replace(/\/$/, "");
    const title = _normSpaces(a.textContent || "") || url;

    const dateISO = _extractISODateFromText(title) || _extractISODateFromSlug(url);
    hits.push({ title, url, dateISO });
  }

  // Fallback robuste: si le DOM ne contient pas de liens /textes/ (page de recherche "différente",
  // rendu minimal, anti-bot, etc.), on extrait les URLs /textes/... depuis le HTML brut.
  if (hits.length === 0) {
    const raw = html || "";
    const reTextes = /\/textes\/[a-z0-9\-]+/gi;
    const found = new Set<string>();
    for (const m of raw.match(reTextes) || []) {
      const url = `https://sti.eduscol.education.fr${m}`.split("?")[0].replace(/\/$/, "");
      if (found.has(url)) continue;
      found.add(url);
      const dateISO = _extractISODateFromSlug(url);
      hits.push({ title: url, url, dateISO });
    }
  }


  // Dédoublonnage
  const seen = new Set<string>();
  return hits.filter((h) => (seen.has(h.url) ? false : (seen.add(h.url), true)));
}

async function _extractPdfFromTextesPage(textesUrl: string): Promise<{ pdfUrl?: string; dateISO?: string }> {
  const res = await tauriFetch(textesUrl, { method: "GET" });
  if (!res.ok) throw new Error(`HTTP ${res.status}`);
  const html = await _decodeResponseToText(res);

  const doc = new DOMParser().parseFromString(html, "text/html");
  const h1 = _normSpaces(doc.querySelector("h1")?.textContent || "");
  const dateISO = _extractISODateFromText(h1) || _extractISODateFromSlug(textesUrl);

  // 1er lien PDF sur la page (souvent "Fichier")
  const aPdf = doc.querySelector('a[href$=".pdf"], a[href*=".pdf?"]') as HTMLAnchorElement | null;
  if (aPdf) {
    const href = (aPdf.getAttribute("href") || "").trim();
    if (href) {
      const abs = href.startsWith("http") ? href : new URL(href, textesUrl).toString();
      return { pdfUrl: abs, dateISO };
    }
  }

  // fallback regex brut
  const m = html.match(/https?:\/\/[^\s"'<>]+\.pdf(\?[^\s"'<>]+)?/i);
  return { pdfUrl: m?.[0], dateISO };
}


async function _extractBestPdfFromReferentielsProfessionnelsHtml(referentielHtmlUrl: string): Promise<string | undefined> {
  const res = await tauriFetch(referentielHtmlUrl, { method: "GET" });
  if (!res.ok) return undefined;
  const html = await _decodeResponseToText(res);

  // 1) Priorité au lien dont le texte contient "Annexes"
  try {
    const doc = new DOMParser().parseFromString(html, "text/html");
    const links = Array.from(doc.querySelectorAll("a[href]")) as HTMLAnchorElement[];
    const annexA = links.find((a) => /annexes?/i.test((a.textContent || "").trim()));
    if (annexA) {
      const href = (annexA.getAttribute("href") || "").trim();
      if (href) return new URL(href, referentielHtmlUrl).toString();
    }
  } catch {
    // ignore
  }

  // 2) Extraction brute d'un href "Annexes...pdf" (relatif ou absolu)
  const annexHref =
    html.match(/href\s*=\s*\"([^\"]*Annexes[^\"]*\.pdf[^\"]*)\"/i) ||
    html.match(/href\s*=\s*'([^']*Annexes[^']*\.pdf[^']*)'/i);
  if (annexHref?.[1]) return new URL(annexHref[1], referentielHtmlUrl).toString();

  // 3) Fallback : premier PDF trouvé
  const anyPdfHref =
    html.match(/href\s*=\s*\"([^\"]*\.pdf[^\"]*)\"/i) ||
    html.match(/href\s*=\s*'([^']*\.pdf[^']*)'/i);
  if (anyPdfHref?.[1]) return new URL(anyPdfHref[1], referentielHtmlUrl).toString();

  // 4) Fallback : URLs PDF absolues dans le HTML
  const rawRegex = /https?:\/\/[^\s"'<>]+\.pdf(\?[^\s"'<>]+)?/gi;
  const m = (html.match(rawRegex) || [])[0];
  return m || undefined;
}


function _parseLegifranceSearchResults(html: string): Array<{ title: string; url: string }> {
  const doc = new DOMParser().parseFromString(html, "text/html");
  const anchors = Array.from(doc.querySelectorAll('a[href]')) as HTMLAnchorElement[];
  const hits: Array<{ title: string; url: string }> = [];
  for (const a of anchors) {
    const href = (a.getAttribute("href") || "").trim();
    if (!href) continue;

    // Legifrance renvoie souvent des liens relatifs
    let abs = "";
    try {
      abs = href.startsWith("http") ? href : new URL(href, "https://www.legifrance.gouv.fr").toString();
    } catch {
      continue;
    }

    // On privilégie les textes JORF/LODA (arrêtés au JO / textes consolidés)
    if (!/legifrance\.gouv\.fr\/(jorf\/id\/|loda\/id\/|jorf\/article_jo\/)/i.test(abs)) continue;

    const title = _normSpaces(a.textContent || "") || abs;
    hits.push({ title, url: abs.split("#")[0] });
  }

  // Dédoublonnage
  const seen = new Set<string>();
  return hits.filter((h) => (seen.has(h.url) ? false : (seen.add(h.url), true))).slice(0, 12);
}

async function searchReferentielAddFiles(diplome: CapCatalogEntry, query: string) : Promise<RefSearchResult[]> {
  const results: RefSearchResult[] = [];
  const seen = new Set<string>();

  const push = (r: RefSearchResult) => {
    const key = (r.pdfUrl || r.pageUrl || "").trim();
    if (!key) return;
    if (seen.has(key)) return;
    seen.add(key);
    results.push(r);
  };

  // 1) Référentiels professionnels (Eduscol) : extraire PDFs + liens Legifrance présents
  try {
    const referentielUrl = normalizeEduscolUrl(diplome.url);
    const res = await tauriFetch(referentielUrl, { method: "GET" });
    if (res.ok) {
      const html = await _decodeResponseToText(res);
      const doc = new DOMParser().parseFromString(html, "text/html");
      const anchors = Array.from(doc.querySelectorAll("a[href]")) as HTMLAnchorElement[];
      for (const a of anchors) {
        const href = (a.getAttribute("href") || "").trim();
        if (!href) continue;
        let abs = "";
        try { abs = new URL(href, referentielUrl).toString(); } catch { continue; }

        const label = _normSpaces(a.textContent || "") || abs;
        const low = (label + " " + abs).toLowerCase();

        // PDFs (annexes, référentiel, règlement...)
        if (abs.toLowerCase().includes(".pdf")) {
          push({
            title: label,
            source: "referentiels",
            pageUrl: referentielUrl,
            pdfUrl: _normalizeEduscolPdfUrl(abs),
          });
          continue;
        }

        // Lien Legifrance éventuellement présent sur la page
        if (abs.includes("legifrance.gouv.fr")) {
          push({
            title: label,
            source: "legifrance",
            pageUrl: abs,
          });
          continue;
        }

        // Quelques pages HTML utiles (si l'utilisateur veut garder la page)
        if (low.includes("arrêt") || low.includes("arrete") || low.includes("référ") || low.includes("referentiel")) {
          push({
            title: label,
            source: "referentiels",
            pageUrl: abs,
          });
        }
      }

      // Bonus : meilleur PDF “Annexes” si détectable
      const best = await _extractBestPdfFromReferentielsProfessionnelsHtml(referentielUrl);
      if (best) {
        push({
          title: "Annexes (PDF) — Eduscol",
          source: "referentiels",
          pageUrl: referentielUrl,
          pdfUrl: _normalizeEduscolPdfUrl(best),
        });
      }
    }
  } catch {
    // ignore
  }

  // 2) Légifrance : recherche simple via la page /search/all
  try {
    const q = _normSpaces([diplome.title, query, "arrêté", "référentiel"].filter(Boolean).join(" "));
    const searchUrl = `https://www.legifrance.gouv.fr/search/all?init=true&page=1&query=${encodeURIComponent(q)}&searchField=ALL&tab_selection=all`;
    const res = await tauriFetch(searchUrl, { method: "GET" });
    if (res.ok) {
      const html = await _decodeResponseToText(res);
      const hits = _parseLegifranceSearchResults(html);
      for (const h of hits) {
        push({
          title: h.title,
          source: "legifrance",
          pageUrl: h.url,
        });
      }
    }
  } catch {
    // ignore
  }

  // Tri : PDF d'abord, puis référentiels, puis legifrance
  results.sort((a, b) => {
    const ap = a.pdfUrl ? 1 : 0;
    const bp = b.pdfUrl ? 1 : 0;
    if (ap !== bp) return bp - ap;
    if (a.source !== b.source) return a.source === "referentiels" ? -1 : 1;
    return (a.title || "").localeCompare(b.title || "");
  });

  return results;
}


async function searchStiArreteCandidatesForCap(
  capLabelOrQuery: string,
  capCode?: string
): Promise<{ searchTerms: string; searchUrl: string; candidates: _StiHit[] }> {
  const label = _normSpaces(capLabelOrQuery);
  const code = _normSpaces(capCode || "");

  // Requête "large" : on veut tomber sur les pages de type /textes/arrete-de-creation-et-referentiel...
  const searchTerms = [label, "cap", "arrêté", "arrete", "création", "creation", "référentiel", "referentiel", code]
    .filter(Boolean)
    .join(" ");
  const searchUrl = `https://sti.eduscol.education.fr/sti/search/node/${encodeURIComponent(searchTerms)}`;

  const res = await tauriFetch(searchUrl, { method: "GET" });
  if (!res.ok) throw new Error(`HTTP ${res.status}`);
  const searchHtml = await _decodeResponseToText(res);

  let hits = _parseStiSearchResults(searchHtml);

  // Préférence : titre contenant "arrêté/arrete" ET "référentiel/referentiel"
  const filtered = hits.filter((h) => {
    const t = (h.title || "").toLowerCase();
    return (t.includes("arrêt") || t.includes("arrete")) && (t.includes("référ") || t.includes("referentiel"));
  });
  if (filtered.length > 0) hits = filtered;

  // On visite quelques hits pour récupérer PDF + date
  const candidates: _StiHit[] = [];
  for (const h of hits.slice(0, 10)) {
    try {
      const { pdfUrl, dateISO } = await _extractPdfFromTextesPage(h.url);
      candidates.push({
        pageUrl: h.url,
        title: h.title,
        dateISO: _maxISO(h.dateISO, dateISO),
        pdfUrl,
      });
    } catch {
      // ignore
    }
  }

  // Tri : date desc, puis priorité aux PDF présents
  candidates.sort((a, b) => {
    const da = a.dateISO || "0000-00-00";
    const db = b.dateISO || "0000-00-00";
    if (da !== db) return db.localeCompare(da);
    return (b.pdfUrl ? 1 : 0) - (a.pdfUrl ? 1 : 0);
  });

  return { searchTerms, searchUrl, candidates };
}

async function findLatestStiArretePdfForCap(capLabelOrQuery: string, capCode?: string): Promise<_StiHit | null> {
  const { candidates } = await searchStiArreteCandidatesForCap(capLabelOrQuery, capCode);
  return candidates.length ? candidates[0] : null;
}

async function proposeLatestArreteForCap(capTitle: string, capUrl: string) {
  setAnalyzeBusy(true);
  try {
    // 1) Déterminer un code CAP si possible (pour construire CAP_XXX.html)
    const capCode =
      extractCapCodeFromUrl(capUrl) ||
      deriveCapCodeFromTitle(capTitle) ||
      undefined;

    setReferentielName(capTitle || "");
    setReferentielMessage("Recherche du dernier arrêté/référentiel…");
    setStiArreteCandidates([]);
    setStiSearchTerms("");
    setStiSearchUrl("");

    // 2) Tentative directe via referentiels-professionnels (plus fiable que STI pour récupérer le PDF Annexes)
    let preferredUrl: string | undefined;
    let preferredInfo: string | undefined;

    const isReferentielsHtml =
      /referentiels-professionnels\.eduscol\.education\.fr\/(CAP_[A-Z0-9]{2,10})\.html/i.test(String(capUrl || ""));

    const referentielHtmlUrl =
      (isReferentielsHtml ? String(capUrl).split("?")[0].split("#")[0] : null) ||
      (capCode ? `https://referentiels-professionnels.eduscol.education.fr/${capCode}.html` : null);

    if (referentielHtmlUrl) {
      try {
        const pdf = await _extractBestPdfFromReferentielsProfessionnelsHtml(referentielHtmlUrl);
        if (pdf) {
          preferredUrl = _normalizeEduscolPdfUrl(pdf);
          preferredInfo = "PDF (Annexes) trouvé via referentiels-professionnels.";
        }
      } catch {
        // ignore
      }
    }

    // 3) Recherche STI : sert à proposer plusieurs liens et, si besoin, à trouver une page "arrêté de création…"
    const sti = await searchStiArreteCandidatesForCap(capTitle, capCode);
    setStiSearchTerms(sti.searchTerms);
    setStiSearchUrl(sti.searchUrl);
    setStiArreteCandidates(sti.candidates);

    // 4) Si on n’a pas trouvé via referentiels-professionnels, on prend le meilleur résultat STI
    if (!preferredUrl) {
      const hit = sti.candidates[0];
      if (!hit) {
        setReferentielMessage("Aucun arrêté/référentiel trouvé (STI + referentiels-professionnels).");
        return;
      }
      preferredUrl = _normalizeEduscolPdfUrl(hit.pdfUrl || hit.pageUrl);
      preferredInfo = hit.pdfUrl ? "Dernier arrêté/référentiel trouvé (STI)." : "Page STI trouvée (PDF non détecté).";
    }

    setReferentielSourceUrl(preferredUrl);
    setReferentielMessage(preferredInfo || "Lien arrêté/référentiel proposé.");
  } catch (e: any) {
    setReferentielMessage(`Erreur recherche dernier arrêté : ${String(e?.message ?? e)}`);
  } finally {
    setAnalyzeBusy(false);
  }
}



async function openCapReferentielPicker(capTitle: string, capUrl: string) {
  // Affichage inline (plus de fenêtre/modal). On prépare simplement la liste.
  setCapRefPickerOpen(false);
  setCapRefPickerBusy(true);
  setCapRefPickerError(null);
  setCapRefPickerTitle(capTitle || "");
  setCapRefPickerCapUrl(capUrl || "");
  setCapRefChoices([]);

  try {
    const capCode =
      extractCapCodeFromUrl(capUrl) ||
      deriveCapCodeFromTitle(capTitle) ||
      undefined;

    // Construit une URL "referentiels-professionnels" si possible (meilleure source pour Annexes_*.pdf)
    const isReferentielsHtml =
      /referentiels-professionnels\.eduscol\.education\.fr\/(CAP_[A-Z0-9]{2,10})\.html/i.test(String(capUrl || ""));

    const referentielHtmlUrl =
      (isReferentielsHtml ? String(capUrl).split("?")[0].split("#")[0] : null) ||
      (capCode ? `https://referentiels-professionnels.eduscol.education.fr/${capCode}.html` : null);

    const choices: CapRefChoice[] = [];

    // 1) Eduscol referentiels-professionnels (Annexes PDF + autres PDFs de la page)
    if (referentielHtmlUrl) {
      // Ajoute la page HTML elle-même (utile si aucun PDF détecté)
      choices.push({
        title: "Page référentiel (Eduscol)",
        url: referentielHtmlUrl,
        source: "eduscol",
        isPdf: false,
        score: 1,
      });

      try {
        const res = await tauriFetch(referentielHtmlUrl, { method: "GET" });
        if (res.ok) {
          const html = await _decodeResponseToText(res);
          const doc = new DOMParser().parseFromString(html, "text/html");
          const anchors = Array.from(doc.querySelectorAll("a[href]")) as HTMLAnchorElement[];

          for (const a of anchors) {
            const href = (a.getAttribute("href") || "").trim();
            if (!href) continue;
            let abs = "";
            try {
              abs = new URL(href, referentielHtmlUrl).toString();
            } catch {
              continue;
            }
            const title = _normSpaces(a.textContent || "") || abs;
            const isPdf = abs.toLowerCase().includes(".pdf");
            // On conserve surtout les PDFs / annexes
            const low = (title + " " + abs).toLowerCase();
            if (!isPdf && !low.includes("annexe") && !low.includes("annexes")) continue;

            const dateISO = _extractISODateFromText(title) || _extractISODateFromSlug(abs);
            const normUrl = _normalizeEduscolPdfUrl(abs);

            choices.push({
              title: title,
              url: normUrl,
              source: "eduscol",
              dateISO,
              isPdf,
              score: scoreResource(title, abs) + (dateISO ? 10 : 0),
            });
          }
        }
      } catch {
        // ignore (la fenêtre doit quand même s'ouvrir)
      }

      // Tentative rapide "meilleur PDF" (Annexes)
      try {
        const bestPdf = await _extractBestPdfFromReferentielsProfessionnelsHtml(referentielHtmlUrl);
        if (bestPdf) {
          const normUrl = _normalizeEduscolPdfUrl(bestPdf);
          choices.push({
            title: "Annexes (PDF) — Eduscol",
            url: normUrl,
            source: "eduscol",
            dateISO: _extractISODateFromSlug(normUrl),
            isPdf: true,
            score: 100,
          });
        }
      } catch {
        // ignore
      }
    }

    // 2) STI Eduscol "textes" (souvent l'arrêté + PDF)
    try {
      const sti = await searchStiArreteCandidatesForCap(capTitle, capCode);
      // On garde ces infos pour affichage aussi dans le drawer (compat avec l'existant)
      setStiSearchTerms(sti.searchTerms);
      setStiSearchUrl(sti.searchUrl);
      setStiArreteCandidates(sti.candidates);

      for (const c of sti.candidates || []) {
        const urlToUse = _normalizeEduscolPdfUrl(c.pdfUrl || c.pageUrl);
        const isPdf = !!c.pdfUrl || urlToUse.toLowerCase().includes(".pdf");
        choices.push({
          title: c.title || (isPdf ? "PDF (STI)" : "Page STI"),
          url: urlToUse,
          source: "sti",
          dateISO: c.dateISO,
          isPdf,
          score: (c.dateISO ? 20 : 0) + (isPdf ? 10 : 0),
        });
      }
    } catch {
      // ignore
    }

    // Dédoublonnage + tri
    const seen = new Set<string>();
    const uniq = choices.filter((c) => {
      const u = (c.url || "").trim();
      if (!u) return false;
      if (seen.has(u)) return false;
      seen.add(u);
      return true;
    });

    uniq.sort((a, b) => {
      const da = a.dateISO || "0000-00-00";
      const db = b.dateISO || "0000-00-00";
      if (da !== db) return db.localeCompare(da);
      if (a.isPdf !== b.isPdf) return (b.isPdf ? 1 : 0) - (a.isPdf ? 1 : 0);
      return (b.score || 0) - (a.score || 0);
    });

    setCapRefChoices(uniq);
    if (uniq.length === 0) {
      setCapRefPickerError("Aucun lien détecté pour ce CAP (essayez “Analyser l’URL” ou “Dernier arrêté”).");
    }
  } catch (e: any) {
    setCapRefPickerError(String(e?.message ?? e));
  } finally {
    setCapRefPickerBusy(false);
  }
}


async function analyzeReferentielUrl(inputUrl: string) {
  setAnalyzeBusy(true);
  try {
    const raw = (inputUrl || "").trim();
    if (!raw) {
      setReferentielMessage("Renseigne une URL.");
      return;
    }

    // Normalisation (les pages "referentiels-professionnels.eduscol..." répondent souvent mieux via eduscol.education.fr)
    const url = normalizeEduscolUrl(raw);

    setReferentielMessage("Analyse en cours…");

    const res = await tauriFetch(url, { method: "GET" });
    const ct = (res.headers?.get?.("content-type") || "").toLowerCase();

    // PDF direct
    if (ct.includes("application/pdf") || url.toLowerCase().includes(".pdf")) {
      setReferentielSourceUrl(url);
      setReferentielMessage("PDF détecté.");
      return;
    }

    // JSON direct
    if (ct.includes("application/json") || url.toLowerCase().endsWith(".json")) {
      const jsonText = await res.text();
      setReferentielJsonText(jsonText);
      setReferentielSourceUrl(url);
      setReferentielMessage("JSON chargé depuis l’URL.");
      return;
    }

    // HTML (ou autre) : lire en bytes et décoder avec fallback (certains contenus Eduscol ne sont pas UTF-8)
    const decodeToText = async (r: any) => {
      try {
        const ab = await r.arrayBuffer();
        // Tentative UTF-8, puis fallback windows-1252 (souvent utilisé côté legacy)
        const tdUtf8 = new TextDecoder("utf-8", { fatal: false });
        const utf8 = tdUtf8.decode(ab);
        // Heuristique : si beaucoup de caractères de remplacement, on tente windows-1252
        const replacementCount = (utf8.match(/\uFFFD/g) || []).length;
        if (replacementCount > 10) {
          const td1252 = new TextDecoder("windows-1252", { fatal: false } as any);
          return td1252.decode(ab);
        }
        return utf8;
      } catch {
        // Dernier recours
        return await r.text();
      }
    };

    const html = await decodeToText(res);

    // 0) Méthode la plus fiable : trouver le <a> dont le texte contient "Annexes"
try {
  const doc = new DOMParser().parseFromString(html, "text/html");
  const links = Array.from(doc.querySelectorAll("a[href]"));
  const annexA = links.find((a) => /annexes?/i.test((a.textContent || "").trim()));
  if (annexA) {
    const href = (annexA.getAttribute("href") || "").trim();
    if (href) {
      const pdfAbs = new URL(href, url).toString();
      setReferentielSourceUrl(pdfAbs);
      setReferentielMessage("Lien PDF (Annexes) trouvé.");
      return;
    }
  }
} catch {
  // ignore
}


    // 🔥 Extraction directe du href "Annexes...pdf" même si le lien est relatif (ex: CAP_PAR/Annexes_...pdf)
    const annexHref =
      html.match(/href\s*=\s*"([^"]*Annexes[^"]*\.pdf[^"]*)"/i) ||
      html.match(/href\s*=\s*'([^']*Annexes[^']*\.pdf[^']*)'/i);

    if (annexHref?.[1]) {
      const pdfAbs = new URL(annexHref[1], url).toString();
      setReferentielSourceUrl(pdfAbs);
      setReferentielMessage("Lien PDF (Annexes) trouvé.");
      return;
    }

    // Fallback: premier href .pdf (relatif ou absolu)
    const anyPdfHref =
      html.match(/href\s*=\s*"([^"]*\.pdf[^"]*)"/i) ||
      html.match(/href\s*=\s*'([^']*\.pdf[^']*)'/i);

    if (anyPdfHref?.[1]) {
      const pdfAbs = new URL(anyPdfHref[1], url).toString();
      setReferentielSourceUrl(pdfAbs);
      setReferentielMessage("Lien PDF trouvé.");
      return;
    }

    // Extraire des URLs PDF depuis le HTML brut (robuste même si le lien n'est pas un <a> classique)
    const pdfFromRaw: string[] = [];
    const rawRegex = /https?:\/\/[^\s"'<>]+\.pdf(\?[^\s"'<>]+)?/gi;
    for (const m of html.match(rawRegex) || []) pdfFromRaw.push(m);

    // Parse DOM + liens <a>
    const doc = new DOMParser().parseFromString(html, "text/html");
    const anchors = Array.from(doc.querySelectorAll("a[href]"));

    const candidates: Array<{ url: string; title: string; score: number }> = [];

    const pushCandidate = (absUrl: string, title: string) => {
      const t = (title || "").trim();
      const u = (absUrl || "").trim();
      if (!u) return;

      // Filtrage : on garde les PDF évidents, ou les liens "Annexe(s)/Télécharger/Référentiel"
      const lowT = t.toLowerCase();
      const lowU = u.toLowerCase();
      const keep =
        lowU.includes(".pdf") ||
        lowT.includes("annexe") ||
        lowT.includes("télécharger") ||
        lowT.includes("telecharger") ||
        lowT.includes("référentiel") ||
        lowT.includes("referentiel");

      if (!keep) return;

      let score = scoreResource(t, u);

      // Renforcer "annexe" (singulier/pluriel)
      if (lowT.includes("annexe")) score += 6;
      if (lowU.includes("annexe")) score += 6;
      // Favoriser "Annexes_*.pdf"
      if (lowU.includes("annexes_")) score += 4;

      candidates.push({ url: u, title: t || u, score });
    };

    // 1) Liens <a>
    for (const a of anchors) {
      const href = a.getAttribute("href")?.trim();
      if (!href) continue;
      const title = (a.textContent || "").trim() || href;
      try {
        const absUrl = new URL(href, url).toString();
        pushCandidate(absUrl, title);
      } catch {
        // ignore
      }
    }

    // 2) URLs PDF trouvées en brut
    for (const u of pdfFromRaw) {
      pushCandidate(u, "PDF détecté (HTML)");
    }

    // Dédoublonnage + tri
    const seen = new Set<string>();
    const uniq = candidates
      .sort((a, b) => b.score - a.score)
      .filter((c) => (seen.has(c.url) ? false : (seen.add(c.url), true)));

	    if (uniq.length === 0) {
      setReferentielSourceUrl(url);
      setReferentielMessage("Aucun lien PDF détecté sur la page. (Page HTML trouvée, mais pas de PDF exploitable.)");
      return;
    }

	    // IMPORTANT : on ne bloque PAS sur une vérification réseau du PDF.
	    // Dans Tauri, une allowlist trop restrictive ou une redirection peut empêcher le fetch du PDF.
	    // Ici, l'objectif de l'option 2 est de *récupérer le lien PDF* ; on choisit donc le meilleur candidat
	    // (souvent "Annexes_*.pdf") et on le renseigne directement.
	    const best = uniq[0];
	    setReferentielSourceUrl(best.url);
	    setReferentielMessage(`Lien PDF sélectionné : ${best.title}`);
  } catch (e: any) {
    setReferentielMessage(
      `Erreur lors de l’analyse. Vérifie la whitelist HTTP Tauri (eduscol.education.fr) et l’URL. Détail: ${String(
        e?.message ?? e
      )}`
    );
  } finally {
    setAnalyzeBusy(false);
  }
}


  
  // Suivi des compétences : base de données locale
  const [skillsDB, setSkillsDB] = React.useState<SkillsDB>({});
  const [skillsBootstrapped, setSkillsBootstrapped] = React.useState(false);

  // --- Données 1ère année (lecture seule) affichées en 2ème année ---
  const [skillsDBPremiere, setSkillsDBPremiere] = React.useState<SkillsDB>({});
  const [evalMetaListPremiere, setEvalMetaListPremiere] = React.useState<EvalMeta[]>([]);
  const [notationDBPremiere, setNotationDBPremiere] = React.useState<NotationDB>({});
  const [premiereBootstrapped, setPremiereBootstrapped] = React.useState(false);

  // --- Données 2ème année (lecture seule) affichées en 1ère année (utile pour la vue "Évolutions") ---
  const [skillsDBDeuxieme, setSkillsDBDeuxieme] = React.useState<SkillsDB>({});
  const [evalMetaListDeuxieme, setEvalMetaListDeuxieme] = React.useState<EvalMeta[]>([]);
  const [notationDBDeuxieme, setNotationDBDeuxieme] = React.useState<NotationDB>({});
  const [deuxiemeBootstrapped, setDeuxiemeBootstrapped] = React.useState(false);



  const [selectedClassIdForSuivi, setSelectedClassIdForSuivi] = useState<string | null>(null);
  const [selectedClassIdForSuiviDocs, setSelectedClassIdForSuiviDocs] = useState<string | null>(null);
  const [selectedStudentForDocs, setSelectedStudentForDocs] = useState<string | null>(null);
  const [docsRefreshNonce, setDocsRefreshNonce] = useState(0);
  const [docsFilesByFolder, setDocsFilesByFolder] = useState<Record<string, { name: string; path: string }[]>>({});
  const [docsFilesLoading, setDocsFilesLoading] = useState(false);
  
  const [referentielJsonText, setReferentielJsonText] = useState<string>("");

  type DocFolderDef = { key: string; label: string };
  const DOC_FOLDERS_CACHE_KEY = "suivi_docs_folders_v1";
  const DEFAULT_DOC_FOLDERS: DocFolderDef[] = [
    { key: "bulletin", label: "Bulletin de notes" },
    { key: "bilan_atelier", label: "Bilan de compétences atelier" },
    { key: "pfmp", label: "Convention & Notation PFMP" },
  ];

  const [docFolders, setDocFolders] = useState<DocFolderDef[]>(() => {
    try {
      const raw = localStorage.getItem(DOC_FOLDERS_CACHE_KEY);
      if (!raw) return DEFAULT_DOC_FOLDERS;
      const parsed = JSON.parse(raw);
      if (Array.isArray(parsed) && parsed.every((x) => x && typeof x.key === "string" && typeof x.label === "string")) {
        // Merge : garantit la présence des 3 dossiers par défaut (compat)
        const byKey = new Map<string, DocFolderDef>();
        for (const f of DEFAULT_DOC_FOLDERS) byKey.set(f.key, f);
        for (const f of parsed as DocFolderDef[]) byKey.set(f.key, f);
        return Array.from(byKey.values());
      }
      return DEFAULT_DOC_FOLDERS;
    } catch {
      return DEFAULT_DOC_FOLDERS;
    }
  });

  React.useEffect(() => {
    try {
      localStorage.setItem(DOC_FOLDERS_CACHE_KEY, JSON.stringify(docFolders, null, 2));
    } catch {
      // ignore
    }
  }, [docFolders]);

  const handleAddDocFolder = React.useCallback(() => {
    const label = (prompt("Nom du porte-document :") || "").trim();
    if (!label) return;

    const base = (sanitizeFileNamePart(label) || "dossier").toLowerCase();
    let key = base;
    let i = 2;
    while (docFolders.some((f) => f.key === key)) {
      key = `${base}_${i++}`;
    }

    setDocFolders((prev) => [...prev, { key, label }]);
    setDocsRefreshNonce((n) => n + 1);
  }, [docFolders]);

  const [pdfViewer, setPdfViewer] = useState<{ url: string; name: string; relPath: string } | null>(null);
  const [exportYear, setExportYear] = useState<TrainingYear>("premiere");

  React.useEffect(() => {
    // Libère l'URL blob quand on change de PDF / on ferme / on quitte la vue
    return () => {
      if (pdfViewer?.url) {
        try { URL.revokeObjectURL(pdfViewer.url); } catch {}
      }
    };
  }, [pdfViewer?.url]);

  React.useEffect(() => {
    // Si on change d'élève / de classe / de vue, on ferme le viewer
    setPdfViewer(null);
  }, [selectedClassIdForSuiviDocs, selectedStudentForDocs]);



const refreshSuiviElevesDocs = React.useCallback(async () => {
  const classeId = selectedClassIdForSuiviDocs;
  const student = selectedStudentForDocs;
  if (!classeId || !student || !isTauriRuntime()) {
    setDocsFilesByFolder({});
    return;
  }

  const DOC_ROOT = "suivi_eleves_docs";
  const folders = docFolders.map((f) => f.key);

  const basePath = (folderKey: string) => {
    const classPart = sanitizeFileNamePart(classeId);
    const studentPart = sanitizeFileNamePart(student);
    const folderPart = sanitizeFileNamePart(folderKey);
    return `${DOC_ROOT}/${trainingYear}/${classPart}/${studentPart}/${folderPart}`;
  };

  const listFolder = async (folderKey: string) => {
    const dir = basePath(folderKey);
    try {
      const ok = await exists(dir, { baseDir: BaseDirectory.AppLocalData });
      if (!ok) return [];
      const entries = await readDir(dir, { baseDir: BaseDirectory.AppLocalData });
      return entries
        .filter((e: any) => e?.isFile && String(e?.name || "").toLowerCase().endsWith(".pdf"))
        .map((e: any) => ({
          name: String(e.name || ""),
          path: `${dir}/${String(e.name || "")}`,
        }))
        .sort((a, b) => a.name.localeCompare(b.name));
    } catch {
      return [];
    }
  };

  setDocsFilesLoading(true);
  const out: Record<string, { name: string; path: string }[]> = {};
  for (const f of folders) out[f] = await listFolder(f);
  setDocsFilesByFolder(out);
  setDocsFilesLoading(false);
}, [selectedClassIdForSuiviDocs, selectedStudentForDocs, trainingYear, docFolders]);

React.useEffect(() => {
  refreshSuiviElevesDocs();
}, [refreshSuiviElevesDocs, docsRefreshNonce]);
  const [selectedStudentForSuivi, setSelectedStudentForSuivi] = useState<string | null>(null);


  // ✅ Changement d’année centralisé (réinitialise les données dépendantes)
  const switchTrainingYear = React.useCallback((nextYear: TrainingYear) => {
    setEvalMetaBootstrapped(false);
    setEvalMetaList([]);
    setSkillsBootstrapped(false);
    setSkillsDB({});
    setNotationBootstrapped(false);
    setNotationDB({});
    setTrainingYear(nextYear);
    setSelectedEvalIdForClasse(null);

    // Sélections globales
    setSelectedClassIdForSuivi(null);
    setSelectedStudentForSuivi(null);
  }, []);

  // ✅ Synchronisation : la vue "Suivi d'élèves (PDF)" suit les sélecteurs globaux
  React.useEffect(() => {
    setSelectedClassIdForSuiviDocs(selectedClassIdForSuivi);
  }, [selectedClassIdForSuivi]);

  React.useEffect(() => {
    setSelectedStudentForDocs(selectedStudentForSuivi);
  }, [selectedStudentForSuivi]);


  const [exportDrawerOpen, setExportDrawerOpen] = useState(false);
const [exportClassName, setExportClassName] = useState<string>("");
const [exportBusy, setExportBusy] = useState(false);

const importFileInputRef = React.useRef<HTMLInputElement | null>(null);
const [importBusy, setImportBusy] = useState(false);

  // Paramètres généraux (référents / établissement)
  const [generalSettings, setGeneralSettings] = useState<GeneralSettings>({ ...DEFAULT_GENERAL_SETTINGS });
  const [generalSettingsBootstrapped, setGeneralSettingsBootstrapped] = useState(false);
  const [generalSettingsDrawerOpen, setGeneralSettingsDrawerOpen] = useState(false);

  const [generalSettingsSaveFeedback, setGeneralSettingsSaveFeedback] = useState<null | { type: "success" | "error"; message: string }>(null);

  useEffect(() => {
    if (!generalSettingsSaveFeedback) return;
    const t = window.setTimeout(() => setGeneralSettingsSaveFeedback(null), 2200);
    return () => window.clearTimeout(t);
  }, [generalSettingsSaveFeedback]);


const normalizeImportedClassExport = React.useCallback((raw: any, fromName: string, toName: string) => {
  const safeFrom = String(fromName || "").trim();
  const safeTo = String(toName || "").trim();

  const pickFirstValue = (o: any) => {
    if (!o || typeof o !== "object") return undefined;
    const k = Object.keys(o)[0];
    return k ? (o as any)[k] : undefined;
  };

  const normalizeSkills = (skills: any) => {
    const block = (skills && typeof skills === "object")
      ? ((skills as any)[safeFrom] ?? (skills as any)[safeTo] ?? pickFirstValue(skills))
      : undefined;
    return block ? ({ [safeTo]: block } as any) : ({} as any);
  };

  const normalizeNotation = (notation: any) => {
    const out: any = {};
    if (!notation || typeof notation !== "object") return out;
    Object.entries(notation as any).forEach(([schoolYear, byClass]: any) => {
      const classPart = byClass?.[safeFrom] ?? byClass?.[safeTo] ?? pickFirstValue(byClass);
      if (!classPart) return;
      out[schoolYear] = { [safeTo]: classPart };
    });
    return out;
  };

  const normalizeAbsencesRetards = (ar: any): AbsencesRetardsStore => {
  const out: AbsencesRetardsStore = { records: {}, planning: {} };
  if (!ar || typeof ar !== "object") return out;

  const rec = ar.records && typeof ar.records === "object" ? ar.records : {};
  const plan = ar.planning && typeof ar.planning === "object" ? ar.planning : {};

  // records: schoolYear -> classId -> student -> dates
  Object.entries(rec as any).forEach(([schoolYear, byClass]: any) => {
    const classPart = byClass?.[safeFrom] ?? byClass?.[safeTo] ?? pickFirstValue(byClass);
    if (!classPart) return;
    out.records[schoolYear] = { [safeTo]: classPart };
  });

  // planning: schoolYear -> classId -> settings
  Object.entries(plan as any).forEach(([schoolYear, byClass]: any) => {
    const classPart = byClass?.[safeFrom] ?? byClass?.[safeTo] ?? pickFirstValue(byClass);
    if (!classPart) return;
    out.planning[schoolYear] = { [safeTo]: classPart };
  });

  return out;
};

  const normalizeExtraLocalStorage = (extra: any) => {
    const out: Record<string, string> = {};
    if (!extra || typeof extra !== "object") return out;
    Object.entries(extra as any).forEach(([k, v]) => {
      const kk = safeFrom && safeTo && safeFrom !== safeTo
        ? String(k).split(`_${safeFrom}_`).join(`_${safeTo}_`)
        : String(k);
      if (typeof v === "string") out[kk] = v;
    });
    return out;
  };

  const tp = raw?.trainingYears || {};
  const p = tp?.premiere || {};
  const d = tp?.deuxieme || {};

  const classGroup: ClassGroup = (() => {
    const g = raw?.classGroup;
    if (g && typeof g === "object") {
      return {
        id: String((g as any).id || "") || `${Date.now()}_${Math.random().toString(16).slice(2)}`,
        name: safeTo,
        students: String((g as any).students || ""),
      };
    }
    return {
      id: `${Date.now()}_${Math.random().toString(16).slice(2)}`,
      name: safeTo,
      students: "",
    };
  })();

  const mapEvalMeta = (list: any) => {
    const arr = Array.isArray(list) ? list : [];
    return arr.map((ev) => ({ ...ev, group: safeTo }));
  };

  return {
    schema: String(raw?.schema || ""),
    exportedAt: raw?.exportedAt,
    className: safeTo,
    classGroup,
    trainingYears: {
      premiere: {
        evalMeta: mapEvalMeta(p?.evalMeta),
        skills: normalizeSkills(p?.skills),
        notation: normalizeNotation(p?.notation),
        absencesRetards: normalizeAbsencesRetards(p?.absencesRetards),
      },
      deuxieme: {
        evalMeta: mapEvalMeta(d?.evalMeta),
        skills: normalizeSkills(d?.skills),
        notation: normalizeNotation(d?.notation),
        absencesRetards: normalizeAbsencesRetards(d?.absencesRetards),
      },
    },
    devoirFiles: (raw?.devoirFiles && typeof raw.devoirFiles === "object") ? raw.devoirFiles : {},
    extraLocalStorage: normalizeExtraLocalStorage(raw?.extraLocalStorage),
  };
}, []);

const handleImportClassDataFromText = React.useCallback(
  async (jsonText: string) => {
    const rawText = String(jsonText || "");
    if (!rawText.trim()) return;

    setImportBusy(true);
    try {
      let parsed: any;
      try {
        parsed = JSON.parse(rawText);
      } catch {
        alert("❌ Fichier invalide : impossible de lire le JSON.");
        return;
      }

      if (!parsed || typeof parsed !== "object" || parsed.schema !== "classe_export_v1") {
        alert("❌ Ce fichier ne correspond pas à un export de classe (schema attendu : classe_export_v1). ");
        return;
      }

      const fromName = String(parsed.className || "").trim();
      if (!fromName) {
        alert("❌ Export invalide : nom de classe manquant.");
        return;
      }

      let toName = fromName;
      const wantRename = await confirm("Voulez-vous changer le nom de la classe lors de l’import ?", {
        title: "Import",
        kind: "info",
      });
      if (wantRename) {
        const input = window.prompt("Nouveau nom de la classe :", fromName);
        if (input === null) return; // annulation
        const next = String(input || "").trim();
        if (!next) {
          alert("❌ Nom de classe invalide.");
          return;
        }
        toName = next;
      }

      const normalized = normalizeImportedClassExport(parsed, fromName, toName);

      const [groups, evalPrem, evalDeux, skillsPrem, skillsDeux, notationPrem, notationDeux] =
        await Promise.all([
          loadElevesFromStore(),
          loadEvalMetaFromStore("premiere"),
          loadEvalMetaFromStore("deuxieme"),
          loadSkillsFromStore("premiere"),
          loadSkillsFromStore("deuxieme"),
          loadNotationFromStore("premiere"),
          loadNotationFromStore("deuxieme"),
        ]);

      const classExists = (groups || []).some((g) => g.name === toName);

      const existingEvalPremCount = (evalPrem || []).filter((ev) => (ev.group || "") === toName).length;
      const existingEvalDeuxCount = (evalDeux || []).filter((ev) => (ev.group || "") === toName).length;
      const existingSkillsPrem = !!(skillsPrem as any)?.[toName];
      const existingSkillsDeux = !!(skillsDeux as any)?.[toName];
      const existingNotationPremYears = Object.entries((notationPrem || {}) as any)
        .filter(([, byClass]: any) => !!byClass?.[toName]).length;
      const existingNotationDeuxYears = Object.entries((notationDeux || {}) as any)
        .filter(([, byClass]: any) => !!byClass?.[toName]).length;

      // Collisions : devoirs et localStorage
      const devoirCollisions: string[] = [];
      if (isTauriRuntime()) {
        for (const fileName of Object.keys(normalized.devoirFiles || {})) {
          const safe = ensureJsonFileName(fileName);
          try {
            const p = `${devoirDirName("premiere")}/${safe}`;
            if (await exists(p, { baseDir: BaseDirectory.AppLocalData })) devoirCollisions.push(safe);
          } catch {
            // ignore
          }
        }
      }
      const localStorageCollisions: string[] = [];
      try {
        Object.keys(normalized.extraLocalStorage || {}).forEach((k) => {
          if (localStorage.getItem(k) != null) localStorageCollisions.push(k);
        });
      } catch {
        // ignore
      }

      const hasOverwriteRisk =
        classExists ||
        existingEvalPremCount > 0 ||
        existingEvalDeuxCount > 0 ||
        existingSkillsPrem ||
        existingSkillsDeux ||
        existingNotationPremYears > 0 ||
        existingNotationDeuxYears > 0 ||
        devoirCollisions.length > 0 ||
        localStorageCollisions.length > 0;

      if (hasOverwriteRisk) {
        const lines: string[] = [];
        if (classExists) lines.push(`• Classe "${toName}" : existe déjà`);
        if (existingEvalPremCount) lines.push(`• 1ère année : ${existingEvalPremCount} devoir(s) existant(s) seront remplacés`);
        if (existingEvalDeuxCount) lines.push(`• 2ème année : ${existingEvalDeuxCount} devoir(s) existant(s) seront remplacés`);
        if (existingSkillsPrem) lines.push(`• Compétences 1ère année : données existantes seront écrasées`);
        if (existingSkillsDeux) lines.push(`• Compétences 2ème année : données existantes seront écrasées`);
        if (existingNotationPremYears) lines.push(`• Notation 1ère année : ${existingNotationPremYears} année(s) scolaire(s) seront écrasées`);
        if (existingNotationDeuxYears) lines.push(`• Notation 2ème année : ${existingNotationDeuxYears} année(s) scolaire(s) seront écrasées`);
        if (devoirCollisions.length) lines.push(`• Fichiers devoirs : ${devoirCollisions.length} fichier(s) existe(nt) déjà et seront remplacés`);
        if (localStorageCollisions.length) lines.push(`• Notes locales : ${localStorageCollisions.length} clé(s) localStorage seront remplacées`);

        const msg =
          `⚠️ Import : des données vont être écrasées.\n\n` +
          lines.join("\n") +
          `\n\nContinuer ?`;

        const ok = await confirm(msg, { title: "Import", kind: "warning" });
        if (!ok) return;
      }

      // --- Appliquer : classes ---
      const nextGroups: ClassGroup[] = (() => {
        const base = Array.isArray(groups) ? groups.slice() : [];
        const idx = base.findIndex((g) => g.name === toName);
        if (idx >= 0) {
          const keepId = base[idx]?.id;
          base[idx] = { ...normalized.classGroup, id: keepId || normalized.classGroup.id };
          return base;
        }
        return [...base, normalized.classGroup];
      })();

      // --- EvalMeta ---
      const nextEvalPrem = (evalPrem || []).filter((ev) => (ev.group || "") !== toName).concat(normalized.trainingYears.premiere.evalMeta || []);
      const nextEvalDeux = (evalDeux || []).filter((ev) => (ev.group || "") !== toName).concat(normalized.trainingYears.deuxieme.evalMeta || []);

      // --- Skills ---
      const nextSkillsPrem: any = { ...(skillsPrem || {}) };
      const nextSkillsDeux: any = { ...(skillsDeux || {}) };
      delete nextSkillsPrem[toName];
      delete nextSkillsDeux[toName];
      const premBlock = (normalized.trainingYears.premiere.skills as any)?.[toName];
      const deuxBlock = (normalized.trainingYears.deuxieme.skills as any)?.[toName];
      if (premBlock) nextSkillsPrem[toName] = premBlock;
      if (deuxBlock) nextSkillsDeux[toName] = deuxBlock;

      // --- Notation (remplacement complet des entrées de cette classe) ---
      const removeClassFromNotation = (db: any) => {
        const out: any = {};
        Object.entries(db || {}).forEach(([schoolYear, byClass]: any) => {
          const copy: any = { ...(byClass || {}) };
          delete copy[toName];
          if (Object.keys(copy).length) out[schoolYear] = copy;
        });
        return out;
      };
      const mergeNotationForClass = (db: any, imported: any) => {
        const out: any = { ...(db || {}) };
        Object.entries(imported || {}).forEach(([schoolYear, byClass]: any) => {
          const classPart = byClass?.[toName] ?? (() => {
            if (!byClass || typeof byClass !== "object") return undefined;
            const k = Object.keys(byClass)[0];
            return k ? byClass[k] : undefined;
          })();
          if (!classPart) return;
          out[schoolYear] = { ...(out[schoolYear] || {}), [toName]: classPart };
        });
        return out;
      };

      const nextNotationPrem = mergeNotationForClass(removeClassFromNotation(notationPrem), normalized.trainingYears.premiere.notation);
      const nextNotationDeux = mergeNotationForClass(removeClassFromNotation(notationDeux), normalized.trainingYears.deuxieme.notation);

      // --- Persister ---
      await Promise.all([
        saveElevesToStore(nextGroups),
        saveEvalMetaToStore(nextEvalPrem, "premiere"),
        saveEvalMetaToStore(nextEvalDeux, "deuxieme"),
        saveSkillsToStore(nextSkillsPrem as SkillsDB, "premiere"),
        saveSkillsToStore(nextSkillsDeux as SkillsDB, "deuxieme"),
        saveNotationToStore(nextNotationPrem as NotationDB, "premiere"),
        saveNotationToStore(nextNotationDeux as NotationDB, "deuxieme"),
      ]);

      // --- Devoir files (FS) ---
      if (isTauriRuntime()) {
        try {
          await mkdir(devoirDirName("premiere"), {
            baseDir: BaseDirectory.AppLocalData,
            recursive: true,
          } as any);
        } catch {}

        for (const [fileName, content] of Object.entries(normalized.devoirFiles || {})) {
          const safe = ensureJsonFileName(fileName);
          try {
            const p = `${devoirDirName("premiere")}/${safe}`;
            await writeTextFile(p, JSON.stringify(content, null, 2), {
              baseDir: BaseDirectory.AppLocalData,
            } as any);
          } catch (e) {
            console.warn("Import devoir failed:", safe, e);
          }
        }
      } else {
        const n = Object.keys(normalized.devoirFiles || {}).length;
        if (n) alert("⚠️ Import : les fichiers de devoir ne peuvent pas être écrits en mode Web (ignorés)." );
      }

      // --- Extra localStorage ---
      try {
        Object.entries(normalized.extraLocalStorage || {}).forEach(([k, v]) => {
          localStorage.setItem(k, String(v ?? ""));
        });
      } catch {}

      // --- Rafraîchir l'état UI (au moins les données principales) ---
      setClassGroups(nextGroups);
      setEvalMetaListPremiere(nextEvalPrem);
      setEvalMetaListDeuxieme(nextEvalDeux);
      setSkillsDBPremiere(nextSkillsPrem as SkillsDB);
      setSkillsDBDeuxieme(nextSkillsDeux as SkillsDB);
      setNotationDBPremiere(nextNotationPrem as NotationDB);
      setNotationDBDeuxieme(nextNotationDeux as NotationDB);

      if (trainingYear === "premiere") {
        setEvalMetaList(nextEvalPrem);
        setSkillsDB(nextSkillsPrem as SkillsDB);
        setNotationDB(nextNotationPrem as NotationDB);
      } else {
        setEvalMetaList(nextEvalDeux);
        setSkillsDB(nextSkillsDeux as SkillsDB);
        setNotationDB(nextNotationDeux as NotationDB);
      }

      alert(`✅ Import terminé : ${toName}`);
    } catch (e) {
      console.error("Import error:", e);
      alert("❌ Import impossible.");
    } finally {
      setImportBusy(false);
    }
  },
  [normalizeImportedClassExport, trainingYear]
);

const handleImportClick = React.useCallback(async () => {
  if (importBusy) return;

    if (isTauriRuntime()) {
    try {
      const picked = await open({
        title: "Importer une classe",
        multiple: false,
        filters: [
          { name: "Export (ZIP)", extensions: ["zip"] },
          { name: "Export (JSON)", extensions: ["json"] },
        ],
      } as any);
      if (!picked) return;
      const path = Array.isArray(picked) ? picked[0] : picked;
      if (!path) return;

      const p = String(path);

      // ZIP : on extrait le JSON + on restaure les dossiers inclus (devoirs / PDFs)
      if (p.toLowerCase().endsWith(".zip")) {
        const bytes = await readFile(p);
        const ab =
          bytes instanceof Uint8Array
            ? bytes.buffer.slice(bytes.byteOffset, bytes.byteOffset + bytes.byteLength)
            : (bytes as any);

        const zip = await (JSZip as any).loadAsync(ab as any);

        // 1) Trouver le JSON principal (schema classe_export_v1)
        let mainJsonText = "";
        const jsonNames = Object.keys(zip.files || {}).filter(
          (n) => n.toLowerCase().endsWith(".json") && n.toLowerCase() !== "manifest.json"
        );

        for (const n of jsonNames) {
          try {
            const txt = await zip.file(n).async("string");
            const obj = JSON.parse(txt);
            if (obj && typeof obj === "object" && obj.schema === "classe_export_v1") {
              mainJsonText = txt;
              break;
            }
          } catch {
            // ignore
          }
        }

        if (!mainJsonText) {
          // fallback : si manifest.json contient déjà schema, on tente fileName standard
          try {
            const mani = await zip.file("manifest.json")?.async("string");
            const maniObj = mani ? JSON.parse(mani) : null;
            if (maniObj?.className && maniObj?.trainingYear) {
              const guess = Object.keys(zip.files || {}).find(
                (n) =>
                  n.toLowerCase().endsWith(".json") &&
                  n.toLowerCase() !== "manifest.json"
              );
              if (guess) mainJsonText = await zip.file(guess).async("string");
            }
          } catch {}
        }

        if (!mainJsonText) {
          alert("❌ ZIP invalide : impossible de trouver l’export JSON principal.");
          return;
        }

        // 2) Restaurer les fichiers du ZIP vers AppLocalData (hors JSON principal + manifest)
        const ensureParentDir = async (relPath: string) => {
          const parts = String(relPath || "").split("/").filter(Boolean);
          if (parts.length <= 1) return;
          parts.pop();
          const dir = parts.join("/");
          if (!dir) return;
          await mkdir(dir, { baseDir: BaseDirectory.AppLocalData, recursive: true } as any).catch(() => {});
        };

        const entries = Object.keys(zip.files || {});
        for (const name of entries) {
          const f = zip.files[name];
          if (!f || f.dir) continue;

          const lower = String(name).toLowerCase();
          if (lower === "manifest.json") continue;

          // On évite de ré-écrire le JSON principal : il sera importé via handleImportClassDataFromText
          if (lower.endsWith(".json")) {
            // on restaure seulement les JSON de dossiers (ex: devoirs), pas le principal
            // Heuristique : ne pas restaurer un JSON à la racine (souvent le principal)
            const isRootJson = !name.includes("/");
            if (isRootJson) continue;

            try {
              const txt = await zip.file(name).async("string");
              await ensureParentDir(name);
              await writeTextFile(name, txt, { baseDir: BaseDirectory.AppLocalData } as any);
            } catch (e) {
              console.warn("Restore JSON failed:", name, e);
            }
            continue;
          }

          // Binaires (PDF, etc.)
          try {
            const fileBytes = await zip.file(name).async("uint8array");
            await ensureParentDir(name);
            await writeFile(name, fileBytes as any, { baseDir: BaseDirectory.AppLocalData } as any);
          } catch (e) {
            console.warn("Restore file failed:", name, e);
          }
        }

        // 3) Importer le JSON principal (merge dans l'app)
        await handleImportClassDataFromText(mainJsonText);
        return;
      }

      // JSON simple
      const txt = await readTextFile(p);
      await handleImportClassDataFromText(txt);
    } catch (e) {
      console.error("Import open/read error:", e);
      alert("❌ Impossible d’ouvrir ou lire le fichier (permissions / format).");
    }
    return;
  }

  // Mode Web/dev : input file
  importFileInputRef.current?.click();
}, [handleImportClassDataFromText, importBusy]);

const openExportDrawer = React.useCallback(() => {
  const groupIsClass = classGroups.some((c) => c.name === group);
  const fallback =
    exportClassName ||
    selectedClassIdForSuivi ||
    (groupIsClass ? group : "") ||
    classGroups[0]?.name ||
    "";
  setExportClassName(fallback);
  setExportDrawerOpen(true);
}, [classGroups, exportClassName, group, selectedClassIdForSuivi]);

const handleExportClassData = React.useCallback(
  async (classNameRaw?: string) => {
    const className = String(classNameRaw ?? exportClassName ?? "").trim();
    if (!className) {
      alert("Sélectionnez une classe à exporter.");
      return;
    }

    setExportBusy(true);
    try {
      const [allGroups, evalPrem, evalDeux, skillsPrem, skillsDeux, notationPrem, notationDeux] =
        await Promise.all([
          loadElevesFromStore(),
          loadEvalMetaFromStore("premiere"),
          loadEvalMetaFromStore("deuxieme"),
          loadSkillsFromStore("premiere"),
          loadSkillsFromStore("deuxieme"),
          loadNotationFromStore("premiere"),
          loadNotationFromStore("deuxieme"),
        ]);

      const classGroup = allGroups.find((g) => g.name === className) || null;

      const evalMetaPremiere = (evalPrem || []).filter((ev) => (ev.group || "") === className);
      const evalMetaDeuxieme = (evalDeux || []).filter((ev) => (ev.group || "") === className);

      const filterSkillsByClass = (db: SkillsDB): SkillsDB => {
        const block = (db as any)?.[className];
        return block ? ({ [className]: block } as SkillsDB) : ({} as SkillsDB);
      };

      const filterNotationByClass = (db: NotationDB): NotationDB => {
        const out: any = {};
        Object.entries(db || {}).forEach(([schoolYear, byClass]: any) => {
          const classPart = byClass?.[className];
          if (classPart) out[schoolYear] = { [className]: classPart };
        });
        return out as NotationDB;
      };

      // Inclut le contenu JSON des devoirs (si accessible via le FS Tauri)
      const devoirFiles: Record<string, any> = {};
      if (isTauriRuntime()) {
        const seen = new Set<string>();
        const metas = [...evalMetaPremiere, ...evalMetaDeuxieme];
        for (const ev of metas) {
          const safe = ensureJsonFileName(ev.fileName);
          if (seen.has(safe)) continue;
          seen.add(safe);
          try {
            const txt = await readTextFile(`${devoirDirName("premiere")}/${safe}`, {
              baseDir: BaseDirectory.AppLocalData,
            });
            if (txt && txt.trim()) devoirFiles[safe] = JSON.parse(txt);
          } catch {
            // fichier absent => ignore
          }
        }
      }

      // Notes annexes stockées en localStorage (ex : absences / indicateurs)
      const extraLocalStorage: Record<string, string> = {};
      try {
        for (let i = 0; i < localStorage.length; i++) {
          const k = localStorage.key(i);
          if (!k) continue;
          if (!k.includes(`_${className}_`)) continue;
          if (!k.startsWith("bilan_absences_") && !k.startsWith("bilan_absences_traffic_")) continue;
          const v = localStorage.getItem(k);
          if (v != null) extraLocalStorage[k] = v;
        }
      } catch {
        // ignore
      }

      const payload = {
        schema: "classe_export_v1",
        exportedAt: new Date().toISOString(),
        className,
        classGroup,
        trainingYears: {
          premiere: {
            evalMeta: evalMetaPremiere,
            skills: filterSkillsByClass(skillsPrem),
            notation: filterNotationByClass(notationPrem),
          },
          deuxieme: {
            evalMeta: evalMetaDeuxieme,
            skills: filterSkillsByClass(skillsDeux),
            notation: filterNotationByClass(notationDeux),
          },
        },
        devoirFiles,
        extraLocalStorage,
      };

      const fileName = `export_${sanitizeFileNamePart(className)}_${tsForFileName()}.json`;

      // --- Export Tauri : enregistrement à l'emplacement choisi par l'utilisateur (Save dialog) ---
      if (isTauriRuntime()) {
        // ✅ Export complet en ZIP (JSON + devoirs + PDFs de suivi, etc.)
        const zipPath = await save({
          title: "Exporter (ZIP)",
          defaultPath: `export_${sanitizeFileNamePart(className)}_${sanitizeFileNamePart(getCurrentSchoolYear())}_${exportYear}_${tsForFileName()}.zip`,
          filters: [{ name: "Export (ZIP)", extensions: ["zip"] }],
        } as any);

        // Annulé par l'utilisateur
        if (!zipPath) return;

        const zip = new JSZip();

        // 0) Manifest (utile pour l'import ZIP)
        zip.file(
          "manifest.json",
          JSON.stringify(
            {
              schema: "classe_export_v1",
              exportedAt: new Date().toISOString(),
              schoolYear: getCurrentSchoolYear(),
              trainingYear: exportYear,
              className,
            },
            null,
            2
          )
        );

        // 1) JSON principal (même contenu que l'export classique)
        zip.file(fileName, safeJsonStringify(payload, 2));

        // 2) Ajout récursif d'un dossier AppLocalData dans le ZIP
        const addDirToZipFromAppLocalData = async (srcRel: string, zipBase: string) => {
          try {
            const ok = await exists(srcRel, { baseDir: BaseDirectory.AppLocalData } as any);
            if (!ok) return;

            const walk = async (relDir: string) => {
              const entries = await readDir(relDir, { baseDir: BaseDirectory.AppLocalData } as any);
              for (const entry of entries as any[]) {
                const name = String(entry?.name || "");
                if (!name) continue;

                const childRel = `${relDir}/${name}`;
                const isDir = !!entry?.isDir || Array.isArray(entry?.children);

                if (isDir) {
                  await walk(childRel);
                } else {
                  const bytes = await readFile(childRel, { baseDir: BaseDirectory.AppLocalData } as any);
                  const inside = childRel.startsWith(srcRel + "/")
                    ? childRel.slice(srcRel.length + 1)
                    : name;
                  zip.file(`${zipBase}/${inside}`, bytes as any);
                }
              }
            };

            await walk(srcRel);
          } catch (e) {
            console.warn("addDirToZipFromAppLocalData failed:", { srcRel, e });
          }
        };

        // 3) Devoirs (dossier année)
        try {
          await addDirToZipFromAppLocalData(devoirDirName(exportYear), devoirDirName(exportYear));
        } catch (e) {
          console.warn("Export devoirs (ZIP) échoué:", e);
        }

        // 4) PDFs Suivi élèves (dossier de la classe pour l'année choisie)
        try {
          const DOC_ROOT = "suivi_eleves_docs";
          const schoolYearPart = sanitizeFileNamePart(getCurrentSchoolYear());
          const classPart = sanitizeFileNamePart(className);
          const srcDocsBase = `${DOC_ROOT}/${schoolYearPart}/${exportYear}/${classPart}`;

          // On garde le même chemin dans le ZIP pour simplifier l'import
          await addDirToZipFromAppLocalData(srcDocsBase, srcDocsBase);
        } catch (e) {
          console.warn("Export PDFs suivi (ZIP) échoué:", e);
        }

        // 5) Générer + écrire le ZIP
        const zipBytes = await zip.generateAsync({ type: "uint8array" } as any);
        await writeFile(String(zipPath), zipBytes as any);

        alert(`✅ Export ZIP créé : ${zipPath}`);
        setExportDrawerOpen(false);
        return;
      }

      // --- Export Web (dev) : téléchargement direct ---
      try {
        const blob = new Blob([safeJsonStringify(payload, 2)], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = fileName;
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
        alert("✅ Export téléchargé.");
        setExportDrawerOpen(false);
      } catch {
        alert("❌ Impossible de générer l'export dans ce mode.");
      }
    } catch (e) {
      console.error("Export error:", e);
      alert("❌ Export impossible (vérifie les permissions Tauri).");
    } finally {
      setExportBusy(false);
    }
  },
  [classGroups, exportClassName, group, selectedClassIdForSuivi]
);
  // Suivi des compétences : mode élève / classe / évolutions (2 ans)
  const [suiviMode, setSuiviMode] = useState<"eleve" | "classe" | "absences" | "notation" | "evolutions" | "bilan">("eleve");


// Absences / retards (planning annuel)
const [absencesSchoolYear, setAbsencesSchoolYear] = React.useState<string>(() => getCurrentSchoolYear());
const [absencesSelectedDateYmd, setAbsencesSelectedDateYmd] = React.useState<string>(() => toYmd(new Date()));
const [absencesSettingsOpen, setAbsencesSettingsOpen] = React.useState(false);
const [absencesAutoVacCache, setAbsencesAutoVacCache] = React.useState<Record<string, VacationRange[]>>({});
const [absencesAutoVacLoading, setAbsencesAutoVacLoading] = React.useState<Record<string, boolean>>({});
const [absencesAutoVacError, setAbsencesAutoVacError] = React.useState<Record<string, string | null>>({});

// Taille des colonnes jours (zoom)
const [absencesDayColPx, setAbsencesDayColPx] = React.useState<number>(16);
const [absencesTimelineView, setAbsencesTimelineView] = React.useState<"day" | "week">("week");
const [absencesRecapOpen, setAbsencesRecapOpen] = React.useState(false);
const [absencesRecapSemesterKey, setAbsencesRecapSemesterKey] = React.useState<"ALL" | "S1" | "S2">("ALL");


// Affichage : démarrer à la semaine en cours (par défaut) ou tout afficher
const [absencesShowAllWeeks, setAbsencesShowAllWeeks] = React.useState<boolean>(true);
	const [absencesDisplayStartYmd, setAbsencesDisplayStartYmd] = React.useState<string>(() => {
  const td = new Date();
  const monday = addDays(td, -weekdayIndexMon0(td));
  return toYmd(monday);
});

// Navigation : saut de période (mois) quand on n'affiche pas tout
// Date du jour (YYYY-MM-DD) — utilisée pour griser/barrer les semaines déjà passées
	const todayYmd = toYmd(new Date());

// Alertes : seuils AB / RT en % (sur jours de COURS effectifs, du début à aujourd'hui)
// - Vert : en-dessous du seuil Orange
// - Orange : >= seuil Orange
// - Rouge : >= seuil Rouge
type AbsencesThresholdsPct = {
  abOrangePct: number;
  abRedPct: number;
  rtOrangePct: number;
  rtRedPct: number;
};

const ABSENCES_ALERTS_CACHE_KEY_PCT_V1 = "absences_alert_thresholds_pct_v1"; // legacy
const ABSENCES_ALERTS_CACHE_KEY_PCT = "absences_alert_thresholds_pct_v2";

const clampPct = (n: number, fallback: number) => {
  const v = Number.isFinite(n) ? n : fallback;
  return Math.max(0, Math.min(100, v));
};

const readAbsencesThresholdsPct = (): AbsencesThresholdsPct => {
  const defaults = { abOrangePct: 6, abRedPct: 10, rtOrangePct: 9, rtRedPct: 15 };
  try {
    const rawV2 = localStorage.getItem(ABSENCES_ALERTS_CACHE_KEY_PCT);
    if (rawV2) {
      const obj = JSON.parse(rawV2) as any;
      const abOrangePct = clampPct(parseFloat(String(obj?.abOrangePct ?? obj?.abYellowPct ?? defaults.abOrangePct).replace(",", ".")), defaults.abOrangePct);
      const abRedPct = clampPct(parseFloat(String(obj?.abRedPct ?? defaults.abRedPct).replace(",", ".")), defaults.abRedPct);
      const rtOrangePct = clampPct(parseFloat(String(obj?.rtOrangePct ?? obj?.rtYellowPct ?? defaults.rtOrangePct).replace(",", ".")), defaults.rtOrangePct);
      const rtRedPct = clampPct(parseFloat(String(obj?.rtRedPct ?? defaults.rtRedPct).replace(",", ".")), defaults.rtRedPct);
      return {
        abOrangePct: Math.min(abOrangePct, abRedPct),
        abRedPct,
        rtOrangePct: Math.min(rtOrangePct, rtRedPct),
        rtRedPct,
      };
    }

    // v1 : uniquement des seuils "rouges" (abPct/rtPct). L'orange est dérivé à 60%.
    const rawV1 = localStorage.getItem(ABSENCES_ALERTS_CACHE_KEY_PCT_V1);
    if (rawV1) {
      const obj = JSON.parse(rawV1) as any;
      const abRedPct = clampPct(parseFloat(String(obj?.abPct ?? defaults.abRedPct).replace(",", ".")), defaults.abRedPct);
      const rtRedPct = clampPct(parseFloat(String(obj?.rtPct ?? defaults.rtRedPct).replace(",", ".")), defaults.rtRedPct);
      return {
        abRedPct,
        rtRedPct,
        abOrangePct: clampPct(abRedPct * 0.6, defaults.abOrangePct),
        rtOrangePct: clampPct(rtRedPct * 0.6, defaults.rtOrangePct),
      };
    }
  } catch {
    // ignore
  }
  return defaults;
};

const [absencesThresholdsPct, setAbsencesThresholdsPct] = React.useState<AbsencesThresholdsPct>(() => readAbsencesThresholdsPct());

// Alias (compat) : valeurs utilisées dans l'app
const absencesWarnAbsPct = absencesThresholdsPct.abOrangePct;
const absencesAlertAbsPct = absencesThresholdsPct.abRedPct;
const absencesWarnRtPct = absencesThresholdsPct.rtOrangePct;
const absencesAlertRtPct = absencesThresholdsPct.rtRedPct;

// Setters : on garantit Orange <= Rouge
const setAbsencesWarnAbsPct = React.useCallback((v: number) => {
  const next = clampPct(v, absencesWarnAbsPct);
  setAbsencesThresholdsPct((p) => ({ ...p, abOrangePct: Math.min(next, p.abRedPct) }));
}, [absencesWarnAbsPct]);

const setAbsencesAlertAbsPct = React.useCallback((v: number) => {
  const next = clampPct(v, absencesAlertAbsPct);
  setAbsencesThresholdsPct((p) => ({ ...p, abRedPct: next, abOrangePct: Math.min(p.abOrangePct, next) }));
}, [absencesAlertAbsPct]);

const setAbsencesWarnRtPct = React.useCallback((v: number) => {
  const next = clampPct(v, absencesWarnRtPct);
  setAbsencesThresholdsPct((p) => ({ ...p, rtOrangePct: Math.min(next, p.rtRedPct) }));
}, [absencesWarnRtPct]);

const setAbsencesAlertRtPct = React.useCallback((v: number) => {
  const next = clampPct(v, absencesAlertRtPct);
  setAbsencesThresholdsPct((p) => ({ ...p, rtRedPct: next, rtOrangePct: Math.min(p.rtOrangePct, next) }));
}, [absencesAlertRtPct]);

React.useEffect(() => {
  try {
    localStorage.setItem(ABSENCES_ALERTS_CACHE_KEY_PCT, JSON.stringify(absencesThresholdsPct));
  } catch {}
}, [absencesThresholdsPct]);



const ensureAbsencesPlanningSettings = React.useCallback((schoolYear: string, classId: string) => {
  setAbsencesStore((prev) => {
    if (prev.planning?.[schoolYear]?.[classId]) return prev;
    const next: AbsencesRetardsStore = { records: prev.records, planning: { ...(prev.planning || {}) } };
    const byYear = { ...(next.planning[schoolYear] || {}) };
    byYear[classId] = defaultPlanningSettings(schoolYear, "B");
    next.planning[schoolYear] = byYear;
    return next;
  });
}, []);

const absencesPlanningSettings = React.useMemo(() => {
  if (!selectedClassIdForSuivi) return defaultPlanningSettings(absencesSchoolYear, "B");
  return absencesStore.planning?.[absencesSchoolYear]?.[selectedClassIdForSuivi] || defaultPlanningSettings(absencesSchoolYear, "B");
}, [absencesStore.planning, absencesSchoolYear, selectedClassIdForSuivi]);

// Helpers (Absences) : trouver le 1er jour de cours à partir d'une date + navigation (mois)
const absencesFindFirstCourseYmdOnOrAfter = React.useCallback(
  (targetYmd: string) => {
    const s = absencesPlanningSettings.startYmd;
    const e = absencesPlanningSettings.endYmd;
    let d = fromYmd(targetYmd) || fromYmd(s) || new Date();

    // clamp
    if (toYmd(d) < s) d = fromYmd(s) || d;
    if (toYmd(d) > e) d = fromYmd(e) || d;

    for (let i = 0; i < 500; i += 1) {
      const ymd = toYmd(d);
      if (ymd > e) break;

      if (ymd >= s) {
        const wdKey = weekdayKeyFromDate(d);
        if (absencesPlanningSettings.courseDays?.[wdKey]) return ymd;
      }
      d = addDays(d, 1);
    }
    return s;
  },
  [absencesPlanningSettings.startYmd, absencesPlanningSettings.endYmd, absencesPlanningSettings.courseDays]
);

const absencesJumpToCurrentWeek = React.useCallback(() => {
  const td = fromYmd(todayYmd) || new Date();
  const mondayYmd = toYmd(addDays(td, -weekdayIndexMon0(td)));
  setAbsencesShowAllWeeks(false);
  setAbsencesDisplayStartYmd(absencesFindFirstCourseYmdOnOrAfter(mondayYmd));
}, [todayYmd, absencesFindFirstCourseYmdOnOrAfter]);

const absencesJumpByMonths = React.useCallback(
  (deltaMonths: number) => {
    setAbsencesShowAllWeeks(false);
    setAbsencesDisplayStartYmd((prev) => {
      const base = fromYmd(prev) || fromYmd(absencesPlanningSettings.startYmd) || new Date();
      const target = new Date(base.getFullYear(), base.getMonth() + deltaMonths, 1);
      return absencesFindFirstCourseYmdOnOrAfter(toYmd(target));
    });
  },
  [absencesFindFirstCourseYmdOnOrAfter, absencesPlanningSettings.startYmd]
);


const absencesAutoVacKey = React.useMemo(() => {
  return `${absencesSchoolYear}_${absencesPlanningSettings.zone}`;
}, [absencesSchoolYear, absencesPlanningSettings.zone]);

const absencesAutoVacHasKey = React.useMemo(
  () => Object.prototype.hasOwnProperty.call(absencesAutoVacCache, absencesAutoVacKey),
  [absencesAutoVacCache, absencesAutoVacKey]
);
const absencesAutoVacationsForKey = absencesAutoVacHasKey ? absencesAutoVacCache[absencesAutoVacKey] : null;
const absencesAutoVacIsLoading = !!absencesAutoVacLoading[absencesAutoVacKey];
const absencesAutoVacErrorForKey = absencesAutoVacError[absencesAutoVacKey] || null;

// S'assure qu'un planning existe pour la classe (sinon on crée un planning par défaut)
React.useEffect(() => {
  if (!isAbsencesView) return;
  if (!selectedClassIdForSuivi) return;
  ensureAbsencesPlanningSettings(absencesSchoolYear, selectedClassIdForSuivi);
});

// Maintenir une date sélectionnée valide dans la plage du planning
React.useEffect(() => {
  if (!isAbsencesView) return;
  const s = absencesPlanningSettings.startYmd;
  const e = absencesPlanningSettings.endYmd;
  if (absencesSelectedDateYmd < s || absencesSelectedDateYmd > e) {
    setAbsencesSelectedDateYmd(s);
  }
});


// Maintenir un début d'affichage valide (si l'utilisateur a navigué hors de la période)
React.useEffect(() => {
  if (!isAbsencesView) return;
  if (absencesShowAllWeeks) return;
  const s = absencesPlanningSettings.startYmd;
  const e = absencesPlanningSettings.endYmd;
  if (absencesDisplayStartYmd < s || absencesDisplayStartYmd > e) {
    absencesJumpToCurrentWeek();
  }
});


// Chargement auto des vacances (ICS) selon la zone
React.useEffect(() => {
  if (!isAbsencesView) return;
  if (!selectedClassIdForSuivi) return;
  if (absencesPlanningSettings.vacationsMode !== "auto") return;
  if (absencesAutoVacHasKey) return;
  if (absencesAutoVacIsLoading) return;

  setAbsencesAutoVacError((prev) => ({ ...prev, [absencesAutoVacKey]: null }));
  setAbsencesAutoVacLoading((prev) => ({ ...prev, [absencesAutoVacKey]: true }));
  fetchVacationsForSchoolYearFromIcs(absencesPlanningSettings.zone, absencesSchoolYear)
    .then((ranges) => {
      setAbsencesAutoVacCache((prev) => ({ ...prev, [absencesAutoVacKey]: ranges }));
      setAbsencesAutoVacError((prev) => ({ ...prev, [absencesAutoVacKey]: null }));
    })
    .catch((e) => {
      console.warn("Vacances auto non chargées :", e);
      const msg = (e && typeof e === "object" && "message" in (e as any)) ? String((e as any).message) : String(e);
      setAbsencesAutoVacError((prev) => ({ ...prev, [absencesAutoVacKey]: msg }));
      setAbsencesAutoVacCache((prev) => ({ ...prev, [absencesAutoVacKey]: [] }));
    })
    .finally(() => {
      setAbsencesAutoVacLoading((prev) => ({ ...prev, [absencesAutoVacKey]: false }));
    });
}, [
  suiviMode,
  selectedClassIdForSuivi,
  absencesAutoVacKey,
  absencesAutoVacationsForKey,
  absencesAutoVacIsLoading,
  absencesPlanningSettings.zone,
  absencesPlanningSettings.vacationsMode,
  absencesSchoolYear,
]);


const updateAbsencesPlanning = React.useCallback(
  (schoolYear: string, classId: string, updater: (cur: PlanningSettings) => PlanningSettings) => {
    setAbsencesStore((prev) => {
      const current = prev.planning?.[schoolYear]?.[classId] || defaultPlanningSettings(schoolYear, "B");
      const nextSettings = updater(current);

      const nextPlanning: AbsencesRetardsStore["planning"] = { ...(prev.planning || {}) };
      const byYear = { ...(nextPlanning[schoolYear] || {}) };
      byYear[classId] = nextSettings;
      nextPlanning[schoolYear] = byYear;

      return { ...prev, planning: nextPlanning };
    });
  },
  []
);

const setAbsenceStatus = React.useCallback(
  (schoolYear: string, classId: string, studentName: string, ymd: string, status: AttendanceStatus | null) => {
    setAbsencesStore((prev) => {
      const nextRecords: AbsencesRetardsStore["records"] = { ...(prev.records || {}) };
      const byYear = { ...(nextRecords[schoolYear] || {}) };
      const byClass = { ...(byYear[classId] || {}) };
      const byStudent = { ...(byClass[studentName] || {}) };

      if (status) byStudent[ymd] = status;
      else delete byStudent[ymd];

      // nettoyage léger
      if (Object.keys(byStudent).length === 0) delete byClass[studentName];
      else byClass[studentName] = byStudent;

      if (Object.keys(byClass).length === 0) delete byYear[classId];
      else byYear[classId] = byClass;

      if (Object.keys(byYear).length === 0) delete nextRecords[schoolYear];
      else nextRecords[schoolYear] = byYear;

      return { ...prev, records: nextRecords };
    });
  },
  []
);

const setAbsenceStatusForAllStudents = React.useCallback(
  (schoolYear: string, classId: string, students: string[], ymd: string, status: AttendanceStatus | null) => {
    setAbsencesStore((prev) => {
      const nextRecords: AbsencesRetardsStore["records"] = { ...(prev.records || {}) };
      const byYear = { ...(nextRecords[schoolYear] || {}) };
      const byClass = { ...(byYear[classId] || {}) };

      for (const studentName of students) {
        const byStudent = { ...(byClass[studentName] || {}) };
        if (status) byStudent[ymd] = status;
        else delete byStudent[ymd];

        if (Object.keys(byStudent).length === 0) delete byClass[studentName];
        else byClass[studentName] = byStudent;
      }

      if (Object.keys(byClass).length === 0) delete byYear[classId];
      else byYear[classId] = byClass;

      if (Object.keys(byYear).length === 0) delete nextRecords[schoolYear];
      else nextRecords[schoolYear] = byYear;

      return { ...prev, records: nextRecords };
    });
  },
  []
);


  // Bilan périodique (onglet Suivi des compétences)
  const [bilanSemester, setBilanSemester] = useState<SemesterKey>("S1");
  const [bilanAbsencesNote, setBilanAbsencesNote] = useState<string>("");
  const [bilanAbsencesTraffic, setBilanAbsencesTraffic] = useState<TrafficLightColor>("none");
  const [bilanAppreciationNote, setBilanAppreciationNote] = useState<string>("");

  // Année scolaire cible pour le Bilan : on prend la plus récente présente dans la base de notation.
  // (Important pour consulter les données de 1ère année quand on est déjà sur l'année scolaire suivante.)
  const bilanSchoolYear = React.useMemo(
    () => pickLatestSchoolYearFromNotationDB(notationDB, getCurrentSchoolYear()),
    [notationDB, trainingYear]
  );

  // === BILAN : absences/retards auto (comptage + feu) ===
const bilanPlanningSettings = React.useMemo(() => {
  if (!selectedClassIdForSuivi) return defaultPlanningSettings(bilanSchoolYear, "B");
  return (
    absencesStore.planning?.[bilanSchoolYear]?.[selectedClassIdForSuivi] ||
    defaultPlanningSettings(bilanSchoolYear, "B")
  );
}, [absencesStore.planning, bilanSchoolYear, selectedClassIdForSuivi]);

const bilanAutoVacKey = React.useMemo(
  () => `${bilanSchoolYear}_${bilanPlanningSettings.zone}`,
  [bilanSchoolYear, bilanPlanningSettings.zone]
);
const bilanAutoVacHasKey = React.useMemo(
  () => Object.prototype.hasOwnProperty.call(absencesAutoVacCache, bilanAutoVacKey),
  [absencesAutoVacCache, bilanAutoVacKey]
);
const bilanAutoVacationsForKey = bilanAutoVacHasKey ? absencesAutoVacCache[bilanAutoVacKey] : null;
const bilanAutoVacIsLoading = !!absencesAutoVacLoading[bilanAutoVacKey];
const bilanAutoVacErrorForKey = absencesAutoVacError[bilanAutoVacKey] || null;

// (optionnel mais conseillé) charger ICS si vacances auto
React.useEffect(() => {
  if (suiviMode !== "bilan") return;
  if (bilanPlanningSettings.vacationsMode !== "auto") return;
  if (bilanAutoVacHasKey || bilanAutoVacIsLoading) return;

  setAbsencesAutoVacLoading((p) => ({ ...p, [bilanAutoVacKey]: true }));
  setAbsencesAutoVacError((p) => ({ ...p, [bilanAutoVacKey]: null }));

  fetchVacationsForSchoolYearFromIcs(bilanPlanningSettings.zone, bilanSchoolYear)
    .then((ranges) => setAbsencesAutoVacCache((p) => ({ ...p, [bilanAutoVacKey]: ranges || [] })))
    .catch((e) => setAbsencesAutoVacError((p) => ({ ...p, [bilanAutoVacKey]: String(e?.message || e) })))
    .finally(() => setAbsencesAutoVacLoading((p) => ({ ...p, [bilanAutoVacKey]: false })));
}, [
  suiviMode,
  bilanPlanningSettings.vacationsMode,
  bilanPlanningSettings.zone,
  bilanSchoolYear,
  bilanAutoVacKey,
  bilanAutoVacHasKey,
  bilanAutoVacIsLoading,
]);

const bilanAbsencesAuto = React.useMemo(() => {
  if (!selectedClassIdForSuivi || !selectedStudentForSuivi) return null;

  const classId = selectedClassIdForSuivi;
  const studentName = selectedStudentForSuivi;

  const yearBucket =
    (absencesStore.records?.[bilanSchoolYear]?.[classId] || {}) as Record<string, Record<string, AttendanceStatus>>;
  const byDate = yearBucket?.[studentName] || {};

  const startYmd = bilanPlanningSettings.startYmd;
  const endYmd = bilanPlanningSettings.endYmd;

  const vacationRanges: VacationRange[] =
    bilanPlanningSettings.vacationsMode === "auto"
      ? (bilanAutoVacationsForKey || [])
      : (bilanPlanningSettings.vacationsManual || []).map((r) => ({
          startYmd: r.startYmd,
          endYmdExclusive: addDaysYmd(r.endYmd, 1),
          label: r.label || "Vacances",
        }));

  const stageRanges: VacationRange[] = (bilanPlanningSettings.stages || []).map((r) => ({
    startYmd: r.startYmd,
    endYmdExclusive: addDaysYmd(r.endYmd, 1),
    label: r.label || "Stage",
  }));

  const cutoffYmd = todayYmd < endYmd ? todayYmd : endYmd;

  const buildEffectiveCourseSet = (fromStr: string, toInclusiveStr: string) => {
    const set = new Set<string>();
    const s = fromYmd(fromStr);
    const e = fromYmd(toInclusiveStr);
    if (!s || !e) return set;
    for (let d = new Date(s.getTime()); d <= e; d = addDays(d, 1)) {
      const wdKey = weekdayKeyFromDate(d);
      if (!bilanPlanningSettings.courseDays?.[wdKey]) continue;
      const ymd = toYmd(d);
      if (findLabelInRanges(ymd, vacationRanges)) continue;
      if (findLabelInRanges(ymd, stageRanges)) continue;
      set.add(ymd);
    }
    return set;
  };

  // Période du bilan: semestre choisi (S1/S2) ou année
  let periodLabel = "Année";
  let periodSet = buildEffectiveCourseSet(startYmd, cutoffYmd);

  if (bilanSemester === "S1" || bilanSemester === "S2") {
    periodLabel = bilanSemester;

    const parsedSY = parseSchoolYearString(bilanSchoolYear);
    const endYear = parsedSY?.endYear ?? new Date().getFullYear() + 1;

    const fallbackWinterStart = `${endYear}-02-01`;
    const winterVac = vacationRanges.find((r) => /Hiver/i.test(r.label || ""));
    const splitYmd = winterVac?.startYmd || fallbackWinterStart;

    const schoolEndExclusive = addDaysYmd(endYmd, 1);

    const sem =
      bilanSemester === "S1"
        ? { start: startYmd, endExclusive: splitYmd }
        : { start: splitYmd, endExclusive: schoolEndExclusive };

    const semEndInclusive = addDaysYmd(sem.endExclusive, -1);
    const toInclusive = cutoffYmd < semEndInclusive ? cutoffYmd : semEndInclusive;

    periodSet = toInclusive < sem.start ? new Set<string>() : buildEffectiveCourseSet(sem.start, toInclusive);
  }

  const denom = periodSet.size;

  let ab = 0;
  let rt = 0;
  for (const [ymd, status] of Object.entries(byDate)) {
    if (status !== "AB" && status !== "RT") continue;
    if (!periodSet.has(ymd)) continue;
    if (status === "AB") ab += 1;
    else rt += 1;
  }

  const abPct = denom > 0 ? (ab / denom) * 100 : 0;
  const rtPct = denom > 0 ? (rt / denom) * 100 : 0;

  const tooAb = absencesAlertAbsPct > 0 && abPct >= absencesAlertAbsPct;
  const tooRt = absencesAlertRtPct > 0 && rtPct >= absencesAlertRtPct;

  const midAb = absencesWarnAbsPct > 0 && abPct >= absencesWarnAbsPct;
  const midRt = absencesWarnRtPct > 0 && rtPct >= absencesWarnRtPct;

  const traffic: TrafficLightColor =
    denom === 0 ? "none" : tooAb || tooRt ? "red" : midAb || midRt ? "yellow" : "green";

  return { ab, rt, denom, abPct, rtPct, traffic, periodLabel };
}, [
  selectedClassIdForSuivi,
  selectedStudentForSuivi,
  absencesStore.records,
  bilanSchoolYear,
  bilanPlanningSettings,
  bilanAutoVacationsForKey,
  bilanSemester,
  todayYmd,
  absencesWarnAbsPct,
  absencesAlertAbsPct,
  absencesWarnRtPct,
  absencesAlertRtPct,
]);

const bilanAbsencesTrafficAuto: TrafficLightColor = bilanAbsencesAuto?.traffic ?? "none";

  const bilanAbsencesStorageKey = React.useMemo(() => {
    if (!selectedClassIdForSuivi || !selectedStudentForSuivi) return null;
    return `bilan_absences_${trainingYear}_${bilanSchoolYear}_${selectedClassIdForSuivi}_${selectedStudentForSuivi}_${bilanSemester}`;
  }, [trainingYear, bilanSchoolYear, selectedClassIdForSuivi, selectedStudentForSuivi, bilanSemester]);
  const bilanAbsencesTrafficStorageKey = React.useMemo(() => {
    if (!selectedClassIdForSuivi || !selectedStudentForSuivi) return null;
    return `bilan_absences_traffic_${trainingYear}_${bilanSchoolYear}_${selectedClassIdForSuivi}_${selectedStudentForSuivi}_${bilanSemester}`;
  }, [trainingYear, bilanSchoolYear, selectedClassIdForSuivi, selectedStudentForSuivi, bilanSemester]);

  const bilanAppreciationStorageKey = React.useMemo(() => {
    if (!selectedClassIdForSuivi || !selectedStudentForSuivi) return null;
    return `bilan_appreciation_${trainingYear}_${bilanSchoolYear}_${selectedClassIdForSuivi}_${selectedStudentForSuivi}_${bilanSemester}`;
  }, [trainingYear, bilanSchoolYear, selectedClassIdForSuivi, selectedStudentForSuivi, bilanSemester]);
  // Bootstrap paramètres généraux
  useEffect(() => {
    let cancelled = false;
    (async () => {
      const gs = await loadGeneralSettingsFromStore();
      if (cancelled) return;
      setGeneralSettings(gs);
      setGeneralSettingsBootstrapped(true);
    })();
    return () => { cancelled = true; };
  }, []);

  // Auto-compléter la liste des classes (clés) dans les paramètres généraux
  useEffect(() => {
    if (!generalSettingsBootstrapped) return;
    setGeneralSettings((prev) => {
      const next: GeneralSettings = {
        ...prev,
        classReferents: { ...(prev.classReferents || {}) },
      };
      classGroups.forEach((c) => {
        const k = String(c?.name || "").trim();
        if (!k) return;
        if (typeof next.classReferents[k] !== "string") next.classReferents[k] = "";
      });
      return next;
    });
  }, [classGroups, generalSettingsBootstrapped]);

  // Sauvegarde (debounce léger)
  useEffect(() => {
    if (!generalSettingsBootstrapped) return;
    const t = window.setTimeout(() => {
      saveGeneralSettingsToStore(generalSettings).catch(() => {});
    }, 250);
    return () => window.clearTimeout(t);
  }, [generalSettings, generalSettingsBootstrapped]);



  useEffect(() => {
    try {
      if (typeof window === "undefined") return;
      if (!bilanAppreciationStorageKey) {
        setBilanAppreciationNote("");
        return;
      }
      const raw = localStorage.getItem(bilanAppreciationStorageKey);
      setBilanAppreciationNote(raw ?? "");
    } catch {
      setBilanAppreciationNote("");
    }
  }, [bilanAppreciationStorageKey]);

  useEffect(() => {
    try {
      if (typeof window === "undefined") return;
      if (!bilanAppreciationStorageKey) return;
      localStorage.setItem(bilanAppreciationStorageKey, bilanAppreciationNote ?? "");
    } catch {}
  }, [bilanAppreciationStorageKey, bilanAppreciationNote]);



  useEffect(() => {
    try {
      if (typeof window === "undefined") return;
      if (!bilanAbsencesStorageKey) {
        setBilanAbsencesNote("");
        return;
      }
      const raw = localStorage.getItem(bilanAbsencesStorageKey);
      setBilanAbsencesNote(raw ?? "");
    } catch {
      setBilanAbsencesNote("");
    }
  }, [bilanAbsencesStorageKey]);

  useEffect(() => {
    try {
      if (typeof window === "undefined") return;
      if (!bilanAbsencesStorageKey) return;
      localStorage.setItem(bilanAbsencesStorageKey, bilanAbsencesNote ?? "");
    } catch {}
  }, [bilanAbsencesStorageKey, bilanAbsencesNote]);
  useEffect(() => {
    try {
      if (typeof window === "undefined") return;
      if (!bilanAbsencesTrafficStorageKey) {
        setBilanAbsencesTraffic("none");
        return;
      }
      const raw = localStorage.getItem(bilanAbsencesTrafficStorageKey);
      const v = raw as TrafficLightColor | null;
      if (v === "red" || v === "yellow" || v === "green" || v === "none") setBilanAbsencesTraffic(v);
      else setBilanAbsencesTraffic("none");
    } catch {
      setBilanAbsencesTraffic("none");
    }
  }, [bilanAbsencesTrafficStorageKey]);

  useEffect(() => {
    try {
      if (typeof window === "undefined") return;
      if (!bilanAbsencesTrafficStorageKey) return;
      localStorage.setItem(bilanAbsencesTrafficStorageKey, bilanAbsencesTraffic ?? "none");
    } catch {}
  }, [bilanAbsencesTrafficStorageKey, bilanAbsencesTraffic]);


  // Vue "Évolutions" : paramètres (persistés en localStorage)
  const [evolutionSettingsOpen, setEvolutionSettingsOpen] = useState(false);
  const [evolutionCapLine, setEvolutionCapLine] = useState<number>(() => {
    try {
      const raw = typeof window !== "undefined" ? localStorage.getItem("evolution_settings") : null;
      const parsed = raw ? JSON.parse(raw) : null;
      const v = parsed?.capLine;
      if (typeof v === "number" && isFinite(v)) return Math.max(0, Math.min(20, v));
    } catch {}
    return 10;
  });
  const [evolutionGroupMode, setEvolutionGroupMode] = useState<"activite" | "ep">(() => {
    try {
      const raw = typeof window !== "undefined" ? localStorage.getItem("evolution_settings") : null;
      const parsed = raw ? JSON.parse(raw) : null;
      const v = parsed?.groupMode;
      if (v === "ep" || v === "activite") return v;
    } catch {}
    return "activite";
  });

  const [evolutionCardsPerRow, setEvolutionCardsPerRow] = useState<number>(() => {
    try {
      const raw = typeof window !== "undefined" ? localStorage.getItem("evolution_settings") : null;
      const parsed = raw ? JSON.parse(raw) : null;
      const v = parsed?.cardsPerRow;
      if (typeof v === "number" && isFinite(v)) return Math.max(1, Math.min(10, Math.round(v)));
    } catch {}
    return 3;
  });

const [evolutionShowDevoirs, setEvolutionShowDevoirs] = useState<boolean>(() => {
  try {
    const raw = typeof window !== "undefined" ? localStorage.getItem("evolution_settings") : null;
    const parsed = raw ? JSON.parse(raw) : null;
    const v = parsed?.showDevoirs;
    if (typeof v === "boolean") return v;
  } catch {}
  return true;
});

  useEffect(() => {
    try {
      if (typeof window === "undefined") return;
      localStorage.setItem(
        "evolution_settings",
        JSON.stringify({ capLine: evolutionCapLine, groupMode: evolutionGroupMode, cardsPerRow: evolutionCardsPerRow, showDevoirs: evolutionShowDevoirs })
      );
    } catch {}
  }, [evolutionCapLine, evolutionGroupMode, evolutionCardsPerRow, evolutionShowDevoirs]);
  const [classeSemesterForSuivi, setClasseSemesterForSuivi] = useState<SemesterKey>("S1");
  const [selectedEvalIdForClasse, setSelectedEvalIdForClasse] = useState<string | null>(null);
  const [showTasksVolet, setShowTasksVolet] = useState(false);
  const [activeView, setActiveView] = useState<"evaluation" | "suivi" | "suivi_eleves" | "notes" | "ccf" | "referentiel_add">("evaluation");
const [suiviElevesMode, setSuiviElevesMode] = useState<"docs" | "absences">("docs");
const isDocsView = activeView === "suivi_eleves" && suiviElevesMode === "docs";
const isAbsencesView = activeView === "suivi_eleves" && suiviElevesMode === "absences";


// =======================
// CCF (livret) — fiches d'évaluation par élève
// =======================
type CcfLevel = "NON" | "0" | "1" | "2" | "3";
type CcfEpKey = "EP1" | "EP2A1" | "EP2A2" | "EP3"; // "EP1" | "EP2A1" | "EP2A2" | "EP3"

type CcfEvalRow = {
  epKey: CcfEpKey;
  ref: string;
  epreuve: string;
  unite?: string;
  coef: number;
  mode?: string;
  duree?: string;
  // Styles (issus du fichier Excel "Evaluation")
  bgColor?: string;
  fontColor?: string;
};

const CCF_EVALUATION_FALLBACK: CcfEvalRow[] = [
  {
    epKey: "EP1",
    ref: "EP1",
    epreuve: "Étude et préparation d’une intervention",
    unite: "UP1",
    coef: 4,
    mode: "CCF",
    duree: "Environ 3h",
  },
  {
    epKey: "EP2A1",
    ref: "EP2 A1",
    epreuve: "Réalisation et contrôle de travaux courants — Situation 1 (en centre)",
    unite: "UP2",
    coef: 4,
    mode: "CCF",
    duree: "Environ 15h",
  },
  {
    epKey: "EP2A2",
    ref: "EP2 A2",
    epreuve: "Réalisation et contrôle de travaux courants — Situation 2 (en entreprise)",
    unite: "UP2",
    coef: 4,
    mode: "CCF",
    duree: "Environ 14h",
  },
  {
    epKey: "EP3",
    ref: "EP3",
    epreuve: "Réalisation de travaux spécifiques",
    unite: "UP3",
    coef: 2,
    mode: "CCF",
    duree: "Environ 3h",
  },
];
type CcfStudentSheet = {
  meta?: { date?: string; contexte?: string; evaluator?: string; comment?: string; noteProposee?: string };
  levels: Record<string, CcfLevel | undefined>; // itemCode -> level
};
// DB par élève : toutes les EP ne sont pas forcément renseignées dès le départ.
// On utilise donc un Partial pour éviter les erreurs TypeScript lors des mises à jour.
type CcfDb = Record<string, Partial<Record<CcfEpKey, CcfStudentSheet>>>; // studentName -> EP -> sheet

const CCF_DB_KEY = "ccf_db_v1";

const [ccfSelectedClassId, setCcfSelectedClassId] = useState<string | null>(null);
const [ccfSelectedStudentName, setCcfSelectedStudentName] = useState<string | null>(null);
const [ccfEpKey, setCcfEpKey] = useState<CcfEpKey>("EP1");
const [ccfDb, setCcfDb] = useState<CcfDb>(() => {
  try {
    const raw = localStorage.getItem(CCF_DB_KEY);
    return raw ? (JSON.parse(raw) as CcfDb) : {};
  } catch {
    return {};
  }
});


// Sous-onglets CCF + paramètres globaux
type CcfCcfTab = CcfEpKey | "EVALUATION"; // EP1 | EP2A1 | EP2A2 | EP3 | EVALUATION
type CcfGlobalSettings = {
  date?: string;        // date d'évaluation (par défaut)
  evaluator?: string;   // évaluateur (par défaut)
  center?: string;      // centre / établissement
  session?: string;     // session (optionnel)
};

const CCF_TAB_KEY = "ccf_tab_v1";
const CCF_SETTINGS_KEY = "ccf_settings_v1";
const CCF_REG_NOTES_KEY = "ccf_reg_notes_v1";
const CCF_EP_PARAMS_OPEN_KEY = "ccf_ep_params_open_v1";
const CCF_EXCEL_PATH_KEY = "ccf_excel_path_v1";

const [ccfTab, setCcfTab] = useState<CcfCcfTab>(() => {
  try {
    const saved = localStorage.getItem(CCF_TAB_KEY);
    if (saved === "EP1" || saved === "EP2A1" || saved === "EP2A2" || saved === "EP3" || saved === "EVALUATION") return saved as CcfCcfTab;
    // 🧩 Migration : anciens onglets (reglementation / fiches / recap) -> EP1
    return "EP1";
  } catch {
    return "EP1";
  }
});

// Source Excel (livret national) pour l'onglet CCF
const [ccfExcelPath, setCcfExcelPath] = useState<string | null>(() => {
  try {
    return localStorage.getItem(CCF_EXCEL_PATH_KEY);
  } catch {
    return null;
  }
});

// Templates CCF actifs : soit issus de l'Excel branché, soit fallback embarqué
const [ccfTemplates, setCcfTemplates] = useState<typeof CCF_TEMPLATES>(() => CCF_TEMPLATES);
const [ccfEvaluationRows, setCcfEvaluationRows] = useState<CcfEvalRow[]>(() => CCF_EVALUATION_FALLBACK);


// Export JSON CCF (par classe)
const [ccfExportBusy, setCcfExportBusy] = useState(false);

const handleExportCcfJsonForSelectedClass = async () => {
  if (!ccfSelectedClassId) {
    alert("Sélectionne d’abord une classe dans CCF.");
    return;
  }

  setCcfExportBusy(true);
  try {
    const students = getStudentsForClassCCF(ccfSelectedClassId);

    const ccfDbForClass: CcfDb = {};
    for (const st of students) {
      if (ccfDb[st]) ccfDbForClass[st] = ccfDb[st];
    }

    const payload = {
      schema: "ccf_export_v1",
      exportedAt: new Date().toISOString(),
      classId: ccfSelectedClassId,
      students,
      ccfSettings: ccfSettings || {},
      ccfExcelPath: ccfExcelPath || null,
      ccfEvaluationRows,
      ccfDb: ccfDbForClass,
    };

    const fileName = `CCF_${sanitizeFileNamePart(String(ccfSelectedClassId))}_${tsForFileName()}.json`;

    if (isTauriRuntime()) {
      const pickedPath = await save({
        title: "Enregistrer l’export CCF",
        defaultPath: fileName,
        filters: [{ name: "CCF (JSON)", extensions: ["json"] }],
      });
      if (!pickedPath) return;

      const dest = ensureJsonFileName(String(pickedPath));
      await writeTextFile(dest, safeJsonStringify(payload, 2));
      alert(`✅ Export CCF créé : ${dest}`);
      return;
    }

    // Mode Web/dev : téléchargement direct
    const blob = new Blob([safeJsonStringify(payload, 2)], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = fileName;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
    alert("✅ Export CCF téléchargé.");
  } catch (e) {
    console.error(e);
    alert("Erreur pendant l’export CCF.");
  } finally {
    setCcfExportBusy(false);
  }
};

useEffect(() => {
  try {
    if (!ccfExcelPath) localStorage.removeItem(CCF_EXCEL_PATH_KEY);
    else localStorage.setItem(CCF_EXCEL_PATH_KEY, ccfExcelPath);
  } catch {
    // ignore
  }
}, [ccfExcelPath]);

function parseEpSheet(ws: ExcelJS.Worksheet, theme?: { colors: (string | null)[] }) {
  type TmpStyle = { bgColor?: string; fontColor?: string };
  type TmpItem = { code: string; label: string; criteria: string; realWeight: number } & TmpStyle;
  type TmpGroup = { code: string; title: string; items: TmpItem[] } & TmpStyle;

  const groups: any[] = [];
  let current: TmpGroup | null = null;

  const isGroup = (b: string) => /^C\d+(?:\.\d+)+\s*:\s*/.test(b);
  const isItem = (b: string) => /^C\d+(?:\.\d+)+\.\d+$/.test(b);

  const cellText = (cell: any): string => {
    try {
      const master = (cell as any)?.master ?? cell;
      const t = (master as any)?.text;
      if (t != null && String(t).trim() !== "") return String(t);
      const v = (master as any)?.value;
      if (v == null) return "";
      if (typeof v === "string" || typeof v === "number" || typeof v === "boolean") return String(v);
      if (typeof v === "object" && (v as any).result != null) return String((v as any).result);
      if (typeof v === "object" && Array.isArray((v as any).richText)) {
        return (v as any).richText.map((x: any) => x?.text ?? "").join("");
      }
      return String(v);
    } catch {
      return "";
    }
  };

  const cellNumber = (cell: any): number => {
    const master = (cell as any)?.master ?? cell;
    const v = (master as any)?.value;
    if (typeof v === "number" && isFinite(v)) return v;
    const raw = cellText(master).replace(/\s+/g, "").replace(",", ".");
    const n = Number(raw);
    return isFinite(n) ? n : 0;
  };

  const hex2rgb = (hex: string) => {
    const h = hex.replace(/^#/, "");
    const r = parseInt(h.slice(0, 2), 16);
    const g = parseInt(h.slice(2, 4), 16);
    const b = parseInt(h.slice(4, 6), 16);
    return { r, g, b };
  };
  const rgb2hex = ({ r, g, b }: { r: number; g: number; b: number }) =>
    "#" +
    [r, g, b]
      .map((n) => Math.max(0, Math.min(255, Math.round(n))).toString(16).padStart(2, "0"))
      .join("")
      .toUpperCase();

  // OOXML tint: <0 darken, >0 lighten
  const applyTint = (hex: string, tint?: number) => {
    if (typeof tint !== "number" || Number.isNaN(tint) || tint === 0) return hex;
    const { r, g, b } = hex2rgb(hex);
    const f = (c: number) => {
      if (tint < 0) return c * (1 + tint);
      return c + (255 - c) * tint;
    };
    return rgb2hex({ r: f(r), g: f(g), b: f(b) });
  };

  const argbToHex = (argb?: string): string | undefined => {
    if (!argb) return undefined;
    const s = String(argb).replace(/^#/, "").toUpperCase();
    if (s.length === 8) return `#${s.slice(2)}`;
    if (s.length === 6) return `#${s}`;
    return undefined;
  };

  const colorToHex = (color: any): string | undefined => {
    if (!color) return undefined;
    if (color.argb) return argbToHex(color.argb);
    if (typeof color.theme === "number" && theme?.colors) {
      const base = theme.colors[color.theme] || null;
      if (base) return applyTint(base, color.tint);
    }
    return undefined;
  };

  const extractStyle = (cell: any): TmpStyle => {
    try {
      const master = (cell as any)?.master ?? cell;
      const fill = (master as any)?.fill;
      const font = (master as any)?.font;

      const bg =
        colorToHex(fill?.fgColor) ||
        colorToHex(fill?.bgColor) ||
        undefined;

      const fg = colorToHex(font?.color) || undefined;

      const out: TmpStyle = {};
      if (bg) out.bgColor = bg;
      if (fg) out.fontColor = fg;
      return out;
    } catch {
      return {};
    }
  };

  const pickStyledCell = (row: ExcelJS.Row) => {
    // Dans ce livret, les couleurs sont souvent appliquées sur C / F / ou sur une cellule fusionnée.
    const candidates = [2, 3, 6, 16].map((i) => row.getCell(i));
    for (const c of candidates) {
      const st = extractStyle(c);
      if (st.bgColor || st.fontColor) return { cell: c, st };
    }
    return { cell: row.getCell(2), st: extractStyle(row.getCell(2)) };
  };

  const flush = () => {
    if (!current || !current.items.length) return;
    const sum = current.items.reduce((s, it) => s + (it.realWeight || 0), 0);
    const groupPoints = (sum / 100) * 20;
    groups.push({
      code: current.code,
      title: current.title,
      bgColor: current.bgColor,
      fontColor: current.fontColor,
      groupPoints,
      items: current.items.map((it) => ({
        bgColor: it.bgColor,
        fontColor: it.fontColor,
        ...it,
        relative: sum ? (it.realWeight || 0) / sum : 0,
      })),
    });
  };

  ws.eachRow({ includeEmpty: true }, (row) => {
    const b = String(cellText(row.getCell(2)) ?? "").trim();
    const c = String(cellText(row.getCell(3)) ?? "").trim();
    const f = String(cellText(row.getCell(6)) ?? "").trim();
    const p = cellNumber(row.getCell(16));

    if (!b) return;

    if (isGroup(b)) {
      flush();
      const [codePart, ...rest] = b.split(":");
      const { st } = pickStyledCell(row);
      current = {
        code: (codePart ?? "").trim().replace(/\u00A0/g, " "),
        title: rest.join(":").trim(),
        items: [],
        ...st,
      };
      return;
    }

    if (current && isItem(b) && p > 0) {
      const { st } = pickStyledCell(row);
      current.items.push({
        code: b,
        label: c,
        criteria: f,
        realWeight: p,
        ...st,
      });
    }
  });

  flush();
  return groups;
}

async function importCcfTemplatesFromExcel(path: string) {
  const bytes = await readFile(path);

  const ab =
    bytes instanceof Uint8Array
      ? bytes.buffer.slice(bytes.byteOffset, bytes.byteOffset + bytes.byteLength)
      : (bytes as any);

  // --- Theme parsing (pour résoudre fgColor.theme + tint) ---
  const theme = { colors: Array(12).fill(null) as (string | null)[] };

  try {
    const zip = await (JSZip as any).loadAsync(ab as any);
    const themeFile =
      zip.file("xl/theme/theme1.xml") || zip.file("xl/theme/theme.xml");
    const xml = themeFile ? await themeFile.async("string") : "";

    // Récupération du clrScheme: dk1, lt1, dk2, lt2, accent1-6, hlink, folHlink
    const pick = (tag: string) => {
      const m = xml.match(new RegExp(`<a:${tag}[^>]*>[\\s\\S]*?<a:srgbClr[^>]*val="([0-9A-Fa-f]{6})"`, "m"));
      return m ? `#${m[1].toUpperCase()}` : null;
    };

    // index selon OOXML: 0=lt1,1=dk1,2=lt2,3=dk2,4=accent1..9=accent6,10=hlink,11=folHlink
    theme.colors[0] = pick("lt1");
    theme.colors[1] = pick("dk1");
    theme.colors[2] = pick("lt2");
    theme.colors[3] = pick("dk2");
    theme.colors[4] = pick("accent1");
    theme.colors[5] = pick("accent2");
    theme.colors[6] = pick("accent3");
    theme.colors[7] = pick("accent4");
    theme.colors[8] = pick("accent5");
    theme.colors[9] = pick("accent6");
    theme.colors[10] = pick("hlink");
    theme.colors[11] = pick("folHlink");
  } catch {
    // si le thème est illisible, on reste en "sans thème"
  }

  const wb = new ExcelJS.Workbook();
  await wb.xlsx.load(ab as any);

  const norm = (s: string) => s.replace(/\s+/g, " ").trim().toLowerCase();
  const findSheet = (name: string) =>
    wb.worksheets.find((w) => norm(w.name) === norm(name));

  const get = (name: string) => {
    const ws = findSheet(name);
    if (!ws) throw new Error(`Feuille manquante dans l'Excel: ${name}`);
    return parseEpSheet(ws, theme);
  };

  return {
    EP1: get("EP1"),
    EP2A1: get("EP2 A1"),
    EP2A2: get("EP2 A2"),
    EP3: get("EP3"),
  } as unknown as typeof CCF_TEMPLATES;
}



async function importCcfEvaluationFromExcel(path: string): Promise<CcfEvalRow[]> {
  try {
    const bytes = await readFile(path);

    const wb = new ExcelJS.Workbook();
    const ab =
      bytes instanceof Uint8Array
        ? bytes.buffer.slice(bytes.byteOffset, bytes.byteOffset + bytes.byteLength)
        : (bytes as any);

    // --- Theme parsing (pour résoudre fgColor.theme + tint) ---
    const theme = { colors: Array(12).fill(null) as (string | null)[] };

    try {
      const zip = await (JSZip as any).loadAsync(ab as any);
      const themeFile =
        zip.file("xl/theme/theme1.xml") || zip.file("xl/theme/theme.xml");
      const xml = themeFile ? await themeFile.async("string") : "";

      const pick = (tag: string) => {
        const m = xml.match(new RegExp(`<a:${tag}[^>]*>[\s\S]*?<a:srgbClr[^>]*val="([0-9A-Fa-f]{6})"`, "m"));
        return m ? `#${m[1].toUpperCase()}` : null;
      };

      // index OOXML: 0=lt1,1=dk1,2=lt2,3=dk2,4..9=accent1..6,10=hlink,11=folHlink
      theme.colors[0] = pick("lt1");
      theme.colors[1] = pick("dk1");
      theme.colors[2] = pick("lt2");
      theme.colors[3] = pick("dk2");
      theme.colors[4] = pick("accent1");
      theme.colors[5] = pick("accent2");
      theme.colors[6] = pick("accent3");
      theme.colors[7] = pick("accent4");
      theme.colors[8] = pick("accent5");
      theme.colors[9] = pick("accent6");
      theme.colors[10] = pick("hlink");
      theme.colors[11] = pick("folHlink");
    } catch {
      // thème illisible → fallback sans thème
    }

    await wb.xlsx.load(ab as any);

    const norm = (s: string) => s.replace(/\s+/g, " ").trim().toLowerCase();
    const ws = wb.worksheets.find((w) => norm(w.name) === norm("Evaluation"));
    if (!ws) return CCF_EVALUATION_FALLBACK;

    const getText = (cell: any) => {
      const v = cell?.value as any;
      if (v == null) return "";
      if (typeof v === "object" && (v as any).richText) {
        return (v as any).richText.map((x: any) => x.text).join("");
      }
      return String(v);
    };


    // --- Style extraction (bg + font) ---
    const hex2rgb = (hex: string) => {
      const h = hex.replace("#", "");
      const r = parseInt(h.slice(0, 2), 16);
      const g = parseInt(h.slice(2, 4), 16);
      const b = parseInt(h.slice(4, 6), 16);
      return { r, g, b };
    };
    const rgb2hex = (rgb: { r: number; g: number; b: number }) => {
      const clamp = (n: number) => Math.max(0, Math.min(255, Math.round(n)));
      const to2 = (n: number) => clamp(n).toString(16).padStart(2, "0").toUpperCase();
      return `#${to2(rgb.r)}${to2(rgb.g)}${to2(rgb.b)}`;
    };
    const applyTint = (hex: string, tint?: number) => {
      if (typeof tint !== "number" || Number.isNaN(tint) || tint === 0) return hex;
      const { r, g, b } = hex2rgb(hex);
      const f = (c: number) => {
        if (tint < 0) return c * (1 + tint);
        return c + (255 - c) * tint;
      };
      return rgb2hex({ r: f(r), g: f(g), b: f(b) });
    };
    const argbToHex = (argb?: string): string | undefined => {
      if (!argb) return undefined;
      const s = String(argb).replace(/^#/, "").toUpperCase();
      if (s.length === 8) return `#${s.slice(2)}`;
      if (s.length === 6) return `#${s}`;
      return undefined;
    };
    const colorToHex = (color: any): string | undefined => {
      if (!color) return undefined;
      if (color.argb) return argbToHex(color.argb);
      if (typeof color.theme === "number" && theme?.colors) {
        const base = theme.colors[color.theme] || null;
        if (base) return applyTint(base, color.tint);
      }
      return undefined;
    };
    const extractStyle = (cell: any): { bgColor?: string; fontColor?: string } => {
      try {
        const master = (cell as any)?.master ?? cell;
        const fill = (master as any)?.fill;
        const font = (master as any)?.font;

        const bg = colorToHex(fill?.fgColor) || colorToHex(fill?.bgColor) || undefined;
        const fg = colorToHex(font?.color) || undefined;

        const out: { bgColor?: string; fontColor?: string } = {};
        if (bg) out.bgColor = bg;
        if (fg) out.fontColor = fg;
        return out;
      } catch {
        return {};
      }
    };
    const pickRowStyle = (row: any) => {
      const candidates = [4, 5, 7, 8, 9, 10, 11, 12].map((i) => row.getCell(i));
      for (const c of candidates) {
        const st = extractStyle(c);
        if (st.bgColor || st.fontColor) return st;
      }
      return {};
    };

    const rowsByRef: Record<string, any> = {};
    ws.eachRow({ includeEmpty: true }, (row) => {
      const ref = getText(row.getCell(4)).trim(); // D
      if (ref) rowsByRef[ref] = row;
    });

    const rowEP1 = rowsByRef["EP1"];
    const rowEP2A = rowsByRef["EP2 A"];

    let rowSit1: any = null;
    let rowSit2: any = null;
    ws.eachRow({ includeEmpty: true }, (row) => {
      const lib = getText(row.getCell(5)).trim(); // E
      if (/Situation\s*1/i.test(lib)) rowSit1 = row;
      if (/Situation\s*2/i.test(lib)) rowSit2 = row;
    });

    const unitEP2 = rowEP2A ? getText(rowEP2A.getCell(7)).trim() : "UP2";

    const mk = (
      epKey: CcfEpKey,
      ref: string,
      epreuve: string,
      unite: string | undefined,
      coef: number,
      mode: string | undefined,
      duree: string | undefined,
      st?: { bgColor?: string; fontColor?: string }
    ): CcfEvalRow => ({
      epKey,
      ref,
      epreuve,
      unite,
      coef,
      mode,
      duree,
      ...(st || {}),
    });

    const out: CcfEvalRow[] = [];

if (rowEP1) {
  out.push(
    mk(
      "EP1",
      "EP1",
      getText(rowEP1.getCell(5)).trim(),
      getText(rowEP1.getCell(7)).trim(),
      Number(getText(rowEP1.getCell(8)).trim() || 0),
      getText(rowEP1.getCell(9)).trim(),
      getText(rowEP1.getCell(10)).trim(),
      pickRowStyle(rowEP1) // ✅ ici
    )
  );
}

if (rowSit1) {
  out.push(
    mk(
      "EP2A1",
      "EP2 A1",
      `Réalisation et contrôle de travaux courants — ${getText(rowSit1.getCell(5)).trim()}`,
      unitEP2 || "UP2",
      Number(getText(rowSit1.getCell(8)).trim() || 0),
      getText(rowSit1.getCell(9)).trim(),
      getText(rowSit1.getCell(10)).trim(),
      pickRowStyle(rowSit1) // ✅ ici
    )
  );
}

if (rowSit2) {
  out.push(
    mk(
      "EP2A2",
      "EP2 A2",
      `Réalisation et contrôle de travaux courants — ${getText(rowSit2.getCell(5)).trim()}`,
      unitEP2 || "UP2",
      Number(getText(rowSit2.getCell(8)).trim() || 0),
      getText(rowSit2.getCell(9)).trim(),
      getText(rowSit2.getCell(10)).trim(),
      pickRowStyle(rowSit2) // ✅ ici
    )
  );
}

const rowEP3 = rowsByRef["EP3"];
if (rowEP3) {
  out.push(
    mk(
      "EP3",
      "EP3",
      getText(rowEP3.getCell(5)).trim(),
      getText(rowEP3.getCell(7)).trim(),
      Number(getText(rowEP3.getCell(8)).trim() || 0),
      getText(rowEP3.getCell(9)).trim(),
      getText(rowEP3.getCell(10)).trim(),
      pickRowStyle(rowEP3) // ✅ ici
    )
  );
}


    if (out.length !== 4 || out.some((r) => !r.coef)) return CCF_EVALUATION_FALLBACK;
    return out;
  } catch {
    return CCF_EVALUATION_FALLBACK;
  }
}

async function linkCcfExcel() {
  const p = await open({
    multiple: false,
    filters: [{ name: "Excel", extensions: ["xlsx", "xlsm", "xls"] }],
  });
  if (typeof p === "string") {
    setCcfExcelPath(p);
  }
}

function unlinkCcfExcel() {
  setCcfExcelPath(null);
  setCcfTemplates(CCF_TEMPLATES);
  setCcfEvaluationRows(CCF_EVALUATION_FALLBACK);
}

// Auto-refresh : si l'Excel change, l'onglet CCF se met à jour
useEffect(() => {
  if (!ccfExcelPath) return;

  let stopped = false;
  let lastMtime = 0;

  const tick = async () => {
    try {
      const meta = await stat(ccfExcelPath);
      const mtime = meta?.mtime ? new Date(meta.mtime).getTime() : 0;
      if (mtime && mtime !== lastMtime) {
        lastMtime = mtime;
        const tpl = await importCcfTemplatesFromExcel(ccfExcelPath);
        const evr = await importCcfEvaluationFromExcel(ccfExcelPath);
        if (!stopped) {
          setCcfTemplates(tpl);
          setCcfEvaluationRows(evr);
        }
      }
    } catch {
      // Excel introuvable/déplacé : on ne force pas le unlink pour éviter les surprises
    }
  };

  tick();
  const id = setInterval(tick, 1500);

  return () => {
    stopped = true;
    clearInterval(id);
  };
}, [ccfExcelPath]);


// Sync : les onglets CCF pilotent directement l'épreuve (EP1/EP2A1/EP2A2/EP3)
useEffect(() => {
  setCcfEpKey(ccfTab as CcfEpKey);
}, [ccfTab]);

const [ccfSettings, setCcfSettings] = useState<CcfGlobalSettings>(() => {
  try {
    const raw = localStorage.getItem(CCF_SETTINGS_KEY);
    return raw ? (JSON.parse(raw) as CcfGlobalSettings) : {};
  } catch {
    return {};
  }
});

const [ccfRegNotes, setCcfRegNotes] = useState<string>(() => {
  try {
    return localStorage.getItem(CCF_REG_NOTES_KEY) || "";
  } catch {
    return "";
  }
});

// Ouverture/fermeture du panneau "Paramètres de l'épreuve" dans Fiches d'évaluations
const [ccfEpParamsOpen, setCcfEpParamsOpen] = useState<boolean>(() => {
  try {
    const raw = localStorage.getItem(CCF_EP_PARAMS_OPEN_KEY);
    if (raw === "0") return false;
    if (raw === "1") return true;
  } catch {}
  return true;
});

useEffect(() => {
  try {
    localStorage.setItem(CCF_TAB_KEY, ccfTab);
  } catch {}
}, [ccfTab]);

useEffect(() => {
  try {
    localStorage.setItem(CCF_SETTINGS_KEY, JSON.stringify(ccfSettings || {}));
  } catch {}
}, [ccfSettings]);

useEffect(() => {
  try {
    localStorage.setItem(CCF_REG_NOTES_KEY, ccfRegNotes || "");
  } catch {}
}, [ccfRegNotes]);

useEffect(() => {
  try {
    localStorage.setItem(CCF_EP_PARAMS_OPEN_KEY, ccfEpParamsOpen ? "1" : "0");
  } catch {}
}, [ccfEpParamsOpen]);
useEffect(() => {
  try {
    localStorage.setItem(CCF_DB_KEY, JSON.stringify(ccfDb));
  } catch {
    // ignore
  }
}, [ccfDb]);

function ccfFraction(level: CcfLevel | undefined): number | null {
  if (!level) return null;
  if (level === "NON") return null;
  if (level === "0") return 0;
  if (level === "1") return 1 / 3;
  if (level === "2") return 2 / 3;
  return 1;
}

function ccfLevelLabel(level: CcfLevel): string {
  // Affichage compact dans le tableau (NON, 0, 1, 2, 3).
  return level;
}

function ccfLevelButtonClass(level: CcfLevel, active: boolean): string {
  // Base styles keep consistent sizing; color indicates level.
  const base = "px-2 py-1 rounded-md border text-[11px] font-semibold min-w-[44px]";
  const palette =
    level === "NON"
      ? active
        ? "bg-neutral-800 text-white border-neutral-700 dark:bg-neutral-200/20 dark:text-neutral-50 dark:border-neutral-200/30"
        : "bg-white dark:bg-[#0f1b2d] text-neutral-800 dark:text-neutral-100 border-neutral-200 dark:border-sky-400/35 hover:bg-neutral-100/70 dark:hover:bg-neutral-200/10"
      : level === "0"
        ? active
          ? "bg-red-600 text-white border-red-700"
          : "bg-red-50 text-red-800 border-red-200 hover:bg-red-100"
        : level === "1"
          ? active
            ? "bg-orange-600 text-white border-orange-700"
            : "bg-orange-50 text-orange-800 border-orange-200 hover:bg-orange-100"
          : level === "2"
            ? active
              ? "bg-lime-600 text-white border-lime-700"
              : "bg-lime-50 text-lime-800 border-lime-200 hover:bg-lime-100"
            : active
              ? "bg-green-600 text-white border-green-700"
              : "bg-green-50 text-green-800 border-green-200 hover:bg-green-100";

  return classNames(base, palette);
}


function getStudentsForClassCCF(classId: string | null): string[] {
  if (!classId) return [];
  const classe = classGroups.find((c) => (c.id ?? c.name) === classId || c.name === classId);
  if (!classe) return [];
  return String(classe.students || "")
    .split(/\r?\n/)
    .map((s) => s.trim())
    .filter(Boolean);
}

function __normEpKey(ep: any): string {
  return String(ep || "").replace(/\s+/g, "");
}

function getCcfSheet(studentName: string, ep: any): CcfStudentSheet {
  const k = __normEpKey(ep) as CcfEpKey;
  return ccfDb?.[studentName]?.[k] ?? { meta: {}, levels: {} };
}

function setCcfSheet(studentName: string, ep: any, next: CcfStudentSheet) {
  const k = __normEpKey(ep) as CcfEpKey;
  setCcfDb((prev) => ({
    ...prev,
    [studentName]: {
      ...(prev[studentName] || {}),
      [k]: next,
    },
  }));
}

function computeCcfTotal(studentName: string, ep: any) {
  const k = __normEpKey(ep) as CcfEpKey;
  const tplRaw: any = (ccfTemplates?.[k] ?? (CCF_TEMPLATES as any)[k] ?? []);
  const tpl = Array.isArray(tplRaw) ? tplRaw : [];
  const sheet = getCcfSheet(studentName, k);

  let total = 0;
  const groupDetails = tpl.map((g: any) => {
    const itemsArr = Array.isArray(g?.items) ? g.items : [];
    const included = itemsArr
      .map((it: any) => {
        const frac = ccfFraction(sheet.levels?.[it.code] as CcfLevel | undefined);
        return { it, frac };
      })
      .filter((x: any) => x.frac !== null);

    const sumR = included.reduce((a: number, b: any) => a + (b.it.realWeight || 0), 0);
    const sumPoints = included.reduce((a: number, b: any) => a + (b.frac as number) * (b.it.realWeight || 0), 0);
    const groupScore = sumR > 0 ? (sumPoints / sumR) * (g.groupPoints || 0) : 0;

    total += groupScore;
    return { code: g.code, title: g.title, groupPoints: g.groupPoints || 0, groupScore };
  });

  return { total, groupDetails };
}


  const [helpOpen, setHelpOpen] = useState(() => {
    try {
      return localStorage.getItem("first_run_help_dismissed") !== "1";
    } catch {
      return true;
    }
  });
  const [notesMode, setNotesMode] = useState<"devoirs" | "tableau" | "notation">("tableau");
  // Sélections propres à la vue NOTE (notation compétences)
  const [selectedNoteStudent, setSelectedNoteStudent] = useState<string | null>(null);
  const [selectedNoteEvalId, setSelectedNoteEvalId] = useState<string | null>(null);

  // Notation critériée : poids par exigence + niveau 1..4
  const [notationWeights, setNotationWeights] = useState<Record<string, number>>({});

  // Scores "généraux" du devoir (prévisualisation dans DEVOIR)
  const [notationScores, setNotationScores] = useState<Record<string, number>>({});

  // Scores par élève (onglet NOTE → Notation compétences)
  const [studentNotationScores, setStudentNotationScores] = useState<Record<string, number>>({});
  const getWeight = (key: string) => notationWeights[key] ?? 1;
  const [engagementLevel, setEngagementLevel] = useState<EngagementLevel | null>(null);

  // 🔁 Charger la notation d'un élève pour un devoir
const loadCurrentStudentNotation = React.useCallback(() => {
  if (!selectedClassIdForSuivi) return;
  if (!selectedNoteEvalId) return;

  if (!selectedNoteStudent) {
    // pas d'élève sélectionné → on vide uniquement la grille élève
    setStudentNotationScores({});
    setEngagementLevel(null);
    return;
  }

  const schoolYear = getCurrentSchoolYear();
  const className = selectedClassIdForSuivi;
  const studentName = selectedNoteStudent;

  const yearBucket = notationDB[schoolYear] || {};
  const classBucket = yearBucket[className] || {};
  const evalBucket = classBucket[selectedNoteEvalId] || {};
  const entry = (evalBucket as Record<string, NotationEntry>)[studentName];

  if (entry && entry.scoresByCriteria) {
    setStudentNotationScores(entry.scoresByCriteria);
    setEngagementLevel(entry.engagementLevel ?? "normal");
  } else {
    setStudentNotationScores({});
    setEngagementLevel("normal");
  }
}, [
  notationDB,
  selectedClassIdForSuivi,
  selectedNoteEvalId,
  selectedNoteStudent,
]);

useEffect(() => {
  if (activeView !== "notes") return;
  // Dès qu'on est dans NOTE (tableau ou notation), on recharge l'élève courant
  loadCurrentStudentNotation();
}, [
  activeView,
  notesMode,
  selectedClassIdForSuivi,
  selectedNoteEvalId,
  selectedNoteStudent,
  loadCurrentStudentNotation,
]);

const saveCurrentStudentNotation = React.useCallback(() => {
  if (!selectedClassIdForSuivi) {
    alert("Aucune classe sélectionnée.");
    return;
  }
  if (!selectedNoteEvalId) {
    alert("Aucun devoir sélectionné.");
    return;
  }
  if (!selectedNoteStudent) {
    alert("Aucun élève sélectionné.");
    return;
  }

  // 🔒 Si l'élève est marqué AB ou N.NOT, on bloque l'enregistrement
  try {
    const schoolYearCheck = getCurrentSchoolYear();
    const classNameCheck = selectedClassIdForSuivi;
    const studentNameCheck = selectedNoteStudent;

    const existing =
      (((notationDBRef.current || {})[schoolYearCheck] || {})[classNameCheck] || {})[
        selectedNoteEvalId
      ]?.[studentNameCheck] as NotationEntry | undefined;

    const st = existing?.status;
    if (st === "AB" || st === "N.NOT") {
      alert(st === "AB" ? "Cet élève est marqué AB : notation figée." : "Cet élève est marqué N.NOT : notation figée.");
      return;
    }
  } catch {}

  const evalMeta = evalMetaList.find((ev) => ev.id === selectedNoteEvalId);
  if (!evalMeta) {
    alert("Devoir introuvable.");
    return;
  }

  // 1) Vérifier que tous les critères sont notés
  const rows = buildPreviewRows();
  if (!rows || rows.length === 0) {
    alert(
      "Aucun critère n'est défini pour ce devoir.\n" +
        "Vérifie l'onglet COMPÉTENCES / EXIGENCES."
    );
    return;
  }

  const allCritKeys = rows.flatMap((row) =>
    row.criteres.map((_c, idx) => {
      return `${row.task}||${row.comp}::${row.item}::crit#${idx}`;
    })
  );

const missingKeys = allCritKeys.filter((key) => {
  const s = studentNotationScores[key];
  return typeof s !== "number";
});

  if (missingKeys.length > 0) {
    alert(
      "Tous les critères doivent être notés avant d'enregistrer.\n" +
        "Certains critères n'ont pas encore de niveau."
    );
    return;
  }

  // 2) Calcul de la note sur 20 avec engagement
  let totalWeighted = 0;
  let totalWeightForMark = 0;

allCritKeys.forEach((key) => {
    const score = studentNotationScores[key];
    // NR (=0) ou non noté → n’impacte pas la note sur 20
    if (typeof score !== "number" || !isFinite(score) || score <= 0) return;
    const weight = notationWeights[key] ?? 1;
    totalWeighted += score * weight;
    totalWeightForMark += weight;
  });

  if (totalWeightForMark <= 0) {
    alert("Aucun poids saisi pour les critères.");
    return;
  }

  const baseAvgOn4 = totalWeighted / totalWeightForMark;
  const baseOn20 = (baseAvgOn4 / 4) * 20;

  const factor =
    engagementLevel && ENGAGEMENT_FACTORS[engagementLevel]
      ? ENGAGEMENT_FACTORS[engagementLevel]
      : 1;

  const markOn20 = Math.max(0, Math.min(20, baseOn20 * factor));

  // 3) Sauvegarde dans notation_db
  const schoolYear = getCurrentSchoolYear();
  const className = selectedClassIdForSuivi;
  const studentName = selectedNoteStudent;

  const entry: NotationEntry = {
    markOn20,
    totalWeightForStudent: totalWeightForMark,
    semester: evalMeta.semester,
    evalId: evalMeta.id,
    evalName: evalMeta.name,
    className,
    studentName,
    savedAt: new Date().toISOString(),
    scoresByCriteria: { ...studentNotationScores },
    engagementLevel: engagementLevel ?? undefined,
    status: "OK",
  };

// ✅ Calculer un "next" immuable + sauvegarde immédiate (évite les pertes si un chargement est en cours)
const nextNotationDB: NotationDB = (() => {
  const prev = notationDBRef.current || {};
  const next: NotationDB = { ...prev };
  const yearBucket = { ...(next[schoolYear] || {}) };
  const classBucket = { ...(yearBucket[className] || {}) };

  // ✅ On conserve les notations précédentes : un même devoir peut être utilisé plusieurs fois (sessions distinctes par evalId)
// Ensuite on écrit la nouvelle entrée pour CE evalId
  const evalBucket = { ...(classBucket[evalMeta.id] || {}) };
  evalBucket[studentName] = entry;
  classBucket[evalMeta.id] = evalBucket;
  yearBucket[className] = classBucket;
  next[schoolYear] = yearBucket;
  return next;
})();

notationDirtyRef.current = true;
notationDBRef.current = nextNotationDB;
setNotationDB(nextNotationDB);
// Sauvegarde immédiate dans le fichier (et localStorage) de l'année courante
saveNotationToStore(nextNotationDB, trainingYear);

// 🟢 Pousser aussi les niveaux de compétences vers skillsDB
const classIdForSkills = evalMeta.group || className;
const semesterForSkills = evalMeta.semester as SemesterKey;

if (classIdForSkills) {
  pushCurrentDevoirToSuivi(
    classIdForSkills,
    studentName,
    semesterForSkills,
    evalMeta.id,
    studentNotationScores          // 🔥 scores réels de l’élève
  );
}

  alert(
    `Notation enregistrée pour ${studentName} – ${evalMeta.name} : ${markOn20.toFixed(
      2
    )}/20`
  );
}, [
  selectedClassIdForSuivi,
  selectedNoteEvalId,
  selectedNoteStudent,
  evalMetaList,
  notationWeights,
  studentNotationScores,
  notationScores,
  engagementLevel,
  setNotationDB,
]);

// 🟦 Marquer un élève ABSENT (AB) pour le devoir sélectionné (Notation compétences)
const toggleCurrentStudentAbsent = React.useCallback(async () => {
  if (!selectedClassIdForSuivi) {
    alert("Aucune classe sélectionnée.");
    return;
  }
  if (!selectedNoteEvalId) {
    alert("Aucun devoir sélectionné.");
    return;
  }
  if (!selectedNoteStudent) {
    alert("Aucun élève sélectionné.");
    return;
  }

  const evalMeta = evalMetaList.find((ev) => ev.id === selectedNoteEvalId);
  if (!evalMeta) {
    alert("Devoir introuvable.");
    return;
  }

  const schoolYear = getCurrentSchoolYear();
  const className = selectedClassIdForSuivi;
  const studentName = selectedNoteStudent;

  const current =
    (((notationDB[schoolYear] || {})[className] || {})[selectedNoteEvalId] || {})[
      studentName
    ] as NotationEntry | undefined;

  const isCurrentlyAbsent = current?.status === "AB";

  if (isCurrentlyAbsent) {
    const ok = isTauriRuntime()
      ? await confirm("Retirer le statut AB (absent) pour cet élève sur ce devoir ?", {
          title: "Retirer AB",
          kind: "warning",
        })
      : window.confirm("Retirer le statut AB (absent) pour cet élève sur ce devoir ?");

    if (!ok) return;
  }

  const next: NotationDB = { ...notationDB };
  next[schoolYear] = { ...(next[schoolYear] || {}) };
  next[schoolYear][className] = { ...(next[schoolYear][className] || {}) };
  next[schoolYear][className][selectedNoteEvalId] = {
    ...(next[schoolYear][className][selectedNoteEvalId] || {}),
  };

  if (!isCurrentlyAbsent) {
    // On force une entrée "AB" (affichage + gel)
    next[schoolYear][className][selectedNoteEvalId][studentName] = {
      markOn20: 0,
      totalWeightForStudent: 0,
      semester: evalMeta.semester,
      evalId: evalMeta.id,
      evalName: evalMeta.name,
      className,
      studentName,
      savedAt: new Date().toISOString(),
      scoresByCriteria: {},
      engagementLevel: undefined,
      status: "AB",
    };

    // On fige l'UI côté élève
    setStudentNotationScores({});
    setEngagementLevel(null);
  } else {
    // On retire le statut AB (on conserve l'entrée si elle existait, sinon on supprime)
    if (current) {
      next[schoolYear][className][selectedNoteEvalId][studentName] = {
        ...current,
        status: "OK",
        savedAt: new Date().toISOString(),
      };
    }
  }

  setNotationDB(next);
  await saveNotationToStore(next, trainingYear);
}, [
  notationDB,
  evalMetaList,
  selectedClassIdForSuivi,
  selectedNoteEvalId,
  selectedNoteStudent,
  trainingYear,
]);

// 🟨 Marquer un élève NON NOTÉ (N.NOT) pour le devoir sélectionné (Notation compétences)
const toggleCurrentStudentNonNoted = React.useCallback(async () => {
  if (!selectedClassIdForSuivi) {
    alert("Aucune classe sélectionnée.");
    return;
  }
  if (!selectedNoteEvalId) {
    alert("Aucun devoir sélectionné.");
    return;
  }
  if (!selectedNoteStudent) {
    alert("Aucun élève sélectionné.");
    return;
  }

  const evalMeta = evalMetaList.find((ev) => ev.id === selectedNoteEvalId);
  if (!evalMeta) {
    alert("Devoir introuvable.");
    return;
  }

  const schoolYear = getCurrentSchoolYear();
  const className = selectedClassIdForSuivi;
  const studentName = selectedNoteStudent;

  const prev = notationDB || {};
  const next: NotationDB = { ...prev };

  next[schoolYear] = { ...(next[schoolYear] || {}) };
  next[schoolYear][className] = { ...(next[schoolYear][className] || {}) };
  next[schoolYear][className][selectedNoteEvalId] = {
    ...(next[schoolYear][className][selectedNoteEvalId] || {}),
  };

  const current = (next[schoolYear][className][selectedNoteEvalId][studentName] ||
    undefined) as NotationEntry | undefined;

  const currentStatus = current?.status || "OK";

  if (currentStatus !== "N.NOT") {
    // On met N.NOT (et on écrase AB si besoin)
    next[schoolYear][className][selectedNoteEvalId][studentName] = {
      markOn20: 0,
      totalWeightForStudent: 0,
      semester: evalMeta.semester,
      evalId: evalMeta.id,
      evalName: evalMeta.name,
      className,
      studentName,
      savedAt: new Date().toISOString(),
      scoresByCriteria: {},
      engagementLevel: undefined,
      status: "N.NOT",
    };

    // On fige l'UI côté élève
    setStudentNotationScores({});
    setEngagementLevel(null);
  } else {
    // On retire N.NOT
    if (current) {
      next[schoolYear][className][selectedNoteEvalId][studentName] = {
        ...current,
        status: "OK",
        savedAt: new Date().toISOString(),
      };
    }
  }

  setNotationDB(next);
  await saveNotationToStore(next, trainingYear);
}, [
  notationDB,
  evalMetaList,
  selectedClassIdForSuivi,
  selectedNoteEvalId,
  selectedNoteStudent,
  trainingYear,
]);


const suiviElevePdfRef = React.useRef<HTMLDivElement | null>(null);
const suiviClassePdfRef = React.useRef<HTMLDivElement | null>(null);
const suiviEvolutionsPdfRef = React.useRef<HTMLDivElement | null>(null);
const suiviBilanPdfRef = React.useRef<HTMLDivElement | null>(null);
const suiviAbsencesPdfRef = React.useRef<HTMLDivElement | null>(null);
const notesTablePdfRef = React.useRef<HTMLDivElement | null>(null);

const exportCurrentStudentNotationToPdf = (opts?: PreviewTargetOptions) => {
  if (!selectedClassIdForSuivi) {
    alert("Aucune classe sélectionnée.");
    return;
  }
  if (!selectedNoteEvalId) {
    alert("Aucun devoir sélectionné.");
    return;
  }

  const evalMeta = evalMetaList.find((ev) => ev.id === selectedNoteEvalId);
  if (!evalMeta) {
    alert("Devoir introuvable.");
    return;
  }

  const classe = classGroups.find((c) => c.name === selectedClassIdForSuivi);
  const students = (classe?.students || "")
    .split("\n")
    .map((s) => s.trim())
    .filter(Boolean);

  if (!students.length) {
    alert("Aucun élève défini pour cette classe.");
    return;
  }

  const schoolYear = getCurrentSchoolYear();
  const yearBucket = notationDB[schoolYear] || {};
  const classBucket = yearBucket[selectedClassIdForSuivi] || {};
  const evalBucket = (classBucket[evalMeta.id] || {}) as Record<
    string,
    NotationEntry
  >;

  const rows = buildPreviewRows();
  if (!rows || rows.length === 0) {
    alert(
      "Aucun critère n'est défini pour ce devoir.\n" +
        "Vérifie l'onglet COMPÉTENCES / EXIGENCES."
    );
    return;
  }

  const escapeHtml = (raw: string | null | undefined): string => {
    if (!raw) return "";
    return String(raw)
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;");
  };

  // Critères du devoir (identiques pour tous les élèves)
  const critLines = rows.flatMap((row) =>
    row.criteres.map((critereText, idx) => {
      const key = `${row.task}||${row.comp}::${row.item}::crit#${idx}`;
      return {
        key,
        task: row.task,
        comp: row.comp,
        item: row.item,
        critere: critereText,
        exigences: row.exigences as string[] | undefined,
      };
    })
  );

  if (critLines.length === 0) {
    alert("Aucun critère sélectionné.");
    return;
  }

  // ⚖️ Poids : même logique que dans la vue NOTATION → défaut = 1
  const getWeight = (key: string) => notationWeights[key] ?? 1;

  // Regroupement par tâche
  const groupedByTask = critLines.reduce<
    Record<string, (typeof critLines)[number][]>
  >((acc, r) => {
    const label = r.task || "Sans tâche";
    if (!acc[label]) acc[label] = [];
    acc[label].push(r);
    return acc;
  }, {});

  const totalWeight = critLines.reduce(
    (sum, r) => sum + getWeight(r.key),
    0
  );

  const renderScoreScale = (s: number | null) => {
    const levels = [0, 1, 2, 3, 4];
    const effective = s === null || Number.isNaN(s) ? 0 : s;

    const levelStyle = (level: number) => {
      switch (level) {
        case 0:
          return { bg: "#111827", border: "#111827", color: "#f9fafb" };
        case 1:
          return { bg: "#ef4444", border: "#b91c1c", color: "#ffffff" };
        case 2:
          return { bg: "#fb923c", border: "#ea580c", color: "#111827" };
        case 3:
          return { bg: "#6ee7b7", border: "#10b981", color: "#064e3b" };
        case 4:
          return { bg: "#059669", border: "#047857", color: "#ffffff" };
        default:
          return { bg: "#e5e7eb", border: "#d1d5db", color: "#111827" };
      }
    };

    const parts = levels.map((level) => {
      const isActive = effective === level;
      const label = level === 0 ? "NR" : String(level);
      const base = levelStyle(level);

      const bg = isActive ? base.bg : "#f9fafb";
      const border = base.border;
      const color = isActive ? base.color : "#374151";

      return `
        <span style="
          display:inline-flex;
          align-items:center;
          justify-content:center;
          min-width:20px;
          padding:2px 5px;
          border-radius:9999px;
          border:1px solid ${border};
          background:${bg};
          color:${color};
          font-size:10px;
          font-weight:${isActive ? "700" : "500"};
        ">
          ${label}
        </span>
      `;
    });

    return `
      <div style="display:flex;gap:4px;justify-content:center;">
        ${parts.join("")}
      </div>
    `;
  };

  const formatEngagementLabel = (
    level: EngagementLevel | null | undefined
  ) => {
    if (level === "volontaire") return "Très engagé";
    if (level === "engage") return "Engagé";
    if (level === "normal") return "Engagement normal";
    if (level === "attente") return "En attente";
    if (level === "absence") return "Absence d'intérêt";
    return "Non renseigné";
  };

const renderEngagementScale = (
  level: EngagementLevel | null | undefined
) => {
  const options = [
    {
      key: "absence",
      label: "Peu engagé",
      activeBg: "#ef4444",     // rouge (border-red-500)
      activeColor: "#ffffff",
      border: "#ef4444",
      inactiveText: "#b91c1c", // text-red-700
    },
    {
      key: "attente",
      label: "En attente",
      activeBg: "#facc15",     // jaune (border-yellow-400)
      activeColor: "#111827",  // text-neutral-900 dark:text-neutral-300
      border: "#facc15",
      inactiveText: "#a16207", // text-yellow-700
    },
    {
      key: "normal",
      label: "Normal",
      activeBg: "#38bdf8",     // bleu ciel (border-sky-400)
      activeColor: "#111827",  // text-neutral-900 dark:text-neutral-300
      border: "#38bdf8",
      inactiveText: "#0369a1", // text-sky-700
    },
    {
      key: "engage",
      label: "Engagé",
      activeBg: "#22c55e",     // vert (border-green-500)
      activeColor: "#ffffff",
      border: "#22c55e",
      inactiveText: "#15803d", // text-green-700
    },
    {
      key: "volontaire",
      label: "Très engagé",
      activeBg: "#059669",     // émeraude (border-emerald-600)
      activeColor: "#ffffff",
      border: "#059669",
      inactiveText: "#047857", // text-emerald-700
    },
  ] as const;

  const pills = options
    .map((opt) => {
      const isActive = level === opt.key;
      const bg = isActive ? opt.activeBg : "#f9fafb";
      const border = isActive ? opt.border : "#e5e7eb";
      const color = isActive ? opt.activeColor : opt.inactiveText;
      const fontWeight = isActive ? "700" : "500";

      return `
        <span style="
          display:inline-flex;
          align-items:center;
          justify-content:center;
          padding:2px 8px;
          border-radius:9999px;
          border:1px solid ${border};
          background:${bg};
          color:${color};
          font-size:10px;
          font-weight:${fontWeight};
        ">
          ${opt.label}
        </span>
      `;
    })
    .join("");

  return `
    <div style="margin-top:4px;display:flex;flex-wrap:wrap;gap:4px;">
      ${pills}
    </div>
  `;
};
    // Photo du devoir
  const logoHtml = logoDataUrl
    ? `<img src="${logoDataUrl}" style="
          width:4.5cm;
          height:2.5cm;
          object-fit:contain;
          padding:4px;
        " />`
    : "";

  const today = new Date().toLocaleDateString("fr-FR");

  // 🔧 Génère les sections de tâches pour un élève donné
  const buildTaskSectionsHtmlForStudent = (
    scoresByCriteria: Record<string, number>
  ) => {
    const getScore = (key: string) => scoresByCriteria[key];

    return Object.entries(groupedByTask)
      .map(([taskLabel, items]) => {
        const taskWeight = items.reduce(
          (sum, r) => sum + getWeight(r.key),
          0
        );
        const taskPct =
          totalWeight > 0 ? (taskWeight / totalWeight) * 100 : 0;

        const tNum = taskNumber(taskLabel);
        const group = GROUPS.find(
          (g) => tNum >= g.range[0] && tNum <= g.range[1]
        );
        let accentColor = "#9ca3af";
        if (group?.key === "G1") accentColor = "#38bdf8";
        else if (group?.key === "G2") accentColor = "#fbbf24";
        else if (group?.key === "G3") accentColor = "#a855f7";

        type RowWithSpans = {
          row: (typeof items)[number];
          showCompCell: boolean;
          compRowSpan: number;
          showItemCell: boolean;
          itemRowSpan: number;
        };

        const rowsWithSpans: RowWithSpans[] = [];

        for (let i = 0; i < items.length; i++) {
          const current = items[i];

          // Fusion compétence
          let showCompCell = true;
          let compRowSpan = 1;

          if (i > 0 && items[i - 1].comp === current.comp) {
            showCompCell = false;
            compRowSpan = 0;
          } else {
            for (let j = i + 1; j < items.length; j++) {
              if (items[j].comp === current.comp) {
                compRowSpan++;
              } else {
                break;
              }
            }
          }

          // Fusion "être capable de"
          let showItemCell = true;
          let itemRowSpan = 1;

          if (
            i > 0 &&
            items[i - 1].comp === current.comp &&
            items[i - 1].item === current.item
          ) {
            showItemCell = false;
            itemRowSpan = 0;
          } else {
            for (let j = i + 1; j < items.length; j++) {
              if (
                items[j].comp === current.comp &&
                items[j].item === current.item
              ) {
                itemRowSpan++;
              } else {
                break;
              }
            }
          }

          rowsWithSpans.push({
            row: current,
            showCompCell,
            compRowSpan,
            showItemCell,
            itemRowSpan,
          });
        }

        const rowsHtml = rowsWithSpans
          .map(
            ({
              row,
              showCompCell,
              compRowSpan,
              showItemCell,
              itemRowSpan,
            }) => {
              const w = getWeight(row.key);
              const s = getScore(row.key);
              const sVal = typeof s === "number" ? s : null;

              const fam = parseCompetencyFamily(row.comp);
              let famLabel = "";
              if (fam === "C1") famLabel = "COMMUNIQUER";
              else if (fam === "C2") famLabel = "PRÉPARER";
              else if (fam === "C3") famLabel = "RÉALISER";
              else if (fam === "C4") famLabel = "CONTRÔLE";

              const exigencesHtml =
                row.exigences && row.exigences.length > 0
                  ? `<ul style="margin:0;padding-left:16px;">${row.exigences
                      .map((ex) => `<li>${escapeHtml(ex)}</li>`)
                      .join("")}</ul>`
                  : `<span style="color:#9ca3af;font-style:italic;font-size:11px;">Aucune exigence personnalisée</span>`;

              let compCellHtml = "";
              if (showCompCell) {
                compCellHtml = `
                  <td rowspan="${compRowSpan}" style="border:1px solid #e5e7eb;padding:4px 6px;vertical-align:middle;">
                    <div style="display:flex;flex-direction:column;gap:2px;">
                      <div style="display:flex;align-items:center;flex-wrap:wrap;gap:4px;">
                        ${
                          famLabel
                            ? `<span style="
                                display:inline-flex;
                                align-items:center;
                                gap:4px;
                                border-radius:9999px;
                                padding:2px 6px;
                                font-size:10px;
                                font-weight:600;
                                background:#e0f2fe;
                                color:#0369a1;
                              ">
                                <span style="width:6px;height:6px;border-radius:9999px;background:#0ea5e9;"></span>
                                ${famLabel}
                              </span>`
                            : ""
                        }
                        <span style="font-size:11px;font-weight:600;">${escapeHtml(
                          row.comp
                        )}</span>
                      </div>
                    </div>
                  </td>
                `;
              }

              let itemCellHtml = "";
              if (showItemCell) {
                itemCellHtml = `
                  <td rowspan="${itemRowSpan}" style="border:1px solid #e5e7eb;padding:4px 6px;vertical-align:middle;">
                    <div style="font-size:11px;color:#6b7280;">${escapeHtml(
                      row.item
                    )}</div>
                  </td>
                `;
              }

              return `
                <tr>
                  ${compCellHtml}
                  ${itemCellHtml}
                  <td style="border:1px solid #e5e7eb;padding:4px 6px;vertical-align:middle;">
                    ${escapeHtml(row.critere)}
                  </td>
                  <td style="border:1px solid #e5e7eb;padding:4px 6px;vertical-align:middle;">
                   ${exigencesHtml}
                  </td>
                  <td style="border:1px solid #e5e7eb;padding:4px 6px;text-align:center;vertical-align:middle;">
                    ${Number.isFinite(w) ? w.toFixed(1) : ""}
<td style="border:1px solid #e5e7eb;padding:4px 6px;text-align:center;vertical-align:middle;">
  ${renderScoreScale(sVal)}
</td>

                  </td>
                </tr>
              `;
            }
          )
          .join("");

        return `
          <section style="margin-top:18px;">
            <div style="
              border:1px solid #e5e7eb;
              border-left:4px solid ${accentColor};
              border-radius:16px;
              background:#ffffff;
              padding:12px 14px;
            ">
              <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:8px;">
                <div style="display:flex;align-items:center;gap:6px;">
                  <span style="display:inline-block;width:10px;height:10px;border-radius:4px;background:#111827;"></span>
                  <h2 style="margin:0;font-size:14px;font-weight:600;">${escapeHtml(
                    taskLabel
                  )}</h2>
                </div>
                <div style="font-size:11px;color:#6b7280;display:flex;align-items:center;gap:4px;">
                  <span>${items.length} critère(s)</span>
                  <span style="font-size:10px;color:#9ca3af;">•</span>
                  <span>Total poids % : ${taskWeight.toFixed(1)}</span>
                  ${
                    totalWeight > 0
                      ? `<span style="font-size:10px;font-weight:600;color:#111827;margin-left:4px;">
                          (${taskPct.toFixed(1)} % de la note finale)
                         </span>`
                      : ""
                  }
                </div>
              </div>
              <div style="overflow-x:auto;">
                <table style="width:100%;border-collapse:collapse;font-size:11px;">
                  <thead>
                    <tr style="background:#f9fafb;">
                      <th style="border:1px solid #e5e7eb;padding:4px 6px;text-align:left;width:20%;">Compétence</th>
                      <th style="border:1px solid #e5e7eb;padding:4px 6px;text-align:left;width:20%;">Être capable de…</th>
                      <th style="border:1px solid #e5e7eb;padding:4px 6px;text-align:left;width:32%;">Critère d'évaluation</th>
                      <th style="border:1px solid #e5e7eb;padding:4px 6px;text-align:left;width:14%;">Exigences</th>
                      <th style="border:1px solid #e5e7eb;padding:4px 6px;text-align:center;width:7%;">Poids (%)</th>
                      <th style="border:1px solid #e5e7eb;padding:4px 6px;text-align:center;width:7%;">Niveau</th>
                    </tr>
                  </thead>
                  <tbody>
                    ${rowsHtml}
                  </tbody>
                </table>
              </div>
            </div>
          </section>
        `;
      })
      .join("");
  };

  // 🔄 Une page par élève
  const studentPagesHtml = students
    .map((studentName, index) => {
      const entry = evalBucket[studentName];

      if (!entry || !entry.scoresByCriteria) {
        return `
          <div class="page">
            <h1>Notation critériée – ${escapeHtml(evalMeta.name)}</h1>
            <div class="meta">Élève : <strong>${escapeHtml(
              studentName
            )}</strong></div>
            <div class="meta">
              Classe : <strong>${escapeHtml(selectedClassIdForSuivi)}</strong>
              · Semestre : <strong>${escapeHtml(evalMeta.semester)}</strong>
            </div>
            <div class="meta">Date d'édition : ${today}</div>
            <div style="margin-top:16px;font-size:12px;color:#6b7280;">
              Aucune notation enregistrée pour cet élève sur ce devoir.
            </div>
          </div>
          ${
            index < students.length - 1
              ? '<div style="page-break-after:always;"></div>'
              : ""
          }
        `;
      }

      const scores = entry.scoresByCriteria || {};

      // Note /20 : on prend markOn20 s'il existe, sinon on recalcule
      let markOn20 = entry.markOn20;
      if (typeof markOn20 !== "number") {
        let totalWeightForMark = 0;
        let weightedAchieved = 0;
        critLines.forEach((r) => {
          const w = getWeight(r.key);
          const s = scores[r.key];
          if (typeof s !== "number") return;
          totalWeightForMark += w;
          weightedAchieved += w * (s / 4);
        });
        const baseMarkOn20 =
          totalWeightForMark > 0
            ? (weightedAchieved / totalWeightForMark) * 20
            : 0;
        const factor = computeEngagementFactor(entry.engagementLevel);
        markOn20 = Math.max(0, Math.min(20, baseMarkOn20 * factor));
      }

      const engagementLabel = formatEngagementLabel(entry.engagementLevel);
      const taskSectionsHtmlForStudent =
        buildTaskSectionsHtmlForStudent(scores);

      return `
        <div class="page">
          <div style="
            display:flex;
            justify-content:space-between;
            align-items:flex-start;
            gap:16px;
            margin-bottom:12px;
          ">
            <div>
              <h1>ÉVALUATION - ${escapeHtml(evalMeta.name)}</h1>
              <div class="meta">
                Élève : <strong>${escapeHtml(studentName)}</strong>
              </div>
              <div class="meta">
                Classe : <strong>${escapeHtml(selectedClassIdForSuivi)}</strong>
                · Semestre : <strong>${escapeHtml(evalMeta.semester)}</strong>
              </div>
  <div
    style="
      margin-top:8px;
      font-size:12px;
      color:#4b5563;
      display:flex;
      align-items:center;
      gap:8px;
      flex-wrap:wrap;
    "
  >
    <span style="font-weight:600;">ENGAGEMENT&nbsp;:</span>
    ${renderEngagementScale(entry.engagementLevel)}
  </div>
</div>
            <div style="flex-shrink:0;display:flex;align-items:flex-start;gap:8px;">
              <div class="card">
                <div class="card-title">Note finale</div>
                <div class="card-value">${entry.status === "AB" ? "AB" : markOn20.toFixed(2) + " / 20"}</div>
              </div>
              ${logoHtml ? `<div>${logoHtml}</div>` : ""}
            </div>
          </div>

          ${taskSectionsHtmlForStudent}
        </div>
        ${
          index < students.length - 1
            ? '<div style="page-break-after:always;"></div>'
            : ""
        }
      `;
    })
    .join("");

  const html = `
<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>Notation – ${escapeHtml(evalMeta.name)} – ${escapeHtml(
    selectedClassIdForSuivi
  )}</title>
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #f3f4f6;
    }
    .page {
      max-width: 1100px;
      margin: 16px auto;
      background: #ffffff;
      padding: 20px 24px;
      color: #111827;
      font-size: 13px;
    }
    h1 {
      font-size: 20px;
      margin: 0 0 4px 0;
    }
    .meta {
      font-size: 12px;
      color: #4b5563;
      margin-bottom: 2px;
    }
    .card {
      border-radius: 10px;
      border: 1px solid #e5e7eb;
      padding: 8px 10px;
      background: #f9fafb;
    }
    .card-title {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: #6b7280;
      margin-bottom: 2px;
    }
    .card-value {
      font-size: 18px;
      font-weight: 700;
    }
    @page {
      size: A4 landscape;
      margin: 10mm 12mm;
    }
  </style>
</head>
<body>
  ${studentPagesHtml}
</body>
</html>
`;

  pushPreview(html, opts);
};
const exportSuiviElevesToPdf = async () => {
  if (!selectedClassIdForSuivi) {
    alert("Sélectionne une classe avant d'exporter.");
    return;
  }

  const classe = classGroups.find((c) => c.name === selectedClassIdForSuivi);
  if (!classe) return;

  const students = (classe.students || "")
    .split("\n")
    .map((s) => s.trim())
    .filter(Boolean);

  if (students.length === 0) {
    alert("Aucun élève n'est renseigné pour cette classe.");
    return;
  }

  // On force la Vue élève pour être sûr d'avoir le bon rendu
  const prevMode = suiviMode;
  const prevStudent = selectedStudentForSuivi;

  if (suiviMode !== "eleve") setSuiviMode("eleve");

  // Récupère les styles existants (Tailwind etc.)
  const styleTags = Array.from(
    document.querySelectorAll('link[rel="stylesheet"], style')
  )
    .map((n) => (n as HTMLElement).outerHTML)
    .join("\n");

  const esc = (s: string) =>
    s
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&#039;");

  const pages: string[] = [];

  // petite utilitaire pour attendre que React ait rendu
  const nextPaint = () =>
    new Promise<void>((resolve) => requestAnimationFrame(() => resolve()));

  for (const st of students) {
    setSelectedStudentForSuivi(st);

    // 2 frames : 1 pour le state, 1 pour le DOM/layout
    await nextPaint();
    await nextPaint();

    const wrap = suiviElevePdfRef.current;
    if (!wrap) continue;

    pages.push(`
      <div class="pdf-page">
        ${buildPrintHeaderHtml(esc, {
          viewTitle: "Synthèse des compétences",
          studentName: st,
          classId: selectedClassIdForSuivi,
          trainingYear,
          schoolYear: getCurrentSchoolYear(),
        })}
        ${wrap.outerHTML}
      </div>
    `);
}

  // restore
  if (prevMode !== suiviMode) setSuiviMode(prevMode);
  setSelectedStudentForSuivi(prevStudent ?? "");

  const html = `<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>${esc(`Synthèse des compétences — ${selectedClassIdForSuivi}`)}</title>
  ${styleTags}
  <style>
    @page { size: A4 landscape; margin: 8mm; }
    body { margin: 0; -webkit-print-color-adjust: exact; print-color-adjust: exact; }
    .pdf-page { page-break-after: always; padding: 12px; }
    .pdf-page:last-child { page-break-after: auto; }

    .pdf-title {
      font-family: system-ui;
      font-size: 14px;
      font-weight: 700;
      margin: 0 0 10px 0;
    }

    /* éviter les sticky / scroll en export */
    .sticky { position: static !important; }
    .overflow-x-auto { overflow: visible !important; }

    /* optionnel : masquer les éléments marqués no-print si tu en as */
    .no-print { display: none !important; }
  </style>
</head>
<body>
  ${pages.join("\n")}
</body>
</html>`;

  setPreviewHtml(html);
  setPreviewOpen(true);
};
const exportSuiviClasseToPdf = (opts?: PreviewTargetOptions) => {
  const wrap = suiviClassePdfRef.current;
  if (!wrap) {
    alert("Bloc suivi classe introuvable (ref null). Vérifie le ref sur le conteneur.");
    return;
  }

  const classId = selectedClassIdForSuivi;
  if (!classId) {
    alert("Sélectionne une classe avant d'exporter.");
    return;
  }

  const styleTags = Array.from(
    document.querySelectorAll('link[rel="stylesheet"], style')
  )
    .map((n) => (n as HTMLElement).outerHTML)
    .join("\n");

  const esc = (s: string) =>
    s
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&#039;");

  const title = `Suivi de la classe — ${classId} — ${trainingYearLabel(trainingYear)}`;

  const html = `<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>${esc(title)}</title>
  ${styleTags}
  <style>
    @page { size: A4 landscape; margin: 8mm; }
    body { margin: 0; -webkit-print-color-adjust: exact; print-color-adjust: exact; }

    .sticky { position: static !important; }
    .overflow-x-auto { overflow: visible !important; }
    .no-print { display: none !important; }

    #page { width: calc(297mm - 16mm); margin: 0; }
    #pdfRoot { transform-origin: top left; transform: scale(var(--pdfScale, 1)); width: max-content; }

    .absences-print-root table { border-collapse: collapse; }
    .absences-print-root th, .absences-print-root td { padding: 2px 3px !important; }
  </style>
</head>
<body>
  <div style="padding:12px">
${buildPrintHeaderHtml(esc, {
viewTitle: "Suivi de la classe",
classId,
trainingYear,
schoolYear: getCurrentSchoolYear(),
})}

    <div id="page">
      <div id="pdfRoot">
        ${wrap.innerHTML}
      </div>
    </div>
  </div>

  <script>
    function fitToA4Width() {
      const page = document.getElementById('page');
      const root = document.getElementById('pdfRoot');
      const table = root ? root.querySelector('table') : null;
      if (!page || !root || !table) return;

      root.style.setProperty('--pdfScale', 1);

      const available = page.getBoundingClientRect().width;
      const needed = table.scrollWidth || table.getBoundingClientRect().width;
      if (!available || !needed) return;

      const scale = Math.min(1, available / needed);
      root.style.setProperty('--pdfScale', scale.toFixed(4));
    }

    window.addEventListener('load', fitToA4Width);
    window.addEventListener('beforeprint', fitToA4Width);
  </script>
</body>
</html>`;

  pushPreview(html, opts);
};

const openSuiviEleveToPreview = (opts?: PreviewTargetOptions) => {
  const wrap = suiviElevePdfRef.current;
  if (!wrap) {
    alert("Bloc suivi élève introuvable (ref null).");
    return;
  }

  if (!selectedClassIdForSuivi || !selectedStudentForSuivi) {
    alert("Sélectionne une classe et un élève avant d'imprimer.");
    return;
  }

  const styleTags = Array.from(
    document.querySelectorAll('link[rel="stylesheet"], style')
  )
    .map((n) => (n as HTMLElement).outerHTML)
    .join("\n");

  const esc = (s: string) =>
    (s || "")
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&#039;");

  const title = `Synthèse des compétences — Suivi de ${selectedStudentForSuivi} — ${selectedClassIdForSuivi} — ${trainingYearLabel(trainingYear)}`;

  const html = `<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>${esc(title)}</title>
  ${styleTags}
  <style>
    @page { size: A4 landscape; margin: 10mm; }
    body { margin: 0; -webkit-print-color-adjust: exact; print-color-adjust: exact; }
    .sticky { position: static !important; }
    .overflow-x-auto { overflow: visible !important; }
    .no-print { display: none !important; }
  </style>
</head>
<body>
  <div style="padding:12px">
${buildPrintHeaderHtml(esc, {
viewTitle: "Synthèse des compétences",
studentName: selectedStudentForSuivi,
classId: selectedClassIdForSuivi,
trainingYear,
schoolYear: getCurrentSchoolYear(),
})}
    ${wrap.outerHTML}
  </div>
</body>
</html>`;

  pushPreview(html, opts);
};

// Impression – helpers communs pour les vues Suivi
const PRINT_BASE_CSS = `
  body { margin: 0; -webkit-print-color-adjust: exact; print-color-adjust: exact; }
  .sticky { position: static !important; }
  /* En impression, on "déroule" les conteneurs scrollables, mais on évite d'ouvrir les conteneurs en overflow-hidden
     (sinon certains graphiques débordent et recouvrent les blocs adjacents). */
  .overflow-x-auto, .overflow-y-auto, .overflow-auto { overflow: visible !important; }
  .no-print { display: none !important; }
  .print-only { display: block !important; }
  .hidden.print-only { display: block !important; }
  button { display: none !important; }

  /* Impression BILAN : pas d'en-tête "app" + pas de padding, pour coller au PDF */
  body.print-bilan .print-header { display: none !important; }
  body.print-bilan .print-root { padding: 0 !important; }

  /* ==============================
     Livret périodique (style PDF)
     ============================== */
  .bilan-livret { font-family: Arial, Helvetica, sans-serif !important; color: #000 !important; }
  .bilan-livret * { box-sizing: border-box; }

  /* Marges internes (haut/bas/côtés) pour un rendu plus aéré, comme le PDF de référence */
  .bilan-livret .lp-page {
    width: 400mm;
    height: 277mm;
    margin: 0 auto;
    padding: 12mm 12mm 12mm 12mm;
  }
  .bilan-livret .lp-grid { display: grid; grid-template-columns: 1fr 1fr; column-gap: 10mm; height: 100%; }
  .bilan-livret .lp-col { min-width: 0; }

  /* Titre / en-tête (page 1 droite) */
  .bilan-livret .lp-rightTitle { text-align: center; font-size: 12px; font-weight: 700; }
  .bilan-livret .lp-sem { text-align: center; font-size: 12px; margin-top: 6px; letter-spacing: .6px; font-weight: 700; }
  .bilan-livret .lp-nameBox { border: 1px solid #000; margin-top: 6px; padding: 4px 0; text-align: center; font-size: 18px; font-weight: 700; }
  .bilan-livret .lp-centerInfo { text-align: center; font-size: 10px; margin-top: 10px; line-height: 1.35; }
  .bilan-livret .lp-etabRow { text-align: center; }
  .bilan-livret .lp-etabLabel { font-weight: 400; text-transform: none; }
  .bilan-livret .lp-etabName { font-weight: 700; text-transform: uppercase; }
  .bilan-livret .lp-etabLine { text-transform: none; }

  /* Synthèse (cadre "graph") */
  .bilan-livret .lp-chartFrame { margin-top: 16px; border: 1px solid #d0d0d0; padding: 6px; border-radius: 0; }

  /*
    Histogramme (livret) : on sépare la zone de tracé (bandes + barres) et la zone des libellés,
    pour éviter les écarts de hauteur entre la page écran et l'aperçu / impression.
  */
  .bilan-livret .lp-chart { position: relative; height: 70mm; overflow: hidden; }
  .bilan-livret .lp-plot { position: absolute; left: 4mm; right: 4mm; top: 4mm; bottom: 10mm; overflow: hidden; }

  .bilan-livret .lp-band { position: absolute; left: 0; right: 0; }
  .bilan-livret .lp-band.top { top: 0; height: 50%; background: #E7F6EC; }
  .bilan-livret .lp-band.mid { top: 50%; height: 25%; background: #E1F2FA; }
  .bilan-livret .lp-band.bot { top: 75%; height: 25%; background: #FDE7D8; }
  .bilan-livret .lp-midLine { position: absolute; left: 0; right: 0; top: 50%; border-top: 1px solid rgba(0,0,0,.35); }

  .bilan-livret .lp-bars { position: relative; z-index: 2; height: 100%; display: flex; align-items: flex-end; justify-content: space-between; gap: 0; }
  .bilan-livret .lp-barWrap { flex: 1; min-width: 0; height: 100%; display: flex; flex-direction: column; justify-content: flex-end; align-items: center; }
  .bilan-livret .lp-bar { width: 3mm; background: #16a34a; }
  .bilan-livret .lp-bar.gray { background: #6b7280; }
  .bilan-livret .lp-barPair { display: flex; align-items: flex-end; justify-content: center; gap: 1mm; height: 100%; }

  .bilan-livret .lp-labels { position: absolute; left: 4mm; right: 4mm; bottom: 0; height: 10mm; display: flex; align-items: flex-start; justify-content: space-between; }
  .bilan-livret .lp-labelWrap { flex: 1; min-width: 0; display: flex; justify-content: center; }
  .bilan-livret .lp-xlbl { font-size: 7px; line-height: 1; transform: rotate(-40deg); transform-origin: top left; white-space: nowrap; opacity: .85; }

  /* Intérêt pour la pratique professionnelle */
  .bilan-livret .lp-motivTitle { margin-top: 8px; font-size: 11px; font-weight: 700; }
  /* Hauteur maîtrisée pour rester proche du gabarit PDF (sans étirer la colonne droite) */
  .bilan-livret .lp-motivBox {
    border: 2px solid #000;
    padding: 4px 6px;
    text-align: center;
    font-size: 14px;
    font-weight: 800;
    letter-spacing: .4px;
    background: #fff;
    min-height: 12mm;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  .bilan-livret .lp-motivBox.good { border-color: #16a34a; }
  .bilan-livret .lp-motivBox.mid { border-color: #f59e0b; }
  .bilan-livret .lp-motivBox.bad { border-color: #ef4444; }

  /* Absences (boîte + feu tricolore) */
  .bilan-livret .lp-absBox {
    margin-top: 16px;
    border: 1px solid #000;
    display: grid;
    grid-template-columns: 28px 1fr;
    /* évite que le 3ème point soit rogné quand le texte est vide */
    min-height: 16mm;
    align-items: stretch;
  }
  .bilan-livret .lp-traffic {
    border-right: 1px solid #000;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 3px;
    padding: 2mm 0;
    background: #f3f3f3;
  }
  .bilan-livret .lp-trafficDot { width: 10px; height: 10px; border-radius: 50%; border: 1px solid #000; background: #bdbdbd; }
  .bilan-livret .lp-trafficDot.green { background: #00ff00; }
  .bilan-livret .lp-trafficDot.yellow { background: #ffff00; }
  .bilan-livret .lp-trafficDot.red { background: #ff0000; }
  .bilan-livret .lp-absText { padding: 3mm 3mm; font-size: 10px; display: flex; align-items: center; }

  /* Appréciation */
  .bilan-livret .lp-appTitle { margin-top: 12px; font-size: 11px; font-weight: 700; }
  .bilan-livret .lp-appBox {
    border: 1px solid #000;
    padding: 3mm;
    /* hauteur mini proche du PDF de référence, même si le texte est vide */
    min-height: 28mm;
    font-size: 10px;
    line-height: 1.25;
    white-space: pre-wrap;
  }

  /* Signatures */
  .bilan-livret .lp-signTable { margin-top: 12px; width: 100%; border-collapse: collapse; font-size: 10px; }
  .bilan-livret .lp-signTable th,
  .bilan-livret .lp-signTable td { border: 1px solid #000; padding: 8px; }
  .bilan-livret .lp-signTable th { font-weight: 700; background: #fff; }
  /* Zone signature plus haute, sans dépendre du DPI */
  .bilan-livret .lp-signBlank { height: 25mm; }

  /* Titres gris (page 2) */
  .bilan-livret .lp-grayTitle { background: #e6e6e6; border: 1px solid #000; padding: 4px 6px; font-weight: 700; font-size: 11px; text-transform: uppercase; }
  .bilan-livret .lp-note { font-size: 10px; margin: 6px 0 6px 0; font-weight: 700; }

  /* Liste tâches */
  .bilan-livret .lp-taskRow { display: grid; grid-template-columns: 42px 1fr 14px; column-gap: 6px; font-size: 14px; padding: 2px 0; line-height: 1.3; }
  .bilan-livret .lp-taskCode { font-weight: 700; }
  .bilan-livret .lp-taskMark { text-align: right; font-weight: 700; }

  /* Compétences (style "liste" + cases X colorées) */
  .bilan-livret .lp-compBlock { margin-top: 10px; }
  .bilan-livret .lp-compHead { display: grid; grid-template-columns: 1fr 14px; column-gap: 6px; align-items: center; border-bottom: 1px solid #000; padding: 2px 0; font-size: 14px; font-weight: 700; line-height: 1.5; }
  .bilan-livret .lp-compItem { display: grid; grid-template-columns: 1fr 14px; column-gap: 6px; align-items: start; font-size: 12px; padding: 2px 0; line-height: 1.5; }
  .bilan-livret .lp-status { width: 12px; height: 12px; display: inline-flex; align-items: center; justify-content: center; font-size: 14px; font-weight: 900; line-height: 1; color: #000; }
  .bilan-livret .lp-status.NA { background: #ff0000; }
  .bilan-livret .lp-status.EA { background: #ffff00; }
  .bilan-livret .lp-status.A { background: #00ff00; }
  .bilan-livret .lp-status.NE { background: #d9d9d9; }
  .bilan-livret .lp-legendLine { margin: 8px 0 6px 0; font-size: 10px; }
  .bilan-livret .lp-legendLine .lp-legItem { margin-right: 18px; white-space: nowrap; }
  .bilan-livret .lp-legendLine .lp-legItem .lp-status { margin-right: 4px; }

  /* Bilan périodique : éviter les "lignes vides" entre la synthèse (histogramme) et le relevé des compétences */
  /* Bilan périodique (livret) : on masque la mise en page écran dans l'aperçu / impression */
  .bilan-screen-layout { display: none !important; }

  /* Livret : pagination maîtrisée */
  .bilan-livret .livret-page { break-after: page !important; page-break-after: always !important; }
  .bilan-livret .livret-page:last-child { break-after: auto !important; page-break-after: auto !important; }


  .bilan-print-root > :not([hidden]) ~ :not([hidden]) { margin-top: 0 !important; }
  .bilan-page-1 { margin-bottom: 0 !important; padding-bottom: 0 !important; }
  /* Évite un double saut de page (break-after + break-before) qui peut créer un blanc entre les deux sections */
  .bilan-page-2 {
    margin-top: 0 !important;
    padding-top: 0 !important;
    break-before: auto !important;
    page-break-before: auto !important;
  }

  /* Recharts : évite les superpositions (tooltips/labels) dans l'aperçu / impression */
  .recharts-tooltip-wrapper { display: none !important; }
  .bilan-print-root .bilan-chart-wrap { overflow: hidden !important; }

  /* Bilan des compétences : compacter en impression pour éviter une 3ème page */
  @media print {
    .bilan-page-2 { margin-top: 0 !important; padding-top: 0 !important; }
    .bilan-page-2 .bilan-group { box-shadow: none !important; border-width: 1px !important; }
    .bilan-page-2 .bilan-group-header { padding: 4px 6px !important; }
    .bilan-page-2 .bilan-group-grid {
      padding: 4px 6px !important;
      gap: 4px !important;
      grid-template-columns: repeat(3, minmax(0, 1fr)) !important;
    }

    .bilan-page-2 .bilan-competence-card { box-shadow: none !important; border-width: 1px !important; }
    .bilan-page-2 .bilan-competence-head { padding: 3px 4px !important; }
    .bilan-page-2 .bilan-competence-items { padding: 3px 4px !important; }
    .bilan-page-2 .bilan-competence-card { font-size: 9px !important; line-height: 1.2 !important; }
    .bilan-page-2 .bilan-competence-item { padding: 1px 3px !important; font-size: 8px !important; line-height: 1.15 !important; }
  }
`;

const collectPrintStyleTags = () =>
  Array.from(document.querySelectorAll('link[rel="stylesheet"], style'))
    .map((n) => (n as HTMLElement).outerHTML)
    .join("\n");

const escapeHtmlForPrint = (s: string) =>
  (s || "")
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#039;");

const serializeDomForPrint = (el: HTMLElement) => {
  // outerHTML suffit dans la plupart des cas ; le clone évite quelques surprises (hidden, etc.)
  const clone = el.cloneNode(true) as HTMLElement;
  clone.querySelectorAll("[hidden]").forEach((n) =>
    (n as HTMLElement).removeAttribute("hidden")
  );

  // Important : cloneNode ne reflète pas toujours les valeurs *courantes* des champs
  // (notamment textarea / select). On recopie explicitement les valeurs depuis le DOM original.
  const origFields = Array.from(el.querySelectorAll("input, textarea, select"));
  const cloneFields = Array.from(clone.querySelectorAll("input, textarea, select"));
  const n = Math.min(origFields.length, cloneFields.length);

  for (let i = 0; i < n; i++) {
    const o = origFields[i] as HTMLElement;
    const c = cloneFields[i] as HTMLElement;
    if (o.tagName !== c.tagName) continue;

    if (o.tagName === "TEXTAREA") {
      const ov = (o as HTMLTextAreaElement).value;
      (c as HTMLTextAreaElement).value = ov;
      // l'HTML imprimé dépend du contenu entre les balises
      (c as HTMLTextAreaElement).textContent = ov;
    } else if (o.tagName === "INPUT") {
      const oi = o as HTMLInputElement;
      const ci = c as HTMLInputElement;
      if (oi.type === "checkbox" || oi.type === "radio") {
        ci.checked = oi.checked;
        if (oi.checked) ci.setAttribute("checked", "");
        else ci.removeAttribute("checked");
      } else {
        ci.value = oi.value;
        ci.setAttribute("value", oi.value);
      }
    } else if (o.tagName === "SELECT") {
      const os = o as HTMLSelectElement;
      const cs = c as HTMLSelectElement;
      cs.value = os.value;
      Array.from(cs.options).forEach((opt) => {
        const isSel = opt.value === os.value;
        opt.selected = isSel;
        if (isSel) opt.setAttribute("selected", "");
        else opt.removeAttribute("selected");
      });
    }
  }
  return clone.outerHTML;
};

const pushRefToPreview = (params: {
  wrap: HTMLElement;
  title: string;
  page: "A4 portrait" | "A4 landscape" | "A3 landscape";
  header: PrintHeaderMeta;
  opts?: PreviewTargetOptions;
  bodyClass?: string;
  extraCss?: string;
}) => {
  const styleTags = collectPrintStyleTags();
  const bodyClassAttr = params.bodyClass ? ` class="${params.bodyClass}"` : "";
  const html = `<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>${escapeHtmlForPrint(params.title)}</title>
  ${styleTags}
  <style>
    @page { size: ${params.page}; margin: 10mm 10mm; }
    ${PRINT_BASE_CSS}
    ${params.extraCss || ""}
  </style>
</head>
<body${bodyClassAttr}>
  <div class="print-root" style="padding:12px">
${buildPrintHeaderHtml(escapeHtmlForPrint, params.header)}
    ${serializeDomForPrint(params.wrap)}
  </div>
</body>
</html>`;

  pushPreview(html, params.opts);
};

const openSuiviEvolutionsToPreview = (opts?: PreviewTargetOptions) => {
  const wrap = suiviEvolutionsPdfRef.current;
  if (!wrap) {
    alert("Bloc suivi évolutions introuvable (ref null).");
    return;
  }

  if (!selectedClassIdForSuivi || !selectedStudentForSuivi) {
    alert("Sélectionne une classe et un élève avant d'imprimer.");
    return;
  }

  pushRefToPreview({
    wrap,
    title: `Évolutions — Suivi de ${selectedStudentForSuivi} — ${selectedClassIdForSuivi} — ${trainingYearLabel(trainingYear)}`,
    page: "A4 landscape",
    header: {
      viewTitle: "Évolutions",
      studentName: selectedStudentForSuivi,
      classId: selectedClassIdForSuivi,
      trainingYear,
      schoolYear: getCurrentSchoolYear(),
    },
    bodyClass: "bg-white text-neutral-900 print-bilan",
    opts,
  });
};

const openSuiviBilanToPreview = (opts?: PreviewTargetOptions) => {
  const wrap = suiviBilanPdfRef.current;
  if (!wrap) {
    alert("Aucun contenu Bilan à imprimer.");
    return;
  }

  if (!selectedClassIdForSuivi || !selectedStudentForSuivi) {
    alert("Sélectionne une classe et un élève avant d'imprimer.");
    return;
  }

  pushRefToPreview({
    wrap,
    title: `Bilan — Suivi de ${selectedStudentForSuivi} — ${selectedClassIdForSuivi} — ${trainingYearLabel(trainingYear)} — ${bilanSemester}`,
    page: "A3 landscape",
    header: {
      viewTitle: `Bilan (${bilanSemester})`,
      studentName: selectedStudentForSuivi,
      classId: selectedClassIdForSuivi,
      trainingYear,
      schoolYear: getCurrentSchoolYear(),
    },
    bodyClass: "bg-white text-neutral-900 print-bilan",
    opts,
  });
};

const sanitizeAbsencesClassName = (s: string) =>
  String(s ?? "")
    .replace(/\s*[—–-]\s*CAP\s*2025\s*-\s*2027\s*/gi, "")
    .trim();

const openSuiviAbsencesToPreview = (opts?: PreviewTargetOptions) => {
  const wrap = suiviAbsencesPdfRef.current;
  if (!wrap) {
    alert("Aucun contenu Absences / retards à imprimer.");
    return;
  }

  const classId = selectedClassIdForSuivi;
  if (!classId) {
    alert("Sélectionne une classe avant d'imprimer.");
    return;
  }

  const styleTags = collectPrintStyleTags();
  const classLabel = sanitizeAbsencesClassName(classId);
  const title = `Absences / retards${classLabel ? ` — ${classLabel}` : ""} — ${absencesSchoolYear} — ${trainingYearLabel(trainingYear)}`;

  const recapHtml = (() => {
    try {
      const classe = classGroups.find((c) => c.name === classId);
      const students = (classe?.students || "")
        .split("\n")
        .map((s) => s.trim())
        .filter(Boolean);

      const yearBucket =
        (absencesStore.records?.[absencesSchoolYear]?.[classId] || {}) as Record<
          string,
          Record<string, AttendanceStatus>
        >;

      const startYmd = absencesPlanningSettings.startYmd;
      const endYmd = absencesPlanningSettings.endYmd;

      const vacationRanges: VacationRange[] =
        absencesPlanningSettings.vacationsMode === "auto"
          ? absencesAutoVacationsForKey || []
          : (absencesPlanningSettings.vacationsManual || []).map((r) => ({
              startYmd: r.startYmd,
              endYmdExclusive: addDaysYmd(r.endYmd, 1),
              label: r.label || "Vacances",
            }));

      const stageRanges: VacationRange[] = (absencesPlanningSettings.stages || []).map((r) => ({
        startYmd: r.startYmd,
        endYmdExclusive: addDaysYmd(r.endYmd, 1),
        label: r.label || "PFMP",
      }));

      const cutoffYmd = todayYmd < endYmd ? todayYmd : endYmd;

      const buildCourseYmdSet = (from: string, to: string) => {
        const set = new Set<string>();
        const s = fromYmd(from);
        const e = fromYmd(to);
        if (!s || !e) return set;
        for (let d = new Date(s.getTime()); d <= e; d = addDays(d, 1)) {
          const wdKey = weekdayKeyFromDate(d);
          if (!absencesPlanningSettings.courseDays?.[wdKey]) continue;
          const ymd = toYmd(d);
          if (findLabelInRanges(ymd, vacationRanges)) continue;
          if (findLabelInRanges(ymd, stageRanges)) continue;
          set.add(ymd);
        }
        return set;
      };

      const effectiveCourseYmdSet = buildCourseYmdSet(startYmd, cutoffYmd);

      type SemesterKey = "S1" | "S2";
      type SemesterInfo = { key: SemesterKey; startYmd: string; endYmdExclusive: string };

      const yearEndExclusive = addDaysYmd(endYmd, 1);
      const winterVac = vacationRanges.find((r) => /vacances.*hiver/i.test(r.label || ""));
      const summerVac = vacationRanges.find((r) => /vacances.*(ete|été)/i.test(r.label || ""));

      const syParsed = parseSchoolYearString(absencesSchoolYear);
      const fallbackWinterStart = syParsed ? `${syParsed.endYear}-02-01` : `${new Date().getFullYear()}-02-01`;

      const clampYmd = (ymdIn: string, minYmd: string, maxYmd: string) => {
        if (ymdIn < minYmd) return minYmd;
        if (ymdIn > maxYmd) return maxYmd;
        return ymdIn;
      };

      const s1StartYmd = startYmd;
      const s1EndExclYmd = clampYmd(winterVac?.startYmd || fallbackWinterStart, startYmd, yearEndExclusive);
      const s2StartYmd = clampYmd(winterVac?.endYmdExclusive || s1EndExclYmd, startYmd, yearEndExclusive);
      const s2EndExclYmd = clampYmd(summerVac?.startYmd || yearEndExclusive, startYmd, yearEndExclusive);

      const semestersBase: SemesterInfo[] = [
        { key: "S1", startYmd: s1StartYmd, endYmdExclusive: s1EndExclYmd },
        { key: "S2", startYmd: s2StartYmd, endYmdExclusive: s2EndExclYmd },
      ];

      const semesters: SemesterInfo[] = semestersBase.map((s) => {
        let st = clampYmd(s.startYmd, startYmd, yearEndExclusive);
        let en = clampYmd(s.endYmdExclusive, startYmd, yearEndExclusive);
        if (en <= st) en = addDaysYmd(st, 1);
        return { ...s, startYmd: st, endYmdExclusive: en };
      });

      const semS1 = semesters.find((s) => s.key === "S1") || semesters[0];
      const semS2 = semesters.find((s) => s.key === "S2") || semesters[1] || semesters[0];

      const courseDaysBySemesterSoFar: Record<SemesterKey, number> = { S1: 0, S2: 0 };
      for (const ymd of effectiveCourseYmdSet) {
        if (ymd >= semS1.startYmd && ymd < semS1.endYmdExclusive) courseDaysBySemesterSoFar.S1 += 1;
        else if (ymd >= semS2.startYmd && ymd < semS2.endYmdExclusive) courseDaysBySemesterSoFar.S2 += 1;
      }

      const studentSemesterCounts: Record<string, Record<SemesterKey, { ab: number; rt: number }>> = {};
      for (const st of students) {
        const byDate = yearBucket?.[st] || {};
        const semMap: Record<SemesterKey, { ab: number; rt: number }> = {
          S1: { ab: 0, rt: 0 },
          S2: { ab: 0, rt: 0 },
        };

        for (const [ymd, status] of Object.entries(byDate)) {
          if (status !== "AB" && status !== "RT") continue;
          if (ymd < startYmd || ymd > cutoffYmd) continue;
          if (!effectiveCourseYmdSet.has(ymd)) continue;

          const sem: SemesterKey =
            ymd >= semS2.startYmd && ymd < semS2.endYmdExclusive ? "S2" : "S1";

          if (status === "AB") semMap[sem].ab += 1;
          else semMap[sem].rt += 1;
        }

        studentSemesterCounts[st] = semMap;
      }

      const rows = students
        .slice()
        .sort((a, b) => a.localeCompare(b))
        .map((st) => {
          const c = studentSemesterCounts[st] || { S1: { ab: 0, rt: 0 }, S2: { ab: 0, rt: 0 } };
          const totAb = c.S1.ab + c.S2.ab;
          const totRt = c.S1.rt + c.S2.rt;
          return { st, c, totAb, totRt };
        });

      const totals = rows.reduce(
        (acc, r) => {
          acc.S1.ab += r.c.S1.ab;
          acc.S1.rt += r.c.S1.rt;
          acc.S2.ab += r.c.S2.ab;
          acc.S2.rt += r.c.S2.rt;
          acc.T.ab += r.totAb;
          acc.T.rt += r.totRt;
          return acc;
        },
        { S1: { ab: 0, rt: 0 }, S2: { ab: 0, rt: 0 }, T: { ab: 0, rt: 0 } }
      );

      const semRange = (sem: SemesterInfo) => {
        const endIncl = addDaysYmd(sem.endYmdExclusive, -1);
        return `${formatYmdFr(sem.startYmd)} → ${formatYmdFr(endIncl)}`;
      };

      const metaLine = `S1 (${semRange(semS1)}) • S2 (${semRange(semS2)}) • Jours de cours effectifs (jusqu'à ${formatYmdFr(cutoffYmd)}) : S1=${courseDaysBySemesterSoFar.S1}, S2=${courseDaysBySemesterSoFar.S2}`;

      if (rows.length === 0) {
        return `<div class="absences-recap-print"><h2>Récapitulatif absences/retards</h2><div class="meta">${escapeHtmlForPrint(metaLine)}</div><div>Aucun élève.</div></div>`;
      }

      const tr = rows
        .map((r) => {
          return `<tr>
<td class="st">${escapeHtmlForPrint(r.st)}</td>
<td class="n">${r.c.S1.ab}</td>
<td class="n">${r.c.S1.rt}</td>
<td class="n">${r.c.S2.ab}</td>
<td class="n">${r.c.S2.rt}</td>
<td class="n">${r.totAb}</td>
<td class="n">${r.totRt}</td>
</tr>`;
        })
        .join("");

      const tfoot = `<tr>
<td class="st">Total classe</td>
<td class="n">${totals.S1.ab}</td>
<td class="n">${totals.S1.rt}</td>
<td class="n">${totals.S2.ab}</td>
<td class="n">${totals.S2.rt}</td>
<td class="n">${totals.T.ab}</td>
<td class="n">${totals.T.rt}</td>
</tr>`;

      return `<div class="absences-recap-print">
  <h2>Récapitulatif absences/retards</h2>
  <div class="meta">${escapeHtmlForPrint(metaLine)}</div>
  <table class="recap-table">
    <colgroup>
      <col style="width:52%" />
      <col style="width:8%" /><col style="width:8%" />
      <col style="width:8%" /><col style="width:8%" />
      <col style="width:8%" /><col style="width:8%" />
    </colgroup>
    <thead>
      <tr>
        <th class="left">Élève</th>
        <th colspan="2">S1</th>
        <th colspan="2">S2</th>
        <th colspan="2">Total</th>
      </tr>
      <tr>
        <th class="left"></th>
        <th>AB</th><th>RT</th>
        <th>AB</th><th>RT</th>
        <th>AB</th><th>RT</th>
      </tr>
    </thead>
    <tbody>${tr}</tbody>
    <tfoot>${tfoot}</tfoot>
  </table>
</div>`;
    } catch (e) {
      return `<div class="absences-recap-print"><h2>Récapitulatif absences/retards</h2><div>Impossible de générer le récapitulatif.</div></div>`;
    }
  })();

  const printedMainDom = (() => {
    const dom = serializeDomForPrint(wrap);
    return dom;
  })();



  const html = `<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>${escapeHtmlForPrint(title)}</title>
  ${styleTags}
  <style>
    @page { size: A3 landscape; margin: 8mm 8mm 8mm 4mm; }
    ${PRINT_BASE_CSS}

    /* On garde le texte des boutons dans le tableau (en-têtes jours/semaine) */
    .absences-print-root table button { display: contents !important; }

    /* Nettoyage UI */
    .absences-controls, .absences-sidepanel { display: none !important; }
    .absences-grid { grid-template-columns: 1fr !important; }

    #page { width: calc(420mm - 16mm); margin: 0; overflow: visible; }
    #recapRoot { margin-top: 6mm; }
    #pdfRoot { transform-origin: top left; transform: scale(var(--pdfScale, 1)); width: max-content; }

    /*
      Important: en impression Chromium, transform: scale() ne réduit pas toujours la hauteur "layout" utilisée
      pour la pagination, ce qui peut envoyer le récap en page 2. On utilise zoom en mode print (layout-aware).
    */
    @media print {
      /* Supprime le padding inline pour maximiser la hauteur disponible */
      .print-root { padding: 0 !important; }
      #pdfRoot { zoom: var(--pdfScale, 1) !important; transform: none !important; }
    }
    .absences-print-root table { border-collapse: collapse; }
    /* Table (absences/retards) : lisibilité en impression */
    .absences-print-root table { font-size: 13px !important; }
    /* Noms élèves plus grands en print */
    .absences-print-root .student-name { font-size: 15px !important; }
    .absences-print-root td.sticky.left-0 { font-size: 15px !important; }
    /* Les libellés AB/RT & périodes utilisaient text-[10px] en UI */
    .absences-print-root .text-\\[10px\\] { font-size: 13px !important; }
    .absences-print-root .text-\\[11px\\] { font-size: 14px !important; }
    .absences-print-root th, .absences-print-root td { padding: 2px 3px !important; }
    /* Les cellules ont souvent un height inline => on force une hauteur plus confortable */
    .absences-print-root th[style], .absences-print-root td[style] { height: 20px !important; }


    /* Colonne élèves : toujours sur 1 ligne + ellipsis (impression) */
    .absences-print-root td.sticky.left-0 { white-space: nowrap !important; }
    .absences-print-root .student-name-row { min-width: 0 !important; }
    .absences-print-root .student-name {
      display: block;
      min-width: 0 !important;
      overflow: hidden !important;
      text-overflow: ellipsis !important;
      white-space: nowrap !important;
    }

/* Empêche le clipping horizontal (containers scroll/hidden) */
.absences-print-root .overflow-x-auto { overflow: visible !important; }
.absences-print-root .overflow-hidden { overflow: visible !important; }

/* Largeur auto de la colonne Élève (pour gagner de la place) */
.absences-print-root { --nameColW: 140px; }
.absences-print-root colgroup col:first-child { width: var(--nameColW) !important; }
.absences-print-root th.sticky.left-0,
.absences-print-root td.sticky.left-0 {
  width: var(--nameColW) !important;
  min-width: var(--nameColW) !important;
  max-width: var(--nameColW) !important;
}
.absences-print-root th.sticky.left-0,
.absences-print-root td.sticky.left-0 {
  padding-left: 4px !important;
  padding-right: 4px !important;
}

    /* Récapitulatif (impression) : toujours S1 + S2 (même si S2 pas commencé) — sur la même page */
    .absences-recap-print { break-inside: avoid; page-break-inside: avoid; max-width: 260mm; margin: 0; }
    .absences-recap-print h2 { font-size: 15px; font-weight: 800; margin: 0 0 3px 0; }
    .absences-recap-print .meta { font-size: 11px; color: #444; margin: 0 0 4px 0; }
    .absences-recap-print table { width: 100%; border-collapse: collapse; font-size: 10px; table-layout: fixed; }
    .absences-recap-print th, .absences-recap-print td { border: 1px solid #d4d4d4; padding: 2px 4px; height: 18px; }
    .absences-recap-print th { background: #f5f5f5; }
    .absences-recap-print td.n { text-align: center; font-variant-numeric: tabular-nums; }
    .absences-recap-print td.st, .absences-recap-print th.left { text-align: left; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .absences-recap-print tfoot td { font-weight: 700; }

  </style>
</head>
<body class="bg-white text-neutral-900">
  <div class="print-root" style="padding:8px">
${buildPrintHeaderHtml(escapeHtmlForPrint, {
viewTitle: "Absences / retards",
classId: classLabel,
trainingYear,
schoolYear: absencesSchoolYear,
})}

    <div id="page">
      <div id="pdfRoot">
        ${printedMainDom}
      </div>
      <div id="recapRoot">
        ${recapHtml}
      </div>
    </div>
  </div>

<script>
  function computeStudentNameColWidth() {
    const root = document.querySelector('.absences-print-root');
    if (!root) return;

    const nameEls = Array.from(root.querySelectorAll('.student-name'));
    if (!nameEls.length) return;

    const sample = nameEls[0];
    const cs = window.getComputedStyle(sample);
    const font = cs.font || (cs.fontWeight + " " + cs.fontSize + " " + cs.fontFamily);

    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    if (!ctx) return;
    ctx.font = font;

    let max = 0;
    for (const el of nameEls) {
      const t = (el.textContent || '').trim();
      if (!t) continue;
      const w = ctx.measureText(t).width;
      if (w > max) max = w;
    }
    if (!max) return;

    // padding du TD + marge (indicateurs / icônes) + clamp pour gagner de la place
    const desired = Math.min(160, Math.max(110, Math.ceil(max + 18)));
    root.style.setProperty('--nameColW', desired + 'px');
  }

  function fitToA3Width() {
    const page = document.getElementById('page');
    const root = document.getElementById('pdfRoot');
    if (!page || !root) return;

    root.style.setProperty('--pdfScale', 1);

    const pageRect = page.getBoundingClientRect();
    const baseW = page.dataset.baseW ? Number(page.dataset.baseW) : pageRect.width;
    const baseH = page.dataset.baseH ? Number(page.dataset.baseH) : pageRect.height;
    if (!page.dataset.baseW) page.dataset.baseW = String(baseW);
    if (!page.dataset.baseH) page.dataset.baseH = String(baseH);

    const availableW = baseW;

    const neededW = root.scrollWidth || root.getBoundingClientRect().width;
    if (!availableW || !neededW) return;

    const scaleRaw = Math.min(1, availableW / neededW);
    // Petite marge de sécurité pour éviter qu'1px de débordement déclenche une 2ème page
    const scaleSafe = Math.max(0.1, Math.min(1, scaleRaw * 0.99));
    root.style.setProperty('--pdfScale', scaleSafe.toFixed(4));
  }

  function layoutAndFit() {
    computeStudentNameColWidth();
    fitToA3Width();
  }

  window.addEventListener('load', () => {
    layoutAndFit();
    // Recalcule après rendu des polices/mesures (évite pagination surprise)
    setTimeout(layoutAndFit, 50);
  });
  window.addEventListener('beforeprint', () => {
    layoutAndFit();
    setTimeout(layoutAndFit, 50);
  });
</script>
</body>
</html>`;

  pushPreview(html, opts);
};


const exportNotesTableToPdf = (opts?: PreviewTargetOptions) => {
  try {
    if (!selectedClassIdForSuivi) return;

    const classe = classGroups.find((c) => c.name === selectedClassIdForSuivi);
    if (!classe) return;

    const students = (classe.students || "")
      .split("\n")
      .map((s) => s.trim())
      .filter(Boolean);

    const evalsForClass = evalMetaList.filter(
      (ev) =>
        ev.group === classe.name &&
        ev.semester !== "Ne pas utiliser de semestre"
    );

    const schoolYear = getCurrentSchoolYear();
    const notationsForYear = notationDB[schoolYear]?.[classe.name] || {};

    if (students.length === 0) {
      alert("Aucun élève n'est renseigné pour cette classe.");
      return;
    }
    if (evalsForClass.length === 0) {
      alert("Aucun devoir n'est encore associé à cette classe.");
      return;
    }

    const evalsS1 = evalsForClass.filter((ev) => ev.semester === "S1");
    const evalsS2 = evalsForClass.filter((ev) => ev.semester === "S2");

    const title = `Tableau des notes — ${classe.name} — ${schoolYear} — ${trainingYearLabel(trainingYear)}`;

    const buildTableHtml = (label: string, evals: EvalMeta[]) => {
      if (evals.length === 0) {
        return `<div class="section"><h2>${escapeHtml(label)}</h2><div class="empty">Aucun devoir pour ce semestre.</div></div>`;
      }

      const head = evals
        .map(
          (ev) => `
            <th>
              <div class="h-name">${escapeHtml(ev.name)}</div>
            </th>
          `
        )
        .join("");

      const rows = students
        .map((st) => {
          const cells = evals
            .map((ev) => {
              const evalBucket = (notationsForYear as any)[ev.id] || {};
              const entry = evalBucket[st] as NotationEntry | undefined;
              const mark = entry?.markOn20;
              const status = entry?.status;

              const display =
                status === "AB"
                            ? "AB"
                            : status === "N.NOT"
                              ? "N.NOT"
                              : typeof mark === "number"
                                ? mark.toFixed(2).replace(".", ",")
                                : "—";

              return `<td>${escapeHtml(display)}</td>`;
            })
            .join("");

          return `
            <tr>
              <td class="student">${escapeHtml(st)}</td>
              ${cells}
            </tr>
          `;
        })
        .join("");

      return `
        <div class="section">
          <h2>${escapeHtml(label)}</h2>
          <table>
            <thead>
              <tr>
                <th class="left">Élève</th>
                ${head}
              </tr>
            </thead>
            <tbody>
              ${rows}
            </tbody>
          </table>
        </div>
      `;
    };

    const html = `<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>${escapeHtml(title)}</title>
  <style>
    @page { size: A4 landscape; margin: 10mm; }
    body { font-family: Arial, sans-serif; color: #111; }
    h1 { font-size: 16px; margin: 0 0 6px; }
    .meta { font-size: 11px; color: #444; margin-bottom: 10px; }
    h2 { font-size: 13px; margin: 14px 0 6px; }
    .section { margin-top: 10px; }
    .empty { font-size: 11px; color: #666; padding: 8px 0; }

    table { width: 100%; border-collapse: collapse; font-size: 10px; }
    th, td { border: 1px solid #bbb; padding: 4px 6px; }
    th { background: #f5f5f5; text-align: center; vertical-align: bottom; }
    td { text-align: center; }
    th.left, td.student { text-align: left; }
    td.student { font-weight: 600; white-space: nowrap; }
    .h-name { font-weight: 700; font-size: 10px; }
  </style>
</head>
<body>
${buildPrintHeaderHtml(escapeHtml, {
viewTitle: "Tableau des notes",
classId: classe.name,
trainingYear,
schoolYear,
})}

  ${buildTableHtml("Semestre 1", evalsS1)}
  ${buildTableHtml("Semestre 2", evalsS2)}
</body>
</html>`;

    pushPreview(html, opts);
  } catch (e) {
    console.error("Export PDF tableau notes error:", e);
    alert("Impossible d'exporter le tableau des notes en PDF.");
  }
};

  // Vue classe : pour chaque devoir, on garde les tâches et les compétences évaluées
  const [tasksByEvalId, setTasksByEvalId] = useState<Record<string, string[]>>({});
  const [compsByEvalId, setCompsByEvalId] = useState<Record<string, string[]>>({});
  // Pour NOTE : critères + poids par devoir
  const [criteresByEvalId, setCriteresByEvalId] = useState<Record<string, string[]>>({});
  const [weightsByEvalId, setWeightsByEvalId] = useState<
  Record<string, Record<string, number>>
>({});

  // Base des devoirs : liste de tous les fichiers enregistrés
  const [devoirDBOpen, setDevoirDBOpen] = useState(false);
  const [savedDevoirs, setSavedDevoirs] = useState<SavedDevoirMeta[]>([]);
  const [savedDevoirsTrash, setSavedDevoirsTrash] = useState<SavedDevoirMeta[]>([]);
  const [devoirDBTab, setDevoirDBTab] = useState<"devoirs" | "corbeille">("devoirs");


// Rafraîchir la base des devoirs si on change d'année pendant que la fenêtre est ouverte
useEffect(() => {
  if (!devoirDBOpen) return;
  if (!isTauriRuntime()) return;
  refreshDevoirDatabaseLists().catch(() => {});
}, [devoirDBOpen, trainingYear]);

// Charge tâches + compétences + critères + poids pour toutes les évaluations de la classe sélectionnée
useEffect(() => {
  if (!isTauriRuntime()) return;
  if (!selectedClassIdForSuivi) {
    setTasksByEvalId({});
    setCompsByEvalId({});
    setCriteresByEvalId({});
    setWeightsByEvalId({});
    return;
  }

  (async () => {
    try {
      const evalsForClass = evalMetaList.filter(
        (ev) => ev.group === selectedClassIdForSuivi
      );

      const mapTasks: Record<string, string[]> = {};
      const mapComps: Record<string, string[]> = {};
      const mapCriteres: Record<string, string[]> = {};
      const mapWeights: Record<string, Record<string, number>> = {};

      for (const ev of evalsForClass) {
        try {
          const safeName = ev.fileName.endsWith(".json")
            ? ev.fileName
            : `${ev.fileName}.json`;

          const txt = await readTextFile(`${DEVOIR_DIR}/${safeName}`, {
            baseDir: BaseDirectory.AppLocalData,
          });

          const data = JSON.parse(txt);

          const tasks = Array.isArray(data.selectedTasks)
            ? (data.selectedTasks as string[])
            : [];

          const comps = Array.isArray(data.selectedCompetences)
            ? (data.selectedCompetences as string[])
            : [];

          const criteres = Array.isArray(data.selectedCriteres)
            ? (data.selectedCriteres as string[])
            : [];

          const weights = (data.notationWeights || {}) as Record<string, number>;

          mapTasks[ev.id] = tasks;
          mapComps[ev.id] = comps;
          mapCriteres[ev.id] = criteres;
          mapWeights[ev.id] = weights;
        } catch (e) {
          console.warn("Erreur lecture devoir pour vue classe / NOTE", e);
        }
      }

      setTasksByEvalId(mapTasks);
      setCompsByEvalId(mapComps);
      setCriteresByEvalId(mapCriteres);
      setWeightsByEvalId(mapWeights);
    } catch (e) {
      console.warn(
        "Erreur chargement tâches/compétences/critères/poids des évaluations",
        e
      );
    }
  })();
}, [evalMetaList, selectedClassIdForSuivi, trainingYear]);

useEffect(() => {
  if (!selectedNoteEvalId) return;

  const meta = evalMetaList.find((ev) => ev.id === selectedNoteEvalId);
  if (!meta) return;

  (async () => {
    try {
      // Charge le devoir complet comme dans la vue DEVOIR
      await loadSavedDevoir(meta.fileName);

      // Optionnel : recaler groupe + semestre
      if (meta.group) {
        setGroup(meta.group);
      }
      if (meta.semester === "S1" || meta.semester === "S2") {
        setEvaluationSemester(meta.semester);
      }
    } catch (e) {
      console.error("Erreur lors du chargement du devoir depuis NOTE :", e);
    }
  })();
}, [selectedNoteEvalId, evalMetaList]);

  // --- Effets init ---
// Remplace l'effet qui charge les exigences perso par :
React.useEffect(() => {
  (async () => {
    try {
      // 0) tenter le cache
      let seed: Record<string, string[]> | null = null;
      try {
        const cache = localStorage.getItem('exigences_db_cache');
        if (cache) seed = JSON.parse(cache);
      } catch {}

      // 1) Tauri: AppData
      if (!seed && isTauriRuntime() && await getTauriFs()) {
        const disk = await loadExigencesFromTauri();
        if (disk && Object.keys(disk).length > 0) seed = disk;
      }

      // 2) réseau → repli JSON statique
      if (!seed) {
        try {
          seed = await __fetchExigencesSeed(); // ← essaie /api puis /data/exigences_db.json
        } catch {
          seed = {};
        }
      }

      const data = seed ?? {};
      setPersistedExigencesDB(data);
      setExigencesIndex(buildExigencesIndex(data));
      try { localStorage.setItem('exigences_db_cache', JSON.stringify(data)); } catch {}

      // Sème aussi dans AppData si Tauri
      if (isTauriRuntime() && await getTauriFs()) {
        try { await saveExigencesToTauri(data); } catch (e) {
          console.warn('Seed AppData failed', e);
        }
      }
    } catch (e) {
      console.warn('Impossible de charger les exigences perso', e);
    }
  })();
}, []);

  // Charge la base tâches/compétences si présente (sinon fallback aux valeurs par défaut)
  React.useEffect(() => {
    (async () => {
      try {
        const r = await fetch('/data/taches_competences.json');
        if (r.ok) {
          const data = await r.json() as TCMap;
          if (data && typeof data === 'object') setTcMap(data);
        }
      } catch {}
    })();
  }, []);

  // S'assure qu'une tâche active est définie après chargement de tcMap
  React.useEffect(() => {
    const ks = Object.keys(tcMap);
    // On nettoie seulement ce qui n'existe plus, sans rien présélectionner
    setSelectedTasks(prev => prev.filter(t => ks.includes(t)));
    setActiveTask(prev => (prev && ks.includes(prev)) ? prev : null);
  }, [tcMap]);

  // Charge la base critères/résultats
  React.useEffect(() => {
    (async () => {
      try {
        const r = await fetch('/data/criteres_resultats.json');
        if (r.ok) setCritResDB(await r.json() as CriteresResultsDB);
      } catch {}
    })();
  }, []);

  // Nettoyage éventuel du scroll-lock (sécurité)
  useEffect(() => {
    document.documentElement.classList.remove('overflow-hidden');
    // @ts-ignore
    document.documentElement.dataset.scrollLockCount = "0";
  }, []);

  // Persiste le thème
  useEffect(() => {
    const root = document.documentElement;
    if (theme === 'dark') root.classList.add('dark'); else root.classList.remove('dark');
    localStorage.setItem('theme', theme);
  }, [theme]);

  // --- Autosave ---
React.useEffect(() => {
  if (!customExigences) return;

  if (autosaveTimer.current != null) window.clearTimeout(autosaveTimer.current);
  autosaveTimer.current = window.setTimeout(async () => {
    const merged: Record<string, string[]> = {};
    const add = (key: string, arr: string[]) => {
      merged[key] = Array.from(new Set([...(merged[key] || []), ...arr]));
    };
    if (persistedExigencesDB) {
      for (const [k, v] of Object.entries(persistedExigencesDB)) add(k, Array.isArray(v) ? v : []);
    }
    if (customExigences) {
      for (const [rawKey, v] of Object.entries(customExigences)) {
        const normKey = normalizeKeyFromCritKey(rawKey);
        add(normKey, Array.isArray(v) ? v : []);
      }
    }

    try {
      if (isTauriRuntime() && await getTauriFs()) {
        await saveExigencesToTauri(merged);
        setPersistedExigencesDB(merged);
          setExigencesIndex(buildExigencesIndex(merged));
      } else {
        await fetch('/api/exigences', {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(merged),
        });
        setPersistedExigencesDB(merged);
          setExigencesIndex(buildExigencesIndex(merged));
      }
    } catch (e) {
      console.warn('Autosave échoué', e);
    }
  }, 800);

  return () => { if (autosaveTimer.current != null) window.clearTimeout(autosaveTimer.current); };
}, [customExigences]);

  // Chargement au démarrage
React.useEffect(() => {
  (async () => {
    try {
      const groups = await loadElevesFromStore();
      if (Array.isArray(groups)) {
        setClassGroups(groups);
      }
    } catch (e) {
      console.warn("Erreur chargement eleves.json :", e);
    } finally {
      // ✅ On indique que le chargement initial (même vide) est terminé
      setElevesBootstrapped(true);
    }
  })();
}, []);

// Sauvegarde automatique dès que classGroups change (après bootstrap)
React.useEffect(() => {
  if (!elevesBootstrapped) return; // ⛔ ne rien sauvegarder avant la fin du chargement initial
  saveElevesToStore(classGroups).catch((e) =>
    console.warn("Erreur sauvegarde eleves.json :", e)
  );
}, [classGroups, elevesBootstrapped]);

    // Voir ou se sauvegarde le fichier classe / éléves
  React.useEffect(() => {
  (async () => {
    const dir = await appLocalDataDir();
    console.log("Dossier AppLocalData :", dir);
  })();
}, []);

    // Charge la base des évaluations (selon l'année) au démarrage + à chaque changement d'année
  React.useEffect(() => {
    setEvalMetaBootstrapped(false);

    (async () => {
      try {
        const list = await loadEvalMetaFromStore(trainingYear);
        if (Array.isArray(list)) {
          setEvalMetaList(list);
        } else {
          setEvalMetaList([]);
        }
      } catch (e) {
        console.warn("Impossible de charger evaluations_db :", e);
        setEvalMetaList([]);
      } finally {
        setEvalMetaBootstrapped(true);
      }
    })();
  }, [trainingYear]);

  // Sauvegarde la base des évaluations dès qu'elle change (dans le fichier de l'année courante)
  React.useEffect(() => {
  if (!evalMetaBootstrapped) return;
  const y = trainingYearRef.current;
  saveEvalMetaToStore(evalMetaList, y).catch((e) =>
    console.warn("Erreur sauvegarde evaluations_db :", e)
  );
}, [evalMetaList, evalMetaBootstrapped]);

// Chargement du suivi compétences (selon l'année) au démarrage + à chaque changement d'année
React.useEffect(() => {
  setSkillsBootstrapped(false);

  (async () => {
    try {
      const db = await loadSkillsFromStore(trainingYear);
      setSkillsDB(db && typeof db === "object" ? db : {});
    } catch (e) {
      console.warn("Erreur chargement skills_db :", e);
      setSkillsDB({});
    } finally {
      setSkillsBootstrapped(true);
    }
  })();
}, [trainingYear]);

// Sauvegarde du suivi compétences (fichier + localStorage) — selon l'année courante
React.useEffect(() => {
  if (!skillsBootstrapped) return;
  const y = trainingYearRef.current;
  saveSkillsToStore(skillsDB, y).catch((e) =>
    console.warn("Erreur sauvegarde skills_db :", e)
  );
}, [skillsBootstrapped, skillsDB]);



// Charger les données de 1ère année en lecture seule quand on est en 2ème année
React.useEffect(() => {
  let mounted = true;
  setPremiereBootstrapped(false);

  if (trainingYear !== "deuxieme") {
    setSkillsDBPremiere({});
    setEvalMetaListPremiere([]);
    setNotationDBPremiere({});
    setPremiereBootstrapped(true);
    return () => {
      mounted = false;
    };
  }

  (async () => {
    try {
      const [sdb, eml, ndb] = await Promise.all([
        loadSkillsFromStore("premiere"),
        loadEvalMetaFromStore("premiere"),
        loadNotationFromStore("premiere"),
        loadAbsencesRetardsFromStore("premiere"),
      ]);

      if (!mounted) return;

      setSkillsDBPremiere(sdb && typeof sdb === "object" ? sdb : {});
      setEvalMetaListPremiere(Array.isArray(eml) ? eml : []);
      setNotationDBPremiere(ndb && typeof ndb === "object" ? ndb : {});
    } catch (e) {
      console.warn("Erreur chargement données 1ère année (lecture seule) :", e);
      if (!mounted) return;
      setSkillsDBPremiere({});
      setEvalMetaListPremiere([]);
      setNotationDBPremiere({});
    } finally {
      if (mounted) setPremiereBootstrapped(true);
    }
  })();

  return () => {
    mounted = false;
  };
}, [trainingYear]);


// Charger les données de 2ème année en lecture seule quand on est en 1ère année
// (utile pour afficher l'évolution sur 2 ans dans la vue "Évolutions")
React.useEffect(() => {
  let mounted = true;
  setDeuxiemeBootstrapped(false);

  if (trainingYear !== "premiere") {
    setSkillsDBDeuxieme({});
    setEvalMetaListDeuxieme([]);
    setNotationDBDeuxieme({});
    setDeuxiemeBootstrapped(true);
    return () => {
      mounted = false;
    };
  }

  (async () => {
    try {
      const [sdb, eml, ndb] = await Promise.all([
        loadSkillsFromStore("deuxieme"),
        loadEvalMetaFromStore("deuxieme"),
        loadNotationFromStore("deuxieme"),
        loadAbsencesRetardsFromStore("deuxieme"),
      ]);

      if (!mounted) return;
      setSkillsDBDeuxieme(sdb && typeof sdb === "object" ? sdb : {});
      setEvalMetaListDeuxieme(Array.isArray(eml) ? eml : []);
      setNotationDBDeuxieme(ndb && typeof ndb === "object" ? ndb : {});
    } catch (e) {
      console.warn("Erreur chargement données 2ème année (lecture seule) :", e);
      if (!mounted) return;
      setSkillsDBDeuxieme({});
      setEvalMetaListDeuxieme([]);
      setNotationDBDeuxieme({});
    } finally {
      if (mounted) setDeuxiemeBootstrapped(true);
    }
  })();

  return () => {
    mounted = false;
  };
}, [trainingYear]);



  // Classe sélectionnée par défaut pour le suivi (par *nom* de classe)
  useEffect(() => {
  if (!selectedClassIdForSuivi && classGroups.length > 0) {
    setSelectedClassIdForSuivi(classGroups[0].name);
  }
}, [classGroups, selectedClassIdForSuivi]);

  // Élève sélectionné par défaut quand la classe change
  useEffect(() => {
    if (!selectedClassIdForSuivi) {
      setSelectedStudentForSuivi(null);
      return;
    }
    const classe = classGroups.find((c) => c.name === selectedClassIdForSuivi);
    if (!classe) {
      setSelectedStudentForSuivi(null);
      return;
    }
    const students = (classe.students || "")
      .split("\n")
      .map((s) => s.trim())
      .filter(Boolean);

    if (!students.length) {
      setSelectedStudentForSuivi(null);
      return;
    }
    if (!selectedStudentForSuivi || !students.includes(selectedStudentForSuivi)) {
      setSelectedStudentForSuivi(students[0]);
    }
  }, [selectedClassIdForSuivi, classGroups, selectedStudentForSuivi]);

// Quand on passe en mode "notation" dans le suivi,
// on charge automatiquement un devoir pour la classe sélectionnée
useEffect(() => {
  if (suiviMode !== "notation") return;
  if (!selectedClassIdForSuivi) return;

  const classe = classGroups.find((c) => c.name === selectedClassIdForSuivi);
  if (!classe) return;

  // Tous les devoirs S1/S2 de cette classe
  const evalsForClass = evalMetaList.filter(
    (ev) =>
      ev.group === classe.name &&
      ev.semester !== "Ne pas utiliser de semestre"
  );
  if (!evalsForClass.length) return;

  // On essaie de reprendre le devoir déjà sélectionné,
  // sinon on prend le 1er de la liste
  let targetEval =
    (selectedEvalIdForClasse
      ? evalsForClass.find((ev) => ev.id === selectedEvalIdForClasse)
      : null) ?? evalsForClass[0];

  // Si aucun id sélectionné, on mémorise celui du devoir choisi
  if (!selectedEvalIdForClasse || selectedEvalIdForClasse !== targetEval.id) {
    setSelectedEvalIdForClasse(targetEval.id);
  }

  // On charge le devoir complet (comme dans handleOpenClasseDevoir)
  (async () => {
    try {
      await loadSavedDevoir(targetEval.fileName);
      if (targetEval.group) {
        setGroup(targetEval.group);
      }
      if (targetEval.semester) {
        setEvaluationSemester(targetEval.semester as SemesterKey);
      }
    } catch (err) {
      console.error(
        "Erreur lors du chargement auto du devoir pour la notation élèves :",
        err
      );
    }
  })();
}, [
  suiviMode,
  selectedClassIdForSuivi,
  selectedEvalIdForClasse,
  evalMetaList,
  classGroups,
]);

// Affecter un niveau 1–4 à un élève / semestre / compétence (sans toggle)
// 🔹 Petit helper pour avoir une mise à jour immuable et propre du skillsDB
function ensureStudentCompEntry(
  db: SkillsDB,
  classId: string,
  studentName: string,
  compLabel: string
): { next: SkillsDB; compRec: Record<SemesterKey, Level1to4> } {
  const next: SkillsDB = { ...db };

  // Classe
  const classRec = next[classId] ? { ...next[classId] } : {};
  next[classId] = classRec;

  // Élève
  const studentRec = classRec[studentName]
    ? { ...classRec[studentName] }
    : {};
  classRec[studentName] = studentRec;

  // Compétence / critère (clé = compLabel ou critKey)
  const compRec = studentRec[compLabel]
    ? { ...(studentRec[compLabel] as any) }
    : ({} as Record<SemesterKey, Level1to4>);
  studentRec[compLabel] = compRec as any;

  return { next, compRec };
}

const setStudentLevel = (
  classId: string,
  studentName: string,
  semester: SemesterKey,
  compLabel: string,
  level: Level1to4
) => {
  setSkillsDB((prev) => {
    const { next, compRec } = ensureStudentCompEntry(
      prev,
      classId,
      studentName,
      compLabel
    );

    // On enregistre systématiquement le niveau pour ce semestre
    compRec[semester] = level;

    return next;
  });
};

// 🔹 Push automatique depuis la notation de devoir (inchangé dans le comportement)
const pushCurrentDevoirToSuivi = (
  classId: string,
  studentName: string,
  semester: SemesterKey,
  evalId: string,
  scoresByCriteria: Record<string, number>
) => {
  const levelsByComp = computeLevelsFromCurrentDevoir(scoresByCriteria);

  Object.entries(levelsByComp).forEach(([compLabel, lvl]) => {
    // ✅ clé stable = evalId||compétence (évite les collisions quand le même devoir est réutilisé ou entre 1ère/2ème année)
    const keyWithEval = `${evalId}||${compLabel}`;
    setStudentLevel(classId, studentName, semester, keyWithEval, lvl as Level1to4);
  });
};



const loadSavedDevoir = async (fileName: string) => {
  try {
    if (!isTauriRuntime()) {
      alert("Chargement disponible uniquement dans la version Tauri.");
      return;
    }

    const safeName = fileName.endsWith(".json") ? fileName : `${fileName}.json`;
    const txt = await readTextFile(`${DEVOIR_DIR}/${safeName}`, {baseDir: BaseDirectory.AppLocalData,});
    const data = JSON.parse(txt);

    // 🔹 ID & semestre (si tu utilises ces états)
    if (data.evaluationId) {
      setEvaluationId(data.evaluationId);
    }
    if (data.evaluationSemester) {
      setEvaluationSemester(data.evaluationSemester as SemesterKey);
    }

    // 🔹 En-tête
    setTitle(data.title || "");
    setProject(data.project || "");
    setLogoDataUrl((data as any).logoDataUrl || null);
    setProfessionalSituation(data.professionalSituation || "");
    setEvaluator(data.evaluator || "");
    setGroup(data.group || "GROUPE");
    setEvaluationCategory((data.evaluationCategory || data.typeEvaluation) as EvaluationCategory || "Découverte professionnel");
    setObjectives(data.objectives || "");
    setEvaluationType(data.evaluationType || "criterie");

    // 🔹 Tâches
    const loadedTasks = data.selectedTasks || [];
    setSelectedTasks(loadedTasks);
    if (loadedTasks.length > 0) {
      setActiveTask(loadedTasks[0]);
    } else {
      setActiveTask(null);
    }

    // 🔹 Compétences / critères / sous-critères
    setSelectedCompetences(data.selectedCompetences || []);
    setSelectedCriteres(data.selectedCriteres || []);
    setSelectedSubCrit(data.selectedSubCrit || []);

    // 🔹 Exigences
    setCustomExigences(data.customExigences || {});
    setPersistedExigencesDB(data.persistedExigencesDB || {});
    setSelectedExigence(data.selectedExigence || {});

    // 🔹 Notation
    setNotationWeights(data.notationWeights || {});
    setNotationScores(data.notationScores || {});

  } catch (err) {
    console.error("Erreur chargement devoir depuis la base :", err);
    alert("Impossible d’ouvrir ce devoir.");
  }
};

const handleOpenDevoirDatabase = async () => {
  if (!isTauriRuntime()) {
    alert("La base des devoirs est disponible uniquement dans l'application Tauri.");
    return;
  }

  setDevoirDBOpen(true);
  await refreshDevoirDatabaseLists();
};

const ensureJsonName = (name: string) =>
  name.toLowerCase().endsWith(".json") ? name : `${name}.json`;

// Les "instances" (anciennes copies générées) ne doivent pas apparaître dans la base des devoirs.
// Elles restent toutefois lisibles si elles sont référencées par une évaluation déjà créée.
const isDevoirInstanceFile = (name: string) =>
  /(__copie_|__copy_|(?:^|[ _-])copie(?:[ _-]|\.|$)|\(copie\))/i.test(String(name || ""));

const listDevoirsFromFolder = async (folder: string): Promise<SavedDevoirMeta[]> => {
  let entries: any[] = [];
  try {
    entries = await readDir(folder, { baseDir: BaseDirectory.AppLocalData });
  } catch (e) {
    // dossier absent => liste vide
    return [];
  }

  const files: any[] = [];
  const flatten = (arr: any[]) => {
    arr.forEach((e: any) => {
      if (Array.isArray(e.children) && e.children.length) flatten(e.children);
      else files.push(e);
    });
  };
  flatten(entries);

  const items: SavedDevoirMeta[] = [];

  for (const f of files) {
    const name = String((f as any).name || "");
    if (!name.toLowerCase().endsWith(".json")) continue;

    // ✅ Base des devoirs = uniquement des devoirs "uniques".
    // Les anciennes copies/instances (__copie_) ne doivent pas polluer la liste.
    if (folder === DEVOIR_DIR && isDevoirInstanceFile(name)) continue;

    // ✅ Base des devoirs : afficher uniquement les devoirs "uniques" (pas les copies/instances).
    if (folder === DEVOIR_DIR && isDevoirInstanceFile(name)) continue;

    const path = `${folder}/${name}`;
    let txt = "";
    try {
      txt = await readTextFile(path, { baseDir: BaseDirectory.AppLocalData });
    } catch {
      continue;
    }

    let title = name;
    let group: string | undefined;
    let evaluationType: string | undefined;

    try {
      const data = JSON.parse(txt);
      if (data && typeof data === "object") {
        if (typeof data.title === "string" && data.title.trim()) title = data.title;
        if (typeof data.group === "string" && data.group.trim()) group = data.group;
        if (typeof data.evaluationType === "string" && data.evaluationType.trim())
          evaluationType = data.evaluationType;
      }
    } catch {}

    items.push({ fileName: name, title, group, evaluationType });
  }

  items.sort((a, b) => a.title.localeCompare(b.title));
  return items;
};

const refreshDevoirDatabaseLists = async () => {
  const normal = await listDevoirsFromFolder(DEVOIR_DIR);
  const trash = await listDevoirsFromFolder(DEVOIR_TRASH_DIR);
  setSavedDevoirs(normal);
  setSavedDevoirsTrash(trash);
};

// Helper : détecte l'usage d'un fichier devoir dans Vue classe (année courante + autre année)
const getDevoirUsedClasses = async (fileName: string) => {
  const safe = ensureJsonName(fileName);

  const currentYear = trainingYearRef.current;
  const otherYear: TrainingYear = currentYear === "premiere" ? "deuxieme" : "premiere";

  const metasCurrent = evalMetaList.filter((ev) => ensureJsonName(ev.fileName) === safe);
  let metasOther: EvalMeta[] = [];
  try {
    metasOther = (await loadEvalMetaFromStore(otherYear)).filter(
      (ev) => ensureJsonName(ev.fileName) === safe
    );
  } catch {
    metasOther = [];
  }

  const metas = [...metasCurrent, ...metasOther];
  const classes = Array.from(new Set(metas.map((m) => m.group).filter(Boolean))) as string[];
  return { count: metas.length, classes };
};

const purgeDevoirFromEvalMetaYear = async (year: TrainingYear, safeFileName: string) => {
  try {
    const list = await loadEvalMetaFromStore(year);
    const filtered = list.filter((ev) => ensureJsonName(ev.fileName) !== safeFileName);
    if (filtered.length !== list.length) {
      await saveEvalMetaToStore(filtered, year);
    }
  } catch {
    // ignore
  }
};

const moveDevoirToTrash = async (dv: SavedDevoirMeta) => {
  if (!isTauriRuntime()) return;

  // ✅ Alerte si utilisé dans Vue classe
  const { classes } = await getDevoirUsedClasses(dv.fileName);

  const msg =
    classes.length > 0
      ? `⚠️ Ce devoir est utilisé dans "Vue classe" pour :\n- ${classes.join(
          "\n- "
        )}\n\nLe mettre à la corbeille le retirera automatiquement de ces classes. Continuer ?`
      : `Mettre "${dv.title}" dans la corbeille ?`;

  const ok = await confirm(msg, { title: "Corbeille", kind: "warning" });
  if (!ok) return;


  const srcName = ensureJsonName(dv.fileName);
  const srcPath = `${DEVOIR_DIR}/${srcName}`;

  try {
    // s'assurer que la corbeille existe
    try {
      await mkdir(DEVOIR_TRASH_DIR, {
        baseDir: BaseDirectory.AppLocalData,
        recursive: true,
      } as any);
    } catch {}

    // éviter d’écraser si un fichier du même nom existe déjà
    let dstName = srcName;
    let dstPath = `${DEVOIR_TRASH_DIR}/${dstName}`;
    if (await exists(dstPath, { baseDir: BaseDirectory.AppLocalData })) {
      dstName = `${Date.now()}__${srcName}`;
      dstPath = `${DEVOIR_TRASH_DIR}/${dstName}`;
    }

    // ✅ MOVE (au lieu de copier+supprimer)
    try {
      await rename(srcPath, dstPath, { baseDir: BaseDirectory.AppLocalData } as any);
    } catch (renameErr) {
      // fallback copie+remove + rollback si remove échoue
      const txt = await readTextFile(srcPath, { baseDir: BaseDirectory.AppLocalData });
      await writeTextFile(dstPath, txt, { baseDir: BaseDirectory.AppLocalData });

      try {
        await remove(srcPath, { baseDir: BaseDirectory.AppLocalData });
      } catch (rmErr) {
        try { await remove(dstPath, { baseDir: BaseDirectory.AppLocalData }); } catch {}
        throw rmErr;
      }
    }

    // Nettoyage des références côté evalMetaList
    setEvalMetaList((prev) => prev.filter((ev) => ensureJsonName(ev.fileName) !== srcName));

    // ✅ Idem dans l'autre année (si jamais le même fichier était référencé)
    const currentYear = trainingYearRef.current;
    const otherYear: TrainingYear = currentYear === "premiere" ? "deuxieme" : "premiere";
    await purgeDevoirFromEvalMetaYear(otherYear, srcName);

    await refreshDevoirDatabaseLists();
  } catch (e) {
    console.error("Erreur déplacement corbeille :", { srcPath, file: dv.fileName, e });
    alert(
      "Impossible de mettre ce devoir à la corbeille.\n" +
      String((e as any)?.message ?? e)
    );
  }
};


const restoreDevoirFromTrash = async (dv: SavedDevoirMeta) => {
  if (!isTauriRuntime()) return;

  try {
    const name = ensureJsonName(dv.fileName);
    const srcPath = `${DEVOIR_TRASH_DIR}/${name}`;
    const dstPath = `${DEVOIR_DIR}/${name}`;

    const txt = await readTextFile(srcPath, { baseDir: BaseDirectory.AppLocalData });

    // si un devoir du même nom existe déjà, on évite l’écrasement
    let finalDst = dstPath;
    if (await exists(dstPath, { baseDir: BaseDirectory.AppLocalData })) {
      const newName = `${Date.now()}__${name}`;
      finalDst = `${DEVOIR_DIR}/${newName}`;
    }

    await writeTextFile(finalDst, txt, { baseDir: BaseDirectory.AppLocalData });
    await remove(srcPath, { baseDir: BaseDirectory.AppLocalData });

    await refreshDevoirDatabaseLists();
  } catch (e) {
    console.error("Erreur restauration :", e);
    alert("Impossible de restaurer ce devoir.");
  }
};
const deleteDevoirPermanently = async (dv: SavedDevoirMeta) => {
  if (!isTauriRuntime()) return;

  // ✅ Alerte si utilisé dans Vue classe
  const { classes } = await getDevoirUsedClasses(dv.fileName);

  const msg =
    classes.length > 0
      ? `⚠️ Ce devoir est encore référencé dans "Vue classe" pour :\n- ${classes.join(
          "\n- "
        )}\n\nLe supprimer définitivement le retirera aussi de ces classes. Continuer ?`
      : `Supprimer définitivement "${dv.title}" ? (irréversible)`;

  const ok = await confirm(msg, {
    title: "Suppression définitive",
    kind: "warning",
  });
  if (!ok) return;

  try {
    const name = ensureJsonName(dv.fileName);

    await remove(`${DEVOIR_TRASH_DIR}/${name}`, {
      baseDir: BaseDirectory.AppLocalData,
    });

    // ✅ Sécurité : retirer aussi les références éventuelles dans les 2 années
    await purgeDevoirFromEvalMetaYear("premiere", name);
    await purgeDevoirFromEvalMetaYear("deuxieme", name);

    // ✅ update UI immédiat
    setSavedDevoirsTrash((prev) =>
      prev.filter((x) => ensureJsonName(x.fileName) !== name)
    );

    // ✅ re-scan (au cas où)
    await refreshDevoirDatabaseLists();
  } catch (e) {
    console.error("Erreur suppression définitive :", e);
    alert("Impossible de supprimer définitivement ce devoir.");
  }
};

const makeUniqueEvalId = () => `${Date.now()}-${Math.random().toString(16).slice(2)}`;

const handleSelectDevoirFromDatabase = async (dv: SavedDevoirMeta) => {
  try {
    if (!isTauriRuntime()) {
      alert("La base des devoirs est disponible uniquement dans l'application Tauri.");
      return;
    }

    const inSuiviClasse =
      activeView === "suivi" && suiviMode === "classe" && !!selectedClassIdForSuivi;

    const safeSrcName = ensureJsonName(dv.fileName);
    const srcPath = `${DEVOIR_DIR}/${safeSrcName}`;

    const srcTxt = await readTextFile(srcPath, { baseDir: BaseDirectory.AppLocalData });
    const srcData: any = JSON.parse(srcTxt || "{}");

    // 🔎 ID "template" (dans le fichier devoir). On le conserve pour l'édition du devoir,
    // mais en Vue classe on crée une *instance* (id unique) dans le JSON des évaluations.
    const srcEvalId: string | null =
      typeof srcData?.evaluationId === "string" && srcData.evaluationId.trim()
        ? srcData.evaluationId.trim()
        : null;

    // ✅ En Vue classe : chaque ajout = une nouvelle entrée (nouvel id) dans evaluations_db_*.json
    // ✅ Dans la base des devoirs : on reste sur 1 fichier unique (aucune copie créée)
    const idToUse = inSuiviClasse ? makeUniqueEvalId() : (srcEvalId || makeUniqueEvalId());

    // Si on ouvre le devoir (édition), on garantit qu'il a un evaluationId.
    if (!inSuiviClasse && !srcEvalId) {
      const patched = { ...srcData, evaluationId: idToUse };
      await writeTextFile(srcPath, JSON.stringify(patched, null, 2), {
        baseDir: BaseDirectory.AppLocalData,
      });
    }

    // ✅ On charge toujours le fichier devoir unique
    await loadSavedDevoir(safeSrcName);

    if (inSuiviClasse) {
      const classId = selectedClassIdForSuivi as string;
      const sem = classeSemesterForSuivi;

      setEvalMetaList((prev) => {
        if (prev.some((ev) => ev.id === idToUse)) return prev;

        const now = new Date().toISOString();
        const nameToUse =
          (typeof srcData?.title === "string" && srcData.title.trim()
            ? srcData.title.trim()
            : dv.title) || safeSrcName.replace(/\.json$/i, "");

        return [
          ...prev,
          {
            id: idToUse,
            name: nameToUse,
            fileName: safeSrcName,
            group: classId,
            semester: sem,
            createdAt: now,
          },
        ];
      });
    }

    setDevoirDBOpen(false);
  } catch (e) {
    console.error("Erreur sélection devoir depuis base :", e);
    alert("Impossible d'ajouter ce devoir depuis la base.");
  }
};


  // Données pour l'histogramme d'un élève


  type EvolutionBar = { label: string; fullLabel?: string; value: number | null };

  const MiniEvolutionChart = ({
    bars,
    splitIndex,
    capLine,
    showDevoirs = true,
  }: {
    bars: EvolutionBar[];
    splitIndex: number;
    capLine: number;
    showDevoirs?: boolean;
  }) => {
    const W = 440;
    const H = showDevoirs ? 190 : 150; 
    // marge droite réduite : pas de légende "Découverte / Fondamentaux / Professionnalisation"
    const M = {  
  top: 4,
  right: 18,
  bottom: showDevoirs ? 24 : 4, // ✅ réduit la “zone vide” en bas
  left: 32,
    };
    const plotW = W - M.left - M.right;
    const plotH = H - M.top - M.bottom;
    const maxY = 20;
    const capY = Math.max(0, Math.min(maxY, typeof capLine === "number" && isFinite(capLine) ? capLine : 10));

    const dark = theme === "dark";
    const miniChartPalette = {
      zoneDisc: dark ? "#3b2315" : "#FDE7D8",
      zoneFund: dark ? "#102a3d" : "#E1F2FA",
      zonePro: dark ? "#123221" : "#E7F6EC",
      zoneOpacity: dark ? 0.55 : 1,
      gridStroke: dark ? "rgba(148,163,184,0.28)" : "#7A7A7A",
      gridOpacity: dark ? 0.55 : 0.6,
      tickFill: dark ? "#e5e7eb" : "#444",
      xLabelFill: dark ? "#e5e7eb" : "#333",
      capStroke: dark ? "#f59e0b" : "#8B4E1D",
      sepStroke: dark ? "rgba(226,232,240,0.55)" : "#444",
      barFill: dark ? "#ef4444" : "#7F1D1D",
    } as const;


    const n = Math.max(1, bars.length);
    const step = plotW / n;
    const barW = Math.max(2, step * 0.65);
    const gap = step - barW;

    const yFor = (v: number) => M.top + ((maxY - v) / maxY) * plotH;
    const xFor = (i: number) => M.left + i * step + gap / 2;

    const labelEvery = Math.max(1, Math.ceil(bars.length / 12));

    const displayLabel = (s: string) => {
      const t = String(s || "");
      return t.length > 18 ? t.slice(0, 18) + "…" : t;
    };

    const band = (from: number, to: number, fill: string, opacity = 1) => {
      const y1 = yFor(to);
      const y2 = yFor(from);
      return (
        <rect
          x={M.left}
          y={y1}
          width={plotW}
          height={Math.max(0, y2 - y1)}
          fill={fill}
          fillOpacity={opacity}
        />
      );
    };

    // Zones fixes (0→20) + seuil CAP paramétrable
    const discoveryMax = 5;
    const discTo = Math.min(discoveryMax, maxY);
    const capTop = Math.max(0, Math.min(maxY, capY));
    const fundFrom = discTo;
    const fundTo = Math.max(fundFrom, capTop);
    const proFrom = fundTo;
    const proTo = maxY;

    const ZONES = [
      { key: "disc", label: "Découverte", from: 0, to: discTo, fill: miniChartPalette.zoneDisc },
      { key: "fund", label: "Apprentissages des fondamentaux", from: fundFrom, to: fundTo, fill: miniChartPalette.zoneFund },
      { key: "pro", label: "Professionnalisation", from: proFrom, to: proTo, fill: miniChartPalette.zonePro },
    ].filter((z) => z.to > z.from + 1e-6);

    const tickValues = Array.from(
      new Set([0, discTo, capTop, 10, 15, 20].map((v) => Math.round(v * 10) / 10))
    ).sort((a, b) => a - b);

    // IMPORTANT :
    // Quand on augmente le nombre de cartes par ligne, chaque carte devient plus étroite.
    // Avec un SVG en largeur 100% + hauteur fixe, le viewport change de ratio.
    // Le SVG conserve le ratio du viewBox (preserveAspectRatio par défaut) → effet "letterbox"
    // (blanc en haut/bas) perçu comme des marges qui augmentent.
    // Solution : verrouiller le ratio du conteneur sur le ratio du viewBox.
    const aspectRatio = `${W} / ${H}`;

    return (
      <div className="w-full" style={{ aspectRatio }}>
        <svg
          viewBox={`0 0 ${W} ${H}`}
          className="w-full h-full"
          preserveAspectRatio="xMidYMid meet"
        >
        {/* bandes de niveaux (0-20) */}
        {ZONES.map((z) => band(z.from, z.to, z.fill, miniChartPalette.zoneOpacity))}

        {/* grilles */}
        {tickValues.map((v) => (
          <g key={v}>
            <line
              x1={M.left}
              x2={M.left + plotW}
              y1={yFor(v)}
              y2={yFor(v)}
              stroke={miniChartPalette.gridStroke}
              strokeWidth={0.8}
              opacity={miniChartPalette.gridOpacity}
            />
            <text
              x={M.left - 6}
              y={yFor(v) + 3}
              textAnchor="end"
              fontSize={9}
              fill={miniChartPalette.tickFill}
            >
              {v}
            </text>
          </g>
        ))}

        {/* ligne CAP */}
        <line
          x1={M.left}
          x2={M.left + plotW}
          y1={yFor(capY)}
          y2={yFor(capY)}
          stroke={miniChartPalette.capStroke}
          strokeWidth={2.2}
        />
        <text
          x={M.left + plotW - 4}
          y={yFor(capY) - 4}
          textAnchor="end"
          fontSize={10.5}
          fontWeight={800}
          fill={miniChartPalette.capStroke}
        >
          CAP
        </text>

        {/* séparation année 1 / année 2 */}
        {splitIndex > 0 && splitIndex < bars.length && (
          <line
            x1={M.left + splitIndex * step}
            x2={M.left + splitIndex * step}
            y1={M.top}
            y2={M.top + plotH}
            stroke={miniChartPalette.sepStroke}
            strokeWidth={1}
            strokeDasharray="4 4"
            opacity={0.5}
          />
        )}

        {/* barres */}
        {bars.map((b, i) => {
          if (b.value == null) return null;
          const v = Math.max(0, Math.min(maxY, b.value));
          const x = xFor(i);
          const y = yFor(v);
          const h = yFor(0) - y;
          return (
            <g key={i}>
              <title>{(b.fullLabel ?? b.label)} — {v.toFixed(1)} / 20</title>
              <rect
                x={x}
                y={y}
                width={barW}
                height={Math.max(0, h)}
                fill={miniChartPalette.barFill}
              />
            </g>
          );
        })}

        {/* labels X */}
        {showDevoirs && bars.map((b, i) => {
          if (i % labelEvery !== 0) return null;
          const x = xFor(i) + barW / 2;
          const y = M.top + plotH + 18;
          return (
            <text
              key={i}
              x={x}
              y={y}
              fontSize={8.5}
              fill={miniChartPalette.xLabelFill}
              textAnchor="end"
              transform={`rotate(-55 ${x} ${y})`}
            >
              <title>{b.fullLabel ?? b.label}</title>
              {displayLabel(b.label)}
            </text>
          );
        })}
        </svg>
      </div>
    );
  };

const handleRemoveEvalFromClasseSemester = (evalId: string) => {
  const ev = evalMetaList.find((x) => x.id === evalId);

  const ok = window.confirm(
    "Supprimer ce devoir et effacer toutes les notes + niveaux de synthèse associés ? (irréversible)"
  );
  if (!ok) return;

  // 1) Retirer la colonne (meta)
  setEvalMetaList((prev) => prev.filter((x) => x.id !== evalId));

  // 2) Désélectionner si besoin
  if (selectedNoteEvalId === evalId) setSelectedNoteEvalId(null);
  if (selectedEvalIdForClasse === evalId) setSelectedEvalIdForClasse(null);

  // 3) Purger NOTATION_DB (année scolaire courante, classe concernée)
  try {
    const schoolYear = getCurrentSchoolYear();
    const classId = ev?.group;

    setNotationDB((prev) => {
      const next: NotationDB = { ...prev };
      const yearBucket: any = { ...(next[schoolYear] || {}) };

      if (classId && yearBucket[classId]) {
        const classBucket: any = { ...(yearBucket[classId] || {}) };
        if (classBucket[evalId]) delete classBucket[evalId];
        yearBucket[classId] = classBucket;
      } else {
        // fallback: si pas de classe, on supprime partout (rare)
        Object.keys(yearBucket).forEach((cls) => {
          const classBucket: any = { ...(yearBucket[cls] || {}) };
          if (classBucket[evalId]) delete classBucket[evalId];
          yearBucket[cls] = classBucket;
        });
      }

      next[schoolYear] = yearBucket;
      return next;
    });
  } catch (e) {
    console.warn("Purge notationDB échouée:", e);
  }

  // 4) Purger SKILLS_DB (clé = evalId||comp ; legacy = evalName||comp)
  try {
    const classId = ev?.group;
    const legacyName = (ev?.name || "").trim();
    if (!classId) return;

    setSkillsDB((prev) => {
      const classRec: any = (prev as any)[classId];
      if (!classRec) return prev;

      const next: SkillsDB = { ...prev };
      const nextClassRec: any = { ...classRec };
      (next as any)[classId] = nextClassRec;

      Object.entries(classRec).forEach(([studentName, studentRecordAny]) => {
        const studentRecord = (studentRecordAny || {}) as Record<string, any>;
        let changed = false;
        const nextStudent: any = { ...studentRecord };

        Object.keys(studentRecord).forEach((k) => {
          if (k.startsWith(`${evalId}||`)) {
            delete nextStudent[k];
            changed = true;
            return;
          }
          if (legacyName && k.startsWith(`${legacyName}||`)) {
            delete nextStudent[k];
            changed = true;
            return;
          }
        });

        if (changed) nextClassRec[studentName] = nextStudent;
      });

      return next;
    });
  } catch (e) {
    console.warn("Purge skillsDB échouée:", e);
  }
};

  // --- Helpers UI ---
  const isTaskExpanded = (task: string) => expandedTasks[task] ?? true;
  const toggleTaskExpanded = (task: string) => setExpandedTasks(prev => ({ ...prev, [task]: !(prev[task] ?? true) }));
  const isCompExpanded = (compKey: string) => expandedCompetences[compKey] ?? false;
  const toggleCompExpanded = (compKey: string) => setExpandedCompetences(prev => ({ ...prev, [compKey]: !(prev[compKey] ?? false) }));

  const toggleSubCrit = (key: string, comp: string, item: string) => {
    const [taskLabel] = key.split("||");
    const compScopedKey = taskLabel + "||" + comp;

    setSelectedSubCrit(prevSub => {
      const on = prevSub.includes(key);
      const nextSub = on ? prevSub.filter(k => k !== key) : [...prevSub, key];

      if (on) {
        const stillUnderComp = nextSub.some(k => k.startsWith(taskLabel + "||" + comp + "::"));
        if (!stillUnderComp) setSelectedCompetences(prevComps => prevComps.filter(c => c !== compScopedKey));

        setSelectedCriteres(prevCrit => {
          const critKey = comp + "::" + item;
          const remainsForItem = nextSub.some(k => k.startsWith(taskLabel + "||" + comp + "::" + item + "::"));
          return remainsForItem ? prevCrit : prevCrit.filter(k => k !== critKey);
        });
      } else {
        setSelectedCriteres(prevCrit => {
          const critKey = comp + "::" + item;
          return prevCrit.includes(critKey) ? prevCrit : [...prevCrit, critKey];
        });
        setSelectedCompetences(prevComps => prevComps.includes(compScopedKey) ? prevComps : [...prevComps, compScopedKey]);
      }
      return nextSub;
    });
  };

  const toggleExigenceSelection = (critKey: string, ex: string) => {
    setSelectedExigence(prev => {
      const current = prev[critKey] ?? getEffectiveExigences(critKey);
      const next = current.includes(ex) ? current.filter(e => e !== ex) : [...current, ex];
      return { ...prev, [critKey]: next };
    });
  };

  const removeFromCell = (critKey: string, ex: string) => {
    setSelectedExigence(prev => {
      const current = prev[critKey] ?? getEffectiveExigences(critKey);
const next = { ...prev };
next[critKey] = current.filter(e => e !== ex);
return next;
    });
  };

  const getDBExigences = (critKey: string): string[] => {
    const { comp, item } = parseScopedCritKey(critKey);
    if (!critResDB) return [];
    const compEntry = critResDB[comp];
    const itemEntry = compEntry?.[item];
    return itemEntry?.exigences ?? [];
  };

  const getEffectiveExigences = (critKey: string): string[] => {
    const base = getDBExigences(critKey) || [];
    const custom = customExigences[critKey] || [];
    const set = new Set<string>([...base, ...custom]);
    return Array.from(set);
  };

  const openManage = (critKey: string) => {
    setCustomExigences(prev => {
      if (prev[critKey]) return prev;
      const base = getDBExigences(critKey);
      const { comp, item } = parseScopedCritKey(critKey);
      const persisted = getPersistedExigencesFor(comp, item) ?? [];
      return { ...prev, [critKey]: Array.from(new Set([...base, ...persisted])) };
    });
    setManageKey(critKey);
    setDrawerInput("");
  };

  const addDrawerExigence = () => {
    if (!manageKey) return;
    const v = drawerInput.trim();
    if (!v) return;
    setCustomExigences(prev => {
      const base = prev[manageKey!] ?? [];
      const arr = [...base];
      if (!arr.includes(v)) arr.push(v);
      return { ...prev, [manageKey!]: arr };
    });
    setSelectedExigence(prev => {
      const current = prev[manageKey!] ?? [];
      return current.includes(v) ? prev : { ...prev, [manageKey!]: [...current, v] };
    });
    setDrawerInput("");
  };

  const removeDrawerExigence = (idx: number) => {
    if (!manageKey) return;
    setCustomExigences(prev => {
      const arr = [...(prev[manageKey!] ?? getDBExigences(manageKey!))];
      if (idx < 0 || idx >= arr.length) return prev;
      const ex = arr[idx];
      arr.splice(idx, 1);
      const next = { ...prev, [manageKey!]: arr };

      // remove from selectedExigence so UI selection updates immediately
      setSelectedExigence(prevSel => {
        const cur = prevSel[manageKey!] ?? [];
        return { ...prevSel, [manageKey!]: cur.filter(e => e !== ex) };
      });

      // Also remove from persistedExigencesDB if present in the persisted "library"
      try {
        const { task, comp, item } = parseScopedCritKey(manageKey!);
        const code = __extractCode(comp) || comp;
        const codeKey = __norm(code);
        const itemKey = __norm(__cleanItem(item));
        const pair = codeKey + '::' + itemKey;
        const rawKey = rawKeyByPairRef.current[pair] || `${code} II ${__cleanItem(item)} :`;
        const currentPersist = Array.isArray((persistedExigencesDB as any)?.[rawKey]) ? (persistedExigencesDB as any)[rawKey] as string[] : [];
        if (currentPersist.includes(ex)) {
          const nextPersist = { ...(persistedExigencesDB || {}) };
          const filtered = currentPersist.filter(v => v !== ex);
          if (filtered.length > 0) nextPersist[rawKey] = filtered;
          else delete nextPersist[rawKey];
          setPersistedExigencesDB(nextPersist);
          setExigencesIndex(buildExigencesIndex(nextPersist));
          try { localStorage.setItem('exigences_db_cache', JSON.stringify(nextPersist)); } catch {}
          (async () => {
            try {
              if (isTauriRuntime() && await getTauriFs()) {
                await saveExigencesToTauri(nextPersist);
              }
            } catch (e) {
              console.warn('saveExigencesToTauri failed', e);
            }
          })();
        }
      } catch (e) {
        // ignore errors here to avoid crashing manage UI
        console.warn('Failed to remove from persistedExigencesDB', e);
      }

      return next;
    });
  };

  const onLogoUpload = async (f: File) => {
    const reader = new FileReader();
    reader.onload = () => setLogoDataUrl(String(reader.result));
    reader.readAsDataURL(f);
  };

  // Petit helper pour sécuriser le HTML
  const escapeHtml = (unsafe: string) =>
    (unsafe || "")
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&#039;");

  // Construit les lignes du tableau d'exigences perso (comme l'étape 3)
  const buildPreviewRows = () => {
    if (!critResDB) return [];

    const rows: {
      task: string;
      comp: string;
      item: string;
      criteres: string[];
      exigences: string[];
    }[] = [];

    sortByTaskNumber(selectedTasks).forEach((task) => {
      const comps = (tcMap[task] || []) as string[];

      comps.forEach((comp) => {
        const compEntry = (critResDB as any)[comp] || {};
        const itemKeys = Object.keys(compEntry);

        itemKeys.forEach((item) => {
          // On garde seulement les items où au moins un sous-critère est sélectionné
          const prefix = `${task}||${comp}::${item}::`;
          const subList: string[] =
            (critResDB &&
              (critResDB as any)[comp] &&
              (critResDB as any)[comp][item]?.resultats) ||
            [];

          const selectedIdx = selectedSubCrit
            .filter((k) => k.startsWith(prefix) && !/::E\d+$/.test(k))
            .map((k) => {
              const m = k.match(/::(\d+)$/);
              return m ? Number(m[1]) : null;
            })
            .filter((n): n is number => n !== null);

          if (selectedIdx.length === 0) return;

          const critKey = `${task}||${comp}::${item}`;
          const normKey = normalizeKeyFromCritKey(critKey);

          const options = Array.from(
            new Set([
              ...getEffectiveExigences(critKey),
              ...(persistedExigencesDB?.[normKey] ?? []),
              ...(getPersistedExigencesFor(comp, item) ?? []),
              ...(customExigences?.[critKey] ?? []),
            ] as string[])
          );

          const baseSelected =
            selectedExigence[critKey] ?? getEffectiveExigences(critKey);
          const chosenAll = Array.from(new Set(baseSelected));
          const chosenCustom = chosenAll.filter((ex) => options.includes(ex));

          rows.push({
            task,
            comp,
            item,
            criteres: selectedIdx.map((i) => subList[i]),
            exigences: chosenCustom,
          });
        });
      });
    });

    return rows;
  };
// Calcule un niveau 0–3 par compétence à partir du devoir en cours
function computeLevelsFromCurrentDevoir(
  scoresByCriteria: Record<string, number>
): Record<string, Level1to4> {
  const rows = buildPreviewRows();
  if (!rows || rows.length === 0) {
    return {};
  }

  let evalLabel = "";
  if (selectedNoteEvalId) {
    const meta = evalMetaList.find((ev) => ev.id === selectedNoteEvalId);
    if (meta?.name) {
      evalLabel = meta.name.trim();
    }
  }

  type Agg = { weighted: number; totalWeight: number };
  const agg: Record<string, Agg> = {};

  rows.forEach((row) => {
    row.criteres.forEach((_critereText: string, idx: number) => {
      const key = `${row.task}||${row.comp}::${row.item}::crit#${idx}`;
      const score = scoresByCriteria[key];
      const weight = notationWeights[key] ?? 1;

      if (typeof score !== "number") return;

      const baseCompLabel = row.comp;
      const compLabel = baseCompLabel;

      if (!agg[compLabel]) {
        agg[compLabel] = { weighted: 0, totalWeight: 0 };
      }

      agg[compLabel].weighted += score * weight;
      agg[compLabel].totalWeight += weight;
    });
  });

  const result: Record<string, Level1to4> = {};
  for (const [compLabel, { weighted, totalWeight }] of Object.entries(agg)) {
    if (totalWeight === 0) continue;

    const avg = weighted / totalWeight;
    let lvl: Level1to4;
    if (avg < 1.5) lvl = 1;
    else if (avg < 2.5) lvl = 2;
    else if (avg < 3.5) lvl = 3;
    else lvl = 4;

    result[compLabel] = lvl;
  }

  return result;
}


// 🔁 Rendu réutilisable de la NOTATION critériée

const renderNotationCriteree = (options?: { lockWeights?: boolean }) => {
  const lockWeights = options?.lockWeights ?? false;
  const rows = buildPreviewRows();

  if (!rows || rows.length === 0) {
    return (
      <div className="text-sm text-neutral-600 dark:text-neutral-300">
        Sélectionnez d&apos;abord des critères dans les onglets{" "}
        <strong>COMPÉTENCES</strong> et <strong>EXIGENCES</strong>.
      </div>
    );
  }

  // Chaque critère de chaque item devient une « ligne de notation »
  const critLines = rows.flatMap((row) =>
    row.criteres.map((critereText, idx) => {
      const key = `${row.task}||${row.comp}::${row.item}::crit#${idx}`;
      return {
        key,
        task: row.task,
        comp: row.comp,
        item: row.item,
        critere: critereText,
        exigences: row.exigences,
      };
    })
  );

  if (critLines.length === 0) {
    return (
      <div className="text-sm text-neutral-600 dark:text-neutral-300">
        Aucun critère sélectionné. Utilisez d&apos;abord l&apos;onglet <strong>COMPÉTENCES</strong>.
      </div>
    );
  }

    // 🔀 Choix de la source des scores :
  // - DEVOIR (lockWeights = false) → notationScores (barème / prévisualisation)
  // - NOTE   (lockWeights = true)  → studentNotationScores (par élève)
  const scoreMap = lockWeights ? studentNotationScores : notationScores;
  const getScoreForView = (key: string) => scoreMap[key];
  const setScoreForView = lockWeights
    ? setStudentNotationScores
    : setNotationScores;

   // 🔹 Poids total (tous critères confondus)
const totalWeight = critLines.reduce(
  (sum, r) => sum + getWeight(r.key),
  0
);
// 🔹 Calcul de la note de base (sur 20) à partir des poids + scores
let totalWeightForMark = 0;
let weightedAchieved = 0;

critLines.forEach((r) => {
  const w = notationWeights[r.key] ?? 1;
  const s = getScoreForView(r.key); // 0,1,2,3,4 (0 = NR)

  if (typeof s !== "number") return; // pas encore noté

  totalWeightForMark += w;
  weightedAchieved += w * (s / 4);
});

const baseMarkOn20 =
  totalWeightForMark > 0 ? (weightedAchieved / totalWeightForMark) * 20 : 0;

  // 🔹 Bonus / malus d'engagement uniquement dans la vue "notation par devoir"
  // (lockWeights = true côté onglet NOTE)
  const factor = lockWeights ? computeEngagementFactor(engagementLevel) : 1;

  // on borne entre 0 et 20 pour éviter les valeurs aberrantes
  const finalMark = Math.max(0, Math.min(20, baseMarkOn20 * factor));

  // 🟦 Statut AB (absent) : affichage + gel de la notation pour cet élève
  const schoolYearForAbsence = getCurrentSchoolYear();
  const classNameForAbsence = selectedClassIdForSuivi;
  const evalIdForAbsence = selectedNoteEvalId;
  const studentNameForAbsence = selectedNoteStudent;
  const currentNotationEntryForAbsence: NotationEntry | undefined =
    lockWeights && classNameForAbsence && evalIdForAbsence && studentNameForAbsence
      ? ((((notationDB[schoolYearForAbsence] || {})[classNameForAbsence] || {})[
          evalIdForAbsence
        ] || {})[studentNameForAbsence] as NotationEntry | undefined)
      : undefined;
  const isAbsentForThisEval = currentNotationEntryForAbsence?.status === "AB";
  const isNonNotedForThisEval = currentNotationEntryForAbsence?.status === "N.NOT";
  const isFrozenForThisEval = isAbsentForThisEval || isNonNotedForThisEval;

  // 🔹 Regroupement par tâche (affichage proche de l’onglet DEVOIR)
  const groupedByTask = critLines.reduce<
    Record<string, (typeof critLines)[number][]>
  >((acc, r) => {
    const label = r.task || "Sans tâche";
    if (!acc[label]) acc[label] = [];
    acc[label].push(r);
    return acc;
  }, {});

  return (
    <div className="space-y-4">


{/* Bandeau explicatif + engagement + note + bouton */}
<div className="flex flex-wrap items-start justify-between gap-3">
  {/* Colonne gauche : Notation critériée + texte + engagement (en dessous) */}
  <div className="flex flex-col gap-2 max-w-4xl">
    <div className="border border-sky-200 dark:border-sky-400/40 rounded-2xl px-4 py-3 bg-white dark:bg-[#182433] keep-light shadow-sm text-xs text-neutral-700 dark:text-neutral-300 space-y-1">
      <h2 className="text-base font-semibold text-neutral-900 dark:text-neutral-300">Notation critériée</h2>

      {lockWeights ? (
        // 🔒 Mode NOTE : on saisit les niveaux, les poids sont figés
        <p className="text-xs text-neutral-500 max-w-4xl">
          Dans cette vue, saisir uniquement le{" "}
          <strong>niveau de maîtrise</strong> pour chaque critère (NR, 1, 2, 3, 4).
          Les <strong>poids</strong> sont définis dans l&apos;onglet{" "}
          <strong>DEVOIR</strong>. La <strong>note finale</strong> est
          calculée à partir des niveaux renseignés, des pondérations et de
          l&apos;éventuel <strong>ajustement d&apos;engagement de l&apos;élève</strong>.
          <br />
          <span className="font-semibold uppercase">
            Niveau de maîtrise :
          </span>{" "}
          NR = 0 = Non Réalisé, 1 = Non acquis, 2 = En cours d&apos;acquisition,
          3 = Maîtrise satisfaisante, 4 = Très bonne maîtrise.
        </p>
      ) : (
        // 🛠️ Mode DEVOIR : on construit le barème et les poids
        <p className="text-xs text-neutral-500 max-w-4xl">
          Dans cet onglet, tu construis le <strong>barème</strong> du devoir.
          Pour chaque <strong>critère d&apos;évaluation</strong>, saisis un{" "}
          <strong>poids en %</strong> (10, 20, 40…) qui reflète son importance
          dans le devoir. Plus le <strong>poids</strong> est élevé, plus il
          compte dans la <strong>note finale</strong>. Le total des poids peut
          dépasser <strong>100&nbsp;%</strong> : ils sont utilisés comme{" "}
          <strong>coefficients relatifs</strong> et automatiquement pris en
          compte pour calculer la note sur 20.
          <br />
          <span className="font-semibold uppercase">
            Niveau de maîtrise
          </span>{" "}
          (NR = 0 = Non Réalisé, 1 = Non acquis, 2 = En cours d&apos;acquisition,
          3 = Maîtrise satisfaisante, 4 = Très bonne maîtrise).
        </p>
      )}
    </div>

{/* Engagement de l'élève en LIGNE (compact) avec contours colorés */}
{lockWeights && selectedNoteStudent && (
  <div className="border border-neutral-200 dark:border-sky-400/35 rounded-2xl px-4 py-3 bg-yellow-50 dark:bg-[#1f2d42] keep-light shadow-sm text-xs text-neutral-700 dark:text-neutral-300 max-w-4xl space-y-1">
  <div className="flex flex-wrap items-center gap-2 text-[12px]">
    <h2 className="text-base font-semibold text-neutral-900 dark:text-neutral-300">ENGAGEMENT DE L&apos;ÉLÈVE :</h2>

    {(() => {
      const OPTIONS: Array<{ id: EngagementLevel; label: string }> = [
        { id: "absence", label: "Peu engagé" },
        { id: "attente", label: "En attente" },
        { id: "normal", label: "Normal" },
        { id: "engage", label: "Engagé" },
        { id: "volontaire", label: "Très engagé" },
      ];

      const hexToRgba = (hex: string, alpha: number) => {
        const h = hex.replace("#", "");
        const full = h.length === 3 ? h.split("").map((ch) => ch + ch).join("") : h;
        const n = parseInt(full, 16);
        const r = (n >> 16) & 255;
        const g = (n >> 8) & 255;
        const b = n & 255;
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
      };

      const COLORS: Record<EngagementLevel, { bg: string; text: string }> = {
        absence: { bg: "#ef4444", text: "#111827" },     // rouge
        attente: { bg: "#facc15", text: "#111827" },     // jaune
        normal: { bg: "#38bdf8", text: "#111827" },      // bleu ciel
        engage: { bg: "#22c55e", text: "#111827" },      // vert
        volontaire: { bg: "#059669", text: "#111827" },  // vert foncé
      };

      return OPTIONS.map((opt) => {
        const isActive = engagementLevel === opt.id;
        const c = COLORS[opt.id];

        return (
          <button
            key={opt.id}
            type="button"
            disabled={lockWeights && isFrozenForThisEval}
            onClick={() => {
              if (lockWeights && isFrozenForThisEval) return;
              setEngagementLevel(opt.id);
            }}
            style={{ backgroundColor: isActive ? c.bg : hexToRgba(c.bg, 0.25), borderColor: c.bg, color: c.text }}
            className={classNames(
              "inline-flex items-center gap-1 px-2 py-1 rounded-full border text-[10px] transition",
              "disabled:opacity-50 disabled:cursor-not-allowed",
              isActive ? "font-semibold" : "hover:brightness-95",
              isActive &&
                "ring-2 ring-offset-1 ring-neutral-900/30 dark:ring-neutral-100/60 ring-offset-white dark:ring-offset-[#0b1220] shadow-sm"
            )}
          >
            <span
              className="w-2 h-2 rounded-full border flex items-center justify-center"
              style={{ borderColor: c.text }}
              aria-hidden="true"
            >
              {isActive && (
                <span
                  className="w-1.5 h-1.5 rounded-full"
                  style={{ backgroundColor: c.text }}
                />
              )}
            </span>

            <span>{opt.label}</span>
          </button>
        );
      });
    })()}

  </div>
  </div>
)}

  </div>
  {/* Encadré STATUT entre engagement et note */}
  {lockWeights && selectedNoteStudent && (
    <div className="border border-dark-800 dark:border-sky-400/40 rounded-2xl px-3 py-3 bg-white dark:bg-[#182433] keep-light shadow-sm text-xs text-neutral-700 dark:text-neutral-300 self-start">
      <div className="text-[11px] font-semibold text-neutral-700 dark:text-neutral-300 mb-2">STATUT :</div>
      <div className="flex items-center gap-2">
        <Button
          size="sm"
          variant="outline"
          className={classNames(
            "!h-8 !px-3 !rounded-full !border !text-xs !font-semibold",
            isAbsentForThisEval
              ? "!bg-red-600 !text-white !border-red-600 hover:!bg-red-700"
              : "!bg-white !text-neutral-900 !border-neutral-300 hover:!bg-amber-100/70 dark:!bg-[#182433] dark:!text-neutral-50 dark:!border-neutral-600 dark:hover:!bg-[#3d2707]"
          )}
          onClick={toggleCurrentStudentAbsent}
        >
          {isAbsentForThisEval ? "Annuler AB" : "AB"}
        </Button>

        <Button
          size="sm"
          variant="outline"
          className={classNames(
            "!h-8 !px-3 !rounded-full !border !text-xs !font-semibold",
            isNonNotedForThisEval
              ? "!bg-violet-600 !text-white !border-violet-600 hover:!bg-violet-700"
              : "!bg-white !text-neutral-900 !border-neutral-300 hover:!bg-amber-100/70 dark:!bg-[#182433] dark:!text-neutral-50 dark:!border-neutral-600 dark:hover:!bg-[#3d2707]"
          )}
          onClick={toggleCurrentStudentNonNoted}
        >
          {isNonNotedForThisEval ? "Annuler N.NOT" : "N.NOT"}
        </Button>
      </div>
    </div>
  )}


  {/* Colonne droite : note finale + bouton Enregistrer EN DESSOUS */}
  <div className="border border-sky-200 dark:border-sky-400/40 rounded-2xl px-3 py-2 bg-white dark:bg-[#182433] keep-light shadow-sm text-right text-sm min-w-[230px]">
    <div className="text-xs text-neutral-500">Pondération totale</div>
    <div className="font-semibold">{totalWeight.toFixed(1)} %</div>
    <div className="text-xs text-neutral-500 mt-1">
      Note finale (sur 20)
    </div>
<div className="text-lg font-bold">
  {isAbsentForThisEval ? "AB" : isNonNotedForThisEval ? "N.NOT" : `${finalMark.toFixed(2)} / 20`}
</div>

{isFrozenForThisEval && (
  <div className="text-xs text-neutral-500 mt-1">
    {isAbsentForThisEval ? "Élève absent : notation figée" : "Élève non noté : notation figée"}
  </div>
)}

{lockWeights && selectedNoteStudent && (
  <div className="mt-3 flex justify-end gap-2">
    <Button size="sm" onClick={saveCurrentStudentNotation} disabled={isFrozenForThisEval}>
      Enregistrer la notation de {selectedNoteStudent}
    </Button>
  </div>
)}

  </div>
</div>


      {/* Un bloc par TÂCHE */}
      <div className="space-y-5">
        {Object.entries(groupedByTask).map(([taskLabel, items]) => {
          const taskWeight = items.reduce(
            (sum, r) => sum + (getWeight(r.key) || 0),
            0
          );
          const taskPct =
            totalWeight > 0 ? (taskWeight / totalWeight) * 100 : 0;

          // 🔹 Trouver le groupe (G1, G2, G3) en fonction du numéro de tâche
          const tNum = taskNumber(taskLabel);
          const group = GROUPS.find(
            (g) => tNum >= g.range[0] && tNum <= g.range[1]
          );
          const groupStyles = group ? GROUP_STYLES[group.key] : undefined;

          type RowWithSpans = {
            row: (typeof items)[number];
            showCompCell: boolean;
            compRowSpan: number;
            showItemCell: boolean;
            itemRowSpan: number;
          };

          const rowsWithSpans: RowWithSpans[] = [];

          for (let i = 0; i < items.length; i++) {
            const current = items[i];

            // ----- Fusion COMPÉTENCE -----
            let showCompCell = true;
            let compRowSpan = 1;

            if (i > 0 && items[i - 1].comp === current.comp) {
              // même compétence que la ligne précédente → pas de cellule
              showCompCell = false;
              compRowSpan = 0;
            } else {
              // on compte combien de lignes consécutives partagent la même compétence
              for (let j = i + 1; j < items.length; j++) {
                if (items[j].comp === current.comp) {
                  compRowSpan++;
                } else {
                  break;
                }
              }
            }

            // ----- Fusion ÊTRE CAPABLE DE (comp + item identiques) -----
            let showItemCell = true;
            let itemRowSpan = 1;

            if (
              i > 0 &&
              items[i - 1].comp === current.comp &&
              items[i - 1].item === current.item
            ) {
              // même comp + même item que la ligne précédente → pas de cellule
              showItemCell = false;
              itemRowSpan = 0;
            } else {
              // on compte combien de lignes consécutives ont le même couple (comp, item)
              for (let j = i + 1; j < items.length; j++) {
                if (
                  items[j].comp === current.comp &&
                  items[j].item === current.item
                ) {
                  itemRowSpan++;
                } else {
                  break;
                }
              }
            }

            rowsWithSpans.push({
              row: current,
              showCompCell,
              compRowSpan,
              showItemCell,
              itemRowSpan,
            });
          }

          return (
            <section key={taskLabel}>
              {/* 🔹 Encadré coloré suivant le groupe G1/G2/G3 */}
              <div
                className={classNames(
                  "border rounded-2xl bg-white dark:bg-[#1f2d42] shadow-sm px-4 py-3 space-y-3",
                  groupStyles?.accentBorder || "border-neutral-200 dark:border-sky-400/35"
                )}
              >
                {/* En-tête de la tâche */}
                <div className="flex items-center justify-between">
                  <div className="flex items-center gap-2">
                    <span className="inline-block w-3 h-3 rounded-[4px] bg-neutral-900 dark:bg-neutral-100" />
                    <h3 className="text-sm sm:text-base font-semibold text-neutral-900 dark:text-neutral-300">
                      {taskLabel}
                    </h3>
                  </div>

                  <div className="text-[11px] sm:text-xs text-neutral-500 text-right flex items-center gap-1">
                    <span>{items.length} critère(s)</span>
                    <span className="text-[10px] text-neutral-400">•</span>
                    <span>Total poids % : {taskWeight.toFixed(1)}</span>
                    {totalWeight > 0 && (
                      <span className="ml-1 text-[10px] font-semibold text-neutral-900 dark:text-neutral-300">
                        ({taskPct.toFixed(1)} % de la note finale)
                      </span>
                    )}
                  </div>
                </div>

                {/* Tableau de notation pour cette tâche */}
                <div className="overflow-x-auto">
                  <table className="w-full text-xs border-collapse">
                    <thead>
                      <tr className="bg-neutral-50 dark:bg-[#1f2d42]">
                        <th className="border px-2 py-1 text-left w-[20%]">
                          Compétence
                        </th>
                        <th className="border px-2 py-1 text-left w-[20%]">
                          Être capable de…
                        </th>
                        <th className="border px-2 py-1 text-left w-[32%]">
                          Critère d&apos;évaluation
                        </th>
                        <th className="border px-2 py-1 text-left w-[10%]">
                          Exigence
                        </th>
                        <th className="border px-2 py-1 text-center w-[7%] dark:bg-[#0f1b2d] dark:text-neutral-300">Poids (%)</th>
                        <th className="border px-2 py-1 text-center w-[6%]">
                          Niveau
                        </th>
                      </tr>
                    </thead>

                    <tbody>
                      {rowsWithSpans.map(
                        ({
                          row: r,
                          showCompCell,
                          compRowSpan,
                          showItemCell,
                          itemRowSpan,
                        }) => {
                          const w = getWeight(r.key) || 0;
                          const s = getScoreForView(r.key);

                          const fam = parseCompetencyFamily(r.comp);
                          const famKey =
                            fam === "C1" ||
                            fam === "C2" ||
                            fam === "C3" ||
                            fam === "C4"
                              ? fam
                              : null;
                          const famStyle = famKey
                            ? FAMILY_STYLES[famKey]
                            : null;
                          const famLabel =
                            famKey === "C1"
                              ? "COMMUNIQUER"
                              : famKey === "C2"
                              ? "PRÉPARER"
                              : famKey === "C3"
                              ? "RÉALISER"
                              : famKey === "C4"
                              ? "CONTRÔLE"
                              : "";

                          const isNR = s === 0;

                          return (
                            <tr key={r.key}>
                              {/* COL 1 — Compétence (fusionnée) */}
                              {showCompCell && (
                                <td
                                  className="border px-2 py-1 align-middle"
                                  rowSpan={compRowSpan}
                                >
                                  <div className="flex flex-col gap-0.5">
                                    <div className="flex items-center gap-1 flex-wrap">
                                      {famStyle && (
                                        <span
                                          className={classNames(
                                            "inline-flex items-center gap-1 rounded-full px-1.5 py-0.5 text-[10px] font-semibold",
                                            famStyle.chipBg,
                                            famStyle.chipText
                                          )}
                                        >
                                          <span
                                            className={classNames(
                                              "w-2 h-2 rounded-full",
                                              famStyle.bullet
                                            )}
                                          />
                                          {famLabel}
                                        </span>
                                      )}
                                      <span className="text-[11px] font-semibold">
                                        {r.comp}
                                      </span>
                                    </div>
                                  </div>
                                </td>
                              )}

                              {/* COL 2 — Être capable de… (fusionnée si même comp+item) */}
                              {showItemCell && (
                                <td
                                  className="border px-2 py-1 align-middle"
                                  rowSpan={itemRowSpan}
                                >
                                  <div className="text-[11px] text-neutral-500 dark:text-neutral-300">
                                    {r.item}
                                  </div>
                                </td>
                              )}

                              {/* COL 3 — Critère d'évaluation */}
                              <td className="border px-2 py-1 align-middle">
                                {r.critere}
                              </td>

                              {/* COL 4 — Exigences */}
                              <td className="border px-2 py-1 align-middle">
                                {r.exigences && r.exigences.length > 0 ? (
                                  <ul className="list-disc pl-4 space-y-0.5">
                                    {r.exigences.map((ex, i) => (
                                      <li key={i}>{ex}</li>
                                    ))}
                                  </ul>
                                ) : (
                                  <span className="text-[11px] text-neutral-400 italic">
                                    Aucune exigence personnalisée
                                  </span>
                                )}
                              </td>

                              {/* COL 5 — Poids (%) */}
                              <td className="border px-2 py-1 text-center align-middle dark:bg-[#0f1b2d]">
                                {lockWeights ? (
                                  <span className="inline-block min-w-[3rem] text-xs">
                                    {Number.isFinite(w) ? w : 0}
                                  </span>
                                ) : (
                                  <Input
                                    type="number"
                                    min={0}
                                    step={1}
                                    className="h-7 w-16 mx-auto text-center text-xs !bg-white dark:!bg-[#0b1220] !text-neutral-900 dark:!text-neutral-50 !border-neutral-300 dark:!border-neutral-700/60 placeholder:text-neutral-500 dark:placeholder:text-neutral-500"
                                    value={Number.isFinite(w) ? w : ""}
                                    onChange={(e) => {
                                      const v = parseFloat(
                                        e.target.value.replace(",", ".")
                                      );
                                      setNotationWeights((prev) => ({
                                        ...prev,
                                        [r.key]: isNaN(v)
                                          ? 0
                                          : Math.max(0, v),
                                      }));
                                    }}
                                  />
                                )}
                              </td>

                              {/* COL 6 — Niveau NR + 1..4 */}
                              <td className="border px-2 py-1 text-center align-middle">
                                <div className="inline-flex items-center gap-1">
                                  {/* NR */}
                                  <button
                                    type="button"
                                    onClick={() =>
                                      setScoreForView((prev) => {
                                        const current = prev[r.key] ?? null;
                                        const next = { ...prev };

                                        if (current === 0) {
                                          delete next[r.key];
                                          return next;
                                        }

                                        next[r.key] = 0;
                                        return next;
                                      })
                                    }
                                    className="p-0 rounded-full"
                                  >
                                    <span
                                      className={classNames(
                                        "h-7 px-2 inline-flex items-center justify-center rounded-full border text-[10px] transition",
                                        isNR
                                          ? "bg-neutral-900 border-neutral-900 text-white font-semibold ring-2 ring-offset-1 ring-neutral-900/30 dark:bg-neutral-100 dark:border-neutral-100 dark:text-neutral-300 dark:ring-neutral-100/60 ring-offset-white dark:ring-offset-[#0b1220]"
                                          : "bg-white dark:bg-[#182433] text-neutral-700 dark:text-neutral-300 border-neutral-300 dark:border-sky-400/35 hover:bg-amber-100/70 dark:hover:bg-[#3d2707]"
                                      )}
                                    >
                                      NR
                                    </span>
                                  </button>

                                  {/* 1 à 4 */}
                                  {[1, 2, 3, 4].map((val) => {
                                    const isActive = s === val;

                                    // Couleurs fixes (ne dépendent pas de Tailwind → pas de purge, OK en dark mode)
                                    const LEVEL_COLORS: Record<1 | 2 | 3 | 4, { bg: string; text: string }> = {
                                      1: { bg: "#ef4444", text: "#ffffff" }, // rouge
                                      2: { bg: "#f97316", text: "#ffffff" }, // orange
                                      3: { bg: "#facc15", text: "#111827" }, // jaune
                                      4: { bg: "#22c55e", text: "#ffffff" }, // vert
                                    };
                                    const c = LEVEL_COLORS[val as 1 | 2 | 3 | 4];

                                    return (
                                      <button
                                        key={val}
                                        type="button"
                                        onClick={() =>
                                          setScoreForView((prev) => {
                                            const current = prev[r.key] ?? null;
                                            const next = { ...prev };

                                            if (current === val) {
                                              delete next[r.key];
                                              return next;
                                            }

                                            next[r.key] = val;
                                            return next;
                                          })
                                        }
                                        className="p-0 rounded-full"
                                      >
                                        <span
                                          style={{
                                            backgroundColor: c.bg,
                                            borderColor: c.bg,
                                            color: c.text,
                                          }}
                                          className={classNames(
                                            "h-7 w-7 inline-flex items-center justify-center rounded-full border text-xs transition",
                                            isActive ? "opacity-100" : "opacity-35 hover:opacity-60",
                                            isActive &&
                                              "font-semibold ring-2 ring-offset-1 ring-neutral-900/30 dark:ring-neutral-100/60 ring-offset-white dark:ring-offset-[#0b1220] shadow-sm"
                                          )}
                                        >
                                          {val}
                                        </span>
                                      </button>
                                    );
                                  })}</div>
                              </td>
                            </tr>
                          );
                        }
                      )}
                    </tbody>
                  </table>
                </div>
              </div>
            </section>
          );
        })}
      </div>

    </div>
  );
};

// Ouvre un devoir depuis la vue "classe" : charge le devoir et affiche l'aperçu
const handleOpenClasseDevoir = async (ev: EvalMeta) => {
  try {
    if (!isTauriRuntime()) {
      alert(
        "L'aperçu du devoir n'est disponible que dans la version installée (Tauri)."
      );
      return;
    }

    // On mémorise l'ID du devoir sélectionné pour la vue classe (utile plus tard)
    setSelectedEvalIdForClasse(ev.id);

    // Charger le devoir complet à partir de son fichier
    await loadSavedDevoir(ev.fileName);

    // (Optionnel) remettre le groupe / semestre dans les champs de l'évaluation
    if (ev.group) {
      setGroup(ev.group);
    }
    if (ev.semester) {
      setEvaluationSemester(ev.semester as SemesterKey);
    }

  } catch (err) {
    console.error(
      "Erreur lors de l'ouverture du devoir depuis la vue classe :",
      err
    );
    alert("Impossible d'ouvrir l'aperçu de ce devoir.");
  }
};
  const openPreviewWindow = (overrideEvaluationType?: string, overrideCategory?: string, opts?: PreviewTargetOptions) => {
  if (typeof window === "undefined") return;

  const rows = buildPreviewRows();

  // 🔹 Calcul des rowSpan pour la colonne "TÂCHES"
  const taskRowSpans: number[] = [];
  for (let i = 0; i < rows.length; i++) {
    if (i > 0 && rows[i].task === rows[i - 1].task) {
      // même tâche que la ligne précédente → on ne ré-affiche pas la cellule
      taskRowSpans[i] = 0;
    } else {
      // nouvelle tâche → on compte combien de lignes consécutives partagent la même tâche
      let span = 1;
      while (i + span < rows.length && rows[i + span].task === rows[i].task) {
        span++;
      }
      taskRowSpans[i] = span;
    }
  }
  // 🔹 Calcul des rowSpan pour la colonne "COMPÉTENCE"
  // (fusionne seulement si TÂCHE ET COMPÉTENCE sont identiques)
  const compRowSpans: number[] = [];
  for (let i = 0; i < rows.length; i++) {
    if (
      i > 0 &&
      rows[i].task === rows[i - 1].task &&
      rows[i].comp === rows[i - 1].comp
    ) {
      // même tâche + même compétence que la ligne précédente → on ne ré-affiche pas la cellule
      compRowSpans[i] = 0;
    } else {
      let span = 1;
      while (
        i + span < rows.length &&
        rows[i + span].task === rows[i].task &&
        rows[i + span].comp === rows[i].comp
      ) {
        span++;
      }
      compRowSpans[i] = span;
    }
  }

  const logoHtml = logoDataUrl
    ? `<img src="${logoDataUrl}" style="max-width:120px;max-height:120px;object-fit:contain;" />`
    : "";

  // Chaque ligne de "Objectifs" = une puce
  const objectifsLines = (objectives || "")
    .split("\n")
    .map((l) => l.trim())
    .filter((l) => l.length > 0);

  const objectifsHtml = objectifsLines.length
    ? `<ul class="objectifs-list">
        ${objectifsLines.map((line) => `<li>${escapeHtml(line)}</li>`).join("")}
       </ul>`
    : "";

  // Situation professionnelle
  const situationHtml = professionalSituation
    ? `<p>${escapeHtml(professionalSituation)}</p>`
    : "<p><span style='color:#888;font-style:italic;'>Non renseignée</span></p>";

  const evalType = overrideEvaluationType ?? evaluationType;

  const evalCategory = overrideCategory ?? evaluationCategory;

  const isAuto = evalType === "Auto-évaluation";
  const isCodeColor = evalType === "code-couleur";
  const isCriterie = evalType === "criterie";

  // 🔹 Construction du tableau (Aperçu / Impression)
  // - Auto-évaluation & Code-couleur : on garde le tableau "par ligne" (rows)
  // - Critérié : on imprime une ligne PAR CRITÈRE, avec Poids + bulles NR/1/2/3/4 (comme dans l'app)
  let tableHtml = "";

  if (isCriterie) {
    const critLines = rows.flatMap((r) =>
      (r.criteres || []).map((crit, idx) => ({
        key: `${r.task}||${r.comp}::${r.item}::crit#${idx}`,
        task: r.task,
        comp: r.comp,
        item: r.item,
        critere: crit,
        exigences: r.exigences || [],
      }))
    );

    const taskSpans: number[] = [];
    const compSpans: number[] = [];
    const itemSpans: number[] = [];

    for (let i = 0; i < critLines.length; i++) {
      // TÂCHE
      if (i > 0 && critLines[i].task === critLines[i - 1].task) {
        taskSpans[i] = 0;
      } else {
        let span = 1;
        while (i + span < critLines.length && critLines[i + span].task === critLines[i].task) span++;
        taskSpans[i] = span;
      }

      // COMPÉTENCE (fusion uniquement si TÂCHE + COMPÉTENCE identiques)
      if (
        i > 0 &&
        critLines[i].task === critLines[i - 1].task &&
        critLines[i].comp === critLines[i - 1].comp
      ) {
        compSpans[i] = 0;
      } else {
        let span = 1;
        while (
          i + span < critLines.length &&
          critLines[i + span].task === critLines[i].task &&
          critLines[i + span].comp === critLines[i].comp
        ) {
          span++;
        }
        compSpans[i] = span;
      }

      // ÊTRE CAPABLE DE (fusion si TÂCHE + COMP + ITEM identiques)
      if (
        i > 0 &&
        critLines[i].task === critLines[i - 1].task &&
        critLines[i].comp === critLines[i - 1].comp &&
        critLines[i].item === critLines[i - 1].item
      ) {
        itemSpans[i] = 0;
      } else {
        let span = 1;
        while (
          i + span < critLines.length &&
          critLines[i + span].task === critLines[i].task &&
          critLines[i + span].comp === critLines[i].comp &&
          critLines[i + span].item === critLines[i].item
        ) {
          span++;
        }
        itemSpans[i] = span;
      }
    }

    const bubble = (
      label: string,
      border: string,
      bg: string,
      fg: string
    ) => `
      <span style="
        display:inline-flex;
        align-items:center;
        justify-content:center;
        width:22px;
        height:22px;
        border-radius:9999px;
        border:2px solid ${border};
        background:${bg};
        color:${fg};
        font-size:10px;
        font-weight:800;
        line-height:1;
        box-sizing:border-box;
      ">${label}</span>
    `;

    const scaleHtml = `
      <div style="display:flex;gap:6px;justify-content:center;flex-wrap:wrap;">
        ${bubble("NR", "#6b7280", "transparent", "var(--text)")}
        ${bubble("1", "#ef4444", "transparent", "#ef4444")}
        ${bubble("2", "#f97316", "transparent", "#f97316")}
        ${bubble("3", "#eab308", "transparent", "#eab308")}
        ${bubble("4", "#22c55e", "transparent", "#22c55e")}
      </div>
    `;


    let body = "";
    critLines.forEach((r, idx) => {
      body += "<tr>";

      // TÂCHES fusionnée
      if (taskSpans[idx] > 0) {
        body += `<td rowspan="${taskSpans[idx]}">${escapeHtml(r.task)}</td>`;
      }

      // COMPÉTENCE fusionnée
      if (compSpans[idx] > 0) {
        body += `<td rowspan="${compSpans[idx]}">${escapeHtml(r.comp)}</td>`;
      }

      // ÊTRE CAPABLE DE fusionnée
      if (itemSpans[idx] > 0) {
        body += `<td rowspan="${itemSpans[idx]}">${escapeHtml(r.item)}</td>`;
      }

      // CRITÈRE
      body += `<td>${escapeHtml(r.critere)}</td>`;

      // EXIGENCES
      body += "<td>";
      if (r.exigences && r.exigences.length) {
        body += r.exigences.map((e: string) => escapeHtml(e)).join("<br />");
      } else {
        body += "<span style='color:#888;font-style:italic;'>Aucune sélection</span>";
      }
      body += "</td>";

      // POIDS
      const w = notationWeights[r.key] ?? 1;
      body += `<td style="text-align:center;">${Number.isFinite(w) ? w : ""}</td>`;

      // NIVEAU (bulles)
      body += `<td>${scaleHtml}</td>`;

      body += "</tr>";
    });

    tableHtml =
      critLines.length === 0
        ? `<p style="font-style:italic;color:#666;font-size:11px;">Aucun critère sélectionné.</p>`
        : `
<table>
  <thead>
    <tr>
      <th>TÂCHES</th>
      <th>COMPÉTENCE</th>
      <th>ÊTRE CAPABLE DE</th>
      <th>CRITÈRES D'ÉVALUATION</th>
      <th>EXIGENCES</th>
      <th style="width:12mm;">POIDS (%)</th>
      <th style="width:44mm;">NIVEAU</th>
    </tr>
  </thead>
  <tbody>
    ${body}
  </tbody>
</table>`;
  } else {
    // 🔹 Construction du <tbody> à la main (plus simple que rows.map dans le template)
    let tableBodyHtml = "";

    rows.forEach((r, idx) => {
      const taskSpan = taskRowSpans[idx] || 0;
      const compSpan = compRowSpans[idx] || 0;

      tableBodyHtml += "<tr>";

      // Colonne TÂCHES fusionnée
      if (taskSpan > 0) {
        tableBodyHtml += `<td rowspan="${taskSpan}">${escapeHtml(r.task)}</td>`;
      }

      // Colonne COMPÉTENCE fusionnée
      if (compSpan > 0) {
        tableBodyHtml += `<td rowspan="${compSpan}">${escapeHtml(r.comp)}</td>`;
      }

      // Colonne ÊTRE CAPABLE DE
      tableBodyHtml += `<td>${escapeHtml(r.item)}</td>`;

      // Colonne CRITÈRES D'ÉVALUATION
      tableBodyHtml += `<td>${(r.criteres || []).map((c) => escapeHtml(c)).join("<br />")}</td>`;

      // Colonne EXIGENCES
      tableBodyHtml += "<td>";
      if (r.exigences && r.exigences.length) {
        tableBodyHtml += r.exigences.map((e) => escapeHtml(e)).join("<br />");
      } else {
        tableBodyHtml += "<span style='color:#888;font-style:italic;'>Aucune sélection</span>";
      }
      tableBodyHtml += "</td>";

      // Colonnes auto-évaluation (smileys)
      if (isAuto) {
        tableBodyHtml += `<td class="auto-col"></td>`;
        tableBodyHtml += `<td class="auto-col"></td>`;
        tableBodyHtml += `<td class="auto-col"></td>`;
      }

      // Colonnes code couleur
      if (isCodeColor) {
        tableBodyHtml += `<td class="code-col"></td>`;
        tableBodyHtml += `<td class="code-col"></td>`;
        tableBodyHtml += `<td class="code-col"></td>`;
        tableBodyHtml += `<td class="code-col"></td>`;
      }

      tableBodyHtml += "</tr>";
    });

    tableHtml =
      rows.length === 0
        ? `<p style="font-style:italic;color:#666;font-size:11px;">Aucune exigence personnalisée sélectionnée.</p>`
        : `
<table>
  <thead>
    <tr>
      <th>TÂCHES</th>
      <th>COMPÉTENCE</th>
      <th>ÊTRE CAPABLE DE</th>
      <th>CRITÈRES D'ÉVALUATION</th>
      <th>EXIGENCES</th>
      ${
        isAuto
          ? `
      <th class="auto-col">😕</th>
      <th class="auto-col">😐</th>
      <th class="auto-col">😊</th>
      `
          : ""
      }
      ${
        isCodeColor
          ? `
      <th class="code-col code-red">●</th>
      <th class="code-col code-orange">●</th>
      <th class="code-col code-yellow">●</th>
      <th class="code-col code-green">●</th>
      `
          : ""
      }
    </tr>
  </thead>
  <tbody>
    ${tableBodyHtml}
  </tbody>
</table>`;
  }

  const previewIsDark = theme === "dark";
  const previewOuterBg = previewIsDark ? "#0b1220" : "#f3f4f6";
  const previewPageBg = previewIsDark ? "#0f1b2d" : "#ffffff";
  const previewText = previewIsDark ? "#f8fafc" : "#111827";
  const previewMuted = previewIsDark ? "rgba(248,250,252,.72)" : "#4b5563";
  const previewBorder = previewIsDark ? "rgba(148,163,184,.50)" : "#d1d5db";
  const previewTheadBg = previewIsDark ? "#162238" : "#f3f4f6";
  const previewTheadText = previewIsDark ? "#e2e8f0" : "#111827";

  const html = `
<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>${escapeHtml(title || "Évaluation")}</title>
  <style>
    :root {
      --outer-bg: ${previewOuterBg};
      --page-bg: ${previewPageBg};
      --text: ${previewText};
      --muted: ${previewMuted};
      --border: ${previewBorder};
      --thead-bg: ${previewTheadBg};
      --thead-text: ${previewTheadText};
    }

    * {
      box-sizing: border-box;
    }

    html, body {
      height: 100%;
    }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: var(--outer-bg); /* bleu autour */
      display: flex;
      justify-content: center;
      align-items: flex-start;
      padding: 16px;
      color: var(--text);
    }

    /* 📄 Feuille A4 paysage à l'écran (ratio 297 x 210) */
    .page {
      background: var(--page-bg);
      padding: 10mm 12mm;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    @media screen {
      .page {
        width: min(1120px, 100%);
        aspect-ratio: 297 / 210;
        height: auto;
      }
    }

    .header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      padding-bottom: 6px;
      border-bottom: 2px solid var(--text);
      margin-bottom: 6px;
    }

    .header-left h1 {
      font-size: 16px;
      margin: 0 0 4px 0;
    }

    .meta {
      font-size: 11px;
      color: var(--muted);
      line-height: 1.3;
    }

    .meta-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      column-gap: 18px;
      row-gap: 2px;
      max-width: 620px;
    }
    .meta-wide {
      grid-column: 1 / -1;
    }

    .logo {
      text-align: right;
      min-width: 120px;
    }

    .logo img {
      max-width: 110px;
      max-height: 110px;
      object-fit: contain;
    }

    .content {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 6px;
      overflow: hidden;
      font-size: 11px;
    }

    .section {
      margin: 0;
    }

    .section h2 {
      font-size: 12px;
      margin: 0 0 3px 0;
      text-transform: uppercase;
      letter-spacing: .04em;
    }

    .section p {
      margin: 0;
    }

    /* 🔹 Ligne du haut : Objectifs + Situation pro */
    .top-row {
      display: flex;
      gap: 8mm;
      align-items: flex-start;
    }

    .section-objectifs {
      flex: 1.2;
    }

    .section-situation {
      flex: 1;
      padding-left: 4mm; /* léger décalage vers la gauche */
    }

    .section-situation h2,
    .section-situation p {
      text-align: left; /* alignement à gauche */
    }

    .section-table {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    .table-wrapper {
      flex: 1;
      min-height: 0;
      overflow: auto;
      border: none;         /* pas de bordure autour du bloc */
      border-radius: 0px;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 10px;
    }

    .objectifs-list {
      margin: 0;
      padding-left: 6mm; /* effet tabulation devant chaque objectif */
    }

    .objectifs-list li {
      margin: 0 0 0.5mm 0;  /* moins d'espace entre objectifs */
      font-size: 11px;
      line-height: 1.2;
    }

    th, td {
      border: 1px solid var(--border);
      padding: 3px 4px;
      vertical-align: middle;
    }

    thead th {
      background: var(--thead-bg);
      color: var(--thead-text);
      text-align: center;
      font-weight: 600;
      text-transform: uppercase;
    }

    .auto-col {
      width: 10mm;
      text-align: center;
      font-size: 12px;
    }

    .code-col {
      width: 8mm;
      text-align: center;
      font-size: 12px;
    }
      
    .crit-col {
      width: 8mm;
      text-align: center;
      font-size: 11px;
    }
    .code-red { color: #dc2626; }
    .code-orange { color: #ea580c; }
    .code-yellow { color: #eab308; }
    .code-green { color: #16a34a; }

    @page {
      size: A4 landscape;
      margin: 10mm 12mm;
    }

    @media print {
      :root {
        --outer-bg: #ffffff;
        --page-bg: #ffffff;
        --text: #111827;
        --muted: #374151;
        --border: #6b7280;
        --thead-bg: #f3f4f6;
        --thead-text: #111827;
      }

      body {
        background: #ffffff;
        padding: 0;
        display: block;
      }

      .page {
        box-shadow: none;
        width: auto;
        height: auto;
        margin: 0;
        padding: 0;
      }

      .table-wrapper {
        overflow: visible;
        border: 1px solid var(--border);
      }
    }
  </style>
</head>
<body>
  <div class="page">
    <div class="header">
      <div class="header-left">
        <h1>${escapeHtml(title || "Évaluation CAP Maçonnerie")}</h1>
        <div class="meta-grid">
          <div class="meta">Projet : ${escapeHtml(project || "")}</div>
          <div class="meta">Classe : ${escapeHtml(group || "")}</div>
          <div class="meta">Évaluateur : ${escapeHtml(evaluator || "")}</div>
          <div class="meta">Année : ${escapeHtml(trainingYearLabel(trainingYear))}</div>
          <div class="meta meta-wide">Niveau : ${escapeHtml(evalCategory || "")}</div>
        </div>
      </div>
      <div class="logo">
        ${logoHtml}
      </div>
    </div>

    <div class="content">
      <div class="top-row">
        <div class="section section-objectifs">
          <h2>Objectifs de l'évaluation</h2>
          ${objectifsHtml || "<p><span style='color:#888;font-style:italic;'>Non renseignés</span></p>"}
        </div>
        <div class="section section-situation">
          <h2>Situation professionnelle</h2>
          ${situationHtml}
        </div>
      </div>

      <div class="section section-table">
        <h2>Tableau des exigences personnalisées</h2>
        <div class="table-wrapper">
          ${tableHtml}
        </div>
      </div>
    </div>
  </div>
</body>
</html>
`;

  pushPreview(html, opts);
};


  const handlePrintClick = () => {
    try {
      // 📝 DEVOIR / ÉVALUATION
      if (activeView === "evaluation") {
        setPrintEvaluationType(evaluationType);
        openPreviewWindow(evaluationType, evaluationCategory, { mode: "modal", autoPrint: true, target: "printWindow" });
        return;
      }

      // 📊 SUIVI
      if (activeView === "suivi") {
        if (suiviMode === "eleve") {
          openSuiviEleveToPreview({ mode: "modal", autoPrint: true, target: "printWindow" });
          return;
        }
        if (suiviMode === "classe") {
          exportSuiviClasseToPdf({ mode: "modal", autoPrint: true, target: "printWindow" });
          return;
        }
        if (suiviMode === "absences") {
          openSuiviAbsencesToPreview({ mode: "modal", autoPrint: true, target: "printWindow" });
          return;
        }
        if (suiviMode === "notation") {
          exportCurrentStudentNotationToPdf({ mode: "modal", autoPrint: true, target: "printWindow" });
          return;
        }
        if (suiviMode === "evolutions") {
          openSuiviEvolutionsToPreview({ mode: "modal", autoPrint: true, target: "printWindow" });
          return;
        }
        if (suiviMode === "bilan") {
          openSuiviBilanToPreview({ mode: "modal", autoPrint: true, target: "printWindow" });
          return;
        }
        // Fallback : si une sous-vue non prévue existe
        alert('Impression indisponible pour cette sous-vue de "Suivi".');
        return;
      }

      // ✅ NOTES
      if (activeView === "notes") {
        if (notesMode === "tableau") {
          exportNotesTableToPdf({ mode: "modal", autoPrint: true, target: "printWindow" });
          return;
        }
        // notesMode === "notation"
        exportCurrentStudentNotationToPdf({ mode: "modal", autoPrint: true, target: "printWindow" });
        return;
      }

      // Fallback
      setPrintEvaluationType(evaluationType);
      openPreviewWindow(evaluationType, evaluationCategory, { mode: "modal", autoPrint: true, target: "printWindow" });
    } catch (e) {
      console.error("handlePrintClick failed:", e);
    }
  };

async function handleCheckUpdate() {
  if (updateBusy) return;
  setUpdateBusy(true);

  try {
    const update = await check();

    if (!update?.available) {
      await confirm("Aucune mise à jour disponible.", {
        title: "Mise à jour",
        kind: "info",
      });
      return;
    }

    const ok = await confirm(
      `Mise à jour disponible (${update.version}).\n\nTélécharger et installer maintenant ?`,
      { title: "Mise à jour", kind: "info" }
    );

    if (!ok) return;

    // Télécharge + installe, puis relance l’app
    await update.downloadAndInstall();
    await relaunch();
  } catch (e) {
    console.error(e);
    await confirm(`Erreur mise à jour : ${String(e)}`, {
      title: "Mise à jour",
      kind: "error",
    });
  } finally {
    setUpdateBusy(false);
  }
}

// Volet TÂCHES global : total S1 + S2
function TasksVoletTotal({
  selectedClassId,
}: {
  selectedClassId: string | null;
}) {
  if (!selectedClassId) return null;

  // Tous les devoirs S1 + S2 de la classe
  const evalsForClasse = evalMetaList.filter(
    (ev) => ev.group === selectedClassId
  );

  // Toutes les tâches triées (T1, T2, ...)
  const allTasks = sortByTaskNumber(Object.keys(tcMap));

  // Compter S1 + S2
  const countByTask: Record<string, number> = {};

  evalsForClasse.forEach((ev) => {
    (tasksByEvalId[ev.id] || []).forEach((taskLabel) => {
      countByTask[taskLabel] = (countByTask[taskLabel] || 0) + 1;
    });
  });

  const taskUsageList = allTasks.map((label) => ({
    label,
    count: countByTask[label] || 0,
  }));

  return (
    <div className="border rounded-lg bg-white dark:bg-[#1f2d42] w-full overflow-hidden shadow-sm">
      <div className="bg-neutral-900 text-white text-xs font-semibold text-center py-1">
        Tâches – TOTAL (S1 + S2)
      </div>
      <div className="max-h-[720px] overflow-auto">
        <table className="w-full border-collapse text-[11px] text-neutral-900 dark:text-neutral-300">
          <thead>
            <tr>
              {/* Colonne Famille (en-tête, vertical) */}
              <th className="border border-neutral-300 dark:border-sky-400/35 bg-neutral-100 dark:bg-[#1f2d42] px-1 py-1 text-center align-middle w-10">
                <span
                  style={{
                    writingMode: "vertical-rl",
                    transform: "rotate(180deg)",
                    whiteSpace: "normal",      // ✅ autorise le retour à la ligne
                    wordBreak: "break-word",   // ✅ casse les mots longs si besoin
                    maxHeight: 96,             // optionnel : limite la hauteur du texte dans le header
                    overflow: "hidden",
                  }}
                >
                </span>
              </th>
              <th className="border border-neutral-300 dark:border-sky-400/35 bg-neutral-100 dark:bg-[#1f2d42] px-2 py-1 text-middle">
                Tâches
              </th>
              <th className="border border-neutral-300 dark:border-sky-400/35 bg-neutral-100 dark:bg-[#1f2d42] px-2 py-1 text-center w-10">
                Nb
              </th>
            </tr>
          </thead>
          <tbody>
            {taskUsageList.map((t, index) => {
              // 🔹 Groupe de la tâche
              const tNum = taskNumber(t.label);
              const group = GROUPS.find(
                (g) => tNum >= g.range[0] && tNum <= g.range[1]
              );

              // Fond des cellules selon la famille
              const cellBgClass =
                group?.key === "G1"
                  ? "bg-sky-50 dark:bg-sky-950/35"
                  : group?.key === "G2"
                  ? "bg-amber-50 dark:bg-amber-950/35"
                  : group?.key === "G3"
                  ? "bg-violet-50 dark:bg-violet-950/35"
                  : "bg-white dark:bg-[#1f2d42]";

              // Libellé famille pour la colonne gauche
              const famLabel =
                group?.key === "G1"
                  ? "COMMUNIQUER · PRÉPARATION"
                  : group?.key === "G2"
                  ? "RÉALISER & CONTRÔLE\nD'OUVRAGE COURANT"
                  : group?.key === "G3"
                  ? "RÉALISATION DE\nTRAVAUX SPÉCIFIQUES"
                  : "";

              // 🔹 Déterminer si c'est la première ligne de ce groupe
              const prevTask = index > 0 ? taskUsageList[index - 1] : null;
              const prevNum = prevTask ? taskNumber(prevTask.label) : null;
              const prevGroup =
                prevNum !== null
                  ? GROUPS.find(
                      (g) => prevNum >= g.range[0] && prevNum <= g.range[1]
                    )
                  : null;

              const isFirstOfGroup =
                group && group.key !== prevGroup?.key ? true : false;

              // 🔹 Calculer le rowSpan pour la cellule Famille
              let rowSpan = 0;
              if (isFirstOfGroup && group) {
                for (let i = index; i < taskUsageList.length; i++) {
                  const num = taskNumber(taskUsageList[i].label);
                  const g = GROUPS.find(
                    (gg) => num >= gg.range[0] && num <= gg.range[1]
                  );
                  if (!g || g.key !== group.key) break;
                  rowSpan++;
                }
              }

              return (
                <tr key={t.label}>
                  {/* Colonne Famille : cellule fusionnée, texte vertical */}
                  {isFirstOfGroup && group && rowSpan > 0 && (
                    <td
                      rowSpan={rowSpan}
                      className={classNames(
                        "border border-neutral-300 dark:border-sky-400/35 px-1 py-1 w-10 text-center align-middle",
                        cellBgClass
                      )}
                    >
                      <span
                      className="text-[8px] leading-tight"
                        style={{
                          writingMode: "vertical-rl",
                          transform: "rotate(180deg)",
                          whiteSpace: "pre-wrap",
                          fontWeight: 600,
                        }}
                      >
                        {famLabel}
                      </span>
                    </td>
                  )}

                  {/* Colonne Tâche */}
                  <td
                    className={classNames(
                      "border border-neutral-300 dark:border-sky-400/35 px-2 py-1",
                      cellBgClass
                    )}
                  >
                    {t.label}
                  </td>

                  {/* Colonne Nb */}
                  <td
                    className={classNames(
                      "border border-neutral-300 dark:border-sky-400/35 px-2 py-1 text-center font-semibold",
                      cellBgClass
                    )}
                  >
                    {t.count > 0 ? t.count : ""}
                  </td>
                </tr>
              );
            })}
          </tbody>
        </table>
      </div>
    </div>
  );
}



// Tableau "type Excel" : compétences en lignes, devoirs en colonnes pour 1 semestre
function DoubleSemesterMatrix({
  allCompetences,
  evalMetaList,
  selectedClassId,
  compsByEvalId,
  onAddDevoirS1,
  onAddDevoirS2,
  onRemoveDevoir,
}: {
  allCompetences: string[];
  evalMetaList: EvalMeta[];
  selectedClassId: string | null;
  compsByEvalId: Record<string, string[]>;
  onAddDevoirS1: () => void;
  onAddDevoirS2: () => void;
  onRemoveDevoir: (ev: EvalMeta) => void;
  onOpenDevoir: (ev: EvalMeta) => void;
}) {
  if (!selectedClassId) return null;

  const MAX_DEVOIRS_PER_SEMESTRE = 20;

  const evalsS1 = evalMetaList
    .filter((ev) => ev.group === selectedClassId && ev.semester === "S1")
    .slice(0, MAX_DEVOIRS_PER_SEMESTRE);

  const evalsS2 = evalMetaList
    .filter((ev) => ev.group === selectedClassId && ev.semester === "S2")
    .slice(0, MAX_DEVOIRS_PER_SEMESTRE);

return (
  <div className="border rounded-lg overflow-hidden shadow-sm bg-white dark:bg-[#11f2d42]">
    <div className="overflow-x-auto">
      <table className="min-w-full border-collapse text-xs text-neutral-900 dark:text-neutral-300">
        <thead>
          {/* Ligne 1 : bandeaux S1 / S2 */}
          <tr>
            {/* Nouvelle colonne Famille (en-tête, fusionnée sur 2 lignes) */}
<th
  rowSpan={2}
  className="border border-neutral-300 dark:border-sky-400/35 bg-white dark:bg-[#1f2d42] sticky left-0 z-30 w-10 px-1 py-2 text-[11px] font-semibold text-neutral-700 dark:text-neutral-300 text-center align-middle"
>
  <span
    style={{
      writingMode: "vertical-rl",
      transform: "rotate(180deg)",
      whiteSpace: "normal",      // ✅ autorise le retour à la ligne
      wordBreak: "break-word",   // ✅ casse les mots longs si besoin
      maxHeight: 96,             // optionnel : limite la hauteur du texte dans le header
      overflow: "hidden",
    }}
  >
  </span>
</th>


            {/* Colonne Compétence : titre général */}
            <th className="border border-neutral-300 dark:border-sky-400/35 bg-white dark:bg-[#182433] sticky left-0 z-20 w-80 px-3 py-2 text-middle align-middle">
              <div className="text-[11px] text-neutral-400">
                Vue d&apos;ensemble par semestre
              </div>
            </th>

            {/* Bandeau S1 */}
            <th
              colSpan={MAX_DEVOIRS_PER_SEMESTRE + 1}
              className="border border-neutral-300 dark:border-sky-400/35 bg-amber-100 dark:bg-amber-950/45 text-neutral-900 dark:text-neutral-300 text-[11px] font-semibold text-center"
            >
              <div className="flex flex-col items-center py-1">
                <span>SEMESTRE 1</span>
                <span className="text-[10px] font-normal opacity-80">
                  Devoirs &amp; compétences évaluées
                </span>
              </div>
            </th>

            {/* Colonne vide de séparation */}
            <th className="w-4 bg-white dark:bg-[#1f2d42]" />

            {/* Bandeau S2 */}
            <th
              colSpan={MAX_DEVOIRS_PER_SEMESTRE + 1}
              className="border border-neutral-300 dark:border-sky-400/35 bg-lime-100 dark:bg-lime-950/45 text-neutral-900 dark:text-neutral-300 text-[11px] font-semibold text-center"
            >
              <div className="flex flex-col items-center py-1">
                <span>SEMESTRE 2</span>
                <span className="text-[10px] font-normal opacity-80">
                  Devoirs &amp; compétences évaluées
                </span>
              </div>
            </th>
          </tr>

          {/* Ligne 2 : en-têtes détaillés */}
          <tr>
            {/* En-tête Compétence */}
            <th
              className="sticky left-0 z-20 border border-neutral-300 dark:border-sky-400/35 bg-white dark:bg-[#182433] px-3 py-2 text-middle w-80 align-middle text-[14px] font-semibold text-neutral-700 dark:text-neutral-300"
            >
              COMPÉTENCES
            </th>

            {/* Colonnes S1 */}
            {Array.from({ length: MAX_DEVOIRS_PER_SEMESTRE }).map((_, idx) => {
              const ev = evalsS1[idx];
              return (
                <th
                  key={`S1-${idx}`}
                  className="border border-neutral-300 dark:border-sky-400/35 text-center px-0.5 py-1 align-top bg-white dark:bg-[#182433] w-[22px]"
                  style={{ width: 22 }}
                >
                  {ev ? (
                    <div className="flex flex-col items-center gap-1">
                      <div
                        className="text-[10px] font-medium leading-tight text-neutral-700 dark:text-neutral-300"
                        style={{
                          writingMode: "vertical-rl",
                          transform: "rotate(180deg)",
                          whiteSpace: "normal",      // ✅ autorise le retour à la ligne
                          wordBreak: "break-word",   // ✅ casse les mots longs si besoin
                          maxHeight: 96,             // optionnel : limite la hauteur du texte dans le header
                          overflow: "hidden",
                        }}
                        title={ev.name}
                      >
                        {ev.name}
                      </div>

<button
  type="button"
  onClick={() => onRemoveDevoir(ev)}
  className="w-4 h-4 flex items-center justify-center rounded-full bg-red-50 dark:bg-red-950/40 text-red-600 dark:text-red-200 hover:bg-amber-100/70 dark:hover:bg-red-900/30 border border-red-200 dark:border-red-800/50 text-[9px] leading-none transition-colors"
  title="Supprimer ce devoir"
>
  ✕
</button>

                    </div>
                  ) : (
<button
  type="button"
  onClick={onAddDevoirS1}
  className="w-5 h-5 flex items-center justify-center rounded-full border border-dashed border-amber-400 bg-amber-50 dark:bg-amber-950/35 hover:bg-amber-100 dark:bg-amber-950/45"
  title="Ajouter un devoir en S1"
>
  <Plus className="w-3 h-3" />
</button>

                  )}
                </th>
              );
            })}

            {/* Nb S1 (GRIS) */}
            <th className="border border-neutral-300 dark:border-sky-400/35 bg-neutral-100 dark:bg-[#1f2d42] text-center w-16 text-[11px] font-semibold text-neutral-800 dark:text-neutral-300">
              Nb S1
            </th>

            {/* Colonne vide de séparation */}
            <th className="w-4 bg-white dark:bg-[#1f2d42]" />

            {/* Colonnes S2 */}
            {Array.from({ length: MAX_DEVOIRS_PER_SEMESTRE }).map((_, idx) => {
              const ev = evalsS2[idx];
              return (
                <th
                  key={`S2-${idx}`}
                  className="border border-neutral-300 dark:border-sky-400/35 text-center px-0.5 py-1 align-top bg-white dark:bg-[#1f2d42] w-[22px]"
                  style={{ width: 22 }}
                >
                  {ev ? (
                    <div className="flex flex-col items-center gap-1">
                      <div
                        className="text-[10px] font-medium leading-tight text-neutral-700 dark:text-neutral-300"
                        style={{
                          writingMode: "vertical-rl",
                          transform: "rotate(180deg)",
                          whiteSpace: "normal",      // ✅ autorise le retour à la ligne
                          wordBreak: "break-word",   // ✅ casse les mots longs si besoin
                          maxHeight: 96,             // optionnel : limite la hauteur du texte dans le header
                          overflow: "hidden",
                        }}
                        title={ev.name}
                      >
                        {ev.name}
                      </div>

<button
  type="button"
  onClick={() => onRemoveDevoir(ev)}
  className="w-4 h-4 flex items-center justify-center rounded-full bg-red-50 dark:bg-red-950/40 text-red-600 dark:text-red-200 hover:bg-amber-100/70 dark:hover:bg-red-900/30 border border-red-200 dark:border-red-800/50 text-[9px] leading-none transition-colors"
  title="Supprimer ce devoir"
>
  ✕
</button>

                    </div>
                  ) : (
<button
  type="button"
  onClick={onAddDevoirS2}
  className="w-5 h-5 flex items-center justify-center rounded-full border border-dashed border-lime-500 bg-lime-50 dark:bg-lime-950/35 hover:bg-lime-100 dark:bg-lime-950/45"
  title="Ajouter un devoir en S2"
>
  <Plus className="w-3 h-3" />
</button>

                  )}
                </th>
              );
            })}

            {/* Nb S2 (GRIS) */}
            <th className="border border-neutral-300 dark:border-sky-400/35 bg-neutral-100 dark:bg-[#1f2d42] text-center w-16 text-[11px] font-semibold text-neutral-800 dark:text-neutral-300">
              Nb S2
            </th>
          </tr>
        </thead>

        <tbody>
          {allCompetences.map((compLabel, rowIndex) => {
            const countS1 = evalsS1.filter((ev) =>
              (compsByEvalId[ev.id] || []).some((e) =>
                e.includes(`||${compLabel}`)
              )
            ).length;

            const countS2 = evalsS2.filter((ev) =>
              (compsByEvalId[ev.id] || []).some((e) =>
                e.includes(`||${compLabel}`)
              )
            ).length;

            const fam = parseCompetencyFamily(compLabel); // "C1" | "C2" | "C3" | "C4" | "OTHER"
            const prevFam =
              rowIndex > 0
                ? parseCompetencyFamily(allCompetences[rowIndex - 1])
                : undefined;
            const nextFam =
              rowIndex < allCompetences.length - 1
                ? parseCompetencyFamily(allCompetences[rowIndex + 1])
                : undefined;

            const hasFam =
              fam === "C1" || fam === "C2" || fam === "C3" || fam === "C4";

            const isFamFirst = hasFam && fam !== prevFam;
            const isFamLast = hasFam && fam !== nextFam;

            const famTopColor =
              fam === "C1"
                ? "border-t-sky-400"
                : fam === "C2"
                ? "border-t-amber-400"
                : fam === "C3"
                ? "border-t-lime-400"
                : fam === "C4"
                ? "border-t-fuchsia-400"
                : "";
            const famBottomColor =
              fam === "C1"
                ? "border-b-sky-400"
                : fam === "C2"
                ? "border-b-amber-400"
                : fam === "C3"
                ? "border-b-lime-400"
                : fam === "C4"
                ? "border-b-fuchsia-400"
                : "";
            const famLeftColor =
              fam === "C1"
                ? "border-l-sky-400"
                : fam === "C2"
                ? "border-l-amber-400"
                : fam === "C3"
                ? "border-l-lime-400"
                : fam === "C4"
                ? "border-l-fuchsia-400"
                : "";
            const famRightColor =
              fam === "C1"
                ? "border-r-sky-400"
                : fam === "C2"
                ? "border-r-amber-400"
                : fam === "C3"
                ? "border-r-lime-400"
                : fam === "C4"
                ? "border-r-fuchsia-400"
                : "";

            const famBg =
              fam === "C1"
                ? "bg-sky-50 dark:bg-sky-950/35"
                : fam === "C2"
                ? "bg-amber-50 dark:bg-amber-950/35"
                : fam === "C3"
                ? "bg-lime-50 dark:bg-lime-950/35"
                : fam === "C4"
                ? "bg-fuchsia-50 dark:bg-fuchsia-950/35"
                : "bg-white dark:bg-[#1f2d42]";

            const topThicknessClass =
              hasFam && isFamFirst ? "border-t-2" : hasFam ? "border-t" : "";
            const bottomThicknessClass =
              hasFam && isFamLast ? "border-b-2" : hasFam ? "border-b" : "";

            const topColorClass = hasFam && isFamFirst ? famTopColor : "";
            const bottomColorClass = hasFam && isFamLast ? famBottomColor : "";

            // RowSpan pour la colonne Famille
            let famRowSpan = 0;
            if (hasFam && isFamFirst) {
              let span = 1;
              for (let i = rowIndex + 1; i < allCompetences.length; i++) {
                if (
                  parseCompetencyFamily(allCompetences[i]) !== fam
                ) {
                  break;
                }
                span++;
              }
              famRowSpan = span;
            }

            const famLabel =
              fam === "C1"
                ? "COM."
                : fam === "C2"
                ? "PRÉPARER"
                : fam === "C3"
                ? "RÉALISER"
                : fam === "C4"
                ? "CONT."
                : "";

            return (
              <tr
                key={compLabel}
                className="odd:bg-white even:bg-neutral-50 hover:bg-amber-100/70/80 dark:odd:bg-[#1f2d42] dark:even:bg-[#1f2d42] dark:hover:bg-[#3d2707] transition-colors"
              >
                {/* Colonne Famille : cellule fusionnée (rowSpan) */}
                {hasFam && isFamFirst && famRowSpan > 0 && (
  <td
    rowSpan={famRowSpan}
    className={classNames(
      "border border-neutral-300 dark:border-sky-400/35 sticky left-0 z-20 w-10 px-1 py-1 text-[11px] text-neutral-900 dark:text-neutral-300 text-center align-middle",
      famBg,
      "align-middle",
      "border-l-2",
      famLeftColor,
      topThicknessClass,
      topColorClass,
      bottomThicknessClass,
      bottomColorClass
    )}
  >
    <div className="flex items-center justify-center h-full">
      <span
        className="font-semibold"
        style={{
          writingMode: "vertical-rl",
          transform: "rotate(180deg)",
          whiteSpace: "normal",      // ✅ autorise le retour à la ligne
          wordBreak: "break-word",   // ✅ casse les mots longs si besoin
          maxHeight: 96,             // optionnel : limite la hauteur du texte dans le header
          overflow: "hidden",
        }}
      >
        {famLabel}
      </span>
    </div>
  </td>
)}


                {/* Colonne compétence */}
                <td
                  className={classNames(
                    "sticky left-0 z-10 px-2 py-[2px] text-[11px] leading-[1.05] align-middle border border-neutral-300 dark:border-sky-400/35 min-w-[280px] w-[280px]",
                    hasFam ? famBg : "bg-white dark:bg-[#1f2d42]",
                    topThicknessClass,
                    topColorClass,
                    bottomThicknessClass,
                    bottomColorClass
                  )}
                >
{(() => {
  const code = compactCode(compLabel);
  const label = compLabel.replace(/^C\s*\d+\.\d+\s*[:.]\s*/, "").trim();

  return (
    <div className="grid grid-cols-[auto,1fr] gap-x-2 items-start">
      <span className="text-[11px] font-semibold text-neutral-900 dark:text-neutral-300 whitespace-nowrap">
        {code}
      </span>

      <span
        className="text-[11px] text-neutral-800 dark:text-neutral-300 break-words"
        style={{
          display: "-webkit-box",
          WebkitBoxOrient: "vertical",
          WebkitLineClamp: 2, // max 2 lignes si trop long
          overflow: "hidden",
        }}
        title={label}
      >
        {label}
      </span>
    </div>
  );
})()}

                </td>

                {/* croix S1 */}
                {Array.from({ length: MAX_DEVOIRS_PER_SEMESTRE }).map(
                  (_, idx) => {
                    const ev = evalsS1[idx];
                    const uses =
                      ev &&
                      (compsByEvalId[ev.id] || []).some((e) =>
                        e.includes(`||${compLabel}`)
                      );
                    return (
                      <td
                        key={`S1-${compLabel}-${idx}`}
                        className={classNames(
                          "border border-neutral-300 dark:border-sky-400/35 text-center align-middle",
                          hasFam ? famBg : "bg-white dark:bg-[#1f2d42]",
                          topThicknessClass,
                          topColorClass,
                          bottomThicknessClass,
                          bottomColorClass
                        )}
                      >
                        {uses ? "×" : ""}
                      </td>
                    );
                  }
                )}

                {/* Nb S1 (GRIS, mais bordures haut/bas colorées si début/fin de famille) */}
                <td
                  className={classNames(
                    "border border-neutral-300 dark:border-sky-400/35 text-center font-semibold bg-neutral-100 dark:bg-[#1f2d42] text-[11px] text-neutral-800 dark:text-neutral-300",
                    topThicknessClass,
                    topColorClass,
                    bottomThicknessClass,
                    bottomColorClass
                  )}
                >
                  {countS1 || ""}
                </td>

                {/* Colonne vide de séparation */}
                <td className="w-4 bg-white dark:bg-[#1f2d42]" />

                {/* croix S2 */}
                {Array.from({ length: MAX_DEVOIRS_PER_SEMESTRE }).map(
                  (_, idx) => {
                    const ev = evalsS2[idx];
                    const uses =
                      ev &&
                      (compsByEvalId[ev.id] || []).some((e) =>
                        e.includes(`||${compLabel}`)
                      );
                    return (
                      <td
                        key={`S2-${compLabel}-${idx}`}
                        className={classNames(
                          "border border-neutral-300 dark:border-sky-400/35 text-center align-middle",
                          hasFam ? famBg : "bg-white dark:bg-[#1f2d42]",
                          topThicknessClass,
                          topColorClass,
                          bottomThicknessClass,
                          bottomColorClass
                        )}
                      >
                        {uses ? "×" : ""}
                      </td>
                    );
                  }
                )}

                {/* Nb S2 (GRIS, bordure droite colorée pour fermer le bloc) */}
                <td
                  className={classNames(
                    "border border-neutral-300 dark:border-sky-400/35 text-center font-semibold bg-neutral-100 dark:bg-[#1f2d42] text-[11px] text-neutral-800 dark:text-neutral-300",
                    hasFam && "border-r-2",
                    hasFam && famRightColor,
                    topThicknessClass,
                    topColorClass,
                    bottomThicknessClass,
                    bottomColorClass
                  )}
                >
                  {countS2 || ""}
                </td>
              </tr>
            );
          })}
        </tbody>
      </table>
    </div>
  </div>
);



}

function SemesterMatrix({
  semester,
  allCompetences,
  evalMetaList,
  selectedClassId,
  compsByEvalId,
  onAddDevoir,
  onRemoveDevoir,
  onOpenDevoir,      
  hideCompetences = false,   
}: {
  semester: SemesterKey;
  allCompetences: string[];
  evalMetaList: EvalMeta[];
  selectedClassId: string | null;
  compsByEvalId: Record<string, string[]>;
  onAddDevoir: () => void;
  onRemoveDevoir: (ev: EvalMeta) => void;
  onOpenDevoir: (ev: EvalMeta) => void;   
  hideCompetences?: boolean; // 
}) {
  if (!selectedClassId) return null;

  const MAX_DEVOIRS_PER_SEMESTRE = 20;

  // Devoirs de la classe pour ce semestre
  const evalsForSem = evalMetaList
    .filter((ev) => ev.group === selectedClassId && ev.semester === semester)
    .slice(0, MAX_DEVOIRS_PER_SEMESTRE);

  const headerColor = semester === "S1" ? "bg-amber-400" : "bg-lime-500";

  return (
    <div className="border rounded-lg overflow-hidden shadow-sm flex-1 min-w-[480px] bg-white dark:bg-[#1f2d42]">
      {/* Bandeau SEMESTRE */}
      <div className={`${headerColor} text-white font-semibold text-center py-2`}>
        {semester === "S1" ? "SEMESTRE 1" : "SEMESTRE 2"}
      </div>

      <div className="overflow-x-auto">
        <table className="min-w-full border-collapse text-xs text-neutral-900 dark:text-neutral-300">
          <thead>
            <tr>
              {/* Colonne compétences */}
              {!hideCompetences && (
  <th
    className="border border-neutral-300 dark:border-sky-400/35 bg-neutral-100 dark:bg-[#1f2d42] px-2 py-2 text-left align-bottom w-64 sticky left-0 z-20 bg-white dark:bg-[#1f2d42]"
  >
    Compétences
  </th>
)}
              {/* Colonnes devoirs (max 20) */}
              {Array.from({ length: MAX_DEVOIRS_PER_SEMESTRE }).map((_, idx) => {
                const ev = evalsForSem[idx];

                return (
                  <th
                    key={idx}
                    className="border border-neutral-300 dark:border-sky-400/35 text-center px-0.5 py-1 align-top bg-white dark:bg-[#1f2d42] w-[22px]"
                    style={{ width: 22 }}
                  >
                    {ev ? (
                      <div className="flex flex-col items-center gap-1">
                        {/* Nom du devoir en vertical */}
                        <button
  type="button"
  onClick={() => onOpenDevoir(ev)}
  className="text-[10px] font-medium leading-tight underline decoration-dotted hover:text-neutral-900 dark:text-neutral-300"
  style={{
    writingMode: "vertical-rl",
    transform: "rotate(180deg)",
    whiteSpace: "normal",      // ✅ autorise le retour à la ligne
    wordBreak: "break-word",   // ✅ casse les mots longs si besoin
    maxHeight: 96,             // optionnel : limite la hauteur du texte dans le header
    overflow: "hidden",
  }}
  title="Ouvrir l'aperçu et la notation de ce devoir"
>
  {ev.name}
</button>


                        {/* Bouton pour retirer ce devoir de la classe / semestre */}
                        <button
                          type="button"
                          onClick={() => onRemoveDevoir(ev)}
                          className="mt-1 w-5 h-5 flex items-center justify-center rounded-full border border-neutral-400 hover:bg-amber-100/70 dark:bg-[#182433]"
                          title="Retirer ce devoir de cette classe / semestre"
                        >
                          <X className="w-3 h-3" />
                        </button>
                      </div>
                    ) : (
                      // Slot vide → bouton +
                      <button
                        type="button"
                        onClick={onAddDevoir}
                        className="w-6 h-6 flex items-center justify-center rounded-full border border-dashed border-neutral-400 hover:bg-amber-100/70 dark:bg-[#182433]"
                        title="Ajouter un devoir pour ce semestre"
                      >
                        <Plus className="w-3 h-3" />
                      </button>
                    )}
                  </th>
                );
              })}

              {/* Colonne "Nb" = nombre de devoirs utilisant la compétence */}
              <th className="border border-neutral-300 dark:border-sky-400/35 bg-neutral-100 dark:bg-[#1f2d42] px-2 py-2 text-center align-bottom w-16 text-[11px]">
                Nb
              </th>
            </tr>
          </thead>

          <tbody>
            {allCompetences.map((compLabel) => {
              // 🔢 Compter le nombre de devoirs du semestre qui utilisent cette compétence
              const countForComp = evalsForSem.reduce((acc, ev) => {
                if (!ev) return acc;
                const compsForEv = compsByEvalId[ev.id] || [];
                const usesComp = compsForEv.some((entry) => {
                  const parts = entry.split("||");
                  // format : tâche||compétence||...
                  return parts[1] === compLabel;
                });
                return acc + (usesComp ? 1 : 0);
              }, 0);

              return (
                <tr key={compLabel}>
                  {/* Libellé compétence */}
                  {!hideCompetences && (
  <td
    className="border border-neutral-300 dark:border-sky-400/35 px-2 py-1 text-[11px] bg-white dark:bg-[#182433] sticky left-0 z-10"
  >
    <span className="font-semibold">{compactCode(compLabel)}</span>{" "}
    <span className="text-[10px] text-neutral-600 dark:text-neutral-300">
      {compLabel.replace(/^C\s*\d+\.\d+\s*[:.]\s*/, "")}
    </span>
  </td>
)}
                  {/* cellules X / vides pour chaque devoir */}
                  {Array.from({ length: MAX_DEVOIRS_PER_SEMESTRE }).map((_, idx) => {
                    const ev = evalsForSem[idx];

                    if (!ev) {
                      return (
                        <td
                          key={idx}
                          className="border border-neutral-300 dark:border-sky-400/35 text-center align-middle"
                        />
                      );
                    }

                    const compsForEv = compsByEvalId[ev.id] || [];
                    const usesComp = compsForEv.some((entry) => {
                      const parts = entry.split("||");
                      return parts[1] === compLabel;
                    });

                    return (
                      <td
                        key={idx}
                        className="border border-neutral-300 dark:border-sky-400/35 text-center align-middle"
                      >
                        {usesComp ? (
                          <span className="font-bold text-lg leading-none">
                            ×
                          </span>
                        ) : null}
                      </td>
                    );
                  })}

                  {/* Nb de devoirs qui utilisent cette compétence */}
                  <td className="border border-neutral-300 dark:border-sky-400/35 text-center align-middle text-[11px] font-semibold bg-neutral-50 dark:bg-[#1f2d42]">
                    {countForComp > 0 ? countForComp : ""}
                  </td>
                </tr>
              );
            })}
          </tbody>
        </table>
      </div>
    </div>
  );
}


  return (
    <div
      className="w-full min-h-screen pb-16 bg-neutral-50 text-neutral-900 dark:bg-[#1f2d42] dark:text-white px-2 sm:px-2 lg:px-0 night-root"
    >
      <FirstRunHelp open={helpOpen} onOpenChange={setHelpOpen} />

      <style>{String.raw`
/* Vue nuit — palette demandée */
.dark .night-root{
  /* Bordures UI (cartes, blocs, etc.) */
  --night-border: #182433;

  /* Bordures TABLEAUX (bleu clair) -> ajuste l’opacité si besoin */
  --night-table-border: rgba(147, 197, 253, 0.55); /* bleu clair (blue-300) */
}

/* Par défaut, on garde les bordures UI en sombre */
.dark .night-root [class*="border-neutral-"]{
  border-color: var(--night-border) !important;
}

/* MAIS pour les tableaux : lignes en bleu clair */
.dark .night-root table,
.dark .night-root table th,
.dark .night-root table td{
  border-color: var(--night-table-border) !important;
}

/* Et pour les bordures "neutral" appliquées aux cellules */
.dark .night-root table [class*="border-neutral-"],
.dark .night-root table [class*="border-l-neutral-"],
.dark .night-root table [class*="border-r-neutral-"],
.dark .night-root table [class*="border-t-neutral-"],
.dark .night-root table [class*="border-b-neutral-"]{
  border-color: var(--night-table-border) !important;
}

/* Fond des tableaux */
.dark .night-root table{
  background: #1f2d42 !important;
  color: #fff !important;
}

/* CCF : traits noirs (lignes du tableau) */
.ccf-table,
.ccf-table th,
.ccf-table td{
  border-color: #000 !important;
}

/* Fallback : conteneurs de tableaux (évite les “cartes” blanches autour des tables) */
.dark .night-root :is(div,section,article)[class*="overflow-x-auto"],
.dark .night-root :is(div,section,article)[class*="overflow-auto"],
.dark .night-root :is(div,section,article)[class*="overflow-y-auto"] {
  background: #1f2d42 !important;
  color: #fff !important;
}
.dark .night-root :is(div,section,article)[class*="shadow"][class*="bg-"]:not(.keep-light) {
  background: #1f2d42 !important;
  color: #fff !important;
}

/* Wrappers qui contiennent un tableau (si :has supporté) */
.dark .night-root :is(div,section,article):has(table) {
  background: #1f2d42 !important;
  color: #fff !important;
}

/* Neutralise les backgrounds “clairs” dans les cellules/entêtes (sans toucher aux couleurs de notes) */
.dark .night-root table .bg-white,
.dark .night-root table .bg-neutral-50,
.dark .night-root table .bg-neutral-100,
.dark .night-root table .bg-neutral-200,
.dark .night-root table .bg-neutral-50\/60,
.dark .night-root table .bg-white\/70,
.dark .night-root table .bg-white\/80,
.dark .night-root table .bg-white\/95,
.dark .night-root table [class*="bg-slate-"],
.dark .night-root table [class*="bg-gray-"],
.dark .night-root table [class*="bg-zinc-"],
.dark .night-root table [class*="bg-stone-"],
.dark .night-root table .bg-muted,
.dark .night-root table .bg-background,
.dark .night-root table .bg-card,
.dark .night-root table .bg-secondary,
.dark .night-root table .bg-accent {
  background: #182433 !important;
}

/* Lignes alternées (classes Tailwind avec :) */
.dark .night-root table .odd\:bg-white:nth-child(odd),
.dark .night-root table .odd\:bg-neutral-50:nth-child(odd),
.dark .night-root table .even\:bg-neutral-50:nth-child(even),
.dark .night-root table .even\:bg-neutral-50\/60:nth-child(even) {
  background: #1f2d42 !important;
}

/* Texte “neutre” → blanc dans les tableaux */
.dark .night-root table [class*="text-neutral-"],
.dark .night-root table [class*="text-slate-"],
.dark .night-root table [class*="text-gray-"],
.dark .night-root table [class*="text-zinc-"] {
  color: #fff !important;
}

/* Pastilles */
.dark .night-root :is(span,button,div,a)[class*="rounded-full"][class*="border-"] {
  border-color: #182433 !important;
}
.dark .night-root :is(span,button,div,a)[class*="rounded-full"][class*="ring-"] {
  --tw-ring-color: #182433 !important;
}

/* Impression — Bilan périodique : conserver l'affichage écran */
@page { size: A4 landscape; margin: 10mm 10mm; }

@media print {
  /* Compactage spécifique au livret (page 2) */
  .bilan-livret .lp-compBlock { margin-top: 6px !important; }

  .bilan-livret .lp-compHead {
    font-size: 16px !important;
    line-height: 1.25 !important;
    padding: 1px 0 !important;
  }

  .bilan-livret .lp-compItem {
    font-size: 14px !important;
    line-height: 1.2 !important;
    padding: 1px 0 !important;
  }

  .bilan-livret .lp-legendLine {
    margin: 4px 0 4px 0 !important;
    font-size: 9px !important;
  }

  .bilan-livret .lp-status {
    width: 14px !important;
    height: 14px !important;
    font-size: 16px !important;
  }
}

/* --- Topbar responsive (réduction progressive dès 1490px ; labels courts < 640px ; icônes seules < 480px) --- */
.topbar-row{
  display:flex;
  flex-wrap:nowrap;
  align-items:center;
  overflow-x:auto;
  overflow-y:hidden;
  -webkit-overflow-scrolling: touch;
  scrollbar-width: none;

  /* 1490 -> 640 */
  --tb-fs: clamp(10px, calc(8.494px + 0.2353vw), 12px);
  --tb-h:  clamp(30px, calc(26.988px + 0.4706vw), 34px);
  --tb-px: clamp(9px,  calc(6.741px + 0.3529vw), 12px);
  --tb-gap: clamp(6px, calc(4.494px + 0.2353vw), 8px);
  --tb-icon: clamp(16px, calc(14.494px + 0.2353vw), 18px);

  gap:var(--tb-gap);
}
.topbar-btn{
  height:var(--tb-h) !important;
  padding-left:var(--tb-px) !important;
  padding-right:var(--tb-px) !important;
  gap:var(--tb-gap) !important;
  font-size:var(--tb-fs) !important;
  line-height:1.1 !important;
  white-space:nowrap !important;
}
.topbar-icon{ width:var(--tb-icon) !important; height:var(--tb-icon) !important; }
.topbar-emoji{ font-size:var(--tb-icon) !important; line-height:1 !important; }
.topbar-row::-webkit-scrollbar{ display:none; }
.topbar-subgroup{ display:flex; flex-wrap:nowrap; align-items:center; gap:var(--tb-gap); }

@media (max-width:1024px){
  /* ✅ Sur écrans plus petits : on autorise le retour à la ligne (sélecteurs visibles) */
  .topbar-row{
    flex-wrap:wrap;
    overflow-x:visible;
  }
  .topbar-subgroup{
    flex-wrap:wrap;
  }
}

@media (max-width:640px){
  .topbar-row{
    --tb-fs: clamp(9px,  calc(6px + 0.625vw), 10px);
    --tb-h:  clamp(28px, calc(22px + 1.25vw), 30px);
    --tb-px: clamp(6px,  calc(-3px + 1.875vw), 9px);
    --tb-gap: clamp(4px, calc(-2px + 1.25vw), 6px);
    --tb-icon: clamp(14px, calc(8px + 1.25vw), 16px);
  }
}
@media (max-width:480px){
  .topbar-label{ display:none !important; }
  .topbar-btn{ padding-left:8px !important; padding-right:8px !important; }
}

/* --- Stepbar (TÂCHES / COMPÉTENCES / EXIGENCES / ÉVALUATION) --- */
.stepbar-list{
  display:flex;
  flex-wrap:wrap;
  align-items:center;

  /* 1490 -> 640 */
  --sb-fs: clamp(10px, calc(8.494px + 0.2353vw), 12px);
  --sb-h:  clamp(28px, calc(25.741px + 0.3529vw), 32px);
  --sb-px: clamp(8px,  calc(5.741px + 0.3529vw), 11px);
  --sb-gap: clamp(6px, calc(4.494px + 0.2353vw), 8px);
  --sb-icon: clamp(14px, calc(12.494px + 0.2353vw), 16px);

  gap:var(--sb-gap);
}
.stepbar-trigger{
  height:var(--sb-h) !important;
  padding-left:var(--sb-px) !important;
  padding-right:var(--sb-px) !important;
  gap:var(--sb-gap) !important;
  font-size:var(--sb-fs) !important;
  line-height:1.1 !important;
  white-space:nowrap !important;
}
.stepbar-icon{
  font-size:var(--sb-icon) !important;
  line-height:1 !important;
}

@media (max-width:640px){
  .stepbar-list{
    --sb-fs: clamp(9px,  calc(6px + 0.625vw), 10px);
    --sb-h:  clamp(26px, calc(22px + 0.9vw), 28px);
    --sb-px: clamp(6px,  calc(-1px + 1.3vw), 8px);
    --sb-gap: clamp(4px, calc(-2px + 1.25vw), 6px);
    --sb-icon: clamp(12px, calc(8px + 0.9vw), 14px);
  }
}
@media (max-width:480px){
  .stepbar-label{ display:none !important; }
  .stepbar-trigger{ padding-left:8px !important; padding-right:8px !important; }
}

/* --- Suivi mode tabs (Devoirs / Synthèse / Évolutions / Bilan) --- */
.suivi-tabs{
  display:flex;
  flex-wrap:wrap;
  align-items:center;

  /* 1490 -> 640 */
  --st-fs: clamp(10px, calc(8.494px + 0.2353vw), 12px);
  --st-px: clamp(8px,  calc(5.741px + 0.3529vw), 11px);
  --st-py: clamp(4px,  calc(3.247px + 0.1176vw), 5px);
  --st-gap: clamp(4px, calc(2.494px + 0.2353vw), 6px);
  --st-icon: clamp(14px, calc(12.494px + 0.2353vw), 16px);

  gap:var(--st-gap);
  font-size:var(--st-fs);
}
.suivi-btn{
  padding:var(--st-py) var(--st-px) !important;
  gap:var(--st-gap) !important;
  font-size:var(--st-fs) !important;
  line-height:1.1 !important;
  white-space:nowrap !important;
}
.suivi-icon{
  font-size:var(--st-icon) !important;
  line-height:1 !important;
}

@media (max-width:640px){
  .suivi-tabs{
    --st-fs: clamp(9px,  calc(6px + 0.625vw), 10px);
    --st-px: clamp(6px,  calc(-1px + 1.3vw), 8px);
    --st-py: clamp(3px,  calc(1px + 0.6vw), 4px);
    --st-gap: clamp(3px, calc(-2px + 1.25vw), 5px);
    --st-icon: clamp(12px, calc(8px + 0.9vw), 14px);
  }
}
@media (max-width:480px){
  .suivi-label{ display:none !important; }
  .suivi-btn{ padding-left:8px !important; padding-right:8px !important; }
}
`}</style>

      {previewOpen && previewHtml && (
  <div
    className="fixed inset-0 z-[9999] bg-black/60 px-4 pb-4 pt-[72px]"
    role="dialog"
    aria-modal="true"
    onMouseDown={(e) => {
      if (e.target === e.currentTarget) {
        closePreviewModal();
      }
    }}
  >
    <div className="keep-light bg-white dark:bg-[#1f2d42] text-neutral-900 dark:text-neutral-300 w-[calc(100vw-32px)] h-[calc(100vh-72px-32px)] max-w-none max-h-none rounded-2xl shadow-xl flex flex-col overflow-hidden">
      <div className="flex items-center justify-between px-4 py-2 border-b border-neutral-200 dark:border-sky-400/35 bg-white dark:bg-[#1f2d42] sticky top-0 z-10">
        <span className="font-semibold text-sm">Aperçu</span>
        <div className="flex items-center gap-2">
          {/* Sélecteur propre à l'Aperçu (indépendant de la fenêtre Impression) */}
          <div className="flex items-center gap-2 mr-2">
            <span className="text-xs text-neutral-600 dark:text-neutral-300">Type d’aperçu</span>
            <select
              className="h-8 w-[220px] text-xs border border-neutral-300 dark:border-sky-400/35 rounded-md px-2 bg-white dark:bg-[#182433]"
              value={previewEvaluationType || ""}
              onChange={(e) => {
                const v = e.target.value;
                setPreviewEvaluationType(v);
                openPreviewWindow(v, evaluationCategory, { target: "preview" });
              }}
            >
              <option value="" disabled>
                Sélectionner un type
              </option>
              <option value="Auto-évaluation">Auto-évaluation</option>
              <option value="code-couleur">Code couleur</option>
              <option value="criterie">Critérié</option>
            </select>
          </div>

          <Button
            variant="ghost"
            className="h-8 w-8 p-0 text-xl leading-none"
            aria-label="Fermer l'aperçu"
            onClick={() => {
              closePreviewModal();
            }}
          >
            ×
          </Button>
        </div>
      </div>

	      <div className="flex-1 overflow-auto bg-neutral-50 dark:bg-[#1f2d42]">
        <iframe
          ref={previewIframeRef}
          title="Aperçu d'impression"
          srcDoc={previewHtml || ""}
          className="w-full h-full border-0"
        />
      </div>
    </div>
  </div>
)}



      
      {printOpen && printHtml && (
        <div
          // Décalage vers le bas pour éviter la confusion avec la barre du haut (CAP-...)
          // + fond plus opaque / blur pour ne pas voir la barre derrière.
          className="fixed inset-0 z-[10000] bg-black/80 backdrop-blur-sm px-4 pb-4 pt-[128px]"
          role="dialog"
          aria-modal="true"
          onMouseDown={(e) => {
            if (e.target === e.currentTarget) {
              closePrintModal();
            }
          }}
        >
          <div className="keep-light bg-white dark:bg-[#1f2d42] text-neutral-900 dark:text-neutral-300 w-[calc(100vw-32px)] h-[calc(100vh-128px-32px)] max-w-none max-h-none rounded-2xl shadow-xl flex flex-col overflow-hidden">
            <div className="sticky top-0 z-10">
              <div className="flex items-center justify-between px-4 py-2 bg-white dark:bg-[#1f2d42] text-neutral-900 dark:text-neutral-300 border-b border-neutral-200 dark:border-sky-400/35">
                <span className="font-semibold text-sm">Impression</span>
                <div className="flex items-center gap-2">
                  <Button
                    variant="outline"
                    className="h-8 px-3 text-xs bg-white hover:bg-amber-100/70 dark:bg-[#182433] text-neutral-900 dark:text-neutral-300 border-neutral-300 dark:border-sky-400/35 hover:bg-amber-100/70 dark:bg-[#182433]"
                    onClick={() => {
                      startPrintJob(printHtml);
                    }}
                  >
                    Imprimer
                  </Button>

                  <Button
                    variant="ghost"
                    className="h-8 px-3 text-xs text-neutral-900 dark:text-neutral-300 hover:bg-amber-100/70 dark:bg-[#182433]"
                    aria-label="Fermer la fenêtre d'impression"
                    onClick={() => {
                      closePrintModal();
                    }}
                  >
                    ✕ Fermer
                  </Button>
                </div>
              </div>

              {activeView === "evaluation" && (
                <div className="flex items-center gap-2 px-4 py-2 border-b border-neutral-200 dark:border-sky-400/35 bg-white dark:bg-[#1f2d42]">
                  <span className="text-xs text-neutral-600 dark:text-neutral-300">Type</span>
                  <select
                    className="h-8 w-[220px] text-xs border border-neutral-300 dark:border-sky-400/35 rounded-md px-2 bg-white dark:bg-[#182433]"
                    value={printEvaluationType || ""}
                    onChange={(e) => {
                      const v = e.target.value;
                      setPrintEvaluationType(v);
                      openPreviewWindow(v, evaluationCategory, { target: "printWindow" });
                    }}
                  >
                    <option value="" disabled>
                      Sélectionner un type d'impression
                    </option>
                    <option value="Auto-évaluation">Auto-évaluation</option>
                    <option value="code-couleur">Code couleur</option>
                    <option value="criterie">Critérié</option>
                  </select>
                </div>
              )}
            </div>

            <div className="flex-1 overflow-auto bg-neutral-50 dark:bg-[#1f2d42]">
              <iframe
                ref={printIframeRef}
                title="Impression"
                srcDoc={printHtml || ""}
                className="w-full h-full border-0"
              />
            </div>
          </div>
        </div>
      )}

{printJobHtml && (
  <iframe
    ref={printJobIframeRef}
    title="Print Job"
    srcDoc={printJobHtml || ""}
    className="fixed right-0 bottom-0 w-[1px] h-[1px] opacity-0 pointer-events-none"
  />
)}

<div className="sticky top-0 z-30 bg-white/80 dark:bg-[#1f2d42]/95 backdrop-blur border-b border-neutral-900 dark:border-[#1b467a] dark:text-white night-banner">
        <div className="h-1 w-full bg-[linear-gradient(90deg,#ef4444,#f97316,#f59e0b,#84cc16,#22d3ee,#3b82f6,#6366f1,#8b5cf6,#d946ef)]" />
<div className="topbar-row w-full px-2 py-2 flex items-center">
{/* Actions */}
<input
  ref={importFileInputRef}
  type="file"
  accept="application/json,.json"
  className="hidden"
  onChange={async (e) => {
    try {
      const f = e.target.files?.[0];
      if (!f) return;
      const txt = await f.text();
      await handleImportClassDataFromText(txt);
    } finally {
      // permettre de ré-importer le même fichier
      e.currentTarget.value = "";
    }
  }}
/>

<DropdownMenu>
  <DropdownMenuTrigger asChild>
    <Button
      title="Actions"
      aria-label="Actions"
      className={classNames(
        "topbar-btn isolate border border-neutral-200 dark:border-sky-400/35 !text-neutral-900 dark:!text-neutral-50",
        "!bg-white dark:!bg-[#243554] hover:!bg-amber-100/70 dark:hover:!bg-[#3d2707]"
      )}
    >
      <span className="topbar-emoji" aria-hidden="true">🧰</span>
      <span className="topbar-label sm:hidden">ACTIONS</span>
      <span className="topbar-label hidden sm:inline">ACTIONS</span>
    </Button>
  </DropdownMenuTrigger>

  <DropdownMenuContent
    align="start"
    className="w-64 bg-white dark:bg-[#1f2d42] border border-neutral-200 dark:border-sky-400/35 text-neutral-900 dark:text-neutral-300"
  >
    <DropdownMenuLabel className="text-xs text-neutral-700 dark:text-neutral-300">
      Actions
    </DropdownMenuLabel>

    <DropdownMenuSeparator className="bg-neutral-200 dark:bg-neutral-700/60" />

<DropdownMenuItem
  disabled={updateBusy}
  className="cursor-pointer dark:hover:bg-[#3d2707]"
  onSelect={() => handleCheckUpdate()}
>
  <div className="flex items-center gap-2">
    <span className="text-base leading-none" aria-hidden="true">⬆️</span>
    <span className="text-sm">{updateBusy ? "Vérification…" : "Vérifier mise à jour"}</span>
  </div>
</DropdownMenuItem>

    <DropdownMenuSeparator className="bg-neutral-200 dark:bg-neutral-700/60" />

    <DropdownMenuItem
      disabled={importBusy}
      className="cursor-pointer dark:hover:bg-[#3d2707]"
      onSelect={() => handleImportClick()}
    >
      <div className="flex items-center gap-2">
        <Upload className="w-4 h-4" aria-hidden="true" />
        <span className="text-sm">{importBusy ? "Importer…" : "Importer une classe"}</span>
      </div>
    </DropdownMenuItem>

    <DropdownMenuItem className="cursor-pointer dark:hover:bg-[#3d2707]" onSelect={() => openExportDrawer()}>
      <div className="flex items-center gap-2">
        <Download className="w-4 h-4" aria-hidden="true" />
        <span className="text-sm">Exporter une classe</span>
      </div>
    </DropdownMenuItem>

    <DropdownMenuSeparator className="bg-neutral-200 dark:bg-neutral-700/60" />

    <DropdownMenuItem className="cursor-pointer dark:hover:bg-[#3d2707]" onSelect={() => handlePrintClick()}>
      <div className="flex items-center gap-2">
        <span className="text-base leading-none" aria-hidden="true">🖨️</span>
        <span className="text-sm">Imprimer</span>
      </div>
    </DropdownMenuItem>

    <DropdownMenuSeparator className="bg-neutral-200 dark:bg-neutral-700/60" />

    <DropdownMenuItem className="cursor-pointer dark:hover:bg-[#3d2707]" onSelect={() => setClassDrawerOpen(true)}>
      <div className="flex items-center gap-2">
        <span className="text-base leading-none" aria-hidden="true">📚</span>
        <span className="text-sm">Classes</span>
      </div>
    </DropdownMenuItem>

<DropdownMenuItem className="cursor-pointer dark:hover:bg-[#3d2707]" onSelect={() => { setActiveView("referentiel_add"); setReferentielDrawerOpen(false); }}>
  <div className="flex items-center gap-2">
    <Search className="w-4 h-4" aria-hidden="true" />
    <span className="text-sm">Ajouter mon référentiel</span>
  </div>
</DropdownMenuItem>


    <DropdownMenuItem className="cursor-pointer dark:hover:bg-[#3d2707]" onSelect={() => handleOpenDevoirDatabase()}>
      <div className="flex items-center gap-2">
        <span className="text-base leading-none" aria-hidden="true">📁</span>
        <span className="text-sm">devoirs</span>
      </div>
    </DropdownMenuItem>

    <DropdownMenuItem className="cursor-pointer dark:hover:bg-[#3d2707]" onSelect={() => setGeneralSettingsDrawerOpen(true)}>
      <div className="flex items-center gap-2">
        <Settings2 className="w-4 h-4" aria-hidden="true" />
        <span className="text-sm">Paramètre général</span>
      </div>
    </DropdownMenuItem>

  </DropdownMenuContent>
</DropdownMenu>

<div className="topbar-subgroup">
    {/* Créer un devoir */}
    <Button
      type="button"
      title="Créer un devoir"
      aria-label="Créer un devoir"
      className={classNames(
        "topbar-btn isolate border border-neutral-200 dark:border-sky-400/35 !text-neutral-900 dark:!text-neutral-50",
        activeView === "evaluation"
          ? "!bg-black !text-white" : "!bg-white dark:!bg-[#243554] hover:!bg-amber-100/70 dark:hover:!bg-[#3d2707]"
      )}
      onClick={() => setActiveView("evaluation")}
    >
      <span className="topbar-emoji" aria-hidden="true">📝</span>
      <span className="topbar-label sm:hidden">CRÉER</span>
      <span className="topbar-label hidden sm:inline">CRÉER UN DEVOIR</span>
    </Button>

    {/* Notation */}
    <Button
      type="button"
      title="Notation"
      aria-label="Notation"
      className={classNames(
        "topbar-btn isolate border border-neutral-200 dark:border-sky-400/35 !text-neutral-900 dark:!text-neutral-50",
        activeView === "notes"
          ? "!bg-black !text-white" : "!bg-white dark:!bg-[#243554] hover:!bg-amber-100/70 dark:hover:!bg-[#3d2707]"
      )}
      onClick={() => setActiveView("notes")}
    >
      <span className="topbar-emoji" aria-hidden="true">🧮</span>
      <span className="topbar-label sm:hidden">NOTES</span>
      <span className="topbar-label hidden sm:inline">NOTATION</span>
    </Button>

    {/* Suivi des compétences */}
    <Button
      type="button"
      title="Suivi des compétences"
      aria-label="Suivi des compétences"
      className={classNames(
        "topbar-btn isolate border border-neutral-200 dark:border-sky-400/35 !text-neutral-900 dark:!text-neutral-50",
        activeView === "suivi"
          ? "!bg-black !text-white" : "!bg-white dark:!bg-[#243554] hover:!bg-amber-100/70 dark:hover:!bg-[#3d2707]"
      )}
      onClick={() => setActiveView("suivi")}
    >
      <span className="topbar-emoji" aria-hidden="true">📊</span>
      <span className="topbar-label sm:hidden">SUIVI</span>
      <span className="topbar-label hidden sm:inline">SUIVI DES COMPÉTENCES</span>
    </Button>

    
{/* Suivi d'élèves */}
<Button
  type="button"
  title="Suivi d'élèves"
  aria-label="Suivi d'élèves"
  className={classNames(
    "topbar-btn isolate border border-neutral-200 dark:border-sky-400/35 !text-neutral-900 dark:!text-neutral-50",
    activeView === "suivi_eleves"
      ? "!bg-black !text-white" : "!bg-white dark:!bg-[#243554] hover:!bg-amber-100/70 dark:hover:!bg-[#3d2707]"
  )}
  onClick={() => { setActiveView("suivi_eleves"); setSuiviElevesMode("docs"); }}
>
  <span className="topbar-emoji" aria-hidden="true">🗂️</span>
  <span className="topbar-label sm:hidden">ÉLÈVES</span>
  <span className="topbar-label hidden sm:inline">SUIVI D&apos;ÉLÈVES</span>
</Button>


    {/* CCF */}
    <Button
      type="button"
      title="CCF"
      aria-label="CCF"
      className={classNames(
        "topbar-btn isolate border border-neutral-200 dark:border-sky-400/35 !text-neutral-900 dark:!text-neutral-50",
        activeView === "ccf"
          ? "!bg-black !text-white" : "!bg-white dark:!bg-[#243554] hover:!bg-amber-100/70 dark:hover:!bg-[#3d2707]"
      )}
      onClick={() => setActiveView("ccf")}
    >
      <span className="topbar-emoji" aria-hidden="true">🧾</span>
      <span className="topbar-label sm:hidden">CCF</span>
      <span className="topbar-label hidden sm:inline">CCF</span>
    </Button>

  </div>

{/* Drawer Classe / Élèves */}
<Drawer
  open={classDrawerOpen}
  onClose={() => setClassDrawerOpen(false)}
  side="right"
  className="w-[360px] sm:w-[420px]"
>
  <div className="px-4 py-3 border-b border-neutral-200 dark:border-sky-400/35 font-semibold bg-white dark:bg-[#1f2d42] text-neutral-900 dark:text-neutral-300">
    Classe / élèves
  </div>

  <div className="p-3 space-y-4 bg-neutral-50 dark:bg-[#0f1b2d]">
    <div className="flex items-center justify-between gap-2">
      <div>
        <p className="text-xs text-neutral-600 dark:text-neutral-300">
          Ajoutez une ou plusieurs classes et saisissez les noms des élèves (un par ligne).
        </p>
      </div>
      <Button
        type="button"
        className="h-8 px-3 text-xs !bg-neutral-900 !text-white hover:!bg-amber-100/70 dark:!bg-sky-500/25 dark:!text-sky-50 dark:hover:!bg-sky-500/35 border border-neutral-900/15 dark:border-sky-400/40"
        onClick={() => {
          setClassGroups((prev) => [
            ...prev,
            {
              id: `${Date.now()}-${Math.random().toString(16).slice(2)}`,
              name: `Classe ${prev.length + 1}`,
              students: "",
            },
          ]);
        }}
      >
        + Ajouter une classe
      </Button>
    </div>

    {classGroups.length === 0 ? (
      <p className="text-xs text-neutral-500 dark:text-neutral-300">
        Aucune classe pour l’instant. Cliquez sur <strong>Ajouter une classe</strong> pour commencer.
      </p>
    ) : (
            <div className="space-y-3">
        {classGroups.map((classe, idx) => {
          const s = CLASS_BUBBLE_STYLES[idx % CLASS_BUBBLE_STYLES.length];
          const studentCount = (classe.students || "")
            .split("\n")
            .map((x) => x.trim())
            .filter(Boolean).length;

          return (
            <div
              key={classe.id}
              className="border border-neutral-200 dark:border-sky-400/35 rounded-xl bg-white dark:bg-[#182433] keep-light p-3 space-y-2 shadow-sm"
            >
              {/* ✅ Bulle colorée (identité de la classe) */}
              <div className="flex items-center justify-between gap-2">
                <span
                  className={classNames(
                    "inline-flex items-center gap-2 rounded-full border px-2 py-1 text-[11px] font-semibold",
                    s.bubble
                  )}
                >
                  <span className={classNames("w-2 h-2 rounded-full", s.dot)} aria-hidden="true" />
                  {classe.name || `Classe ${idx + 1}`}
                </span>

                <span className="text-[11px] text-neutral-500 dark:text-neutral-300">
                  {studentCount} élève{studentCount > 1 ? "s" : ""}
                </span>
              </div>

              <div className="flex items-center justify-between gap-2">
                <div className="flex-1 space-y-1">
                  <Label className="text-xs text-neutral-900 dark:text-neutral-300">Intitulé de la classe</Label>
                  <Input
                    value={classe.name}
                    onChange={(e) =>
                      setClassGroups((prev) =>
                        prev.map((c) =>
                          c.id === classe.id ? { ...c, name: e.target.value } : c
                        )
                      )
                    }
                    className="h-8 text-xs !bg-white dark:!bg-[#1f2d42] !text-neutral-900 dark:!text-neutral-50 !border-neutral-300 dark:!border-neutral-700/60"
                    placeholder="Ex : CAP1, CAP2 Groupe A..."
                  />
                </div>
                <Button
                  type="button"
                  variant="ghost"
                  className="h-8 px-2 text-xs text-red-600 dark:text-red-300 hover:bg-amber-100/70 dark:hover:bg-red-950/30"
                  onClick={() =>
                    setClassGroups((prev) => prev.filter((c) => c.id !== classe.id))
                  }
                >
                  Supprimer
                </Button>
              </div>

              <div className="space-y-1">
                <Label className="text-xs text-neutral-900 dark:text-neutral-300">Noms des élèves</Label>
                <Textarea
                  rows={6}
                  className="text-xs !bg-white dark:!bg-[#1f2d42] !text-neutral-900 dark:!text-neutral-50 !border-neutral-300 dark:!border-neutral-700/60"
                  placeholder="Un élève par ligne"
                  value={classe.students}
                  onChange={(e) =>
                    setClassGroups((prev) =>
                      prev.map((c) =>
                        c.id === classe.id
                          ? { ...c, students: e.target.value }
                          : c
                      )
                    )
                  }
                />
              </div>
            </div>
          );
        })}
      </div>
    )}

  </div>
</Drawer>



{/* Drawer Référentiel */}
<Drawer
  open={referentielDrawerOpen}
  onClose={() => setReferentielDrawerOpen(false)}
  side="right"
  className="w-[360px] sm:w-[520px]"
>
  <div className="px-4 py-3 border-b border-neutral-200 dark:border-sky-400/35 font-semibold bg-white dark:bg-[#1f2d42] text-neutral-900 dark:text-neutral-300">
    Ajouter mon référentiel
  </div>

  <div className="p-3 space-y-4 bg-neutral-50 dark:bg-[#0f1b2d]">
    <div className="grid gap-4 lg:grid-cols-2">
      <div className="space-y-4">
    {/* Recherche CAP (PDF only) */}
    <div className="rounded-xl border border-neutral-200 dark:border-sky-400/35 bg-white dark:bg-[#182433] p-3 space-y-2">
      <div className="flex items-center justify-between gap-2">
        <div className="text-sm font-semibold text-neutral-900 dark:text-neutral-200">Recherche d’un CAP (Eduscol)</div>
        <Button
          type="button"
          className="h-8 px-3 text-xs !bg-neutral-900 !text-white hover:!bg-amber-100/70 dark:!bg-sky-500/25 dark:!text-sky-50 dark:hover:!bg-sky-500/35 border border-neutral-900/15 dark:border-sky-400/40"
          disabled={capCatalogLoading}
          onClick={() => fetchCapCatalog()}
        >
          {capCatalogLoading ? "Chargement…" : "Mettre à jour la liste"}
        </Button>
      </div>

      <div className="flex items-center gap-2">
        <Input
          value={capSearchQuery}
          onChange={(e) => setCapSearchQuery(e.target.value)}
          placeholder="Rechercher (ex : PAR, carreleur, peintre, béton armé…) "
          className="h-9 text-sm !bg-white dark:!bg-[#1f2d42] !text-neutral-900 dark:!text-neutral-50 !border-neutral-300 dark:!border-neutral-700/60"
        />
        <label className="flex items-center gap-2 text-xs text-neutral-700 dark:text-neutral-300 select-none">
          <input
            type="checkbox"
            checked={capPdfOnly}
            onChange={(e) => setCapPdfOnly(e.target.checked)}
          />
          PDF uniquement
        </label>
      </div>

      {capCatalogError ? (
        <div className="text-xs text-red-600 dark:text-red-300">{capCatalogError}</div>
      ) : null}

      <div className="max-h-56 overflow-auto rounded-lg border border-neutral-200 dark:border-sky-400/25 bg-neutral-50 dark:bg-[#0f1b2d]">
        {(() => {
          const q = capSearchQuery.trim().toLowerCase();
          const filtered = q
            ? capCatalog.filter((x) => x.title.toLowerCase().includes(q) || x.url.toLowerCase().includes(q)).slice(0, 30)
            : capCatalog.slice(0, 20);

          if (capCatalog.length === 0) {
            return (
              <div className="p-3 text-xs text-neutral-600 dark:text-neutral-300">
                Clique sur <strong>Mettre à jour la liste</strong> pour charger le catalogue CAP.
              </div>
            );
          }
          if (filtered.length === 0) {
            return <div className="p-3 text-xs text-neutral-600 dark:text-neutral-300">Aucun résultat.</div>;
          }
          return (
            <div className="divide-y divide-neutral-200 dark:divide-sky-400/20">
              {filtered.map((it) => (
                <div key={it.url} className="p-2 flex items-center justify-between gap-2">
                  <div className="min-w-0">
                    <div className="text-xs font-medium text-neutral-900 dark:text-neutral-200 truncate">{it.title}</div>
                    <div className="text-[11px] text-neutral-500 dark:text-neutral-400 truncate">{it.url}</div>
                  </div>
                  <div className="flex items-center gap-2">
                    <Button
                      type="button"
                      className="h-7 px-2 text-[11px] !bg-white dark:!bg-[#1f2d42] !text-neutral-900 dark:!text-neutral-50 border border-neutral-200 dark:border-sky-400/35 hover:!bg-amber-100/70 dark:hover:!bg-[#3d2707]"
                      onClick={() => {
                        setReferentielSourceUrl(it.url);
                        setReferentielMessage("URL sélectionnée. Clique sur “Analyser l’URL” pour trouver le PDF.");
                      }}
                    >
                      Choisir
                    </Button>
                    <Button
                      type="button"
                      className="h-7 px-2 text-[11px] !bg-neutral-900 !text-white hover:!bg-amber-100/70 dark:!bg-sky-500/25 dark:!text-sky-50 dark:hover:!bg-sky-500/35 border border-neutral-900/15 dark:border-sky-400/40"
                      onClick={() => {
                        if (capPdfOnly) {
                          openCapReferentielPicker(it.title, it.url);
                        } else {
                          analyzeReferentielUrl(it.url);
                        }
                      }}
                    >
                      {capPdfOnly ? "Trouver PDF" : "Analyser"}
                    </Button>
                  
                    <Button
                      type="button"
                      className="h-7 px-2 text-[11px] !bg-white dark:!bg-[#1f2d42] !text-neutral-900 dark:!text-neutral-50 border border-neutral-200 dark:border-sky-400/35 hover:!bg-amber-100/70 dark:hover:!bg-[#3d2707]"
                      onClick={() => {
                        proposeLatestArreteForCap(it.title, it.url);
                      }}
                    >
                      Dernier arrêté
                    </Button>
</div>
                </div>
              ))}
            </div>
          );
        })()}
      </div>
    </div>

    {/* (Déplacé) La liste des fichiers trouvés s'affiche maintenant dans le bloc "Importer / créer", entre l'action de recherche et l'import. */}
      </div>

      <div className="space-y-4">

    {/* Import URL / JSON */}
    <div className="rounded-xl border border-neutral-200 dark:border-sky-400/35 bg-white dark:bg-[#182433] p-3 space-y-2">
      <div className="text-sm font-semibold text-neutral-900 dark:text-neutral-200">Importer / créer</div>

      <div className="space-y-1">
        <Label className="text-xs text-neutral-900 dark:text-neutral-300">Nom</Label>
        <Input
          value={referentielName}
          onChange={(e) => setReferentielName(e.target.value)}
          placeholder="Ex : CAP Peintre applicateur de revêtements"
          className="h-9 text-sm !bg-white dark:!bg-[#1f2d42] !text-neutral-900 dark:!text-neutral-50 !border-neutral-300 dark:!border-neutral-700/60"
        />
      </div>

      <div className="space-y-1">
        <Label className="text-xs text-neutral-900 dark:text-neutral-300">URL (page Eduscol ou PDF)</Label>
        <div className="flex items-center gap-2">
          <Input
            value={referentielSourceUrl}
            onChange={(e) => setReferentielSourceUrl(e.target.value)}
            placeholder="Colle une URL Eduscol (HTML) ou un PDF"
            className="h-9 text-sm flex-1 !bg-white dark:!bg-[#1f2d42] !text-neutral-900 dark:!text-neutral-50 !border-neutral-300 dark:!border-neutral-700/60"
          />
          <Button
            type="button"
            className="h-9 px-3 text-xs !bg-white dark:!bg-[#1f2d42] !text-neutral-900 dark:!text-neutral-50 border border-neutral-200 dark:border-sky-400/35 hover:!bg-amber-100/70 dark:hover:!bg-[#3d2707]"
            onClick={() => openUrlPreviewWindow(referentielSourceUrl)}
          >
            Aperçu
          </Button>
          <Button
            type="button"
            className="h-9 px-3 text-xs !bg-neutral-900 !text-white hover:!bg-amber-100/70 dark:!bg-sky-500/25 dark:!text-sky-50 dark:hover:!bg-sky-500/35 border border-neutral-900/15 dark:border-sky-400/40"
            disabled={analyzeBusy}
            onClick={() => analyzeReferentielUrl(referentielSourceUrl)}
          >
            {analyzeBusy ? "Analyse…" : "Analyser l’URL"}
          </Button>
        </div>
      </div>

      {referentielMessage ? (
        <div className="text-xs text-neutral-700 dark:text-neutral-300">{referentielMessage}</div>
      ) : null}

      {/* Liste des fichiers trouvés (entre Rechercher/Analyser et Importer) */}
      {(capRefPickerBusy || capRefPickerError || capRefChoices.length > 0 || (stiSearchUrl && stiArreteCandidates.length > 0) || foundResources.length > 0) ? (
        <div className="mt-2 rounded-lg border border-neutral-200 dark:border-sky-400/25 bg-neutral-50 dark:bg-[#0f1b2d] p-2 space-y-2">
          <div className="flex items-center justify-between gap-2">
            <div className="text-xs font-semibold text-neutral-900 dark:text-neutral-200">Fichiers trouvés</div>
            <div className="flex items-center gap-2">
              <Button
                type="button"
                className="h-7 px-2 text-[11px] !bg-white dark:!bg-[#1f2d42] !text-neutral-900 dark:!text-neutral-50 border border-neutral-200 dark:border-sky-400/35 hover:!bg-amber-100/70 dark:hover:!bg-[#3d2707]"
                disabled={capRefPickerBusy || capRefChoices.length === 0}
                onClick={() => {
                  const best = capRefChoices[0];
                  if (!best) return;
                  setReferentielName(capRefPickerTitle || referentielName || "");
                  setReferentielSourceUrl(best.url);
                  setReferentielMessage(`Lien sélectionné : ${best.title}${best.dateISO ? ` (${best.dateISO})` : ""}.`);
                }}
              >
                Plus récent (CAP)
              </Button>
              <Button
                type="button"
                className="h-7 px-2 text-[11px] !bg-neutral-900 !text-white hover:!bg-amber-100/70 dark:!bg-sky-500/25 dark:!text-sky-50 dark:hover:!bg-sky-500/35 border border-neutral-900/15 dark:border-sky-400/40"
                disabled={capRefPickerBusy}
                onClick={() => {
                  setCapRefPickerError(null);
                  setCapRefPickerTitle("");
                  setCapRefPickerCapUrl("");
                  setCapRefChoices([]);
                  setStiSearchUrl("");
                  setStiSearchTerms("");
                  setStiArreteCandidates([]);
                  setFoundResources([]);
                }}
              >
                Effacer
              </Button>
            </div>
          </div>

          {capRefPickerBusy ? (
            <div className="text-[11px] text-neutral-700 dark:text-neutral-300">Recherche en cours…</div>
          ) : null}

          {capRefPickerError ? (
            <div className="text-[11px] text-red-600 dark:text-red-300">{capRefPickerError}</div>
          ) : null}

          {(() => {
            type AnyChoice = { title: string; url: string; dateISO?: string; source: string; isPdf?: boolean; meta?: string };
            const list: AnyChoice[] = [];

            capRefChoices.forEach((c) => {
              list.push({
                title: c.title,
                url: c.url,
                dateISO: c.dateISO,
                source: c.source,
                isPdf: c.isPdf,
                meta: `${c.isPdf ? "PDF" : "Page"}`,
              });
            });

            if (stiArreteCandidates.length > 0) {
              stiArreteCandidates.slice(0, 10).forEach((c) => {
                const urlToUse = c.pdfUrl || c.pageUrl;
                list.push({
                  title: c.title,
                  url: urlToUse,
                  dateISO: c.dateISO,
                  source: "sti",
                  isPdf: Boolean(c.pdfUrl),
                  meta: c.pdfUrl ? "PDF annexes" : "Page",
                });
              });
            }

            if (foundResources.length > 0) {
              foundResources.slice(0, 15).forEach((r) => {
                list.push({
                  title: r.title,
                  url: r.url,
                  source: "analyse",
                  isPdf: r.kind === "pdf",
                  meta: r.kind === "pdf" ? "PDF" : "Page",
                });
              });
            }

            // tri : date desc (si date), puis PDF d'abord
            const sorted = list
              .slice()
              .sort((a, b) => {
                const da = a.dateISO || "";
                const db = b.dateISO || "";
                if (da !== db) return db.localeCompare(da);
                const pa = a.isPdf ? 1 : 0;
                const pb = b.isPdf ? 1 : 0;
                return pb - pa;
              });

            if (sorted.length === 0) return null;

            return (
              <div className="max-h-44 overflow-auto rounded-md border border-neutral-200 dark:border-sky-400/20 bg-white/60 dark:bg-black/10">
                <div className="divide-y divide-neutral-200 dark:divide-sky-400/15">
                  {sorted.slice(0, 20).map((c) => (
                    <div key={c.url} className="p-2 flex items-start justify-between gap-2">
                      <div className="min-w-0">
                        <div className="text-xs font-medium text-neutral-900 dark:text-neutral-100 truncate">{c.title}</div>
                        <div className="text-[11px] text-neutral-600 dark:text-neutral-300 truncate">
                          {c.dateISO ? `${c.dateISO} · ` : ""}
                          {c.meta ? `${c.meta} · ` : ""}
                          {c.source.toUpperCase()}
                        </div>
                        <div className="text-[11px] text-neutral-600 dark:text-neutral-400 truncate">{c.url}</div>
                      </div>
                      <div className="flex items-center gap-2 shrink-0">
                        <Button
                          type="button"
                          className="h-8 px-2 text-[11px] !bg-neutral-900 !text-white hover:!bg-amber-100/70 dark:!bg-sky-500/25 dark:!text-sky-50 dark:hover:!bg-sky-500/35 border border-neutral-900/15 dark:border-sky-400/40"
                          onClick={() => {
                            setReferentielSourceUrl(c.url);
                            if (!referentielName && capRefPickerTitle) setReferentielName(capRefPickerTitle);
                            setReferentielMessage(`Lien sélectionné : ${c.title}${c.dateISO ? ` (${c.dateISO})` : ""}.`);
                          }}
                        >
                          Utiliser
                        </Button>
                        <Button
                          type="button"
                          variant="secondary"
                          className="h-8 px-2 text-[11px]"
                          onClick={() => openUrlPreviewWindow(c.url)}
                        >
                          Voir
                        </Button>
                      </div>
                    </div>
                  ))}
                </div>
              </div>
            );
          })()}

          {stiSearchUrl ? (
            <div className="text-[11px] text-neutral-600 dark:text-neutral-400">
              Recherche STI : <span className="font-mono">{stiSearchTerms}</span>{" "}
              <a
                className="underline underline-offset-2"
                href={stiSearchUrl}
                onClick={(e) => {
                  e.preventDefault();
                  openUrlPreviewWindow(stiSearchUrl);
                }}
              >
                (ouvrir)
              </a>
            </div>
          ) : null}
        </div>
      ) : null}

      {/* (Les résultats STI / ressources détectées sont désormais affichés dans la liste "Fichiers trouvés" ci-dessus.) */}

      <div className="space-y-1">
        <div className="flex items-center justify-between gap-2">
          <Label className="text-xs text-neutral-900 dark:text-neutral-300">JSON itemé</Label>
          <Button
            type="button"
            variant="ghost"
            className="h-7 px-2 text-[11px] text-neutral-900 dark:text-neutral-200 hover:bg-amber-100/70 dark:hover:bg-[#3d2707]"
            onClick={() => {
              const model = {
                formatVersion: 1,
                meta: {
                  id: (referentielName || "cap").toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, ""),
                  title: referentielName || "CAP …",
                  sourceUrl: referentielSourceUrl || "",
                  importedAt: new Date().toISOString(),
                },
                items: [
                  {
                    task: { code: "T1", label: "Tâche 1" },
                    competency: { code: "C1.1", label: "Compétence 1.1" },
                    ability: { code: "EC1", label: "Être capable de…" },
                    criteria: ["Critère 1", "Critère 2"],
                  },
                ],
              };
              setReferentielItemsJson(JSON.stringify(model, null, 2));
            }}
          >
            Modèle
          </Button>
        </div>
        <Textarea
          rows={10}
          value={referentielItemsJson}
          onChange={(e) => setReferentielItemsJson(e.target.value)}
          className="text-xs !bg-white dark:!bg-[#1f2d42] !text-neutral-900 dark:!text-neutral-50 !border-neutral-300 dark:!border-neutral-700/60"
          placeholder='Colle ici ton JSON "itemé" (formatVersion/meta/items)…'
        />
      </div>

      <div className="flex items-center justify-end gap-2">
        <Button
          type="button"
          className="h-9 px-3 text-xs !bg-white dark:!bg-[#1f2d42] !text-neutral-900 dark:!text-neutral-50 border border-neutral-200 dark:border-sky-400/35 hover:!bg-amber-100/70 dark:hover:!bg-[#3d2707]"
          onClick={async () => {
            const f = await open({ multiple: false, filters: [{ name: "JSON", extensions: ["json"] }] });
            if (!f || Array.isArray(f)) return;
            const content = await readTextFile(f);
            setReferentielItemsJson(content);
            setReferentielMessage("JSON chargé depuis un fichier.");
          }}
        >
          Importer un fichier…
        </Button>

        <Button
          type="button"
          className="h-9 px-3 text-xs !bg-neutral-900 !text-white hover:!bg-amber-100/70 dark:!bg-sky-500/25 dark:!text-sky-50 dark:hover:!bg-sky-500/35 border border-neutral-900/15 dark:border-sky-400/40"
          onClick={async () => {
            try {
              const raw = referentielItemsJson.trim();
              if (!raw) throw new Error("JSON vide");
              let doc: any;
              if (raw.startsWith("[")) {
                doc = {
                  formatVersion: 1,
                  meta: { title: referentielName || "Référentiel", sourceUrl: referentielSourceUrl || "", importedAt: new Date().toISOString() },
                  items: JSON.parse(raw),
                };
              } else {
                doc = JSON.parse(raw);
                if (!doc.items || !Array.isArray(doc.items)) throw new Error("Le JSON doit contenir un champ items[]");
              }
              doc.formatVersion = 1;
              doc.meta = doc.meta || {};
              doc.meta.title = doc.meta.title || referentielName || "Référentiel";
              doc.meta.sourceUrl = referentielSourceUrl || doc.meta.sourceUrl || "";
              doc.meta.updatedAt = new Date().toISOString();
              doc.meta.id =
                doc.meta.id ||
                (doc.meta.title || "referentiel").toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");

              await mkdir("referentiels", { baseDir: BaseDirectory.AppLocalData, recursive: true }).catch(() => {});
              await writeTextFile(`referentiels/${doc.meta.id}.json`, JSON.stringify(doc, null, 2), { baseDir: BaseDirectory.AppLocalData });
              setReferentielMessage(`Référentiel sauvegardé : ${doc.meta.id}.json`);
            } catch (e: any) {
              setReferentielMessage(e?.message || "Erreur de sauvegarde");
            }
          }}
        >
          Enregistrer
        </Button>
      </div>
    </div>
      </div>
    </div>

  </div>
</Drawer>


{/* Drawer Export */}
<Drawer
  open={exportDrawerOpen}
  onClose={() => setExportDrawerOpen(false)}
  side="right"
  className="w-[360px] sm:w-[420px]"
>
  <div className="px-4 py-3 border-b border-neutral-200 dark:border-sky-400/35 font-semibold bg-white dark:bg-[#1f2d42] text-neutral-900 dark:text-neutral-300">
    Exporter une classe
  </div>

  <div className="p-3 space-y-4 bg-neutral-50 dark:bg-[#0f1b2d]">
    <p className="text-xs text-neutral-600 dark:text-neutral-300">
      Exporte dans un fichier toutes les données liées à une classe (devoirs sur 2 ans, notation, suivi des compétences…).
    </p>

    <div className="space-y-2">
<label className="text-neutral-900 dark:!text-neutral-50">Classe à exporter</label>

<select
  className="w-full rounded-md border border-neutral-200 bg-white px-3 py-2 text-sm text-neutral-900
             dark:border-sky-400/35 dark:bg-[#1f2d42] dark:text-neutral-300"
  value={exportClassName}
  onChange={(e) => setExportClassName(e.target.value)}
>
  <option value="" disabled>
    Choisir la classe
  </option>
  {classGroups.map((c) => (
    <option key={c.name} value={c.name}>
      {c.name}
    </option>
  ))}
</select>

    </div>

    <div className="flex items-center gap-2">
      <Button
        type="button"
        disabled={!exportClassName || exportBusy}
        className="h-9 px-3 text-xs !bg-neutral-900 !text-white hover:!bg-amber-100/70 dark:!bg-sky-500/25 dark:!text-sky-50 dark:hover:!bg-sky-500/35 border border-neutral-900/15 dark:border-sky-400/40"
        onClick={() => handleExportClassData(exportClassName)}
      >
        {exportBusy ? "Export en cours…" : "Enregistrer sous…"}
      </Button>

      <Button
        type="button"
        variant="ghost"
        className="h-9 px-3 text-xs"
        onClick={() => setExportDrawerOpen(false)}
      >
        Fermer
      </Button>
    </div>

    <div className="text-[11px] text-neutral-500 dark:text-neutral-300">
      Le fichier exporté peut être déplacé sur un autre ordinateur pour sauvegarde ou transfert.
    </div>
  </div>
</Drawer>

{/* Drawer Paramètre général */}
<Drawer
  open={generalSettingsDrawerOpen}
  onClose={() => setGeneralSettingsDrawerOpen(false)}
  side="right"
  className="w-[360px] sm:w-[520px]"
>
  <div className="px-4 py-3 border-b border-neutral-200 dark:border-sky-400/35 font-semibold bg-white dark:bg-[#1f2d42] text-neutral-900 dark:text-neutral-300">
    Paramètre général
  </div>

  <div className="p-3 space-y-4 bg-neutral-50 dark:bg-[#0f1b2d]">
    <p className="text-xs text-neutral-600 dark:text-neutral-300">
      Ces informations sont utilisées dans les impressions (livret périodique). Elles sont sauvegardées dans <span className="font-mono">AppLocalData/{GENERAL_SETTINGS_FILE}</span>.
    </p>

    <div className="space-y-2">
      <Label className="text-neutral-900 dark:!text-neutral-50">Nom de l&apos;établissement</Label>
      <Input
        value={generalSettings.establishmentName}
        onChange={(e) => setGeneralSettings((p) => ({ ...p, establishmentName: e.target.value }))}
        placeholder="Ex: GRETA / CFA / Lycée ..."
        className="bg-white text-neutral-900 border-neutral-200 dark:!bg-[#1f2d42] dark:!text-neutral-50 dark:border-sky-400/35"
      />
    </div>

    <div className="space-y-2">
      <Label className="text-neutral-900 dark:!text-neutral-50">Localisation (optionnel)</Label>
      <Input
        value={generalSettings.establishmentLocation}
        onChange={(e) => setGeneralSettings((p) => ({ ...p, establishmentLocation: e.target.value }))}
        placeholder="Ex: Ville / Adresse courte"
        className="bg-white text-neutral-900 border-neutral-200 dark:!bg-[#1f2d42] dark:!text-neutral-50 dark:border-sky-400/35"
      />
    </div>

    <div className="space-y-2">
      <Label className="text-neutral-900 dark:!text-neutral-50">Référent(s) par défaut (optionnel)</Label>
      <Input
        value={generalSettings.defaultReferents}
        onChange={(e) => setGeneralSettings((p) => ({ ...p, defaultReferents: e.target.value }))}
        placeholder="Ex: Nom Prénom / Nom2 Prénom2"
        className="bg-white text-neutral-900 border-neutral-200 dark:!bg-[#1f2d42] dark:!text-neutral-50 dark:border-sky-400/35"
      />
      <p className="text-[11px] text-neutral-500 dark:text-neutral-300">
        Utilisé si une classe n&apos;a pas de référent renseigné ci-dessous.
      </p>
    </div>

    <div className="pt-2 border-t border-neutral-200 dark:border-sky-400/35">
      <div className="text-sm font-semibold text-neutral-900 dark:text-neutral-300 mb-2">Référent(s) par classe</div>
      <div className="space-y-2">
        {classGroups.length === 0 ? (
          <div className="text-xs text-neutral-600 dark:text-neutral-300">Aucune classe.</div>
        ) : (
          classGroups.map((c) => {
            const k = String(c.name || "").trim();
            const v = (generalSettings.classReferents && typeof generalSettings.classReferents[k] === "string")
              ? generalSettings.classReferents[k]
              : "";
            return (
              <div key={c.id} className="grid grid-cols-1 sm:grid-cols-[170px_1fr] gap-2 items-center">
                <div className="text-xs font-medium text-neutral-800 dark:text-neutral-300">
                  {c.name}
                </div>
                <Input
                  value={v}
                  onChange={(e) =>
                    setGeneralSettings((p) => ({
                      ...p,
                      classReferents: { ...(p.classReferents || {}), [k]: e.target.value },
                    }))
                  }
                  placeholder="Référent(s) de la classe"
                  className="bg-white text-neutral-900 border-neutral-200 dark:!bg-[#1f2d42] dark:!text-neutral-50 dark:border-sky-400/35"
                />
              </div>
            );
          })
        )}
      </div>
    </div>

    <div className="pt-2 border-t border-neutral-200 dark:border-sky-400/35">
      <div className="text-sm font-semibold text-neutral-900 dark:text-neutral-300 mb-2">
        Seuils — Feux Absences / Retards
      </div>
      <div className="text-[11px] text-neutral-500 dark:text-neutral-300">
        Utilisés pour le feu (vert/orange/rouge) dans le suivi et le bilan périodique. Seuils exprimés en % des jours de cours effectifs.
      </div>
      <div className="grid grid-cols-1 sm:grid-cols-2 gap-3 mt-2">
        <div className="space-y-2 rounded-lg border border-neutral-200 dark:border-sky-400/35 bg-white dark:bg-[#182433] p-3">
          <div className="text-xs font-semibold text-neutral-900 dark:text-neutral-300">Absences</div>
          <div className="grid grid-cols-2 gap-2">
            <div className="space-y-1">
              <Label className="text-xs">Orange (%)</Label>
              <Input
                type="number"
                min={0}
                max={100}
                step={0.5}
                value={String(absencesWarnAbsPct)}
                onChange={(e) => {
                  const raw = (e.target.value || "0").replace(",", ".");
                  const n = parseFloat(raw);
                  if (!Number.isFinite(n)) return;
                  setAbsencesWarnAbsPct(n);
                }}
                className="h-9 text-xs bg-white dark:bg-[#1f2d42]"
              />
            </div>
            <div className="space-y-1">
              <Label className="text-xs">Rouge (%)</Label>
              <Input
                type="number"
                min={0}
                max={100}
                step={0.5}
                value={String(absencesAlertAbsPct)}
                onChange={(e) => {
                  const raw = (e.target.value || "0").replace(",", ".");
                  const n = parseFloat(raw);
                  if (!Number.isFinite(n)) return;
                  setAbsencesAlertAbsPct(n);
                }}
                className="h-9 text-xs bg-white dark:bg-[#1f2d42]"
              />
            </div>
          </div>
        </div>

        <div className="space-y-2 rounded-lg border border-neutral-200 dark:border-sky-400/35 bg-white dark:bg-[#182433] p-3">
          <div className="text-xs font-semibold text-neutral-900 dark:text-neutral-300">Retards</div>
          <div className="grid grid-cols-2 gap-2">
            <div className="space-y-1">
              <Label className="text-xs">Orange (%)</Label>
              <Input
                type="number"
                min={0}
                max={100}
                step={0.5}
                value={String(absencesWarnRtPct)}
                onChange={(e) => {
                  const raw = (e.target.value || "0").replace(",", ".");
                  const n = parseFloat(raw);
                  if (!Number.isFinite(n)) return;
                  setAbsencesWarnRtPct(n);
                }}
                className="h-9 text-xs bg-white dark:bg-[#1f2d42]"
              />
            </div>
            <div className="space-y-1">
              <Label className="text-xs">Rouge (%)</Label>
              <Input
                type="number"
                min={0}
                max={100}
                step={0.5}
                value={String(absencesAlertRtPct)}
                onChange={(e) => {
                  const raw = (e.target.value || "0").replace(",", ".");
                  const n = parseFloat(raw);
                  if (!Number.isFinite(n)) return;
                  setAbsencesAlertRtPct(n);
                }}
                className="h-9 text-xs bg-white dark:bg-[#1f2d42]"
              />
            </div>
          </div>
        </div>
      </div>
      <div className="text-[11px] text-neutral-500 dark:text-neutral-300 mt-1">
        Vert = &lt; Orange • Orange = ≥ Orange • Rouge = ≥ Rouge • Sauvegarde automatique.
      </div>
    </div>

    <div className="flex items-center gap-2 pt-2">
      <Button
        type="button"
        className="h-9 px-3 text-xs !bg-neutral-900 !text-white hover:!bg-amber-100/70 dark:!bg-sky-500/25 dark:!text-sky-50 dark:hover:!bg-sky-500/35 border border-neutral-900/15 dark:border-sky-400/40"
        onClick={async () => {
          try {
            await saveGeneralSettingsToStore(generalSettings);
            setGeneralSettingsSaveFeedback({ type: "success", message: "Paramètres enregistrés." });
          } catch {
            setGeneralSettingsSaveFeedback({ type: "error", message: "Échec de l’enregistrement." });
          }
        }}
      >
        Enregistrer
      </Button>

      <Button
        type="button"
        variant="ghost"
        className="h-9 px-3 text-xs"
        onClick={() => setGeneralSettingsDrawerOpen(false)}
      >
        Fermer
      </Button>

      <Button
        type="button"
        variant="ghost"
        className="h-9 px-3 text-xs ml-auto text-red-600 dark:text-red-300 hover:bg-amber-100/70 dark:hover:bg-red-950/30"
        onClick={async () => {
          const ok = await confirm("Réinitialiser les paramètres généraux ?", { title: "Paramètre général", kind: "warning" } as any);
          if (!ok) return;
          setGeneralSettings({ ...DEFAULT_GENERAL_SETTINGS });
          await saveGeneralSettingsToStore({ ...DEFAULT_GENERAL_SETTINGS });
          setGeneralSettingsSaveFeedback({ type: "success", message: "Paramètres réinitialisés." });
        }}
      >
        Réinitialiser
      </Button>
    </div>

    {generalSettingsSaveFeedback ? (
      <div
        className={classNames(
          "mt-2 rounded-md px-3 py-2 text-xs border",
          generalSettingsSaveFeedback.type === "success"
            ? "bg-emerald-50 text-emerald-700 border-emerald-200 dark:bg-emerald-950/30 dark:text-emerald-200 dark:border-emerald-800/60"
            : "bg-red-50 text-red-700 border-red-200 dark:bg-red-950/30 dark:text-red-200 dark:border-red-800/60"
        )}
        role="status"
      >
        {generalSettingsSaveFeedback.message}
      </div>
    ) : null}

  </div>
</Drawer>

<div className="flex-1" />

          <div className="flex items-center gap-1">
            <button
              type="button"
              onClick={() => setTheme(theme === 'dark' ? 'light' : 'dark')}
              className="border rounded-md p-2 w-8 h-8 flex items-center justify-center hover:bg-amber-100/70 dark:bg-[#182433] dark:hover:bg-neutral-900"
              title={theme === 'dark' ? 'Passer en thème clair' : 'Passer en thème sombre'}
              aria-label={theme === 'dark' ? 'Passer en thème clair' : 'Passer en thème sombre'}
            >
              {theme === 'dark' ? <Sun className="w-4 h-4" /> : <Moon className="w-4 h-4" />}
            </button>

            <button
              type="button"
              onClick={() => setHelpOpen(true)}
              className="border rounded-md p-2 w-8 h-8 flex items-center justify-center hover:bg-amber-100/70 dark:bg-[#182433] dark:hover:bg-neutral-900"
              title="Aide"
              aria-label="Aide"
            >
              <span className="text-sm font-bold leading-none">?</span>
            </button>
          </div>

        </div>
      </div>

      <div className="w-full px-2 py-1">
        <div className="flex items-center gap-4">
          <div className="flex-1">
          </div>
        </div>
      </div>

{activeView === "referentiel_add" ? (
  

  <div className="px-4 sm:px-6 lg:px-8 py-6 space-y-4">
    <div className="flex items-start justify-between gap-3">
      <div>
        <div className="text-2xl font-semibold text-neutral-900 dark:text-neutral-100">Ajouter mon référentiel</div>
        <div className="text-sm text-neutral-600 dark:text-neutral-300">
          1) Sélectionner un diplôme • 2) Rechercher arrêtés/référentiels (Eduscol + Légifrance) • 3) Choisir le fichier à conserver
        </div>
      </div>
      <Button
        type="button"
        className="h-9 px-3 text-xs !bg-white dark:!bg-[#1f2d42] !text-neutral-900 dark:!text-neutral-50 border border-neutral-200 dark:border-sky-400/35 hover:!bg-amber-100/70 dark:hover:!bg-[#3d2707]"
        onClick={() => {
          setRefAddStep(1);
          setRefAddDiplome(null);
          setRefAddQuery("");
          setRefAddResults([]);
          setRefAddSelectedUrl("");
          setRefAddError(null);
        }}
      >
        Réinitialiser
      </Button>
    </div>

    {/* Stepper */}
    <div className="flex items-center gap-2 text-xs">
      <span className={classNames("px-2 py-1 rounded-full border", refAddStep === 1 ? "bg-black text-white" : "bg-white dark:bg-[#182433] text-neutral-700 dark:text-neutral-200 border-neutral-200 dark:border-sky-400/35")}>1</span>
      <span className="text-neutral-600 dark:text-neutral-300">Diplôme</span>
      <ChevronRight className="w-4 h-4 text-neutral-400" />
      <span className={classNames("px-2 py-1 rounded-full border", refAddStep === 2 ? "bg-black text-white" : "bg-white dark:bg-[#182433] text-neutral-700 dark:text-neutral-200 border-neutral-200 dark:border-sky-400/35")}>2</span>
      <span className="text-neutral-600 dark:text-neutral-300">Recherche</span>
      <ChevronRight className="w-4 h-4 text-neutral-400" />
      <span className={classNames("px-2 py-1 rounded-full border", refAddStep === 3 ? "bg-black text-white" : "bg-white dark:bg-[#182433] text-neutral-700 dark:text-neutral-200 border-neutral-200 dark:border-sky-400/35")}>3</span>
      <span className="text-neutral-600 dark:text-neutral-300">Choix</span>
    </div>

    <div className="grid gap-4 lg:grid-cols-3">
      {/* 1) Diplôme */}
      <div className={classNames("rounded-2xl border p-4 bg-white dark:bg-[#182433] border-neutral-200 dark:border-sky-400/35 space-y-3", refAddStep !== 1 && "opacity-75")}>
        <div className="flex items-center justify-between gap-2">
          <div className="text-sm font-semibold text-neutral-900 dark:text-neutral-200">1 — Sélectionner le diplôme</div>
          <Button
            type="button"
            className="h-8 px-3 text-[11px] !bg-neutral-900 !text-white hover:!bg-amber-100/70 dark:!bg-sky-500/25 dark:!text-sky-50 dark:hover:!bg-sky-500/35 border border-neutral-900/15 dark:border-sky-400/40"
            disabled={capCatalogLoading}
            onClick={() => fetchCapCatalog()}
          >
            {capCatalogLoading ? "Chargement…" : "Mettre à jour"}
          </Button>
        </div>

        <div className="flex items-center gap-2">
          <Input
            value={refAddDiplome ? ensureCapLabel(refAddDiplome.title) : capSearchQuery}
            onChange={(e) => {
              if (refAddDiplome) return;
              setCapSearchQuery(e.target.value);
            }}
            placeholder="Rechercher un diplôme (ex : électricien, AEPE, peintre…)"
            disabled={!!refAddDiplome}
            className="h-9 text-sm flex-1 !bg-white dark:!bg-[#1f2d42] !text-neutral-900 dark:!text-neutral-50 !border-neutral-300 dark:!border-neutral-700/60"
          />

          {refAddDiplome ? (
            <Button
              type="button"
              variant="secondary"
              className="h-9 px-3 text-xs"
              onClick={() => {
                setRefAddDiplome(null);
                setCapSearchQuery("");
                setRefAddStep(1);
                setRefAddResults([]);
                setRefAddSelectedUrl("");
                setRefAddError(null);
              }}
            >
              Changer
            </Button>
          ) : null}
        </div>

        {capCatalogError ? (
          <div className="text-xs text-red-600 dark:text-red-300">{capCatalogError}</div>
        ) : null}

        {!refAddDiplome ? (
          <div className="max-h-72 overflow-auto rounded-xl border border-neutral-200 dark:border-sky-400/25 bg-neutral-50 dark:bg-[#0f1b2d]">
            {(() => {
              const q = capSearchQuery.trim().toLowerCase();
              const filtered = q
                ? capCatalog.filter((x) => x.title.toLowerCase().includes(q) || x.url.toLowerCase().includes(q)).slice(0, 40)
                : capCatalog.slice(0, 25);

              if (capCatalog.length === 0) {
                return (
                  <div className="p-3 text-xs text-neutral-600 dark:text-neutral-300">
                    Clique sur <strong>Mettre à jour</strong> pour charger la liste des diplômes.
                  </div>
                );
              }
              if (filtered.length === 0) return <div className="p-3 text-xs text-neutral-600 dark:text-neutral-300">Aucun résultat.</div>;

              return (
                <div className="divide-y divide-neutral-200 dark:divide-sky-400/20">
                  {filtered.map((it) => {
                    return (
                      <button
                        key={it.url}
                        type="button"
                        className="w-full text-left p-2 hover:bg-amber-100/70 dark:hover:bg-[#3d2707] transition"
                        onClick={() => {
                          setRefAddDiplome(it);
                          setCapSearchQuery(ensureCapLabel(it.title));
                          setReferentielName(it.title);
                          setRefAddStep(2);
                          setRefAddResults([]);
                          setRefAddSelectedUrl("");
                          setRefAddError(null);
                        }}
                      >
                        <div className="text-xs font-medium text-neutral-900 dark:text-neutral-200 truncate">{it.title}</div>
                        <div className="text-[11px] text-neutral-500 dark:text-neutral-400 truncate">{it.url}</div>
                      </button>
                    );
                  })}
                </div>
              );
            })()}
          </div>
        ) : (
          <div className="text-[11px] text-neutral-500 dark:text-neutral-400">
            Diplôme verrouillé. Clique sur <strong>Changer</strong> pour en sélectionner un autre.
          </div>
        )}
      </div>

      {/* 2) Recherche */}
      <div className={classNames("rounded-2xl border p-4 bg-white dark:bg-[#182433] border-neutral-200 dark:border-sky-400/35 space-y-3", (!refAddDiplome || refAddStep < 2) && "opacity-60")}>
        <div className="text-sm font-semibold text-neutral-900 dark:text-neutral-200">2 — Rechercher les fichiers</div>

        <div className="text-xs text-neutral-600 dark:text-neutral-300">
          Sources : referentiels-professionnels.eduscol.education.fr + legifrance.gouv.fr
        </div>

        <Input
          value={refAddQuery}
          onChange={(e) => setRefAddQuery(e.target.value)}
          placeholder="Mots-clés (optionnel) : arrêté, référentiel, règlement d'examen…"
          disabled={!refAddDiplome}
          className="h-9 text-sm !bg-white dark:!bg-[#1f2d42] !text-neutral-900 dark:!text-neutral-50 !border-neutral-300 dark:!border-neutral-700/60"
        />

        <div className="flex items-center gap-2">
          <Button
            type="button"
            disabled={!refAddDiplome || refAddBusy}
            className="h-9 px-3 text-xs !bg-neutral-900 !text-white hover:!bg-amber-100/70 dark:!bg-sky-500/25 dark:!text-sky-50 dark:hover:!bg-sky-500/35 border border-neutral-900/15 dark:border-sky-400/40"
            onClick={async () => {
              if (!refAddDiplome) return;
              setRefAddBusy(true);
              setRefAddError(null);
              setRefAddResults([]);
              try {
                const r = await searchReferentielAddFiles(refAddDiplome, refAddQuery);
                setRefAddResults(r);
                // On reste sur l'étape 2 pour afficher les documents trouvés ici.
                // L'utilisateur passe à l'étape 3 quand il le souhaite.
                if (r[0]) setRefAddSelectedUrl(r[0].pdfUrl || r[0].pageUrl);
              } catch (e: any) {
                setRefAddError(String(e?.message ?? e));
              } finally {
                setRefAddBusy(false);
              }
            }}
          >
            {refAddBusy ? "Recherche…" : "Rechercher"}
          </Button>

          {refAddDiplome ? (
            <Button
              type="button"
              className="h-9 px-3 text-xs !bg-white dark:!bg-[#1f2d42] !text-neutral-900 dark:!text-neutral-50 border border-neutral-200 dark:border-sky-400/35 hover:!bg-amber-100/70 dark:hover:!bg-[#3d2707]"
              onClick={() => openUrlPreviewWindow(normalizeEduscolUrl(refAddDiplome.url))}
            >
              Ouvrir page Eduscol
            </Button>
          ) : null}
        </div>

        {refAddError ? <div className="text-xs text-red-600 dark:text-red-300">{refAddError}</div> : null}

        {/* Résultats (affichés à l'étape 2) */}
        <div className="rounded-xl border border-neutral-200 dark:border-sky-400/25 bg-neutral-50 dark:bg-[#0f1b2d]">
          <div className="flex items-center justify-between gap-2 px-3 py-2 border-b border-neutral-200 dark:border-sky-400/20">
            <div className="text-xs font-medium text-neutral-900 dark:text-neutral-200">Documents trouvés</div>
            {refAddResults.length > 0 ? (
              <div className="text-[11px] text-neutral-500 dark:text-neutral-400">{refAddResults.length} résultat{refAddResults.length > 1 ? "s" : ""}</div>
            ) : null}
          </div>

          {refAddResults.length === 0 ? (
            <div className="p-3 text-xs text-neutral-600 dark:text-neutral-300">Aucun document affiché pour l’instant. Lance une recherche.</div>
          ) : (
            <div className="max-h-72 overflow-auto divide-y divide-neutral-200 dark:divide-sky-400/20">
              {refAddResults.map((r) => {
                const url = r.pdfUrl || r.pageUrl;
                return (
                  <div key={url} className="p-2">
                    <div className="flex items-start justify-between gap-2">
                      <div className="min-w-0">
                        <div className="text-xs font-medium text-neutral-900 dark:text-neutral-200 truncate">{r.title}</div>
                        <div className="text-[11px] text-neutral-500 dark:text-neutral-400 truncate">
                          {r.source === "referentiels" ? "Eduscol" : "Légifrance"} • {url}
                        </div>
                        {r.pdfUrl ? <div className="text-[11px] text-neutral-600 dark:text-neutral-300">PDF</div> : null}
                      </div>
                      <div className="flex items-center gap-2">
                        <Button
                          type="button"
                          variant="secondary"
                          className="h-8 px-2 text-[11px]"
                          onClick={() => openUrlPreviewWindow(url)}
                        >
                          Voir
                        </Button>
                        <Button
                          type="button"
                          className="h-8 px-2 text-[11px] !bg-neutral-900 !text-white hover:!bg-amber-100/70 dark:!bg-sky-500/25 dark:!text-sky-50 dark:hover:!bg-sky-500/35 border border-neutral-900/15 dark:border-sky-400/40"
                          onClick={() => {
                            setRefAddSelectedUrl(url);
                            setRefAddStep(3);
                          }}
                        >
                          Choisir
                        </Button>
                      </div>
                    </div>
                  </div>
                );
              })}
            </div>
          )}
        </div>
      </div>

      {/* 3) Choix */}
      <div className={classNames("rounded-2xl border p-4 bg-white dark:bg-[#182433] border-neutral-200 dark:border-sky-400/35 space-y-3", refAddStep < 3 && "opacity-60")}>
        <div className="text-sm font-semibold text-neutral-900 dark:text-neutral-200">3 — Sélectionner le fichier à garder</div>

        <div className="max-h-72 overflow-auto rounded-xl border border-neutral-200 dark:border-sky-400/25 bg-neutral-50 dark:bg-[#0f1b2d]">
          {refAddResults.length === 0 ? (
            <div className="p-3 text-xs text-neutral-600 dark:text-neutral-300">
              Lance une recherche pour afficher les arrêtés / référentiels.
            </div>
          ) : (
            <div className="divide-y divide-neutral-200 dark:divide-sky-400/20">
              {refAddResults.map((r) => {
                const url = r.pdfUrl || r.pageUrl;
                const selected = refAddSelectedUrl === url;
                return (
                  <label key={url} className={classNames("flex items-start gap-2 p-2 cursor-pointer hover:bg-amber-100/70 dark:hover:bg-[#3d2707]", selected && "bg-black/5 dark:bg-sky-500/10")}>
                    <input
                      type="radio"
                      name="refAddSelect"
                      className="mt-1"
                      checked={selected}
                      onChange={() => setRefAddSelectedUrl(url)}
                    />
                    <div className="min-w-0 flex-1">
                      <div className="text-xs font-medium text-neutral-900 dark:text-neutral-200 truncate">{r.title}</div>
                      <div className="text-[11px] text-neutral-500 dark:text-neutral-400 truncate">
                        {r.source === "referentiels" ? "Eduscol" : "Légifrance"} • {url}
                      </div>
                      {r.pdfUrl ? (
                        <div className="text-[11px] text-neutral-600 dark:text-neutral-300">PDF</div>
                      ) : null}
                    </div>
                    <div className="flex items-center gap-2">
                      <Button
                        type="button"
                        variant="secondary"
                        className="h-8 px-2 text-[11px]"
                        onClick={(e) => { e.preventDefault(); openUrlPreviewWindow(url); }}
                      >
                        Voir
                      </Button>
                    </div>
                  </label>
                );
              })}
            </div>
          )}
        </div>

        <div className="flex items-center justify-between gap-2">
          <Button
            type="button"
            className="h-9 px-3 text-xs !bg-white dark:!bg-[#1f2d42] !text-neutral-900 dark:!text-neutral-50 border border-neutral-200 dark:border-sky-400/35 hover:!bg-amber-100/70 dark:hover:!bg-[#3d2707]"
            disabled={!refAddSelectedUrl}
            onClick={() => openUrlPreviewWindow(refAddSelectedUrl)}
          >
            Aperçu
          </Button>

          <Button
            type="button"
            className="h-9 px-3 text-xs !bg-neutral-900 !text-white hover:!bg-amber-100/70 dark:!bg-sky-500/25 dark:!text-sky-50 dark:hover:!bg-sky-500/35 border border-neutral-900/15 dark:border-sky-400/40"
            disabled={!refAddSelectedUrl}
            onClick={() => {
              if (!refAddSelectedUrl) return;
              setReferentielSourceUrl(refAddSelectedUrl);
              if (!referentielName && refAddDiplome?.title) setReferentielName(refAddDiplome.title);
              setReferentielMessage("Lien sélectionné. Tu peux maintenant analyser et enregistrer ci-dessous.");
            }}
          >
            Garder ce fichier
          </Button>
        </div>
      </div>
    </div>

    {/* Zone d'enregistrement (réutilise les mêmes champs que le drawer) */}
    <div className="rounded-2xl border border-neutral-200 dark:border-sky-400/35 bg-white dark:bg-[#182433] p-4 space-y-3">
      <div className="text-sm font-semibold text-neutral-900 dark:text-neutral-200">Enregistrer le référentiel</div>

      <div className="grid gap-3 lg:grid-cols-2">
        <div className="space-y-1">
          <Label className="text-xs text-neutral-900 dark:text-neutral-300">Nom</Label>
          <Input
            value={referentielName}
            onChange={(e) => setReferentielName(e.target.value)}
            placeholder="Ex : CAP …"
            className="h-9 text-sm !bg-white dark:!bg-[#1f2d42] !text-neutral-900 dark:!text-neutral-50 !border-neutral-300 dark:!border-neutral-700/60"
          />
        </div>
        <div className="space-y-1">
          <Label className="text-xs text-neutral-900 dark:text-neutral-300">URL (page ou PDF)</Label>
          <div className="flex items-center gap-2">
            <Input
              value={referentielSourceUrl}
              onChange={(e) => setReferentielSourceUrl(e.target.value)}
              placeholder="URL Eduscol / Légifrance / PDF"
              className="h-9 text-sm flex-1 !bg-white dark:!bg-[#1f2d42] !text-neutral-900 dark:!text-neutral-50 !border-neutral-300 dark:!border-neutral-700/60"
            />
            <Button
              type="button"
              className="h-9 px-3 text-xs !bg-white dark:!bg-[#1f2d42] !text-neutral-900 dark:!text-neutral-50 border border-neutral-200 dark:border-sky-400/35 hover:!bg-amber-100/70 dark:hover:!bg-[#3d2707]"
              onClick={() => openUrlPreviewWindow(referentielSourceUrl)}
            >
              Aperçu
            </Button>
            <Button
              type="button"
              className="h-9 px-3 text-xs !bg-neutral-900 !text-white hover:!bg-amber-100/70 dark:!bg-sky-500/25 dark:!text-sky-50 dark:hover:!bg-sky-500/35 border border-neutral-900/15 dark:border-sky-400/40"
              disabled={analyzeBusy}
              onClick={() => analyzeReferentielUrl(referentielSourceUrl)}
            >
              {analyzeBusy ? "Analyse…" : "Analyser"}
            </Button>
          </div>
        </div>
      </div>

      {referentielMessage ? (
        <div className="text-xs text-neutral-700 dark:text-neutral-300">{referentielMessage}</div>
      ) : null}

      <div className="space-y-1">
        <div className="flex items-center justify-between gap-2">
          <Label className="text-xs text-neutral-900 dark:text-neutral-300">JSON itemé</Label>
          <Button
            type="button"
            variant="ghost"
            className="h-7 px-2 text-[11px] text-neutral-900 dark:text-neutral-200 hover:bg-amber-100/70 dark:hover:bg-[#3d2707]"
            onClick={() => {
              const model = {
                formatVersion: 1,
                meta: {
                  id: (referentielName || "referentiel").toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, ""),
                  title: referentielName || "Référentiel",
                  sourceUrl: referentielSourceUrl || "",
                  importedAt: new Date().toISOString(),
                },
                items: [
                  {
                    task: { code: "T1", label: "Tâche 1" },
                    competency: { code: "C1.1", label: "Compétence 1.1" },
                    ability: { code: "EC1", label: "Être capable de…" },
                    criteria: ["Critère 1", "Critère 2"],
                  },
                ],
              };
              setReferentielItemsJson(JSON.stringify(model, null, 2));
            }}
          >
            Modèle
          </Button>
        </div>
        <Textarea
          rows={10}
          value={referentielItemsJson}
          onChange={(e) => setReferentielItemsJson(e.target.value)}
          className="text-xs !bg-white dark:!bg-[#1f2d42] !text-neutral-900 dark:!text-neutral-50 !border-neutral-300 dark:!border-neutral-700/60"
          placeholder='Colle ici ton JSON "itemé" (formatVersion/meta/items)…'
        />
      </div>

      <div className="flex items-center justify-end gap-2">
        <Button
          type="button"
          className="h-9 px-3 text-xs !bg-white dark:!bg-[#1f2d42] !text-neutral-900 dark:!text-neutral-50 border border-neutral-200 dark:border-sky-400/35 hover:!bg-amber-100/70 dark:hover:!bg-[#3d2707]"
          onClick={async () => {
            const f = await open({ multiple: false, filters: [{ name: "JSON", extensions: ["json"] }] });
            if (!f || Array.isArray(f)) return;
            const content = await readTextFile(f);
            setReferentielItemsJson(content);
            setReferentielMessage("JSON chargé depuis un fichier.");
          }}
        >
          Importer un fichier…
        </Button>

        <Button
          type="button"
          className="h-9 px-3 text-xs !bg-neutral-900 !text-white hover:!bg-amber-100/70 dark:!bg-sky-500/25 dark:!text-sky-50 dark:hover:!bg-sky-500/35 border border-neutral-900/15 dark:border-sky-400/40"
          onClick={async () => {
            try {
              const raw = referentielItemsJson.trim();
              if (!raw) throw new Error("JSON vide");
              let doc: any;
              if (raw.startsWith("[")) {
                doc = {
                  formatVersion: 1,
                  meta: { title: referentielName || "Référentiel", sourceUrl: referentielSourceUrl || "", importedAt: new Date().toISOString() },
                  items: JSON.parse(raw),
                };
              } else {
                doc = JSON.parse(raw);
                if (!doc.items || !Array.isArray(doc.items)) throw new Error("Le JSON doit contenir un champ items[]");
              }
              doc.formatVersion = 1;
              doc.meta = doc.meta || {};
              doc.meta.title = doc.meta.title || referentielName || "Référentiel";
              doc.meta.sourceUrl = referentielSourceUrl || doc.meta.sourceUrl || "";
              doc.meta.updatedAt = new Date().toISOString();
              doc.meta.id =
                doc.meta.id ||
                (doc.meta.title || "referentiel").toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");

              await mkdir("referentiels", { baseDir: BaseDirectory.AppLocalData, recursive: true }).catch(() => {});
              await writeTextFile(`referentiels/${doc.meta.id}.json`, JSON.stringify(doc, null, 2), { baseDir: BaseDirectory.AppLocalData });
              setReferentielMessage(`Référentiel sauvegardé : ${doc.meta.id}.json`);
            } catch (e: any) {
              setReferentielMessage(e?.message || "Erreur de sauvegarde");
            }
          }}
        >
          Enregistrer
        </Button>
      </div>
    </div>
  </div>

) : activeView === "evaluation" ? (
<Tabs
    value={step === "params" ? "params" : step === 1 ? "step1" : step === 2 ? "step2" : step === 3 ? "step3" : "step4"}
    onValueChange={(v) =>
      setStep(
        v === "params" ? "params" :
        v === "step1" ? 1 :
        v === "step2" ? 2 :
        v === "step3" ? 3 : 4
      )
    }
  >

{/* ✅ BANDEAU FIXE : étapes + titre du devoir */}
<div className="sticky top-[67px] z-50 backdrop-blur border-b border-black dark:border-sky-400/35 bg-white/95 dark:bg-[#1f2d42]/95 dark:bg-[#1f2d42]/95 dark:border-[#1b467a] dark:text-white night-banner">
  <div className="flex items-center justify-between gap-3 px-4 sm:px-6 lg:px-8 py-2">
    <div className="flex items-center gap-2">
      <TabsList className="stepbar-list w-fit bg-white dark:bg-[#1f2d42] p-1 rounded-md">
  <TabsTrigger
    value="params"
    aria-selected={step === "params"}
    className={classNames(
      "stepbar-trigger inline-flex items-center rounded-full shadow-sm px-3 py-2 text-xs font-medium border bg-white dark:bg-[#182433] text-neutral-900 dark:text-neutral-300 border-neutral-200 dark:border-sky-400/35 hover:bg-amber-100/70 dark:hover:bg-[#3d2707]",
      step === "params" && "!bg-black !text-white"
    )}
  >
    <span className="stepbar-icon" aria-hidden="true">⚙️</span>
    <span className="stepbar-label sm:hidden">PARAM.</span>
    <span className="stepbar-label hidden sm:inline">PARAMÈTRE DU DEVOIR</span>
  </TabsTrigger>

  <TabsTrigger
    value="step1"
    aria-selected={step === 1}
    className={classNames(
      "stepbar-trigger inline-flex items-center rounded-full shadow ring-1 transition duration-150 bg-neutral-50 dark:bg-[#182433] text-neutral-800 dark:text-neutral-300 ring-neutral-200 hover:bg-amber-100/70 dark:hover:bg-[#3d2707]",
      step === 1 && "!bg-black !text-white"
    )}
  >
    <span className="stepbar-icon" aria-hidden="true">✅</span>
    <span className="stepbar-label sm:hidden">TÂCHES</span>
    <span className="stepbar-label hidden sm:inline">TÂCHES</span>
  </TabsTrigger>

  <TabsTrigger
    value="step2"
    aria-selected={step === 2}
    aria-disabled={!activeTask}
    className={classNames(
      "stepbar-trigger inline-flex items-center rounded-full shadow ring-1 transition duration-150 bg-neutral-50 dark:bg-[#182433] text-neutral-800 dark:text-neutral-300 ring-neutral-200 hover:bg-amber-100/70 dark:hover:bg-[#3d2707]",
      !activeTask && "opacity-50 pointer-events-none",
      step === 2 && "!bg-black !text-white"
    )}
  >
    <span className="stepbar-icon" aria-hidden="true">🎯</span>
    <span className="stepbar-label sm:hidden">COMP.</span>
    <span className="stepbar-label hidden sm:inline">COMPÉTENCES</span>
  </TabsTrigger>

  <TabsTrigger
    value="step3"
    aria-selected={step === 3}
    aria-disabled={selectedCriteres.length === 0}
    className={classNames(
      "stepbar-trigger inline-flex items-center rounded-full shadow ring-1 transition duration-150 bg-neutral-50 dark:bg-[#182433] text-neutral-800 dark:text-neutral-300 ring-neutral-200 hover:bg-amber-100/70 dark:hover:bg-[#3d2707]",
      selectedCriteres.length === 0 && "opacity-50 pointer-events-none",
      step === 3 && "!bg-black !text-white"
    )}
  >
    <span className="stepbar-icon" aria-hidden="true">📋</span>
    <span className="stepbar-label sm:hidden">EXIG.</span>
    <span className="stepbar-label hidden sm:inline">EXIGENCES</span>
  </TabsTrigger>

  <TabsTrigger
    value="step4"
    aria-selected={step === 4}
    className={classNames(
      "stepbar-trigger inline-flex items-center rounded-full shadow ring-1 transition duration-150 bg-neutral-50 dark:bg-[#182433] text-neutral-800 dark:text-neutral-300 ring-neutral-200 hover:bg-amber-100/70 dark:hover:bg-[#3d2707]",
      selectedCriteres.length === 0 && "opacity-50",
      step === 4 && "!bg-black !text-white"
    )}
  >
    <span className="stepbar-icon" aria-hidden="true">📝</span>
    <span className="stepbar-label sm:hidden">ÉVAL.</span>
    <span className="stepbar-label hidden sm:inline">ÉVALUATION</span>
  </TabsTrigger>
</TabsList>

    </div>

    <div className="flex items-center justify-end gap-2 min-w-0">
      <div className="text-right text-xl sm:text-2xl font-semibold truncate max-w-[45vw] min-w-0">
        {title?.trim() ? title : "Devoir sans titre"}
      </div>

      <Button
        className="isolate gap-2 h-8 px-3 border border-neutral-200 dark:border-sky-400/35 !bg-green-600 !text-white hover:!bg-green-700 whitespace-nowrap"
        onClick={async () => {
          try {
            if (!isTauriRuntime()) {
              alert("Cette fonction n'est disponible que dans la version Tauri.");
              return;
            }

            // 1️⃣ Proposer un nom par défaut (le titre ou une date)
            const suggestedName =
              (title && title.trim()) ||
              `devoir-${new Date().toISOString().slice(0, 10)}`;

            const input = window.prompt(
              "Nom du devoir à enregistrer :",
              suggestedName
            );

            // Annulé ou vide → on ne sauvegarde pas
            if (!input) {
              return;
            }

            const cleanedName = input.trim().replace(/[<>:"/\\|?*]+/g, "-");
            if (!cleanedName) {
              alert("Le nom du devoir est invalide.");
              return;
            }

            // 2️⃣ Construire les données à sauvegarder
            const data = {
              evaluationId,          // 🔹 ID interne
              title,
              project,
              professionalSituation,
              evaluator,
              group,
              objectives,
              selectedTasks,
              selectedCompetences,
              selectedCriteres,
              selectedSubCrit,
              customExigences,
              persistedExigencesDB,
              selectedExigence,
              evaluationType,
              evaluationSemester,    // 🔹 semestre choisi
              evaluationCategory,
              notationWeights,
              notationScores,
            };

            // 3️⃣ Sauvegarde dans AppData/devoir/<nom>.json
            await saveEvaluationToLocalFolder(cleanedName, data, trainingYear);

            // 4️⃣ Met à jour la base des évaluations (evaluations_db.json)
            const safeName = cleanedName.endsWith(".json")
              ? cleanedName
              : `${cleanedName}.json`;
            const now = new Date().toISOString();

            setEvalMetaList((prev) => {
              const existingIndex = prev.findIndex((ev) => ev.id === evaluationId);
              const base: EvalMeta = {
                id: evaluationId,
                name: title || safeName.replace(/\.json$/, ""),
                fileName: safeName,
                group,
                semester: evaluationSemester,
                createdAt:
                  existingIndex >= 0 ? prev[existingIndex].createdAt : now,
              };

              const next = [...prev];
              if (existingIndex >= 0) next[existingIndex] = base;
              else next.push(base);
              return next;
            });

            // (Optionnel) Si tu veux encore pousser vers le suivi automatiquement :
      const classe = classGroups.find((c) => c.name === group);
      const classKey = classe?.name;
      const studentName = selectedStudentForSuivi || "";

      if (classKey && studentName) {
        pushCurrentDevoirToSuivi(
          classKey,
          studentName,
          evaluationSemester,
          evaluationId,
          notationScores          // ici : scores globaux du devoir
        );
      }

          } catch (err) {
            console.error("Erreur sauvegarde :", err);
            alert("Impossible d'enregistrer le devoir.");
          }
        }}
      >
        💾 ENREGISTRER
      </Button>
	    </div>
	  </div>
</div>




{/* PARAMÈTRE DU DEVOIR */}
<TabsContent
  value="params"
  className="mt-2 px-4 sm:px-6 lg:px-8 h-[calc(100vh-180px)] overflow-hidden"
>
  <div className="h-full overflow-y-auto overscroll-contain pr-2 pt-4">
    <div className="max-w-6xl mx-auto">
      <div className="rounded-xl border border-neutral-200 dark:border-sky-400/35 overflow-hidden bg-white dark:bg-[#182433]">
        <div className="px-4 py-3 border-b border-neutral-200 dark:border-sky-400/35 font-semibold text-neutral-900 dark:text-neutral-300">
          Paramètres du devoir
        </div>

        <div className="p-4 bg-neutral-50 dark:bg-[#0f1b2d]">
          <div className="grid grid-cols-1 lg:grid-cols-2 gap-4">
            {/* Colonne gauche */}
            <div className="space-y-4">
              <div className="space-y-2">
                <Label htmlFor="title" className="text-neutral-900 dark:!text-neutral-50">
                  Titre
                </Label>
                <Input
                  id="title"
                  value={title}
                  onChange={(e) => setTitle(e.target.value)}
                  placeholder="Ex: Maçonnerie – Enduit vertical"
                  className="bg-white text-neutral-900 border-neutral-200 dark:!bg-[#1f2d42] dark:!text-neutral-50 dark:border-sky-400/35 dark:placeholder:text-neutral-400"
                />
              </div>

              <div className="space-y-2">
                <Label htmlFor="project" className="text-neutral-900 dark:!text-neutral-50">
                  Projet
                </Label>
                <Input
                  id="project"
                  value={project}
                  onChange={(e) => setProject(e.target.value)}
                  placeholder="Ex : Construction pavillon Hollander, chantier X..."
                  className="bg-white text-neutral-900 border-neutral-200 dark:!bg-[#1f2d42] dark:!text-neutral-50 dark:border-sky-400/35 dark:placeholder:text-neutral-400"
                />
              </div>

              <div className="space-y-2">
                <Label htmlFor="professionalSituation" className="text-neutral-900 dark:!text-neutral-50">
                  Situation professionnelle
                </Label>
                <Input
                  id="professionalSituation"
                  value={professionalSituation}
                  onChange={(e) => setProfessionalSituation(e.target.value)}
                  placeholder="Ex : Chantier réel, atelier école, plateau technique..."
                  className="bg-white text-neutral-900 border-neutral-200 dark:!bg-[#1f2d42] dark:!text-neutral-50 dark:border-sky-400/35 dark:placeholder:text-neutral-400"
                />
              </div>

              <div className="space-y-2">
                <Label htmlFor="evaluator" className="text-neutral-900 dark:!text-neutral-50">
                  Évaluateur
                </Label>
                <Input
                  id="evaluator"
                  value={evaluator}
                  onChange={(e) => setEvaluator(e.target.value)}
                  placeholder="Nom de l'évaluateur"
                  className="bg-white text-neutral-900 border-neutral-200 dark:!bg-[#1f2d42] dark:!text-neutral-50 dark:border-sky-400/35 dark:placeholder:text-neutral-400"
                />
              </div>

              <div className="space-y-2">
                <Label className="text-neutral-900 dark:!text-neutral-50">Groupe</Label>
                <Select value={group} onValueChange={setGroup}>
                  <SelectTrigger className="bg-white text-neutral-900 border-neutral-200 dark:!bg-[#1f2d42] dark:!text-neutral-50 dark:border-sky-400/35">
                    <SelectValue placeholder="Sélectionner" />
                  </SelectTrigger>
                  <SelectContent className="bg-white dark:bg-[#1f2d42] border border-neutral-200 dark:border-sky-400/35 text-neutral-900 dark:!text-neutral-50">
                    {/* Groupes issus des classes enregistrées dans eleves.json */}
                    {classGroups.map((classe) => (
                      <SelectItem key={classe.id} value={classe.name}>
                        {classe.name}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              </div>
            </div>

            {/* Colonne droite */}
            <div className="space-y-4">
              <div className="space-y-2">
<label className="text-neutral-900 dark:!text-neutral-50">
  Semestre de cette évaluation
</label>

<select
  className="w-full rounded-md border border-neutral-200 bg-white px-3 py-2 text-sm text-neutral-900
             dark:border-sky-400/35 dark:bg-[#1f2d42] dark:text-neutral-300"
  value={evaluationSemester}
  onChange={(e) => setEvaluationSemester(e.target.value as SemesterKey)}
>
  <option value="Ne pas utiliser de semestre">Ne pas l’utiliser dans un semestre</option>
  <option value="S1">Semestre 1</option>
  <option value="S2">Semestre 2</option>
</select>

                <p className="text-[11px] text-neutral-500 dark:text-neutral-300">
                  Ce choix sera enregistré dans la base et utilisé dans le suivi des compétences.
                </p>
              </div>

              <div className="space-y-2">
<label className="text-neutral-900 dark:!text-neutral-50">
  Niveau d&apos;évaluation
</label>

<select
  className="w-full rounded-md border border-neutral-200 bg-white px-3 py-2 text-sm text-neutral-900
             dark:border-sky-400/35 dark:bg-[#1f2d42] dark:text-neutral-300"
  value={evaluationCategory}
  onChange={(e) => setEvaluationCategory(e.target.value as EvaluationCategory)}
>
  <option value="Découverte professionnel">Découverte professionnel</option>
  <option value="Apprentissage des fondamentaux">Apprentissage des fondamentaux</option>
  <option value="Professionnalisation de niveau 3">Professionnalisation de niveau 3</option>
  <option value="Professionnalisation de niveau 4">Professionnalisation de niveau 4</option>
</select>
              </div>

              <div className="space-y-2">
                <Label htmlFor="objs" className="text-neutral-900 dark:!text-neutral-50">
                  Objectifs
                </Label>
                <Textarea
                  id="objs"
                  rows={5}
                  value={objectives}
                  onChange={(e) => setObjectives(e.target.value)}
                  placeholder="Objectifs pédagogiques de l'évaluation"
                  className="bg-white text-neutral-900 border-neutral-200 dark:!bg-[#1f2d42] dark:!text-neutral-50 dark:border-sky-400/35 dark:placeholder:text-neutral-400"
                />
              </div>

              <div className="space-y-2">
                <Label className="text-neutral-900 dark:!text-neutral-50">Logo (PNG/JPG)</Label>
                <div className="flex items-center gap-3">
                  <Input
                    type="file"
                    accept="image/*"
                    onChange={(e) => {
                      const f = e.target.files?.[0];
                      if (f) onLogoUpload(f);
                    }}
                    className="bg-white text-neutral-900 border-neutral-200 dark:!bg-[#1f2d42] dark:!text-neutral-50 dark:border-sky-400/35 file:mr-3 file:px-2 file:py-1 file:rounded-md file:border-0 file:bg-neutral-100 file:text-neutral-700 dark:file:bg-[#1f2d42] dark:file:text-neutral-100"
                  />
                  <ImageIcon className="w-5 h-5 text-neutral-500 dark:text-neutral-300" />
                </div>
                {logoDataUrl && (
                  <div className="mt-2">
                    <img src={logoDataUrl} alt="Logo" className="h-16 object-contain" />
                  </div>
                )}
              </div>
            </div>
          </div>
        </div>
      </div>

<div className="mt-4 rounded-xl border border-neutral-200 dark:border-sky-400/35 bg-white dark:bg-[#182433] keep-light p-4 shadow-sm">
  <div className="flex items-start justify-between gap-3">
    <div>
      <div className="text-sm font-semibold text-neutral-900 dark:text-neutral-100">CCF — Fiches d’évaluation (par élève)</div>
      <div className="text-[11px] text-neutral-500 dark:text-neutral-300">
        Sélectionnez une classe, un élève et une épreuve, puis renseignez les niveaux de maîtrise (N/O / Rouge / Orange / Vert clair / Vert). La note /20 est calculée selon les pondérations du livret.
      </div>
    </div>
  </div>

  {!ccfSelectedStudentName ? (
    <div className="mt-4 text-sm text-neutral-600 dark:text-neutral-300">
      Sélectionnez d’abord une classe et un élève.
    </div>
  ) : (
    (() => {
      const sheet = getCcfSheet(ccfSelectedStudentName, ccfEpKey);
      const computed = computeCcfTotal(ccfSelectedStudentName, ccfEpKey);

      return (
        <>
          
{/* Paramètres de l'épreuve — panneau ouvrable sans pousser l'évaluation */}
<div className="mt-4 relative">
  <div className="flex items-center justify-end gap-3 rounded-xl border border-neutral-200 dark:border-sky-400/35 bg-neutral-50/60 dark:bg-[#0f1b2d] px-3 py-2">
    <Button
      type="button"
      variant="outline"
      size="sm"
      onClick={() => setCcfEpParamsOpen((v) => !v)}
      className="h-8 gap-2"
    >
      <Settings2 className="h-4 w-4" />
      <span>Paramètres de l’épreuve</span>
      <ChevronRight
        className={classNames(
          "h-4 w-4 transition-transform",
          ccfEpParamsOpen ? "rotate-90" : "rotate-0"
        )}
      />
    </Button>
  </div>

  {ccfEpParamsOpen && (
    <div className="absolute right-0 top-full mt-2 w-full md:w-[560px] z-[60] rounded-xl border border-neutral-200 dark:border-sky-400/35 bg-white dark:bg-[#182433] keep-light p-3 shadow-lg">
      <div className="grid grid-cols-1 md:grid-cols-3 gap-3">
        <div className="space-y-1">
          <Label className="text-xs">Date</Label>
          <Input
            type="date"
            value={sheet.meta?.date ?? ""}
            onChange={(e) => {
              setCcfSheet(ccfSelectedStudentName, ccfEpKey, {
                ...sheet,
                meta: { ...(sheet.meta || {}), date: e.target.value },
              });
            }}
          />
        </div>
        <div className="space-y-1 md:col-span-2">
          <Label className="text-xs">Contexte / lieu</Label>
          <Input
            value={sheet.meta?.contexte ?? ""}
            onChange={(e) => {
              setCcfSheet(ccfSelectedStudentName, ccfEpKey, {
                ...sheet,
                meta: { ...(sheet.meta || {}), contexte: e.target.value },
              });
            }}
            placeholder="Ex: Atelier / entreprise / chantier…"
          />
        </div>
      </div>

      <div className="mt-3 grid grid-cols-1 md:grid-cols-3 gap-3 items-end">
        <div className="md:col-span-2" />
        <div className="space-y-1">
          <Label className="text-xs">Note proposée au jury</Label>
          <Input
            value={sheet.meta?.noteProposee ?? ""}
            onChange={(e) => {
              setCcfSheet(ccfSelectedStudentName, ccfEpKey, {
                ...sheet,
                meta: { ...(sheet.meta || {}), noteProposee: e.target.value },
              });
            }}
            placeholder="Ex: 14,5"
          />
        </div>
      </div>
    </div>
  )}
</div>

{/* Résumé note — toujours visible (laisse la place à l'évaluation) */}
          <div className="mt-3 flex flex-col md:flex-row md:items-center md:justify-between gap-2">
            <div className="text-sm">
              <div className="font-semibold text-neutral-900 dark:text-neutral-100">
                Note calculée : {computed.total.toFixed(2)} / 20
              </div>
              <div className="text-[11px] text-neutral-500 dark:text-neutral-300">
                Calcul = somme des notes de compétences (pondération du livret) — les items “NON” ne sont pas pris en compte.
              </div>
            </div>
          </div>

          <div className="mt-4 overflow-x-auto">
            <table className="ccf-table min-w-[980px] w-full text-xs border-collapse">
              <thead>
                <tr className="bg-neutral-50 dark:bg-[#0f1b2d]">
                  <th className="text-left px-2 py-2 border border-neutral-200 dark:border-sky-400/35 w-[110px]">Code</th>
                  <th className="text-left px-2 py-2 border border-neutral-200 dark:border-sky-400/35">Compétence / item</th>
                  <th className="text-left px-2 py-2 border border-neutral-200 dark:border-sky-400/35">Critères</th>
                  <th className="text-right px-2 py-2 border border-neutral-200 dark:border-sky-400/35 w-[90px]">Poids</th>
                  <th className="text-center px-2 py-2 border border-neutral-200 dark:border-sky-400/35 w-[420px]">Niveau</th>
                </tr>
              </thead>
              <tbody>
                {(ccfTemplates?.[ccfEpKey] ?? CCF_TEMPLATES[ccfEpKey]).map((g) => {
                  const gInfo = computed.groupDetails.find((x) => x.code === g.code);
                  return (
                    <React.Fragment key={g.code}>
                      <tr className="bg-white dark:bg-[#182433]" style={(g as any).bgColor || (g as any).fontColor ? { backgroundColor: (g as any).bgColor, color: (g as any).fontColor } : undefined}>
                        <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35 font-semibold">{g.code}</td>
                        <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35 font-semibold" colSpan={2}>
                          {g.title}
                          <span className="ml-2 text-[11px] font-normal text-neutral-500 dark:text-neutral-300">
                            ({(g.groupPoints ?? 0).toFixed(2)} pts) — Score: {(gInfo?.groupScore ?? 0).toFixed(2)} / {(g.groupPoints ?? 0).toFixed(2)}
                          </span>
                        </td>
                        <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35 text-right">
                          {(g.groupPoints ?? 0).toFixed(2)}
                        </td>
                        <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35" />
                      </tr>

                      {g.items.map((it) => {
                        const current = (sheet.levels[it.code] as CcfLevel | undefined) ?? undefined;
                        const options: CcfLevel[] = ["NON", "0", "1", "2", "3"];
                        return (
                          <tr key={it.code} className="bg-white dark:bg-[#182433]" style={(it as any).bgColor || (it as any).fontColor ? { backgroundColor: (it as any).bgColor, color: (it as any).fontColor } : undefined}>
                            <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35">{it.code}</td>
                            <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35">{it.label}</td>
                            <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35">
                              <div className="line-clamp-4 whitespace-pre-wrap">{it.criteria}</div>
                            </td>
                            <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35 text-right">
                              {(it.realWeight ?? 0).toFixed(2)}
                            </td>
                            <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35">
                              <div className="flex items-center justify-center gap-1 flex-wrap">
                                {options.map((opt) => {
                                  const active = current === opt;
                                  return (
                                    <button
                                      key={opt}
                                      type="button"
                                      onClick={() => {
                                        const nextLevels = { ...(sheet.levels || {}) };
                                        nextLevels[it.code] = active ? undefined : opt;
                                        setCcfSheet(ccfSelectedStudentName, ccfEpKey, {
                                          ...sheet,
                                          levels: nextLevels,
                                        });
                                      }}
                                      className={ccfLevelButtonClass(opt, active)}
                                      title={opt === "NON" ? "Non observé / déjà évalué" : `Niveau ${opt}/3`}
                                    >
                                      {ccfLevelLabel(opt)}
                                    </button>
                                  );
                                })}
                              </div>
                            </td>
                          </tr>
                        );
                      })}
                    </React.Fragment>
                  );
                })}
              </tbody>
            </table>
          </div>
        </>
      );
    })()
  )}
</div>
    </div>
  </div>
</TabsContent>

{/* STEP 1 */}
<TabsContent
  value="step1"
  className="mt-2 px-4 sm:px-6 lg:px-8 h-[calc(100vh-180px)] overflow-hidden"
>
  {/* zone scrollable interne */}
  <div className="h-full overflow-y-auto overscroll-contain pr-2">
    <div className="grid gap-6 lg:grid-cols-3 pt-4">
      {GROUPS.map((g) => {
      const styles = GROUP_STYLES[g.key];
      const keys = Object.keys(tcMap);
      const tasks = sortByTaskNumber(
        keys.filter((k) => {
          const n = taskNumber(k);
          return n >= g.range[0] && n <= g.range[1];
        })
      );

      return (
        <div key={g.key} className={classNames("shadow-sm border rounded-xl", styles.accentBorder)}>
          <div className={classNames(styles.headerBg, styles.headerText, "rounded-t-xl px-4 py-3 font-semibold text-base")}>
            {g.title}
          </div>

          <div className="p-4 grid gap-2">
            {tasks.length === 0 ? (
              <div className="text-xs text-neutral-500 dark:text-neutral-300 italic">Aucune tâche dans ce groupe.</div>
            ) : (
              tasks.map((task) => {
                const isSelected = selectedTasks.includes(task);

                return (
                  <button
                    key={task}
                    type="button"
                    aria-pressed={isSelected}
                    onClick={() => {
                      setSelectedTasks((prev) => {
                        const wasSelected = prev.includes(task);
                        const next = wasSelected ? prev.filter((t) => t !== task) : [...prev, task];

                        // si on sélectionne => activeTask = task ; si on désélectionne la dernière => null
                        setActiveTask(wasSelected ? (next[0] ?? null) : task);

                        return next;
                      });
                    }}
                    className={classNames(
                      "text-left rounded-xl border p-3 transition focus:outline-none focus:ring-2 text-neutral-900 dark:text-neutral-300",
                      isSelected
                        ? classNames(styles.buttonSelected)
                        : classNames("bg-white hover:bg-amber-100/70 dark:bg-[#182433]", styles.buttonHover, "border-neutral-200 dark:border-sky-400/35")
                    )}
                  >
                    <div className="text-sm font-medium leading-snug flex items-center gap-2">
                      <span>{task}</span>
                    </div>
                  </button>
                );
              })
            )}
          </div>
        </div>
      );
    })}
  </div>
  </div>
</TabsContent>

 {/* STEP 2 */}
<TabsContent 
value="step2" className="mt-6 px-4 sm:px-6 lg:px-8">
  {(() => {
    const tasksForStep2 =
      selectedTasks && selectedTasks.length > 0
        ? sortByTaskNumber(selectedTasks)
        : activeTask
        ? [activeTask]
        : [];

    if (tasksForStep2.length === 0) {
      return (
        <div className="text-neutral-600 dark:text-neutral-300">
          Choisissez d&apos;abord une tâche.
        </div>
      );
    }

    return (
      <div className="space-y-6">
        {tasksForStep2.map((taskLabel) => (
          <section key={taskLabel}>
            {/* 🔹 ENCADRÉ autour de toute l'activité de la tâche */}
            <div className="border border-neutral-200 dark:border-sky-400/35/60 rounded-xl bg-white dark:bg-[#182433] shadow-sm px-3 py-2 space-y-3">
              {/* En-tête de la tâche */}
              <div className="flex items-center justify-between">
                <div className="flex items-center gap-2">
                  <button
                    onClick={() => toggleTaskExpanded(taskLabel)}
                    className="h-7 w-7 inline-flex items-center justify-center rounded-md border border-neutral-300 dark:border-sky-400/35 bg-white hover:bg-amber-100/70 dark:bg-[#182433] hover:bg-amber-100/70 dark:bg-[#1f2d42] focus:outline-none focus:ring-2 focus:ring-neutral-400"
                    aria-label={
                      isTaskExpanded(taskLabel)
                        ? "Fermer la tâche"
                        : "Ouvrir la tâche"
                    }
                    title={
                      isTaskExpanded(taskLabel)
                        ? "Fermer la tâche"
                        : "Ouvrir la tâche"
                    }
                    type="button"
                  >
                    <ChevronRight
                      className={classNames(
                        "h-4 w-4 transition-transform",
                        isTaskExpanded(taskLabel) && "rotate-90"
                      )}
                    />
                  </button>

                  <h2 className="text-[12px] sm:text-sm font-semibold text-neutral-900 dark:text-neutral-300">
                    {taskLabel}
                  </h2>
                </div>

                <div className="text-xs sm:text-sm text-neutral-600 dark:text-neutral-300">
                  {(tcMap[taskLabel] ?? []).length} compétence(s)
                </div>
              </div>

              {/* Contenu de la tâche : compétences par familles */}
              {isTaskExpanded(taskLabel) && (
                <div className="grid gap-6 xl:grid-cols-4 md:grid-cols-2 grid-cols-1">
                  {(
                    ["C1", "C2", "C3", "C4"] as Array<
                      "C1" | "C2" | "C3" | "C4"
                    >
                  ).map((fam) => {
                    const comps = (tcMap[taskLabel] ?? []).filter(
                      (c) => parseCompetencyFamily(c) === fam
                    );
                    const s = FAMILY_STYLES[fam];
                    const famLabel =
                      fam === "C1"
                        ? "COMMUNIQUER"
                        : fam === "C2"
                        ? "PRÉPARER"
                        : fam === "C3"
                        ? "RÉALISER"
                        : "CONTRÔLE";

                    return (
                      <div
                        key={fam + "|" + taskLabel}
                        className={classNames(
                          "rounded-2xl border bg-white dark:bg-[#182433] overflow-hidden",
                          s.border,
                          s.accentBorder
                        )}
                      >
                        <div
                          className={classNames(
                            "px-2 py-1 border-b-[0.5px]",
                            s.border,
                            s.chipBg
                          )}
                        >
                          <div
                            className={classNames(
                              "flex items-center gap-2 text-[12px] font-semibold",
                              s.headerText
                            )}
                          >
                            {famLabel}
                          </div>
                        </div>

                        <div className="p-3 space-y-2">
                          {comps.length === 0 ? (
                            <div className="text-xs text-neutral-400 italic">
                              Aucune compétence pour cette famille.
                            </div>
                          ) : (
                            comps.map((comp) => {
                              const compKey = taskLabel + "||" + comp;
                              const selected =
                                selectedCompetences.includes(compKey);
                              const entries =
                                critResDB && critResDB[comp]
                                  ? Object.entries(critResDB[comp])
                                  : [];

                              return (
                                <div
                                  key={compKey}
                                  className="border rounded-xl shadow-sm"
                                >
                                  <div
                                    className={classNames(
                                      "w-full text-left rounded-t-lg px-2 py-1 text-[11px] leading-tight transition border-b-[0.5px] cursor-pointer select-none",
                                      selected
                                        ? classNames(
                                            FAMILY_STYLES[
                                              parseCompetencyFamily(comp) as
                                                | "C1"
                                                | "C2"
                                                | "C3"
                                                | "C4"
                                            ].selectedDarkBg,
                                            FAMILY_STYLES[
                                              parseCompetencyFamily(comp) as
                                                | "C1"
                                                | "C2"
                                                | "C3"
                                                | "C4"
                                            ].selectedDarkText,
                                            "border-transparent"
                                          )
                                        : classNames(
                                            s.chipBg,
                                            s.chipText,
                                            s.border
                                          )
                                    )}
                                    onClick={() => toggleCompExpanded(compKey)}
                                    role="button"
                                    aria-expanded={isCompExpanded(compKey)}
                                  >
                                    <div className="text-[11px] leading-snug font-bold flex items-center gap-2">
                                      <button
                                        onClick={(e) => {
                                          e.stopPropagation();
                                          toggleCompExpanded(compKey);
                                        }}
                                        className="h-6 w-6 inline-flex items-center justify-center rounded border border-current/30 bg-transparent hover:bg-amber-100/70/10 dark:bg-[#182433]/10 focus:outline-none focus:ring-2 focus:ring-current/40"
                                        aria-label={
                                          isCompExpanded(compKey)
                                            ? "Fermer la compétence"
                                            : "Ouvrir la compétence"
                                        }
                                        title={
                                          isCompExpanded(compKey)
                                            ? "Fermer la compétence"
                                            : "Ouvrir la compétence"
                                        }
                                        type="button"
                                      >
                                        <ChevronRight
                                          className={classNames(
                                            "h-3.5 w-3.5 transition-transform",
                                            isCompExpanded(compKey) &&
                                              "rotate-90"
                                          )}
                                        />
                                      </button>

                                      <span>{comp}</span>
                                    </div>
                                  </div>

                                  {isCompExpanded(compKey) && (
                                    <div className="p-3 space-y-2 text-xs">
                                      {entries.length === 0 ? (
                                        <div className="text-neutral-400 italic">
                                          Aucun critère disponible.
                                        </div>
                                      ) : (
                                        entries.map(([item, obj]) => {
                                          const subCritList =
                                            (obj as any)?.resultats ?? [];
                                          const critBaseKey =
                                            taskLabel + "||" + comp + "::" + item;

                                          return (
                                            <div
                                              key={critBaseKey}
                                              className="border rounded-lg p-2 space-y-1"
                                            >
                                              <div className="font-semibold text-xs">
                                                {item}
                                              </div>
                                              <div className="flex flex-wrap gap-2 mt-1">
                                                {subCritList.map(
                                                  (res: string, idx: number) => {
                                                    const key =
                                                      critBaseKey + "::" + idx;
                                                    const on =
                                                      selectedSubCrit.includes(
                                                        key
                                                      );
                                                    return (
                                                      <button
                                                        key={key}
                                                        type="button"
                                                        onClick={() =>
                                                          toggleSubCrit(
                                                            key,
                                                            comp,
                                                            item
                                                          )
                                                        }
                                                        className={classNames(
                                                          "px-2 py-1 rounded-full border text-[11px] leading-tight",
                                                          on
                                                            ? FAMILY_STYLES[
                                                                parseCompetencyFamily(
                                                                  comp
                                                                ) as
                                                                  | "C1"
                                                                  | "C2"
                                                                  | "C3"
                                                                  | "C4"
                                                              ]
                                                                .selectedBg
                                                            : "bg-white dark:bg-[#1f2d42] hover:bg-amber-100/70 dark:bg-[#1f2d42] border-neutral-200 dark:border-sky-400/35"
                                                        )}
                                                      >
                                                        {res}
                                                      </button>
                                                    );
                                                  }
                                                )}
                                              </div>
                                            </div>
                                          );
                                        })
                                      )}
                                    </div>
                                  )}
                                </div>
                              );
                            })
                          )}
                        </div>
                      </div>
                    );
                  })}
                </div>
              )}
            </div>
          </section>
        ))}
      </div>
    );
  })()}
</TabsContent>

  {/* STEP 3 */}
<TabsContent value="step3" className="mt-6 px-4 sm:px-6 lg:px-8 pb-20">
            {selectedCriteres.length === 0 ? (
              <div className="text-neutral-600 dark:text-neutral-300">Sélectionnez d'abord des critères en étape 2.</div>
            ) : (
              <div className="space-y-4">
                <div className="flex items-center justify-between">
                </div>

                <div className="overflow-auto rounded-xl border">
<table className="min-w-[900px] w-full text-xs leading-tight table-fixed border-collapse text-neutral-900 dark:text-neutral-300 border border-neutral-300 dark:border-sky-400/35 [&_th]:border [&_th]:border-neutral-300 dark:[&_th]:border-neutral-700/60 [&_th]:text-center [&_th]:px-3 [&_th]:py-1 [&_td]:border [&_td]:border-neutral-200 dark:[&_td]:border-neutral-700/60 [&_td]:px-3 [&_td]:py-1 [&_td]:align-middle [&_td]:text-left">
                    <thead className="bg-neutral-50 dark:bg-[#1f2d42] border-b border-neutral-300 dark:border-sky-400/35">
  <tr className="text-center">
    <th className="py-1 w-[10%]">
      <span className="mx-4">Tâche</span>
    </th>
    <th className="py-1 w-[15%]">
      <span className="mx-4">Compétence</span>
    </th>
    <th className="py-1 w-[20%]">
      <span className="mx-4">Être capable</span>
    </th>
    <th className="py-1 w-[20%]">
      <span className="mx-4">Critère d&apos;évaluation</span>
    </th>
    <th className="py-1 w-[12%]">
      <span className="mx-4">Exigences</span>
    </th>
  </tr>
</thead>

<tbody>
  {sortByTaskNumber(selectedTasks).flatMap((task) => {
    const comps = (tcMap[task] || []) as string[];

    const compItems = comps
      .map((comp) => {
        const allItems = Object.keys(
          (critResDB && (critResDB as any)[comp]) || {}
        );
        const items = allItems.filter((item) => {
          const prefix = task + "||" + comp + "::" + item + "::";
          return selectedSubCrit.some((k) => k.startsWith(prefix));
        });
        return { comp, items };
      })
      .filter((ci) => ci.items.length > 0);

    if (compItems.length === 0) return [] as JSX.Element[];

    type Row = {
      task: string;
      comp: string;
      item: string;
      compRowSpan: number;
      isFirstOfComp: boolean;
    };

    const rows: Row[] = compItems.flatMap((ci) =>
      ci.items.map((item, idx) => ({
        task,
        comp: ci.comp,
        item,
        compRowSpan: ci.items.length,
        isFirstOfComp: idx === 0,
      }))
    );

    // 🔹 Déterminer le groupe de la tâche (G1 / G2 / G3)
    const tNum = taskNumber(task);
    const group = GROUPS.find(
      (g) => tNum >= g.range[0] && tNum <= g.range[1]
    );

    // 🔹 Classe de couleur pour la bordure interne de la cellule "Tâche"
    const taskColorClass =
      group?.key === "G1"
        ? "border-sky-400"
        : group?.key === "G2"
        ? "border-amber-400"
        : group?.key === "G3"
        ? "border-violet-400"
        : "border-neutral-300 dark:border-sky-400/35";

    return rows.map((r, rowIdx) => {
      const critKey = `${r.task}||${r.comp}::${r.item}`;
      const normKey = normalizeKeyFromCritKey(critKey);

      const options = Array.from(
        new Set(
          [
            ...getEffectiveExigences(critKey),
            ...(persistedExigencesDB?.[normKey] ?? []),
            ...(getPersistedExigencesFor(r.comp, r.item) ?? []),
            ...(customExigences?.[critKey] ?? []),
          ] as string[]
        )
      );

      const chosenAll = (
        selectedExigence[critKey] ?? getEffectiveExigences(critKey)
      ).filter((v, i, a) => a.indexOf(v) === i);

      const chosenCustom = chosenAll.filter((ex) => options.includes(ex));

      const prefix = `${r.task}||${r.comp}::${r.item}::`;
      const subList: string[] =
        (critResDB &&
          (critResDB as any)[r.comp] &&
          (critResDB as any)[r.comp][r.item]?.resultats) ||
        [];

      const selectedIdx = selectedSubCrit
        .filter((k) => k.startsWith(prefix) && !/::E\d+$/.test(k))
        .map((k) => {
          const m = k.match(/::(\d+)$/);
          return m ? Number(m[1]) : null;
        })
        .filter((n): n is number => n !== null);

      return (
        <tr
          key={`${r.task}|${r.comp}|${r.item}`}
          className="border-t align-top"
        >
          {/* COL 1 — Tâche (avec bordure verticale colorée interne) */}
          {rowIdx === 0 && (
            <td className="px-4 py-3 align-top" rowSpan={rows.length}>
              <div
                className={classNames(
                  "font-medium pl-3 border-l-4",
                  taskColorClass
                )}
              >
                {formatEvalLabel(r.task, r.comp)}
              </div>
            </td>
          )}

          {/* COL 2 — Compétence */}
          {r.isFirstOfComp && (
            <td className="px-4 py-3 align-top" rowSpan={r.compRowSpan}>
              <div className="font-medium">{r.comp}</div>
            </td>
          )}

          {/* COL 3 — Être capable */}
          <td className="px-4 py-3">{r.item}</td>

          {/* COL 4 — Critère d'évaluation */}
          <td className="px-4 py-3">
            {selectedIdx.length === 0 ? (
              <div className="text-xs text-neutral-500 italic">—</div>
            ) : (
              <ul className="list-disc pl-4 space-y-1 text-xs">
                {selectedIdx.map((i) => (
                  <li key={i}>{subList[i]}</li>
                ))}
              </ul>
            )}
          </td>

          {/* COL 5 — Exigences personnalisées */}
          <td className="px-4 py-3">
            <div className="flex items-center gap-2">
              <DropdownMenu
                onOpenChange={(open) => {
                  if (!open) {
                    setInlineAddKey(null);
                    setInlineAddValue("");
                  }
                }}
              >
                <DropdownMenuTrigger asChild>
                  <button
                    type="button"
                    className="inline-flex items-center gap-1 text-xs px-2 py-1 rounded border border-neutral-300 dark:border-sky-400/35 bg-white hover:bg-amber-100/70 dark:bg-[#182433] hover:bg-amber-100/70 dark:bg-[#182433]"
                    title="Choisir les exigences personnalisées à afficher"
                  >
                    <ChevronRight className="h-3.5 w-3.5" />
                    {`Sélection${
                      chosenCustom.length ? ` (${chosenCustom.length})` : ""
                    }`}
                  </button>
                </DropdownMenuTrigger>

                <DropdownMenuContent
                  key={`${critKey}-${options.length}-${
                    (selectedExigence[critKey] ?? []).length
                  }`}
                  className="w-96 p-2"
                >
                  {options.length === 0 ? (
                    <>
                      <div className="px-2 py-1.5 text-xs text-neutral-500 flex items-center gap-2">
                        Aucune exigence personnalisée.
                        <button
                          onClick={() => openManage(critKey)}
                          className="underline"
                        >
                          Ouvrir la bibliothèque
                        </button>
                      </div>

                      <DropdownMenuSeparator />

                      <div className="px-1 pt-1">
                        <div className="text-[11px] mb-1 text-neutral-500">
                          Ajouter une exigence
                        </div>
                        <div className="flex items-center gap-2">
                          <Input
                            value={
                              inlineAddKey === critKey ? inlineAddValue : ""
                            }
                            onChange={(e) => {
                              setInlineAddKey(critKey);
                              setInlineAddValue(e.target.value);
                            }}
                            onKeyDown={(e) => {
                              if (e.key === "Enter") {
                                const v = (
                                  inlineAddKey === critKey
                                    ? inlineAddValue
                                    : ""
                                ).trim();
                                if (!v) return;
                                setCustomExigences((prev) => {
                                  const base = prev[critKey] ?? [];
                                  const arr = [...base];
                                  if (!arr.includes(v)) arr.push(v);
                                  return { ...prev, [critKey]: arr };
                                });
                                setSelectedExigence((prev) => {
                                  const cur = prev[critKey] ?? [];
                                  return cur.includes(v)
                                    ? prev
                                    : {
                                        ...prev,
                                        [critKey]: [...cur, v],
                                      };
                                });
                                setInlineAddValue("");
                                setInlineAddKey(null);
                              }
                            }}
                            placeholder="Nouvelle exigence…"
                            className="h-8"
                          />
                          <Button
                            className="h-8 px-2"
                            onClick={() => {
                              const v = (
                                inlineAddKey === critKey
                                  ? inlineAddValue
                                  : ""
                              ).trim();
                              if (!v) return;
                              setCustomExigences((prev) => {
                                const base = prev[critKey] ?? [];
                                const arr = [...base];
                                if (!arr.includes(v)) arr.push(v);
                                return { ...prev, [critKey]: arr };
                              });
                              setSelectedExigence((prev) => {
                                const cur = prev[critKey] ?? [];
                                return cur.includes(v)
                                  ? prev
                                  : {
                                      ...prev,
                                      [critKey]: [...cur, v],
                                    };
                              });
                              setInlineAddValue("");
                              setInlineAddKey(null);
                            }}
                          >
                            <Plus className="w-3.5 h-3.5 mr-1" />
                            Ajouter
                          </Button>
                        </div>
                      </div>
                    </>
                  ) : (
                    <>
                      <DropdownMenuLabel className="text-xs text-neutral-500">
                        Exigences personnalisées (cocher pour afficher)
                      </DropdownMenuLabel>
                      <DropdownMenuSeparator />
                      <div className="max-h-64 overflow-auto pr-1">
                        {options.map((ex, i) => (
                          <DropdownMenuCheckboxItem
                            key={i}
                            checked={chosenCustom.includes(ex)}
                            onCheckedChange={(checked) => {
                              if (checked) toggleExigenceSelection(critKey, ex);
                              else removeFromCell(critKey, ex);
                            }}
                            className="text-xs whitespace-normal leading-snug pr-7"
                          >
                            {ex}
                          </DropdownMenuCheckboxItem>
                        ))}
                      </div>
                      <DropdownMenuSeparator />
                      <div className="px-1 pt-1">
                        <div className="text-[11px] mb-1 text-neutral-500">
                          Ajouter une exigence
                        </div>
                        <div className="flex items-center gap-2">
                          <Input
                            value={
                              inlineAddKey === critKey ? inlineAddValue : ""
                            }
                            onChange={(e) => {
                              setInlineAddKey(critKey);
                              setInlineAddValue(e.target.value);
                            }}
                            onKeyDown={(e) => {
                              if (e.key === "Enter") {
                                const v = (
                                  inlineAddKey === critKey
                                    ? inlineAddValue
                                    : ""
                                ).trim();
                                if (!v) return;
                                setCustomExigences((prev) => {
                                  const base = prev[critKey] ?? [];
                                  const arr = [...base];
                                  if (!arr.includes(v)) arr.push(v);
                                  return { ...prev, [critKey]: arr };
                                });
                                setSelectedExigence((prev) => {
                                  const cur = prev[critKey] ?? [];
                                  return cur.includes(v)
                                    ? prev
                                    : {
                                        ...prev,
                                        [critKey]: [...cur, v],
                                      };
                                });
                                setInlineAddValue("");
                                setInlineAddKey(null);
                              }
                            }}
                            placeholder="Nouvelle exigence…"
                            className="h-8"
                          />
                          <Button
                            className="h-8 px-2"
                            onClick={() => {
                              const v = (
                                inlineAddKey === critKey
                                  ? inlineAddValue
                                  : ""
                              ).trim();
                              if (!v) return;
                              setCustomExigences((prev) => {
                                const base = prev[critKey] ?? [];
                                const arr = [...base];
                                if (!arr.includes(v)) arr.push(v);
                                return { ...prev, [critKey]: arr };
                              });
                              setSelectedExigence((prev) => {
                                const cur = prev[critKey] ?? [];
                                return cur.includes(v)
                                  ? prev
                                  : {
                                      ...prev,
                                      [critKey]: [...cur, v],
                                    };
                              });
                              setInlineAddValue("");
                              setInlineAddKey(null);
                            }}
                          >
                            <Plus className="w-3.5 h-3.5 mr-1" />
                            Ajouter
                          </Button>
                        </div>
                      </div>
                    </>
                  )}
                </DropdownMenuContent>
              </DropdownMenu>

              <button
                type="button"
                onClick={() => openManage(critKey)}
                className="h-7 w-7 inline-flex items-center justify-center rounded border border-neutral-300 dark:border-sky-400/35 bg-white hover:bg-amber-100/70 dark:bg-[#182433] hover:bg-amber-100/70 dark:bg-[#182433]"
                title="Gérer la bibliothèque"
                aria-label="Gérer"
              >
                <Settings2 className="w-3.5 h-3.5" />
              </button>
            </div>

            {/* Résumé sélectionné */}
            <div className="mt-2">
              {chosenCustom.length === 0 ? (
                <span className="text-xs text-neutral-500">
                  Aucune sélection personnalisée
                </span>
              ) : (
                <ul className="list-disc pl-4 space-y-1 text-xs">
                  {chosenCustom.map((ex) => (
                    <li key={ex} className="flex items-start gap-2">
                      <span className="flex-1">{ex}</span>
                      <button
                        onClick={() => removeFromCell(critKey, ex)}
                        className="inline-flex items-center justify-center h-5 w-5 rounded border border-neutral-300 dark:border-sky-400/35 hover:bg-amber-100/70 dark:bg-[#182433]"
                        aria-label="Retirer de la cellule"
                        title="Retirer de la cellule"
                      >
                        <Trash2 className="h-3.5 w-3.5" />
                      </button>
                    </li>
                  ))}
                </ul>
              )}
            </div>
          </td>
        </tr>
      );
    });
  })}
</tbody>


                  </table>
                </div>
              </div>
            )}
</TabsContent>

  {/* STEP 4 – NOTATION (CRITÉRIÉE PAR CRITÈRE) */}
<TabsContent value="step4" className="mt-6 px-4 sm:px-6 lg:px-8 pb-20">
  {renderNotationCriteree()}
</TabsContent>


        </Tabs>
 ) : activeView === "ccf" ? (
  <section className="space-y-4 px-2 sm:px-3 lg:px-4 pt-2 pb-12">
    <div className="rounded-2xl border border-neutral-200 dark:border-sky-400/35 bg-white dark:bg-[#182433] keep-light p-4 shadow-sm">

      <div className="mb-3 flex flex-col gap-2 rounded-xl border border-neutral-200 dark:border-sky-400/35 bg-neutral-50 dark:bg-[#0f1b2d] px-3 py-2">
        <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-2">
          <div className="text-sm">
            <div className="font-medium">Source CCF (Excel national)</div>
            <div className="text-xs text-neutral-600 dark:text-neutral-300 break-all">
              {ccfExcelPath ? `Branché : ${ccfExcelPath}` : "Non branché : modèle embarqué"}
            </div>
          </div>
          <div className="flex gap-2">
            <Button type="button" variant="secondary" onClick={linkCcfExcel}>
              Ajouter le fichier de référence Excel
            </Button>
            <Button type="button" variant="outline" onClick={unlinkCcfExcel} disabled={!ccfExcelPath}>
              Enlever le fichier
            </Button>
          </div>
        </div>
        <div className="text-xs text-neutral-600 dark:text-neutral-300">
          Si le fichier est modifié et enregistré, l’onglet CCF se met à jour automatiquement.
        </div>
      </div>

	      <Tabs value={ccfTab} onValueChange={(v) => {
  const next = v as CcfCcfTab;
  setCcfTab(next);
  if (next !== "EVALUATION") setCcfEpKey(next);
}}>
	        {/* Sous-onglets CCF en petites bulles, alignés sur une seule ligne */}
	        <div className="flex items-center justify-between gap-2 flex-wrap">
<TabsList className="!flex !flex-row !flex-nowrap flex-1 max-w-full items-center gap-1 overflow-x-auto rounded-full border border-neutral-200 dark:border-sky-400/35 bg-neutral-50 dark:bg-[#182433] p-1">
  <TabsTrigger value="EP1" className="!w-auto !flex-none shrink-0 whitespace-nowrap rounded-full px-3 py-1 text-xs font-medium !bg-transparent text-neutral-700 dark:text-neutral-300 data-[state=active]:!bg-neutral-900 data-[state=active]:!text-white hover:!bg-amber-100/70 dark:hover:!bg-[#3d2707]">
    EPI
  </TabsTrigger>
  <TabsTrigger value="EP2A1" className="!w-auto !flex-none shrink-0 whitespace-nowrap rounded-full px-3 py-1 text-xs font-medium !bg-transparent text-neutral-700 dark:text-neutral-300 data-[state=active]:!bg-neutral-900 data-[state=active]:!text-white hover:!bg-amber-100/70 dark:hover:!bg-[#3d2707]">
    EP2 A1
  </TabsTrigger>
  <TabsTrigger value="EP2A2" className="!w-auto !flex-none shrink-0 whitespace-nowrap rounded-full px-3 py-1 text-xs font-medium !bg-transparent text-neutral-700 dark:text-neutral-300 data-[state=active]:!bg-neutral-900 data-[state=active]:!text-white hover:!bg-amber-100/70 dark:hover:!bg-[#3d2707]">
    EP2 A2
  </TabsTrigger>
  <TabsTrigger value="EP3" className="!w-auto !flex-none shrink-0 whitespace-nowrap rounded-full px-3 py-1 text-xs font-medium !bg-transparent text-neutral-700 dark:text-neutral-300 data-[state=active]:!bg-neutral-900 data-[state=active]:!text-white hover:!bg-amber-100/70 dark:hover:!bg-[#3d2707]">
    EP3
  </TabsTrigger>
<TabsTrigger value="EVALUATION" className="!w-auto !flex-none shrink-0 whitespace-nowrap rounded-full px-3 py-1 text-xs font-medium !bg-transparent text-neutral-700 dark:text-neutral-300 data-[state=active]:!bg-neutral-900 data-[state=active]:!text-white hover:!bg-amber-100/70 dark:hover:!bg-[#3d2707]">
  Évaluation
</TabsTrigger>
</TabsList>
<div className="flex items-center gap-2 flex-wrap justify-end">
  <Button
    type="button"
    variant="secondary"
    className="h-9 px-3 text-xs"
    disabled={!ccfSelectedClassId || ccfExportBusy}
    onClick={handleExportCcfJsonForSelectedClass}
    title="Exporter les résultats CCF (JSON) pour la classe sélectionnée"
  >
    {ccfExportBusy ? "Export…" : "Enregistrer"}
  </Button>

  <div className="min-w-[170px]">
    <select
      className="h-9 w-full rounded-md border border-neutral-300 dark:border-sky-400/35 bg-white dark:bg-[#182433] px-2 text-xs text-neutral-900 dark:text-neutral-100"
      value={ccfSelectedClassId ?? ""}
      onChange={(e) => {
        const v = e.target.value;
        const next = v ? v : null;
        setCcfSelectedClassId(next);
        const students = getStudentsForClassCCF(next);
        setCcfSelectedStudentName(students[0] ?? null);
      }}
    >
      <option value="" disabled>
        Classe
      </option>
      {classGroups.map((c) => (
        <option key={c.id ?? c.name} value={c.id ?? c.name}>
          {c.name}
        </option>
      ))}
    </select>
  </div>

  <div className="min-w-[170px]">
    <select
      className="h-9 w-full rounded-md border border-neutral-300 dark:border-sky-400/35 bg-white dark:bg-[#182433] px-2 text-xs text-neutral-900 dark:text-neutral-100 disabled:opacity-60"
      value={ccfSelectedStudentName ?? ""}
      disabled={!ccfSelectedClassId}
      onChange={(e) => setCcfSelectedStudentName(e.target.value ? e.target.value : null)}
    >
      <option value="" disabled>
        Élève
      </option>
      {(ccfSelectedClassId ? getStudentsForClassCCF(ccfSelectedClassId) : []).map((name) => (
        <option key={name} value={name}>
          {name}
        </option>
      ))}
    </select>
  </div>

  <div className="min-w-[210px]">
    <select
      className="h-9 w-full rounded-md border border-neutral-300 dark:border-sky-400/35 bg-white dark:bg-[#182433] px-2 text-xs text-neutral-900 dark:text-neutral-100"
      value={ccfEpKey}
      onChange={(e) => setCcfEpKey(e.target.value as CcfEpKey)}
    >
      <option value="EP1">EP1 — Étude & préparation</option>
      <option value="EP2A1">EP2 A1 — Travaux courants (centre)</option>
      <option value="EP2A2">EP2 A2 — Travaux courants (entreprise)</option>
      <option value="EP3">EP3 — Travaux spécifiques</option>
    </select>
  </div>
</div>
</div>


<TabsContent value="EVALUATION" className="mt-4">
{/* Évaluation (règlement + notes coefficientées) */}
  <div className="w-full">
    <div className="rounded-xl border border-black/30 bg-white dark:bg-[#182433] keep-light p-3 shadow-sm">
      <div className="flex items-center justify-between gap-2">
        <div className="text-xs font-semibold text-neutral-900 dark:text-neutral-100">Évaluation</div>
        <div className="text-[11px] text-neutral-600 dark:text-neutral-300">Règlement + notes coefficientées</div>
      </div>

      {(() => {
        if (!ccfSelectedStudentName) {
          return <div className="mt-2 text-xs text-neutral-600 dark:text-neutral-300">Sélectionnez un élève.</div>;
        }

        const rows = ccfEvaluationRows || CCF_EVALUATION_FALLBACK;
        const byEp: Record<CcfEpKey, { note20: number; noteCoef: number }> = {
          EP1: { note20: 0, noteCoef: 0 },
          EP2A1: { note20: 0, noteCoef: 0 },
          EP2A2: { note20: 0, noteCoef: 0 },
          EP3: { note20: 0, noteCoef: 0 },
        };

        (Object.keys(byEp) as CcfEpKey[]).forEach((k) => {
          const note20 = computeCcfTotal(ccfSelectedStudentName, k).total;
          const coef = (rows.find((r) => r.epKey === k)?.coef ?? 0) || 0;
          byEp[k] = { note20, noteCoef: note20 * coef };
        });

        const totalCoef = rows.reduce((a, r) => a + (r.coef || 0), 0);
        const totalCoefNote = (Object.values(byEp) as any[]).reduce((a, x) => a + (x.noteCoef || 0), 0);

        const fmt = (v: number) => (typeof v === "number" && isFinite(v) ? v.toFixed(2).replace(".", ",") : "—");

        return (
          <div className="mt-2 overflow-x-auto">
            <table className="w-full border-collapse ccf-table">
              <thead>
                <tr className="bg-neutral-50 dark:bg-[#0f1b2d]">
                  <th className="border border-black px-2 py-1 text-left text-[11px] font-semibold">Réf.</th>
                  <th className="border border-black px-2 py-1 text-left text-[11px] font-semibold">Épreuve</th>
                  <th className="border border-black px-2 py-1 text-center text-[11px] font-semibold">Unité</th>
                  <th className="border border-black px-2 py-1 text-center text-[11px] font-semibold">Coef.</th>
                  <th className="border border-black px-2 py-1 text-center text-[11px] font-semibold">Mode</th>
                  <th className="border border-black px-2 py-1 text-center text-[11px] font-semibold">Durée</th>
                  <th className="border border-black px-2 py-1 text-center text-[11px] font-semibold">Note /20</th>
                  <th className="border border-black px-2 py-1 text-center text-[11px] font-semibold">Note coef.</th>
                </tr>
              </thead>
<tbody>
  {rows.map((r) => {
    const calc = byEp[r.epKey];

    const rowStyle =
      r.bgColor || r.fontColor
        ? ({
            backgroundColor: r.bgColor,
            color: r.fontColor,
          } as React.CSSProperties)
        : undefined;

    return (
      <tr
        key={r.epKey}
        className="bg-white dark:bg-[#182433]"
        style={rowStyle}
      >
        <td className="border border-black px-2 py-1 text-[11px] font-semibold">{r.ref}</td>
        <td className="border border-black px-2 py-1 text-[11px]">{r.epreuve}</td>
        <td className="border border-black px-2 py-1 text-[11px] text-center">{r.unite || "—"}</td>
        <td className="border border-black px-2 py-1 text-[11px] text-center">{r.coef}</td>
        <td className="border border-black px-2 py-1 text-[11px] text-center">{r.mode || "—"}</td>
        <td className="border border-black px-2 py-1 text-[11px] text-center">{r.duree || "—"}</td>
        <td className="border border-black px-2 py-1 text-[11px] text-center font-semibold">{fmt(calc?.note20 ?? 0)}</td>
        <td className="border border-black px-2 py-1 text-[11px] text-center font-semibold">{fmt(calc?.noteCoef ?? 0)}</td>
      </tr>
    );
  })}


                <tr className="bg-neutral-50 dark:bg-[#0f1b2d]">
                  <td className="border border-black px-2 py-1 text-[11px] font-semibold" colSpan={3}>Total</td>
                  <td className="border border-black px-2 py-1 text-[11px] text-center font-semibold">{totalCoef}</td>
                  <td className="border border-black px-2 py-1" colSpan={3} />
                  <td className="border border-black px-2 py-1 text-[11px] text-center font-semibold">{fmt(totalCoefNote)}</td>
                </tr>
              </tbody>
            </table>
          </div>
        );
      })()}
    </div>
  </div>
</TabsContent>

<TabsContent value="EP1" className="mt-4">
          <div className="flex items-start justify-between gap-3">
        <div>
        </div>
      </div>

      {ccfEpParamsOpen && (
        <div className="mt-1 rounded-xl border border-neutral-200 dark:border-sky-400/35 bg-white dark:bg-[#182433] keep-light p-4 shadow-sm">
          <div className="flex items-start justify-between gap-3">
            <div>
            </div>
          </div>

          <div className="mt-3 grid grid-cols-1 md:grid-cols-4 gap-3">
            <div className="space-y-1">
              <Label className="text-xs">Date d’évaluation</Label>
<Input
  type="date"
  defaultValue={ccfSettings.date ?? ""}
  onBlur={(e) =>
    setCcfSettings((p) => ({ ...p, date: e.target.value }))
  }
/>
            </div>

            <div className="space-y-1">
              <Label className="text-xs">Évaluateur (défaut)</Label>
              <Input
                value={ccfSettings.evaluator ?? ""}
                placeholder="Nom / Prénom"
                onChange={(e) => setCcfSettings((p) => ({ ...p, evaluator: e.target.value }))}
              />
            </div>

            <div className="space-y-1">
              <Label className="text-xs">Centre / établissement</Label>
              <Input
                value={ccfSettings.center ?? ""}
                placeholder="GRETA / Lycée / CFA..."
                onChange={(e) => setCcfSettings((p) => ({ ...p, center: e.target.value }))}
              />
            </div>
          </div>
        </div>
      )}

      {!ccfSelectedStudentName ? (
        <div className="mt-4 text-sm text-neutral-600 dark:text-neutral-300">Sélectionnez d’abord une classe et un élève.</div>
      ) : (
        (() => {
          const sheet = getCcfSheet(ccfSelectedStudentName, ccfEpKey);
          const computed = computeCcfTotal(ccfSelectedStudentName, ccfEpKey);
          const __epKeyN = String(ccfEpKey || "").replace(/\s+/g, "");
          const template = (ccfTemplates?.[__epKeyN] ?? (CCF_TEMPLATES as any)[__epKeyN] ?? []);

          return (
            <>
              {/* Résumé toujours visible (prend peu de place) */}
                            <div className="mt-4 grid grid-cols-1 md:grid-cols-3 gap-3">

                <div className="space-y-1 md:col-span-2">
                  <Label className="text-xs">Contexte / lieu</Label>
                  <Input
                    value={sheet.meta?.contexte ?? ""}
                    onChange={(e) =>
                      setCcfSheet(ccfSelectedStudentName, ccfEpKey, {
                        ...sheet,
                        meta: { ...(sheet.meta || {}), contexte: e.target.value },
                      })
                    }
                    placeholder="Atelier / entreprise / chantier…"
                  />
                </div>
              </div>

              {/* Résumé toujours visible (prend peu de place) */}
              <div className="mt-3 flex flex-col sm:flex-row sm:items-end sm:justify-between gap-2 rounded-xl border border-neutral-200 dark:border-sky-400/35 bg-neutral-50 dark:bg-[#0f1b2d] px-3 py-2">
                <div className="text-sm">
                  <div className="font-semibold text-neutral-900 dark:text-neutral-100">
                    Note calculée : {computed.total.toFixed(2)} / 20
                  </div>
                  <div className="text-[11px] text-neutral-500 dark:text-neutral-300">
                    Les items “NON” ne sont pas pris en compte.
                  </div>
                </div>

                <div className="w-full sm:w-auto">
                  <div className="text-[11px] text-neutral-500 dark:text-neutral-300 mb-1 sm:text-right">
                    Note proposée au jury
                  </div>
                  <Input
                    className="h-9 sm:h-8 w-full sm:w-[150px]"
                    value={sheet.meta?.noteProposee ?? ""}
                    onChange={(e) =>
                      setCcfSheet(ccfSelectedStudentName, ccfEpKey, {
                        ...sheet,
                        meta: { ...(sheet.meta || {}), noteProposee: e.target.value },
                      })
                    }
                    placeholder="Ex: 14,5"
                  />
                </div>
              </div>


              

              <div className="mt-4 overflow-x-auto">
                <table className="ccf-table min-w-[980px] w-full text-xs border-collapse">
                  <thead>
                    <tr className="bg-neutral-50 dark:bg-[#0f1b2d]">
                      <th className="text-left px-2 py-2 border border-neutral-200 dark:border-sky-400/35 w-[110px]">Code</th>
                      <th className="text-left px-2 py-2 border border-neutral-200 dark:border-sky-400/35">Compétence / item</th>
                      <th className="text-left px-2 py-2 border border-neutral-200 dark:border-sky-400/35">Critères</th>
                      <th className="text-right px-2 py-2 border border-neutral-200 dark:border-sky-400/35 w-[90px]">Poids</th>
                      <th className="text-center px-2 py-2 border border-neutral-200 dark:border-sky-400/35 w-[420px]">Niveau</th>
                    </tr>
                  </thead>
                  <tbody>
                    {template.map((g) => {
                      const gInfo = computed.groupDetails.find((x) => x.code === g.code);
                      return (
                        <React.Fragment key={g.code}>
                          <tr className="bg-white dark:bg-[#182433]" style={(g as any).bgColor || (g as any).fontColor ? { backgroundColor: (g as any).bgColor, color: (g as any).fontColor } : undefined}>
                            <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35 font-semibold">{g.code}</td>
                            <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35 font-semibold" colSpan={2}>
                              {g.title}
                              <span className="ml-2 text-[11px] font-normal text-neutral-500 dark:text-neutral-300">
                                ({(g.groupPoints ?? 0).toFixed(2)} pts) — Score: {(gInfo?.groupScore ?? 0).toFixed(2)} / {(g.groupPoints ?? 0).toFixed(2)}
                              </span>
                            </td>
                            <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35 text-right">
                              {(g.groupPoints ?? 0).toFixed(2)}
                            </td>
                            <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35" />
                          </tr>

                          {g.items.map((it) => {
                            const current = (sheet.levels?.[it.code] as CcfLevel | undefined) ?? undefined;
                            const options: CcfLevel[] = ["NON", "0", "1", "2", "3"];
                            return (
                              <tr key={it.code} className="bg-white dark:bg-[#182433]" style={(it as any).bgColor || (it as any).fontColor ? { backgroundColor: (it as any).bgColor, color: (it as any).fontColor } : undefined}>
                                <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35">{it.code}</td>
                                <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35">{it.label}</td>
                                <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35">
                                  <div className="line-clamp-4 whitespace-pre-wrap">{it.criteria}</div>
                                </td>
                                <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35 text-right">
                                  {(it.realWeight ?? 0).toFixed(2)}
                                </td>
                                <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35">
                                  <div className="flex items-center justify-center gap-1 flex-wrap">
                                    {options.map((opt) => {
                                      const active = current === opt;
                                      return (
                                        <button
                                          key={opt}
                                          type="button"
                                          onClick={() => {
                                            const nextLevels = { ...(sheet.levels ?? {}) } as Record<string, CcfLevel | undefined>;
                                            nextLevels[it.code] = active ? undefined : opt;
                                            setCcfSheet(ccfSelectedStudentName, ccfEpKey, {
                                              ...sheet,
                                              levels: nextLevels,
                                            });
                                          }}
                                          className={ccfLevelButtonClass(opt, active)}
                                          title={opt === "NON" ? "Non observé / déjà évalué" : `Niveau ${opt}/3`}
                                        >
                                          {opt}
                                        </button>
                                      );
                                    })}
                                  </div>
                                </td>
                              </tr>
                            );
                          })}
                        </React.Fragment>
                      );
                    })}
                  </tbody>
                </table>
              </div>
            </>
          );
        })()
      )}
    
        </TabsContent>

<TabsContent value="EP2A1" className="mt-4">
          <div className="flex items-start justify-between gap-3">
        <div>
        </div>
      </div>

      {ccfEpParamsOpen && (
        <div className="mt-1 rounded-xl border border-neutral-200 dark:border-sky-400/35 bg-white dark:bg-[#182433] keep-light p-4 shadow-sm">
          <div className="flex items-start justify-between gap-3">
            <div>
            </div>
          </div>

          <div className="mt-3 grid grid-cols-1 md:grid-cols-4 gap-3">
            <div className="space-y-1">
              <Label className="text-xs">Date d’évaluation</Label>
<Input
  type="date"
  defaultValue={ccfSettings.date ?? ""}
  onBlur={(e) =>
    setCcfSettings((p) => ({ ...p, date: e.target.value }))
  }
/>
            </div>

            <div className="space-y-1">
              <Label className="text-xs">Évaluateur (défaut)</Label>
              <Input
                value={ccfSettings.evaluator ?? ""}
                placeholder="Nom / Prénom"
                onChange={(e) => setCcfSettings((p) => ({ ...p, evaluator: e.target.value }))}
              />
            </div>

            <div className="space-y-1">
              <Label className="text-xs">Centre / établissement</Label>
              <Input
                value={ccfSettings.center ?? ""}
                placeholder="GRETA / Lycée / CFA..."
                onChange={(e) => setCcfSettings((p) => ({ ...p, center: e.target.value }))}
              />
            </div>
          </div>
        </div>
      )}

      {!ccfSelectedStudentName ? (
        <div className="mt-4 text-sm text-neutral-600 dark:text-neutral-300">Sélectionnez d’abord une classe et un élève.</div>
      ) : (
        (() => {
          const sheet = getCcfSheet(ccfSelectedStudentName, ccfEpKey);
          const computed = computeCcfTotal(ccfSelectedStudentName, ccfEpKey);
          const __epKeyN = String(ccfEpKey || "").replace(/\s+/g, "");
          const template = (ccfTemplates?.[__epKeyN] ?? (CCF_TEMPLATES as any)[__epKeyN] ?? []);

          return (
            <>
              {/* Résumé toujours visible (prend peu de place) */}
                            <div className="mt-4 grid grid-cols-1 md:grid-cols-3 gap-3">

                <div className="space-y-1 md:col-span-2">
                  <Label className="text-xs">Contexte / lieu</Label>
                  <Input
                    value={sheet.meta?.contexte ?? ""}
                    onChange={(e) =>
                      setCcfSheet(ccfSelectedStudentName, ccfEpKey, {
                        ...sheet,
                        meta: { ...(sheet.meta || {}), contexte: e.target.value },
                      })
                    }
                    placeholder="Atelier / entreprise / chantier…"
                  />
                </div>
              </div>

              {/* Résumé toujours visible (prend peu de place) */}
              <div className="mt-3 flex flex-col sm:flex-row sm:items-end sm:justify-between gap-2 rounded-xl border border-neutral-200 dark:border-sky-400/35 bg-neutral-50 dark:bg-[#0f1b2d] px-3 py-2">
                <div className="text-sm">
                  <div className="font-semibold text-neutral-900 dark:text-neutral-100">
                    Note calculée : {computed.total.toFixed(2)} / 20
                  </div>
                  <div className="text-[11px] text-neutral-500 dark:text-neutral-300">
                    Les items “NON” ne sont pas pris en compte.
                  </div>
                </div>

                <div className="w-full sm:w-auto">
                  <div className="text-[11px] text-neutral-500 dark:text-neutral-300 mb-1 sm:text-right">
                    Note proposée au jury
                  </div>
                  <Input
                    className="h-9 sm:h-8 w-full sm:w-[150px]"
                    value={sheet.meta?.noteProposee ?? ""}
                    onChange={(e) =>
                      setCcfSheet(ccfSelectedStudentName, ccfEpKey, {
                        ...sheet,
                        meta: { ...(sheet.meta || {}), noteProposee: e.target.value },
                      })
                    }
                    placeholder="Ex: 14,5"
                  />
                </div>
              </div>


              

              <div className="mt-4 overflow-x-auto">
                <table className="ccf-table min-w-[980px] w-full text-xs border-collapse">
                  <thead>
                    <tr className="bg-neutral-50 dark:bg-[#0f1b2d]">
                      <th className="text-left px-2 py-2 border border-neutral-200 dark:border-sky-400/35 w-[110px]">Code</th>
                      <th className="text-left px-2 py-2 border border-neutral-200 dark:border-sky-400/35">Compétence / item</th>
                      <th className="text-left px-2 py-2 border border-neutral-200 dark:border-sky-400/35">Critères</th>
                      <th className="text-right px-2 py-2 border border-neutral-200 dark:border-sky-400/35 w-[90px]">Poids</th>
                      <th className="text-center px-2 py-2 border border-neutral-200 dark:border-sky-400/35 w-[420px]">Niveau</th>
                    </tr>
                  </thead>
                  <tbody>
                    {template.map((g) => {
                      const gInfo = computed.groupDetails.find((x) => x.code === g.code);
                      return (
                        <React.Fragment key={g.code}>
                          <tr className="bg-white dark:bg-[#182433]" style={(g as any).bgColor || (g as any).fontColor ? { backgroundColor: (g as any).bgColor, color: (g as any).fontColor } : undefined}>
                            <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35 font-semibold">{g.code}</td>
                            <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35 font-semibold" colSpan={2}>
                              {g.title}
                              <span className="ml-2 text-[11px] font-normal text-neutral-500 dark:text-neutral-300">
                                ({(g.groupPoints ?? 0).toFixed(2)} pts) — Score: {(gInfo?.groupScore ?? 0).toFixed(2)} / {(g.groupPoints ?? 0).toFixed(2)}
                              </span>
                            </td>
                            <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35 text-right">
                              {(g.groupPoints ?? 0).toFixed(2)}
                            </td>
                            <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35" />
                          </tr>

                          {g.items.map((it) => {
                            const current = (sheet.levels?.[it.code] as CcfLevel | undefined) ?? undefined;
                            const options: CcfLevel[] = ["NON", "0", "1", "2", "3"];
                            return (
                              <tr key={it.code} className="bg-white dark:bg-[#182433]" style={(it as any).bgColor || (it as any).fontColor ? { backgroundColor: (it as any).bgColor, color: (it as any).fontColor } : undefined}>
                                <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35">{it.code}</td>
                                <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35">{it.label}</td>
                                <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35">
                                  <div className="line-clamp-4 whitespace-pre-wrap">{it.criteria}</div>
                                </td>
                                <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35 text-right">
                                  {(it.realWeight ?? 0).toFixed(2)}
                                </td>
                                <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35">
                                  <div className="flex items-center justify-center gap-1 flex-wrap">
                                    {options.map((opt) => {
                                      const active = current === opt;
                                      return (
                                        <button
                                          key={opt}
                                          type="button"
                                          onClick={() => {
                                            const nextLevels = { ...(sheet.levels ?? {}) } as Record<string, CcfLevel | undefined>;
                                            nextLevels[it.code] = active ? undefined : opt;
                                            setCcfSheet(ccfSelectedStudentName, ccfEpKey, {
                                              ...sheet,
                                              levels: nextLevels,
                                            });
                                          }}
                                          className={ccfLevelButtonClass(opt, active)}
                                          title={opt === "NON" ? "Non observé / déjà évalué" : `Niveau ${opt}/3`}
                                        >
                                          {opt}
                                        </button>
                                      );
                                    })}
                                  </div>
                                </td>
                              </tr>
                            );
                          })}
                        </React.Fragment>
                      );
                    })}
                  </tbody>
                </table>
              </div>
            </>
          );
        })()
      )}
    
        </TabsContent>

<TabsContent value="EP2A2" className="mt-4">
          <div className="flex items-start justify-between gap-3">
        <div>
        </div>
      </div>

      {ccfEpParamsOpen && (
        <div className="mt-1 rounded-xl border border-neutral-200 dark:border-sky-400/35 bg-white dark:bg-[#182433] keep-light p-4 shadow-sm">
          <div className="flex items-start justify-between gap-3">
            <div>
            </div>
          </div>

          <div className="mt-3 grid grid-cols-1 md:grid-cols-4 gap-3">
            <div className="space-y-1">
              <Label className="text-xs">Date d’évaluation</Label>
<Input
  type="date"
  defaultValue={ccfSettings.date ?? ""}
  onBlur={(e) =>
    setCcfSettings((p) => ({ ...p, date: e.target.value }))
  }
/>
            </div>

            <div className="space-y-1">
              <Label className="text-xs">Évaluateur (défaut)</Label>
              <Input
                value={ccfSettings.evaluator ?? ""}
                placeholder="Nom / Prénom"
                onChange={(e) => setCcfSettings((p) => ({ ...p, evaluator: e.target.value }))}
              />
            </div>

            <div className="space-y-1">
              <Label className="text-xs">Centre / établissement</Label>
              <Input
                value={ccfSettings.center ?? ""}
                placeholder="GRETA / Lycée / CFA..."
                onChange={(e) => setCcfSettings((p) => ({ ...p, center: e.target.value }))}
              />
            </div>
          </div>
        </div>
      )}

      {!ccfSelectedStudentName ? (
        <div className="mt-4 text-sm text-neutral-600 dark:text-neutral-300">Sélectionnez d’abord une classe et un élève.</div>
      ) : (
        (() => {
          const sheet = getCcfSheet(ccfSelectedStudentName, ccfEpKey);
          const computed = computeCcfTotal(ccfSelectedStudentName, ccfEpKey);
          const __epKeyN = String(ccfEpKey || "").replace(/\s+/g, "");
          const template = (ccfTemplates?.[__epKeyN] ?? (CCF_TEMPLATES as any)[__epKeyN] ?? []);

          return (
            <>
              {/* Résumé toujours visible (prend peu de place) */}
                            <div className="mt-4 grid grid-cols-1 md:grid-cols-3 gap-3">

                <div className="space-y-1 md:col-span-2">
                  <Label className="text-xs">Contexte / lieu</Label>
                  <Input
                    value={sheet.meta?.contexte ?? ""}
                    onChange={(e) =>
                      setCcfSheet(ccfSelectedStudentName, ccfEpKey, {
                        ...sheet,
                        meta: { ...(sheet.meta || {}), contexte: e.target.value },
                      })
                    }
                    placeholder="Atelier / entreprise / chantier…"
                  />
                </div>
              </div>

              {/* Résumé toujours visible (prend peu de place) */}
              <div className="mt-3 flex flex-col sm:flex-row sm:items-end sm:justify-between gap-2 rounded-xl border border-neutral-200 dark:border-sky-400/35 bg-neutral-50 dark:bg-[#0f1b2d] px-3 py-2">
                <div className="text-sm">
                  <div className="font-semibold text-neutral-900 dark:text-neutral-100">
                    Note calculée : {computed.total.toFixed(2)} / 20
                  </div>
                  <div className="text-[11px] text-neutral-500 dark:text-neutral-300">
                    Les items “NON” ne sont pas pris en compte.
                  </div>
                </div>

                <div className="w-full sm:w-auto">
                  <div className="text-[11px] text-neutral-500 dark:text-neutral-300 mb-1 sm:text-right">
                    Note proposée au jury
                  </div>
                  <Input
                    className="h-9 sm:h-8 w-full sm:w-[150px]"
                    value={sheet.meta?.noteProposee ?? ""}
                    onChange={(e) =>
                      setCcfSheet(ccfSelectedStudentName, ccfEpKey, {
                        ...sheet,
                        meta: { ...(sheet.meta || {}), noteProposee: e.target.value },
                      })
                    }
                    placeholder="Ex: 14,5"
                  />
                </div>
              </div>


              

              <div className="mt-4 overflow-x-auto">
                <table className="ccf-table min-w-[980px] w-full text-xs border-collapse">
                  <thead>
                    <tr className="bg-neutral-50 dark:bg-[#0f1b2d]">
                      <th className="text-left px-2 py-2 border border-neutral-200 dark:border-sky-400/35 w-[110px]">Code</th>
                      <th className="text-left px-2 py-2 border border-neutral-200 dark:border-sky-400/35">Compétence / item</th>
                      <th className="text-left px-2 py-2 border border-neutral-200 dark:border-sky-400/35">Critères</th>
                      <th className="text-right px-2 py-2 border border-neutral-200 dark:border-sky-400/35 w-[90px]">Poids</th>
                      <th className="text-center px-2 py-2 border border-neutral-200 dark:border-sky-400/35 w-[420px]">Niveau</th>
                    </tr>
                  </thead>
                  <tbody>
                    {template.map((g) => {
                      const gInfo = computed.groupDetails.find((x) => x.code === g.code);
                      return (
                        <React.Fragment key={g.code}>
                          <tr className="bg-white dark:bg-[#182433]" style={(g as any).bgColor || (g as any).fontColor ? { backgroundColor: (g as any).bgColor, color: (g as any).fontColor } : undefined}>
                            <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35 font-semibold">{g.code}</td>
                            <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35 font-semibold" colSpan={2}>
                              {g.title}
                              <span className="ml-2 text-[11px] font-normal text-neutral-500 dark:text-neutral-300">
                                ({(g.groupPoints ?? 0).toFixed(2)} pts) — Score: {(gInfo?.groupScore ?? 0).toFixed(2)} / {(g.groupPoints ?? 0).toFixed(2)}
                              </span>
                            </td>
                            <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35 text-right">
                              {(g.groupPoints ?? 0).toFixed(2)}
                            </td>
                            <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35" />
                          </tr>

                          {g.items.map((it) => {
                            const current = (sheet.levels?.[it.code] as CcfLevel | undefined) ?? undefined;
                            const options: CcfLevel[] = ["NON", "0", "1", "2", "3"];
                            return (
                              <tr key={it.code} className="bg-white dark:bg-[#182433]" style={(it as any).bgColor || (it as any).fontColor ? { backgroundColor: (it as any).bgColor, color: (it as any).fontColor } : undefined}>
                                <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35">{it.code}</td>
                                <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35">{it.label}</td>
                                <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35">
                                  <div className="line-clamp-4 whitespace-pre-wrap">{it.criteria}</div>
                                </td>
                                <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35 text-right">
                                  {(it.realWeight ?? 0).toFixed(2)}
                                </td>
                                <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35">
                                  <div className="flex items-center justify-center gap-1 flex-wrap">
                                    {options.map((opt) => {
                                      const active = current === opt;
                                      return (
                                        <button
                                          key={opt}
                                          type="button"
                                          onClick={() => {
                                            const nextLevels = { ...(sheet.levels ?? {}) } as Record<string, CcfLevel | undefined>;
                                            nextLevels[it.code] = active ? undefined : opt;
                                            setCcfSheet(ccfSelectedStudentName, ccfEpKey, {
                                              ...sheet,
                                              levels: nextLevels,
                                            });
                                          }}
                                          className={ccfLevelButtonClass(opt, active)}
                                          title={opt === "NON" ? "Non observé / déjà évalué" : `Niveau ${opt}/3`}
                                        >
                                          {opt}
                                        </button>
                                      );
                                    })}
                                  </div>
                                </td>
                              </tr>
                            );
                          })}
                        </React.Fragment>
                      );
                    })}
                  </tbody>
                </table>
              </div>
            </>
          );
        })()
      )}
    
        </TabsContent>

<TabsContent value="EP3" className="mt-4">
          <div className="flex items-start justify-between gap-3">
        <div>
        </div>
      </div>

      {ccfEpParamsOpen && (
        <div className="mt-1 rounded-xl border border-neutral-200 dark:border-sky-400/35 bg-white dark:bg-[#182433] keep-light p-4 shadow-sm">
          <div className="flex items-start justify-between gap-3">
            <div>
            </div>
          </div>

          <div className="mt-3 grid grid-cols-1 md:grid-cols-4 gap-3">
            <div className="space-y-1">
              <Label className="text-xs">Date d’évaluation</Label>
<Input
  type="date"
  defaultValue={ccfSettings.date ?? ""}
  onBlur={(e) =>
    setCcfSettings((p) => ({ ...p, date: e.target.value }))
  }
/>
            </div>

            <div className="space-y-1">
              <Label className="text-xs">Évaluateur (défaut)</Label>
              <Input
                value={ccfSettings.evaluator ?? ""}
                placeholder="Nom / Prénom"
                onChange={(e) => setCcfSettings((p) => ({ ...p, evaluator: e.target.value }))}
              />
            </div>

            <div className="space-y-1">
              <Label className="text-xs">Centre / établissement</Label>
              <Input
                value={ccfSettings.center ?? ""}
                placeholder="GRETA / Lycée / CFA..."
                onChange={(e) => setCcfSettings((p) => ({ ...p, center: e.target.value }))}
              />
            </div>
          </div>
        </div>
      )}

      {!ccfSelectedStudentName ? (
        <div className="mt-4 text-sm text-neutral-600 dark:text-neutral-300">Sélectionnez d’abord une classe et un élève.</div>
      ) : (
        (() => {
          const sheet = getCcfSheet(ccfSelectedStudentName, ccfEpKey);
          const computed = computeCcfTotal(ccfSelectedStudentName, ccfEpKey);
          const __epKeyN = String(ccfEpKey || "").replace(/\s+/g, "");
          const template = (ccfTemplates?.[__epKeyN] ?? (CCF_TEMPLATES as any)[__epKeyN] ?? []);

          return (
            <>
              {/* Résumé toujours visible (prend peu de place) */}
                            <div className="mt-4 grid grid-cols-1 md:grid-cols-3 gap-3">

                <div className="space-y-1 md:col-span-2">
                  <Label className="text-xs">Contexte / lieu</Label>
                  <Input
                    value={sheet.meta?.contexte ?? ""}
                    onChange={(e) =>
                      setCcfSheet(ccfSelectedStudentName, ccfEpKey, {
                        ...sheet,
                        meta: { ...(sheet.meta || {}), contexte: e.target.value },
                      })
                    }
                    placeholder="Atelier / entreprise / chantier…"
                  />
                </div>
              </div>

              {/* Résumé toujours visible (prend peu de place) */}
              <div className="mt-3 flex flex-col sm:flex-row sm:items-end sm:justify-between gap-2 rounded-xl border border-neutral-200 dark:border-sky-400/35 bg-neutral-50 dark:bg-[#0f1b2d] px-3 py-2">
                <div className="text-sm">
                  <div className="font-semibold text-neutral-900 dark:text-neutral-100">
                    Note calculée : {computed.total.toFixed(2)} / 20
                  </div>
                  <div className="text-[11px] text-neutral-500 dark:text-neutral-300">
                    Les items “NON” ne sont pas pris en compte.
                  </div>
                </div>

                <div className="w-full sm:w-auto">
                  <div className="text-[11px] text-neutral-500 dark:text-neutral-300 mb-1 sm:text-right">
                    Note proposée au jury
                  </div>
                  <Input
                    className="h-9 sm:h-8 w-full sm:w-[150px]"
                    value={sheet.meta?.noteProposee ?? ""}
                    onChange={(e) =>
                      setCcfSheet(ccfSelectedStudentName, ccfEpKey, {
                        ...sheet,
                        meta: { ...(sheet.meta || {}), noteProposee: e.target.value },
                      })
                    }
                    placeholder="Ex: 14,5"
                  />
                </div>
              </div>


              

              <div className="mt-4 overflow-x-auto">
                <table className="ccf-table min-w-[980px] w-full text-xs border-collapse">
                  <thead>
                    <tr className="bg-neutral-50 dark:bg-[#0f1b2d]">
                      <th className="text-left px-2 py-2 border border-neutral-200 dark:border-sky-400/35 w-[110px]">Code</th>
                      <th className="text-left px-2 py-2 border border-neutral-200 dark:border-sky-400/35">Compétence / item</th>
                      <th className="text-left px-2 py-2 border border-neutral-200 dark:border-sky-400/35">Critères</th>
                      <th className="text-right px-2 py-2 border border-neutral-200 dark:border-sky-400/35 w-[90px]">Poids</th>
                      <th className="text-center px-2 py-2 border border-neutral-200 dark:border-sky-400/35 w-[420px]">Niveau</th>
                    </tr>
                  </thead>
                  <tbody>
                    {template.map((g) => {
                      const gInfo = computed.groupDetails.find((x) => x.code === g.code);
                      return (
                        <React.Fragment key={g.code}>
                          <tr className="bg-white dark:bg-[#182433]" style={(g as any).bgColor || (g as any).fontColor ? { backgroundColor: (g as any).bgColor, color: (g as any).fontColor } : undefined}>
                            <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35 font-semibold">{g.code}</td>
                            <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35 font-semibold" colSpan={2}>
                              {g.title}
                              <span className="ml-2 text-[11px] font-normal text-neutral-500 dark:text-neutral-300">
                                ({(g.groupPoints ?? 0).toFixed(2)} pts) — Score: {(gInfo?.groupScore ?? 0).toFixed(2)} / {(g.groupPoints ?? 0).toFixed(2)}
                              </span>
                            </td>
                            <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35 text-right">
                              {(g.groupPoints ?? 0).toFixed(2)}
                            </td>
                            <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35" />
                          </tr>

                          {g.items.map((it) => {
                            const current = (sheet.levels?.[it.code] as CcfLevel | undefined) ?? undefined;
                            const options: CcfLevel[] = ["NON", "0", "1", "2", "3"];
                            return (
                              <tr key={it.code} className="bg-white dark:bg-[#182433]" style={(it as any).bgColor || (it as any).fontColor ? { backgroundColor: (it as any).bgColor, color: (it as any).fontColor } : undefined}>
                                <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35">{it.code}</td>
                                <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35">{it.label}</td>
                                <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35">
                                  <div className="line-clamp-4 whitespace-pre-wrap">{it.criteria}</div>
                                </td>
                                <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35 text-right">
                                  {(it.realWeight ?? 0).toFixed(2)}
                                </td>
                                <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35">
                                  <div className="flex items-center justify-center gap-1 flex-wrap">
                                    {options.map((opt) => {
                                      const active = current === opt;
                                      return (
                                        <button
                                          key={opt}
                                          type="button"
                                          onClick={() => {
                                            const nextLevels = { ...(sheet.levels ?? {}) } as Record<string, CcfLevel | undefined>;
                                            nextLevels[it.code] = active ? undefined : opt;
                                            setCcfSheet(ccfSelectedStudentName, ccfEpKey, {
                                              ...sheet,
                                              levels: nextLevels,
                                            });
                                          }}
                                          className={ccfLevelButtonClass(opt, active)}
                                          title={opt === "NON" ? "Non observé / déjà évalué" : `Niveau ${opt}/3`}
                                        >
                                          {opt}
                                        </button>
                                      );
                                    })}
                                  </div>
                                </td>
                              </tr>
                            );
                          })}
                        </React.Fragment>
                      );
                    })}
                  </tbody>
                </table>
              </div>
            </>
          );
        })()
      )}
    
        </TabsContent>

      </Tabs>
    </div>
  </section>
) : activeView === "suivi" ? (
  <>
    {/* 🌟 VUE : SUIVI DES COMPÉTENCES */}
    <section className="space-y-4 px-2 sm:px-3 lg:px-4 pt-2 pb-12">
      {(() => {
        const classe = classGroups.find((c) => c.name === selectedClassIdForSuivi);
        const students = classe
          ? (classe.students || "")
              .split("\n")
              .map((s) => s.trim())
              .filter(Boolean)
          : [];

        const evalForClass = classe
          ? evalMetaList.filter((ev) => ev.group === classe.name)
          : [];

        const selectedEvalMeta =
          selectedEvalIdForClasse && evalForClass.length > 0
            ? evalForClass.find((ev) => ev.id === selectedEvalIdForClasse) || null
            : null;

        const compLabelsForClasse: string[] =
          selectedEvalMeta && selectedCompetences.length > 0
            ? selectedCompetences
            : [];

        return (
          <>
{/* 🔝 BANDEAU STICKY : classe + mode + élève + export */}
<div
  className="sticky top-[67px] z-50 backdrop-blur border-b border-black dark:border-sky-400/35 bg-white/70 dark:bg-[#1f2d42]/70 dark:bg-[#1f2d42]/95 dark:border-[#1b467a] dark:text-white night-banner"
>
  <div className="flex flex-col gap-4 sm:flex-row sm:items-end py-2 px-2 sm:px-4 lg:px-6">
    {/* Choix du mode : élève / classe */}
    <div className="flex-1 space-y-1">
      <div className="suivi-tabs inline-flex rounded-full border border-neutral-200 dark:border-sky-400/35 bg-neutral-50 dark:bg-[#182433] p-1">
        <button
          type="button"
          onClick={() => setSuiviMode("eleve")}
          className={classNames(
            "suivi-btn inline-flex items-center rounded-full transition",
            suiviMode === "eleve"
              ? "bg-neutral-900 text-white"
              : "bg-transparent text-neutral-700 dark:text-neutral-300 hover:bg-amber-100/70 dark:bg-[#182433] dark:hover:bg-[#3d2707]"
          )}
        >
          <span className="suivi-icon" aria-hidden="true">🧑‍🎓</span>
          <span className="suivi-label sm:hidden">Synthèse</span>
          <span className="suivi-label hidden sm:inline">Synthèse des compétences élèves</span>
        </button>

        <button
          type="button"
          onClick={() => setSuiviMode("evolutions")}
          className={classNames(
            "suivi-btn inline-flex items-center rounded-full transition",
            suiviMode === "evolutions"
              ? "bg-neutral-900 text-white"
              : "bg-transparent text-neutral-700 dark:text-neutral-300 hover:bg-amber-100/70 dark:bg-[#182433] dark:hover:bg-[#3d2707]"
          )}
        >
          <span className="suivi-icon" aria-hidden="true">📈</span>
          <span className="suivi-label sm:hidden">Évol.</span>
          <span className="suivi-label hidden sm:inline">Évolutions des compétences</span>
        </button>

        <button
          type="button"
          onClick={() => setSuiviMode("bilan")}
          className={classNames(
            "suivi-btn inline-flex items-center rounded-full transition",
            suiviMode === "bilan"
              ? "bg-neutral-900 text-white"
              : "bg-transparent text-neutral-700 dark:text-neutral-300 hover:bg-amber-100/70 dark:bg-[#182433] dark:hover:bg-[#3d2707]"
          )}
        >
          <span className="suivi-icon" aria-hidden="true">🗓️</span>
          <span className="suivi-label sm:hidden">Bilan</span>
          <span className="suivi-label hidden sm:inline">Bilan périodique</span>
        </button>
      </div>
    </div>

    {/* Année / Classe / Élève (au même niveau que les sous-onglets) */}
    <div className="flex flex-wrap items-end gap-2 sm:ml-auto sm:justify-end">
      {/* Année : 1ère / 2ème */}
      <div className="inline-flex rounded-full border border-neutral-200 dark:border-sky-400/35 bg-neutral-50 dark:bg-[#182433] p-1 text-xs">
        <button
          type="button"
          onClick={() => switchTrainingYear("premiere")}
          className={classNames(
            "px-3 py-1 rounded-full transition",
            trainingYear === "premiere"
              ? "bg-neutral-900 text-white"
              : "bg-transparent text-neutral-700 dark:text-neutral-300 hover:bg-amber-100/70 dark:hover:bg-[#3d2707]"
          )}
        >
          1ère
        </button>
        <button
          type="button"
          onClick={() => switchTrainingYear("deuxieme")}
          className={classNames(
            "px-3 py-1 rounded-full transition",
            trainingYear === "deuxieme"
              ? "bg-neutral-900 text-white"
              : "bg-transparent text-neutral-700 dark:text-neutral-300 hover:bg-amber-100/70 dark:hover:bg-[#3d2707]"
          )}
        >
          2ème
        </button>
      </div>

      {/* Classe */}
      <select
        className="h-8 w-[170px] sm:w-[220px] border border-neutral-300 dark:border-sky-400/35 rounded-md bg-white dark:bg-[#182433] px-2 text-xs"
        value={selectedClassIdForSuivi ?? ""}
        onChange={(e) => {
          const next = e.target.value || null;
          setSelectedClassIdForSuivi(next);
          setSelectedStudentForSuivi(null);
          setSelectedEvalIdForClasse(null);
        }}
      >
        <option value="" disabled>
          Classe…
        </option>
        {classGroups.map((c) => (
          <option key={c.id} value={c.name}>
            {c.name}
          </option>
        ))}
      </select>

      {/* Élève */}
      {(() => {
        const classe = classGroups.find((c) => c.name === selectedClassIdForSuivi);
        const students = classe
          ? (classe.students || "")
              .split("\n")
              .map((s) => s.trim())
              .filter(Boolean)
          : [];
        const disabled = !classe || students.length === 0;

        return (
          <select
            className="h-8 w-[130px] sm:w-[160px] border border-neutral-300 dark:border-sky-400/35 rounded-md bg-white dark:bg-[#182433] px-2 text-xs disabled:opacity-60"
            value={selectedStudentForSuivi ?? ""}
            onChange={(e) => setSelectedStudentForSuivi(e.target.value)}
            disabled={disabled}
          >
            <option value="" disabled>
              Élève…
            </option>
            {students.map((st) => (
              <option key={st} value={st}>
                {st}
              </option>
            ))}
          </select>
        );
      })()}
    </div>

  </div>
</div>

            {/* 🔻 CONTENU SOUS LE BANDEAU (scrollable) */}
            <div className="mt-4">
              {/* === VUE ÉLÈVE === */}
              {suiviMode === "eleve" && (
                !classe || !selectedStudentForSuivi ? (
                  <p className="text-sm text-neutral-600 dark:text-neutral-300">
                    Sélectionnez une classe puis un élève pour afficher le suivi des compétences.
                  </p>
                ) : (
                  (() => {
                    const classId = classe.name;
                    const studentName = selectedStudentForSuivi;
                    const schoolYear = getCurrentSchoolYear();

                    const studentRecord = skillsDB[classId]?.[studentName] || {};

                    // Devoirs de la classe utilisables (S1/S2) triés
                    const evalsForClass = evalMetaList
                      .filter(
                        (ev) =>
                          ev.group === classId &&
                          ev.semester !== "Ne pas utiliser de semestre"
                      )
                      .slice()
                      .sort((a, b) => {
                        if (a.semester !== b.semester) {
                          if (a.semester === "S1") return -1;
                          if (b.semester === "S1") return 1;
                        }
                        return (a.createdAt || "").localeCompare(b.createdAt || "");
                      });

                    const evalsS1 = evalsForClass.filter((ev) => ev.semester === "S1");
                    const evalsS2 = evalsForClass.filter((ev) => ev.semester === "S2");

                    const allowedEvalIds = new Set(evalsForClass.map((ev) => ev.id));
                    const allowedEvalNames = new Set(evalsForClass.map((ev) => ev.name));
                    const epByComp = {
                      EP1: new Set(["C1.01", "C2.01", "C2.02"]),
                      EP2: new Set([
                        "C2.03",
                        "C3.01",
                        "C3.02",
                        "C3.04",
                        "C3.06",
                        "C3.09",
                        "C3.10",
                        "C3.11",
                        "C3.12",
                        "C3.15",
                        "C3.16",
                        "C3.17",
                        "C4.01",
                        "C4.02",
                      ]),
                      EP3: new Set(["C1.02", "C3.03", "C3.05", "C3.07", "C3.08", "C3.13", "C3.14"]),
                    } as const;

                    const getEpForComp = (
                      code: string
                    ): "EP1" | "EP2" | "EP3" | null => {
                      if (epByComp.EP1.has(code)) return "EP1";
                      if (epByComp.EP2.has(code)) return "EP2";
                      if (epByComp.EP3.has(code)) return "EP3";
                      return null;
                    };


                    // Toutes les compétences à partir du tcMap
                    const allCompetenceDefs = Array.from(
                      new Set(Object.values(tcMap).flat())
                    )
                      .map((compStr) => {
                        const code = compactCode(compStr);
                        const label = compStr
                          .replace(/^C\s*\d+\.\d+\s*[:.]\s*/, "")
                          .trim();
                        return { code, label };
                      })
                      .sort((a, b) =>
                        a.code.localeCompare(b.code, "fr", {
                          numeric: true,
                          sensitivity: "base",
                        })
                      );

                    // 🔹 Compter le NOMBRE DE CRITÈRES notés par compétence et par semestre
                    const countsByComp: Record<string, { S1: number; S2: number }> = {};

                    try {
                      const yearBucket = (notationDB as any)?.[schoolYear] || {};
                      const classBucket = yearBucket[classId] || {};

                      Object.entries(classBucket).forEach(([bucketKey, evalBucketAny]) => {
                        const evalBucket = evalBucketAny as Record<string, NotationEntry>;
                        const entry = evalBucket[studentName];
                        const entryAny = entry as any;
                        if (!entryAny || !entryAny.scoresByCriteria) return;

                        // Support nouveau format (id) + legacy (nom) + métadonnées stockées dans l'entrée
                        const isActive =
                          allowedEvalIds.has(bucketKey) ||
                          allowedEvalNames.has(bucketKey) ||
                          (entryAny.evalId && allowedEvalIds.has(entryAny.evalId)) ||
                          (entryAny.evalName && allowedEvalNames.has(entryAny.evalName));
                        if (!isActive) return;

                        const sem = entryAny.semester;
                        if (sem !== "S1" && sem !== "S2") return;

                        Object.keys(entryAny.scoresByCriteria).forEach((critKey) => {
                          const score = entryAny.scoresByCriteria?.[critKey];
                          if (typeof score !== "number" || !isFinite(score) || score <= 0) return; // critère non noté / NR

                          // critKey = `${task}||${comp}::${item}::crit#${idx}`
                          const parts = critKey.split("||");
                          if (parts.length < 2) return;
                          const rest = parts[1];
                          const compPart = rest.split("::")[0] || "";

                          const code = compactCode(compPart); // ex : "C2.02"
                          if (!code) return;

                          if (!countsByComp[code]) {
                            countsByComp[code] = { S1: 0, S2: 0 };
                          }
                          if (sem === "S1") countsByComp[code].S1++;
                          else if (sem === "S2") countsByComp[code].S2++;
                        });
                      });
                    } catch (e) {
                      console.warn(
                        "Erreur lors du calcul des compteurs critère/compétence :",
                        e
                      );
                    }

                    
                    // 🔎 Fallback : calcule le niveau à partir des notes enregistrées (notationDB),
                    // utile si le skillsDB n'a pas été rempli / migré.
                    const computeLevelFromNotation = (
                      ev: { id: string; name: string },
                      compCode: string
                    ): Level1to4 | null => {
                      const classBucket =
                        (notationDB as any)?.[schoolYear]?.[classId] || {};
                      const evalBucket = classBucket?.[ev.id] || classBucket?.[ev.name];
                      const entry = evalBucket?.[studentName];

                      const scores: Record<string, any> =
                        (entry as any)?.scoresByCriteria || {};
                      const weights: Record<string, any> =
                        (weightsByEvalId as any)?.[ev.id] || {};

                      let weighted = 0;
                      let totalWeight = 0;

                      Object.entries(scores).forEach(([critKey, score]) => {
                        if (typeof score !== "number" || !isFinite(score) || score <= 0) return;
                        if (!critKey.includes("||")) return;

                        const right = (critKey.split("||")[1] || "").trim();
                        const compLabel = (right.split("::")[0] || "").trim();

                        if (compactCode(compLabel) !== compCode) return;

                        const wRaw = (weights as any)[critKey];
                        const w = typeof wRaw === "number" ? wRaw : 1;
                        if (!isFinite(w) || w <= 0) return;

                        weighted += score * w;
                        totalWeight += w;
                      });

                      if (totalWeight <= 0) return null;

                      const avg = weighted / totalWeight;
                      if (avg < 1.5) return 1;
                      else if (avg < 2.5) return 2;
                      else if (avg < 3.5) return 3;
                      else return 4;
                    };

// 🔹 On stocke toutes les valeurs pour pouvoir faire une moyenne
                    const semesterAgg: Record<
                      string,
                      { label: string; S1Vals: number[]; S2Vals: number[] }
                    > = {};

                    Object.entries(studentRecord).forEach(([rawLabel, semLevels]) => {
                      // On ignore les entrées liées à des devoirs qui ne sont plus dans la classe (évite les "fantômes" en synthèse)
                      let compPart = rawLabel;
                      if (rawLabel.includes("||")) {
                        const [left, compRaw] = rawLabel.split("||");
                        const key = (left || "").trim();
                        const isActive =
                          allowedEvalIds.has(key) || allowedEvalNames.has(key); // support legacy (nom) + nouveau (id)
                        if (!isActive) return;
                        compPart = (compRaw || "").trim();
                      }

                      const code = compactCode(compPart);
                      const text = compPart
                        .replace(/^C\s*\d+\.\d+\s*[:.]\s*/, "")
                        .trim();

                      if (!semesterAgg[code]) {
                        semesterAgg[code] = { label: text, S1Vals: [], S2Vals: [] };
                      }

                      (["S1", "S2"] as SemesterKey[]).forEach((sem) => {
                        const v = (semLevels as any)[sem];
                        if (typeof v === "number") {
                          if (sem === "S1") {
                            semesterAgg[code].S1Vals.push(v);
                          } else if (sem === "S2") {
                            semesterAgg[code].S2Vals.push(v);
                          }
                        }
                      });
                    });

                    
                    // --- Référence 1ère année (S1/S2 + moyenne) pour la vue 2ème année ---
                    const showPremiereSynth = trainingYear === "deuxieme";

                    const evalsForClassPremiere = showPremiereSynth
                      ? evalMetaListPremiere
                          .filter(
                            (ev) =>
                              ev.group === classId &&
                              ev.semester !== "Ne pas utiliser de semestre"
                          )
                          .slice()
                          .sort((a, b) => {
                            if (a.semester !== b.semester) {
                              if (a.semester === "S1") return -1;
                              if (b.semester === "S1") return 1;
                            }
                            return (a.createdAt || "").localeCompare(b.createdAt || "");
                          })
                      : [];

                    const evalsS1Premiere = evalsForClassPremiere.filter(
                      (ev) => ev.semester === "S1"
                    );
                    const evalsS2Premiere = evalsForClassPremiere.filter(
                      (ev) => ev.semester === "S2"
                    );

                    const allowedEvalIdsPremiere = new Set(
                      evalsForClassPremiere.map((ev) => ev.id)
                    );
                    const allowedEvalNamesPremiere = new Set(
                      evalsForClassPremiere.map((ev) => ev.name)
                    );

                    const studentRecordPremiere = showPremiereSynth
                      ? (skillsDBPremiere as any)?.[classId]?.[studentName] || {}
                      : {};

                    // Agrégat niveaux 1ère année, par compétence et par semestre
                    const semesterAggPremiere: Record<
                      string,
                      { label: string; S1Vals: number[]; S2Vals: number[] }
                    > = {};

                    if (showPremiereSynth) {
                      Object.entries(studentRecordPremiere).forEach(
                        ([rawLabel, semLevels]) => {
                          // Filtre "fantômes"
                          let compPart = rawLabel;
                          if (rawLabel.includes("||")) {
                            const [left, compRaw] = rawLabel.split("||");
                            const key = (left || "").trim();
                            const isActive =
                              allowedEvalIdsPremiere.has(key) ||
                              allowedEvalNamesPremiere.has(key);
                            if (!isActive) return;
                            compPart = (compRaw || "").trim();
                          }

                          const code = compactCode(compPart);
                          const text = compPart
                            .replace(/^C\s*\d+\.\d+\s*[:.]\s*/, "")
                            .trim();

                          if (!semesterAggPremiere[code]) {
                            semesterAggPremiere[code] = {
                              label: text,
                              S1Vals: [],
                              S2Vals: [],
                            };
                          }

                          (["S1", "S2"] as SemesterKey[]).forEach((sem) => {
                            const v = (semLevels as any)[sem];
                            if (typeof v === "number") {
                              if (sem === "S1") {
                                semesterAggPremiere[code].S1Vals.push(v);
                              } else if (sem === "S2") {
                                semesterAggPremiere[code].S2Vals.push(v);
                              }
                            }
                          });
                        }
                      );
                    }

                    const resolveSchoolYearFor = (
                      db: any,
                      preferred: string,
                      cls: string
                    ): string | null => {
                      if (db?.[preferred]?.[cls]) return preferred;
                      const keys = Object.keys(db || {});
                      const candidates = keys.filter((k) => db?.[k]?.[cls]);
                      if (candidates.length === 0) return null;

                      const startYear = (k: string) => {
                        const m = String(k).match(/^(\d{4})/);
                        return m ? parseInt(m[1], 10) : 0;
                      };

                      candidates.sort((a, b) => startYear(b) - startYear(a));
                      return candidates[0] || null;
                    };

                    const schoolYearPremiere = resolveSchoolYearFor(
                      notationDBPremiere as any,
                      schoolYear,
                      classId
                    );

                    const countsByCompPremiere: Record<
                      string,
                      { S1: number; S2: number }
                    > = {};

                    try {
                      if (showPremiereSynth && schoolYearPremiere) {
                        const yearBucket =
                          (notationDBPremiere as any)?.[schoolYearPremiere] || {};
                        const classBucket = yearBucket[classId] || {};

                        Object.entries(classBucket).forEach(
                          ([bucketKey, evalBucketAny]) => {
                            const evalBucket = evalBucketAny as Record<
                              string,
                              NotationEntry
                            >;
                            const entry = evalBucket[studentName];
                            const entryAny = entry as any;
                            if (!entryAny || !entryAny.scoresByCriteria) return;

                            const isActive =
                              allowedEvalIdsPremiere.has(bucketKey) ||
                              allowedEvalNamesPremiere.has(bucketKey) ||
                              (entryAny.evalId &&
                                allowedEvalIdsPremiere.has(entryAny.evalId)) ||
                              (entryAny.evalName &&
                                allowedEvalNamesPremiere.has(entryAny.evalName));
                            if (!isActive) return;

                            const sem = entryAny.semester;
                            if (sem !== "S1" && sem !== "S2") return;

                            Object.keys(entryAny.scoresByCriteria).forEach((critKey) => {
                              const score = entryAny.scoresByCriteria?.[critKey];
                              if (typeof score !== "number" || !isFinite(score) || score <= 0) return;

                              const parts = critKey.split("||");
                              if (parts.length < 2) return;
                              const rest = parts[1];
                              const compPart = rest.split("::")[0] || "";
                              const code = compactCode(compPart);
                              if (!code) return;

                              if (!countsByCompPremiere[code]) {
                                countsByCompPremiere[code] = { S1: 0, S2: 0 };
                              }
                              if (sem === "S1") countsByCompPremiere[code].S1++;
                              else if (sem === "S2")
                                countsByCompPremiere[code].S2++;
                            });
                          }
                        );
                      }
                    } catch (e) {
                      console.warn(
                        "Erreur lors du calcul des compteurs 1ère année :",
                        e
                      );
                    }

                    const computeLevelFromNotationPremiere = (
                      ev: { id: string; name: string },
                      compCode: string
                    ): Level1to4 | null => {
                      if (!showPremiereSynth || !schoolYearPremiere) return null;

                      const classBucket =
                        (notationDBPremiere as any)?.[schoolYearPremiere]?.[classId] ||
                        {};
                      const evalBucket = classBucket?.[ev.id] || classBucket?.[ev.name];
                      const entry = evalBucket?.[studentName];

                      const scores: Record<string, any> =
                        (entry as any)?.scoresByCriteria || {};
                      const weights: Record<string, any> =
                        (weightsByEvalId as any)?.[ev.id] || {};

                      let weighted = 0;
                      let totalWeight = 0;

                      Object.entries(scores).forEach(([critKey, score]) => {
                        if (typeof score !== "number" || !isFinite(score) || score <= 0) return;
                        if (!critKey.includes("||")) return;

                        const right = (critKey.split("||")[1] || "").trim();
                        const compLabel = (right.split("::")[0] || "").trim();
                        if (compactCode(compLabel) !== compCode) return;

                        const wRaw = (weights as any)[critKey];
                        const w = typeof wRaw === "number" ? wRaw : 1;
                        if (!isFinite(w) || w <= 0) return;

                        weighted += score * w;
                        totalWeight += w;
                      });

                      if (totalWeight <= 0) return null;

                      const avg = weighted / totalWeight;
                      if (avg < 1.5) return 1;
                      else if (avg < 2.5) return 2;
                      else if (avg < 3.5) return 3;
                      else return 4;
                    };

// 🔹 On convertit en lignes avec une MOYENNE par semestre
                    const rows = allCompetenceDefs.map(({ code, label }) => {
                      const agg = semesterAgg[code];
                      const counts = countsByComp[code] || { S1: 0, S2: 0 };

                      let S1: Level1to4 | undefined;
                      let S2: Level1to4 | undefined;
                      let finalLabel = label;

                      if (agg) {
                        finalLabel = agg.label || label;

                        if (agg.S1Vals.length > 0) {
                          const avg =
                            agg.S1Vals.reduce((sum, v) => sum + v, 0) /
                            agg.S1Vals.length;

                          if (avg < 1.5) S1 = 1;
                          else if (avg < 2.5) S1 = 2;
                          else if (avg < 3.5) S1 = 3;
                          else S1 = 4;
                        }

                        if (agg.S2Vals.length > 0) {
                          const avg =
                            agg.S2Vals.reduce((sum, v) => sum + v, 0) /
                            agg.S2Vals.length;

                          if (avg < 1.5) S2 = 1;
                          else if (avg < 2.5) S2 = 2;
                          else if (avg < 3.5) S2 = 3;
                          else S2 = 4;
                        }
                      }

                      // Fallback : si skillsDB ne fournit pas de synthèse, on calcule à partir de notationDB
                      if (S1 == null) {
                        const vals = evalsS1
                          .map((ev) => computeLevelFromNotation(ev, code))
                          .filter((v): v is Level1to4 => typeof v === "number");

                        if (vals.length > 0) {
                          const avg =
                            vals.reduce((sum, v) => sum + v, 0) / vals.length;

                          if (avg < 1.5) S1 = 1;
                          else if (avg < 2.5) S1 = 2;
                          else if (avg < 3.5) S1 = 3;
                          else S1 = 4;
                        }
                      }

                      if (S2 == null) {
                        const vals = evalsS2
                          .map((ev) => computeLevelFromNotation(ev, code))
                          .filter((v): v is Level1to4 => typeof v === "number");

                        if (vals.length > 0) {
                          const avg =
                            vals.reduce((sum, v) => sum + v, 0) / vals.length;

                          if (avg < 1.5) S2 = 1;
                          else if (avg < 2.5) S2 = 2;
                          else if (avg < 3.5) S2 = 3;
                          else S2 = 4;
                        }
                      }

                      const countAll = counts.S1 + counts.S2;

                      const toLevel = (avg: number): Level1to4 => {
                        if (avg < 1.5) return 1;
                        if (avg < 2.5) return 2;
                        if (avg < 3.5) return 3;
                        return 4;
                      };

                      let ALL: Level1to4 | undefined;

                      const allValsFromSkills: number[] = [];
                      if (agg) {
                        allValsFromSkills.push(...agg.S1Vals, ...agg.S2Vals);
                      }
                      if (allValsFromSkills.length > 0) {
                        const avg =
                          allValsFromSkills.reduce((sum, v) => sum + v, 0) /
                          allValsFromSkills.length;
                        ALL = toLevel(avg);
                      }

                      // Fallback global (tous les devoirs) : utile si skillsDB est incomplet
                      if (ALL == null) {
                        const vals = evalsForClass
                          .map((ev) => computeLevelFromNotation(ev, code))
                          .filter((v): v is Level1to4 => typeof v === "number");

                        if (vals.length > 0) {
                          const avg = vals.reduce((sum, v) => sum + v, 0) / vals.length;
                          ALL = toLevel(avg);
                        }
                      }

                      // --- Synthèses 1ère année (référence) ---
                      let prevS1: Level1to4 | undefined;
                      let prevS2: Level1to4 | undefined;
                      let prevMean: Level1to4 | undefined;

                      const prevCounts = (countsByCompPremiere as any)?.[code] || {
                        S1: 0,
                        S2: 0,
                      };
                      const prevCountS1 = prevCounts.S1 || 0;
                      const prevCountS2 = prevCounts.S2 || 0;
                      const prevCountAll = prevCountS1 + prevCountS2;

                      if (showPremiereSynth) {
                        const aggP = (semesterAggPremiere as any)?.[code];

                        if (aggP) {
                          if (Array.isArray(aggP.S1Vals) && aggP.S1Vals.length > 0) {
                            const avg =
                              aggP.S1Vals.reduce((sum: number, v: number) => sum + v, 0) /
                              aggP.S1Vals.length;

                            if (avg < 1.5) prevS1 = 1;
                            else if (avg < 2.5) prevS1 = 2;
                            else if (avg < 3.5) prevS1 = 3;
                            else prevS1 = 4;
                          }

                          if (Array.isArray(aggP.S2Vals) && aggP.S2Vals.length > 0) {
                            const avg =
                              aggP.S2Vals.reduce((sum: number, v: number) => sum + v, 0) /
                              aggP.S2Vals.length;

                            if (avg < 1.5) prevS2 = 1;
                            else if (avg < 2.5) prevS2 = 2;
                            else if (avg < 3.5) prevS2 = 3;
                            else prevS2 = 4;
                          }
                        }

                        if (prevS1 == null) {
                          const vals = evalsS1Premiere
                            .map((ev) => computeLevelFromNotationPremiere(ev, code))
                            .filter((v): v is Level1to4 => typeof v === "number");

                          if (vals.length > 0) {
                            const avg =
                              vals.reduce((sum, v) => sum + v, 0) / vals.length;
                            prevS1 = toLevel(avg);
                          }
                        }

                        if (prevS2 == null) {
                          const vals = evalsS2Premiere
                            .map((ev) => computeLevelFromNotationPremiere(ev, code))
                            .filter((v): v is Level1to4 => typeof v === "number");

                          if (vals.length > 0) {
                            const avg =
                              vals.reduce((sum, v) => sum + v, 0) / vals.length;
                            prevS2 = toLevel(avg);
                          }
                        }

                        const meanVals: number[] = [];
                        if (typeof prevS1 === "number") meanVals.push(prevS1);
                        if (typeof prevS2 === "number") meanVals.push(prevS2);

                        if (meanVals.length > 0) {
                          const avg =
                            meanVals.reduce((sum, v) => sum + v, 0) / meanVals.length;
                          prevMean = toLevel(avg);
                        }
                      }

                      return {
                        code,
                        label: finalLabel,
                        S1,
                        S2,
                        ALL,
                        countS1: counts.S1,
                        countS2: counts.S2,
                        countAll,
                        prevS1,
                        prevS2,
                        prevMean,
                        prevCountS1,
                        prevCountS2,
                        prevCountAll,
                      };
                    });

                    const renderStaticLevelDot = (level?: number | null) => {
                      if (!level) return null;

                      let cls = "";
                      if (level === 1) cls = "bg-red-500 border-red-500";
                      else if (level === 2)
                        cls = "bg-orange-400 border-orange-400";
                      else if (level === 3)
                        cls = "bg-emerald-300 border-emerald-300";
                      else cls = "bg-emerald-600 border-emerald-600";

                      return (
                        <div
                          className={
                            "inline-block w-3 h-3 shrink-0 rounded-full border " + cls
                          }
                        />
                      );
                    };

                    const renderMiniLegend = (variant: "numeric" | "ep" = "numeric") => {
                      const levels: (1 | 2 | 3 | 4)[] = [1, 2, 3, 4];

                      const labelFor = (val: 1 | 2 | 3 | 4) => {
                        if (variant === "ep") {
                          if (val === 1) return "NE";
                          if (val === 2) return "NA";
                          if (val === 3) return "EA";
                          return "A";
                        }
                        return String(val);
                      };

                      const getColorFor = (val: 1 | 2 | 3 | 4) => {
                        if (val === 1) return "bg-red-500";
                        if (val === 2) return "bg-orange-400";
                        if (val === 3) return "bg-emerald-400";
                        return "bg-emerald-600";
                      };

                      return (
                        <div className="flex w-full overflow-hidden rounded-[2px] mt-1">
                          {levels.map((val) => (
                            <div
                              key={val}
                              className={
                                "flex-1 flex items-center justify-center h-[12px] " +
                                "text-[10px] font-semibold text-white " +
                                getColorFor(val)
                              }
                            >
                              {labelFor(val)}
                            </div>
                          ))}
                        </div>
                      );
                    };

                    const renderHistogramCell = (level?: number, count?: number) => {
                      if (level == null || isNaN(level)) {
                        return (
                          <span className="text-[10px] text-neutral-400">
                            -
                          </span>
                        );
                      }

                      const pct = Math.max(
                        0,
                        Math.min(100, (level / 4) * 100)
                      );

                      const rounded = Math.min(
                        4,
                        Math.max(1, Math.round(level))
                      ) as 1 | 2 | 3 | 4;
                      const getColorFor = (val: 1 | 2 | 3 | 4) => {
                        if (val === 1) return "bg-red-500";
                        if (val === 2) return "bg-orange-400";
                        if (val === 3) return "bg-emerald-400";
                        return "bg-emerald-600";
                      };

                      const barColor = getColorFor(rounded);

                      return (
                        <div className="flex items-center gap-[4px]">
                          <div className="flex-1">
                            <div className="w-full h-[10px] bg-neutral-200 dark:bg-[#1f2d42] rounded">
                              <div
                                className={`h-[10px] rounded ${barColor}`}
                                style={{ width: `${pct}%` }}
                              />
                            </div>
                          </div>

                          {typeof count === "number" && count > 0 && (
                            <span className="text-[10px] text-neutral-600 dark:text-neutral-300 font-semibold">
                              {count}
                            </span>
                          )}
                        </div>
                      );
                    };

return (
  <div className="mt-4">
<div
  ref={suiviElevePdfRef}
  className=""
>
      <div className="no-print px-3 py-2  border-neutral  text-[12px] font-semibold flex items-center justify-between gap-2">
  <span>
    Suivi de {studentName}
  </span>
</div>

{evalsForClass.length === 0 ? (
  <div className="p-3 text-[12px] text-neutral-500">
    Aucun devoir enregistré pour cette classe.
  </div>
) : (
  <table className="min-w-full border-collapse text-[11px] leading-tight text-neutral-900 dark:text-neutral-300">
    <thead>

        {/* Colonne Famille */}
        <th
          rowSpan={2}
          className="border border-neutral-300 dark:border-sky-400/35 bg-white dark:bg-[#1f2d42] sticky left-0 z-30 w-10 px-1 py-2 text-[11px] font-semibold text-neutral-700 dark:text-neutral-300 text-center align-middle"
        >
          <span
            style={{
              writingMode: "vertical-rl",
              transform: "rotate(180deg)",
              whiteSpace: "normal",      // ✅ autorise le retour à la ligne
              wordBreak: "break-word",   // ✅ casse les mots longs si besoin
              maxHeight: 96,             // optionnel : limite la hauteur du texte dans le header
              overflow: "hidden",
            }}
          >
          </span>
        </th>

        {/* Colonne Compétences */}
        <th
          rowSpan={2}
          className="border border-neutral-300 dark:border-sky-400/35 bg-white dark:bg-[#1f2d42] sticky left-0 z-20 w-80 px-3 py-2 align-middle text-[14px] font-semibold text-neutral-700 dark:text-neutral-300"
        >
          COMPÉTENCES
        </th>

        {/* Synthèses 1ère année (référence) – affichées en 2ème année */}
        {trainingYear === "deuxieme" && (
          <>
            
            
            <th
              rowSpan={2}
              className="border border-neutral-300 dark:border-sky-400/35 bg-sky-50 dark:bg-sky-950/35 px-1 py-1 text-center align-top w-[80px] min-w-[80px] max-w-[80px]"
            >
              <div className="flex flex-col h-full">
                <span className="mb-0 leading-tight">Synthèse 1A</span>
                <span className="mb-1 text-[9px] text-neutral-600 dark:text-neutral-300 leading-tight">(moy S1+S2)</span>
                <div className="mt-auto w-full flex justify-center">
                  {renderMiniLegend()}
                </div>
              </div>
            </th>
          </>
        )}

        {/* Bandeau S1 */}
        {evalsS1.length > 0 && (
          <th
            colSpan={evalsS1.length}
            className="border border-neutral-300 dark:border-sky-400/35 bg-amber-100 dark:bg-amber-950/45 px-2 py-1 text-center text-[11px] font-semibold"
          >
            SEMESTRE 1
          </th>
        )}

        {/* Séparation */}
        <th rowSpan={2} className="w-4 bg-white dark:bg-[#1f2d42]" aria-hidden="true" />

        {/* Bandeau S2 */}
        {evalsS2.length > 0 && (
          <th
            colSpan={evalsS2.length}
            className="border border-neutral-300 dark:border-sky-400/35 bg-lime-100 dark:bg-lime-950/45 px-2 py-1 text-center text-[11px] font-semibold"
          >
            SEMESTRE 2
          </th>
        )}

        {/* Séparation */}
        <th rowSpan={2} className="w-4 bg-white dark:bg-[#1f2d42]" aria-hidden="true" />

                {/* Synthèses / Épreuves (2e année) */}
        {trainingYear === "deuxieme" ? (
          <>
            <th
              rowSpan={2}
              className="border border-neutral-300 dark:border-sky-400/35 bg-sky-50 dark:bg-sky-950/35 px-1 py-1 text-center align-top w-[40px] max-w-[40px]"
            >
              <div className="flex flex-col h-full">
                <span className="mb-1">EP1</span>
                <div className="text-[9px] text-neutral-600 dark:text-neutral-300 leading-tight">
                  Étude et préparation d&apos;une intervention
                </div>
                <div className="mt-auto w-full flex justify-center">
                  {renderMiniLegend("ep")}
                </div>
              </div>
            </th>

            <th
              rowSpan={2}
              className="border border-neutral-300 dark:border-sky-400/35 bg-sky-50 dark:bg-sky-950/35 px-1 py-1 text-center align-top w-[40px] max-w-[40px]"
            >
              <div className="flex flex-col h-full">
                <span className="mb-1">EP2</span>
                <div className="text-[9px] text-neutral-600 dark:text-neutral-300 leading-tight">
                  Réalisation et contrôle d&apos;un ouvrage
                </div>
                <div className="mt-auto w-full flex justify-center">
                  {renderMiniLegend("ep")}
                </div>
              </div>
            </th>

            <th
              rowSpan={2}
              className="border border-neutral-300 dark:border-sky-400/35 bg-sky-50 dark:bg-sky-950/35 px-1 py-1 text-center align-top w-[40px] max-w-[40px]"
            >
              <div className="flex flex-col h-full">
                <span className="mb-1">EP3</span>
                <div className="text-[9px] text-neutral-600 dark:text-neutral-300 leading-tight">
                  Réalisation de travaux spécifiques
                </div>
                <div className="mt-auto w-full flex justify-center">
                  {renderMiniLegend("ep")}
                </div>
              </div>
            </th>
          </>
        ) : (
          <>
            <th
              rowSpan={2}
              className="border border-neutral-300 dark:border-sky-400/35 bg-sky-50 dark:bg-sky-950/35 px-1 py-1 text-center align-top w-[80px] max-w-[80px]"
            >
              <div className="flex flex-col h-full">
                <span className="mb-1">Synthèse S1</span>
                <div className="mt-auto w-full flex justify-center">
                  {renderMiniLegend()}
                </div>
              </div>
            </th>

            <th
              rowSpan={2}
              className="border border-neutral-300 dark:border-sky-400/35 bg-sky-50 dark:bg-sky-950/35 px-1 py-1 text-center align-top w-[80px] max-w-[80px]"
            >
              <div className="flex flex-col h-full">
                <span className="mb-1">Synthèse S2</span>
                <div className="mt-auto w-full flex justify-center">
                  {renderMiniLegend()}
                </div>
              </div>
            </th>
          </>
        )}

<tr>
        {/* En-têtes devoirs S1 */}
        {evalsS1.map((ev) => (
          <th
            key={ev.id}
            className="border border-neutral-300 dark:border-sky-400/35 text-center px-0 py-0 align-bottom bg-white dark:bg-[#182433] w-[22px]"
            style={{ width: 22 }}
          >
            <div className="h-[90px] flex flex-col items-center justify-end gap-1 py-1">
             
              <span
                className="text-[10px] font-medium leading-tight text-neutral-700 dark:text-neutral-300"
                style={{
                  writingMode: "vertical-rl",
                  transform: "rotate(180deg)",
                  whiteSpace: "normal",      // ✅ autorise le retour à la ligne
                  wordBreak: "break-word",   // ✅ casse les mots longs si besoin
                  maxHeight: 96,             // optionnel : limite la hauteur du texte dans le header
                  overflow: "hidden",
                }}
                title={ev.name}
              >
                {ev.name}
              </span>
            </div>
          </th>
        ))}

        {/* En-têtes devoirs S2 */}
        {evalsS2.map((ev) => (
          <th
            key={ev.id}
            className="border border-neutral-300 dark:border-sky-400/35 text-center px-0 py-0 align-bottom bg-white dark:bg-[#182433] w-[22px]"
            style={{ width: 22 }}
          >
            <div className="h-[110px] flex flex-col items-center justify-end gap-1 py-1">

              <span
                className="text-[10px] font-medium leading-tight text-neutral-700 dark:text-neutral-300"
                style={{
                  writingMode: "vertical-rl",
                  transform: "rotate(180deg)",
                  whiteSpace: "normal",      // ✅ autorise le retour à la ligne
                  wordBreak: "break-word",   // ✅ casse les mots longs si besoin
                  maxHeight: 96,             // optionnel : limite la hauteur du texte dans le header
                  overflow: "hidden",
                }}
                title={ev.name}
              >
                {ev.name}
              </span>
            </div>
          </th>
        ))}
      </tr>
    </thead>

    <tbody>
      {rows.map((row, rowIndex) => {
        const fam = parseCompetencyFamily(row.code);
        const prevFam =
          rowIndex > 0 ? parseCompetencyFamily(rows[rowIndex - 1].code) : undefined;
        const nextFam =
          rowIndex < rows.length - 1 ? parseCompetencyFamily(rows[rowIndex + 1].code) : undefined;

        const hasFam = fam === "C1" || fam === "C2" || fam === "C3" || fam === "C4";
        const isFamFirst = hasFam && fam !== prevFam;
        const isFamLast = hasFam && fam !== nextFam;

        const famTopColor =
          fam === "C1" ? "border-t-sky-400" :
          fam === "C2" ? "border-t-amber-400" :
          fam === "C3" ? "border-t-lime-400" :
          fam === "C4" ? "border-t-fuchsia-400" : "";

        const famBottomColor =
          fam === "C1" ? "border-b-sky-400" :
          fam === "C2" ? "border-b-amber-400" :
          fam === "C3" ? "border-b-lime-400" :
          fam === "C4" ? "border-b-fuchsia-400" : "";

        const famLeftColor =
          fam === "C1" ? "border-l-sky-400" :
          fam === "C2" ? "border-l-amber-400" :
          fam === "C3" ? "border-l-lime-400" :
          fam === "C4" ? "border-l-fuchsia-400" : "";

        const famRightColor =
          fam === "C1" ? "border-r-sky-400" :
          fam === "C2" ? "border-r-amber-400" :
          fam === "C3" ? "border-r-lime-400" :
          fam === "C4" ? "border-r-fuchsia-400" : "";

        const famBg =
          fam === "C1" ? "bg-sky-50 dark:bg-sky-950/35" :
          fam === "C2" ? "bg-amber-50 dark:bg-amber-950/35" :
          fam === "C3" ? "bg-lime-50 dark:bg-lime-950/35" :
          fam === "C4" ? "bg-fuchsia-50 dark:bg-fuchsia-950/35" : "bg-white dark:bg-[#1f2d42]";

        const topThicknessClass = hasFam && isFamFirst ? "border-t-2" : hasFam ? "border-t" : "";
        const bottomThicknessClass = hasFam && isFamLast ? "border-b-2" : hasFam ? "border-b" : "";
        const topColorClass = hasFam && isFamFirst ? famTopColor : "";
        const bottomColorClass = hasFam && isFamLast ? famBottomColor : "";

        // RowSpan Famille
        let famRowSpan = 0;
        if (hasFam && isFamFirst) {
          let span = 1;
          for (let i = rowIndex + 1; i < rows.length; i++) {
            if (parseCompetencyFamily(rows[i].code) !== fam) break;
            span++;
          }
          famRowSpan = span;
        }

        const famLabel =
          fam === "C1" ? "COM." :
          fam === "C2" ? "PRÉP." :
          fam === "C3" ? "RÉAL." :
          fam === "C4" ? "CONT." : "";

        const CELL_W = 20;
        const CELL_H = 12;

        return (
          <tr
            key={row.code}
            className="odd:bg-white even:bg-neutral-50 hover:bg-amber-100/70/80 dark:odd:bg-[#1f2d42] dark:even:bg-[#1f2d42] dark:hover:bg-[#3d2707] transition-colors"
          >
            {/* Famille */}
            {hasFam ? (
              isFamFirst && famRowSpan > 0 ? (
                <td
                  rowSpan={famRowSpan}
                  className={classNames(
                    "border border-neutral-300 dark:border-sky-400/35 sticky left-0 z-20 w-10 px-1 py-1 text-[11px] text-neutral-900 dark:text-neutral-300 text-center align-middle",
                    famBg,
                    "border-l-2",
                    famLeftColor,
                    topThicknessClass,
                    topColorClass,
                    bottomThicknessClass,
                    bottomColorClass
                  )}
                >
                  <div className="flex items-center justify-center h-full">
                    <span
                      className="font-semibold"
                      style={{
                        writingMode: "vertical-rl",
                        transform: "rotate(180deg)",
                        whiteSpace: "normal",      // ✅ autorise le retour à la ligne
                        wordBreak: "break-word",   // ✅ casse les mots longs si besoin
                        maxHeight: 96,             // optionnel : limite la hauteur du texte dans le header
                        overflow: "hidden",
                      }}
                    >
                      {famLabel}
                    </span>
                  </div>
                </td>
              ) : null
            ) : (
              <td className="border border-neutral-300 dark:border-sky-400/35 bg-white dark:bg-[#1f2d42] sticky left-0 z-20 w-10 px-1 py-1" />
            )}

            {/* Compétence (code + libellé sur la même ligne, max 2 lignes) */}
            <td
              className={classNames(
                "sticky left-0 z-10 px-2 py-[2px] text-[11px] leading-tight align-middle border border-neutral-300 dark:border-sky-400/35",
                hasFam ? famBg : "bg-white dark:bg-[#182433]",
                topThicknessClass,
                topColorClass,
                bottomThicknessClass,
                bottomColorClass
              )}
            >
              <div className="grid grid-cols-[auto,1fr] gap-x-2 items-start">
                <span className="font-semibold text-neutral-900 dark:text-neutral-300 whitespace-nowrap">
                  {row.code}
                </span>
                <span
                  className="text-neutral-800 dark:text-neutral-300 break-words"
                  style={{
                    display: "-webkit-box",
                    WebkitBoxOrient: "vertical",
                    WebkitLineClamp: 2,
                    overflow: "hidden",
                  }}
                  title={row.label}
                >
                  {row.label}
                </span>
              </div>
            </td>

            {/* Synthèses 1ère année (référence) – affichées en 2ème année */}
            {trainingYear === "deuxieme" && (
              <>
                
                
                <td
                  className={classNames(
                    "border border-neutral-300 dark:border-sky-400/35 px-1 py-[1px] w-[80px] min-w-[80px] max-w-[80px] leading-none",
                    hasFam ? famBg : "bg-white dark:bg-[#182433]",
                    topThicknessClass,
                    topColorClass,
                    bottomThicknessClass,
                    bottomColorClass
                  )}
                >
                  {renderHistogramCell((row as any).prevMean, (row as any).prevCountAll)}
                </td>
              </>
            )}

            {/* Devoirs S1 */}
            {evalsS1.map((ev) => {
              const usedInDevoir = (compsByEvalId[ev.id] || []).some((raw) => {
                let compPart = raw;
                if (raw.includes("||")) compPart = raw.split("||")[1].trim();
                return compactCode(compPart) === row.code;
              });

              let levelForEval: number | null = null;
              for (const [rawLabel, semLevels] of Object.entries(studentRecord)) {
                let evalIdPart: string | null = null;
                let evalNamePart: string | null = null;
                let compPart = rawLabel;
                if (rawLabel.includes("||")) {
                  const [evalRaw, compRaw] = rawLabel.split("||");
                  const key = (evalRaw || "").trim();
                  if (key === ev.id) evalIdPart = key;
                  else evalNamePart = key; // legacy (ancien format : nom du devoir)
                  compPart = (compRaw || "").trim();
                }
                if (compactCode(compPart) !== row.code) continue;
                if (evalIdPart && evalIdPart !== ev.id) continue;
                if (!evalIdPart && evalNamePart && evalNamePart !== ev.name) continue;

                const v = (semLevels as any)[ev.semester];
                if (typeof v === "number") {
                  levelForEval = v;
                  break;
                }
              }

              const level =
                levelForEval != null
                  ? levelForEval
                  : computeLevelFromNotation(ev, row.code);

              return (
                <td
                  key={`${ev.id}-${row.code}-S1`}
                  className={classNames(
                    "border border-neutral-300 dark:border-sky-400/35 w-[22px] px-0 py-0 align-middle",
                    hasFam ? famBg : "bg-white dark:bg-[#182433]",
                    topThicknessClass,
                    topColorClass,
                    bottomThicknessClass,
                    bottomColorClass
                  )}
                  style={{ width: CELL_W }}
                >
                  <div
                    className="flex items-center justify-center leading-none"
                    style={{ height: CELL_H }}
                  >
                    {(usedInDevoir || level != null) ? renderStaticLevelDot(level) : null}
                  </div>
                </td>
              );
            })}

            <td className="w-4 bg-white dark:bg-[#1f2d42]" />

            {/* Devoirs S2 */}
            {evalsS2.map((ev) => {
              const usedInDevoir = (compsByEvalId[ev.id] || []).some((raw) => {
                let compPart = raw;
                if (raw.includes("||")) compPart = raw.split("||")[1].trim();
                return compactCode(compPart) === row.code;
              });

              let levelForEval: number | null = null;
              for (const [rawLabel, semLevels] of Object.entries(studentRecord)) {
                let evalIdPart: string | null = null;
                let evalNamePart: string | null = null;
                let compPart = rawLabel;
                if (rawLabel.includes("||")) {
                  const [evalRaw, compRaw] = rawLabel.split("||");
                  const key = (evalRaw || "").trim();
                  if (key === ev.id) evalIdPart = key;
                  else evalNamePart = key; // legacy (ancien format : nom du devoir)
                  compPart = (compRaw || "").trim();
                }
                if (compactCode(compPart) !== row.code) continue;
                if (evalIdPart && evalIdPart !== ev.id) continue;
                if (!evalIdPart && evalNamePart && evalNamePart !== ev.name) continue;

                const v = (semLevels as any)[ev.semester];
                if (typeof v === "number") {
                  levelForEval = v;
                  break;
                }
              }

              const level =
                levelForEval != null
                  ? levelForEval
                  : computeLevelFromNotation(ev, row.code);

              return (
                <td
                  key={`${ev.id}-${row.code}-S2`}
                  className={classNames(
                    "border border-neutral-300 dark:border-sky-400/35 w-[22px] px-0 py-0 align-middle",
                    hasFam ? famBg : "bg-white dark:bg-[#182433]",
                    topThicknessClass,
                    topColorClass,
                    bottomThicknessClass,
                    bottomColorClass
                  )}
                  style={{ width: CELL_W }}
                >
                  <div
                    className="flex items-center justify-center leading-none"
                    style={{ height: CELL_H }}
                  >
                    {(usedInDevoir || level != null) ? renderStaticLevelDot(level) : null}
                  </div>
                </td>
              );
            })}

            <td className="w-4 bg-white dark:bg-[#1f2d42]" />

                        {/* Synthèses / EP */}
            {trainingYear === "deuxieme" ? (
              (() => {
                const ep = getEpForComp(row.code);
                const levelAll = row.ALL ?? row.S2 ?? row.S1;

                const epLabelFor = (val: 1 | 2 | 3 | 4) => {
                  if (val === 1) return "NE";
                  if (val === 2) return "NA";
                  if (val === 3) return "EA";
                  return "A";
                };

                const epColorFor = (val: 1 | 2 | 3 | 4) => {
                  if (val === 1) return "bg-red-500";
                  if (val === 2) return "bg-orange-400";
                  if (val === 3) return "bg-emerald-400";
                  return "bg-emerald-600";
                };

                const renderEpBadge = (lvl?: number | null) => {
                  // Par défaut (non évalué) : NE
                  const v =
                    typeof lvl === "number" && !Number.isNaN(lvl)
                      ? (Math.min(4, Math.max(1, Math.round(lvl))) as 1 | 2 | 3 | 4)
                      : (1 as 1 | 2 | 3 | 4);

                  return (
                    <span
                      className={
                        "inline-flex items-center justify-center rounded-[4px] px-2 py-[2px] text-[10px] font-semibold text-white " +
                        epColorFor(v)
                      }
                    >
                      {epLabelFor(v)}
                    </span>
                  );
                };

                const renderEp = (target: "EP1" | "EP2" | "EP3") => {
                  if (ep !== target) return null;
                  return renderEpBadge(levelAll);
                };

                return (
                  <>
                    <td
                      className={classNames(
                        "border border-neutral-300 dark:border-sky-400/35 px-1 py-[1px] min-w-[30px] max-w-[30px] leading-none",
                        hasFam ? famBg : "bg-white dark:bg-[#182433]",
                        topThicknessClass,
                        topColorClass,
                        bottomThicknessClass,
                        bottomColorClass
                      )}
                    >
                      <div className="flex items-center justify-center leading-none">
                        {renderEp("EP1")}
                      </div>
                    </td>

                    <td
                      className={classNames(
                        "border border-neutral-300 dark:border-sky-400/35 px-1 py-[1px] min-w-[30px] max-w-[30px] leading-none",
                        hasFam ? famBg : "bg-white dark:bg-[#182433]",
                        topThicknessClass,
                        topColorClass,
                        bottomThicknessClass,
                        bottomColorClass
                      )}
                    >
                      <div className="flex items-center justify-center leading-none">
                        {renderEp("EP2")}
                      </div>
                    </td>

                    <td
                      className={classNames(
                        "border border-neutral-300 dark:border-sky-400/35 px-1 py-[1px] min-w-[30px] max-w-[30px] leading-none",
                        hasFam ? famBg : "bg-white dark:bg-[#182433]",
                        hasFam && "border-r-2",
                        hasFam && famRightColor,
                        topThicknessClass,
                        topColorClass,
                        bottomThicknessClass,
                        bottomColorClass
                      )}
                    >
                      <div className="flex items-center justify-center leading-none">
                        {renderEp("EP3")}
                      </div>
                    </td>
                  </>
                );
              })()
            ) : (
              <>
                <td
                  className={classNames(
                    "border border-neutral-300 dark:border-sky-400/35 px-1 py-[1px] min-w-[30px] max-w-[30px] leading-none",
                    hasFam ? famBg : "bg-white dark:bg-[#182433]",
                    topThicknessClass,
                    topColorClass,
                    bottomThicknessClass,
                    bottomColorClass
                  )}
                >
                  {renderHistogramCell(row.S1, row.countS1)}
                </td>

                <td
                  className={classNames(
                    "border border-neutral-300 dark:border-sky-400/35 px-1 py-[1px] min-w-[30px] max-w-[30px] leading-none",
                    hasFam ? famBg : "bg-white dark:bg-[#182433]",
                    hasFam && "border-r-2",
                    hasFam && famRightColor,
                    topThicknessClass,
                    topColorClass,
                    bottomThicknessClass,
                    bottomColorClass
                  )}
                >
                  {renderHistogramCell(row.S2, row.countS2)}
                </td>
              </>
            )}
</tr>
        );
      })}
    </tbody>
  </table>
)}

    </div>
  </div>
);

                  })()
                )
              )}

              {/* === VUE ÉVOLUTIONS (2 ans) === */}
              {suiviMode === "evolutions" && (
                !classe || !selectedStudentForSuivi ? (
                  <p className="text-sm text-neutral-600 dark:text-neutral-300">
                    Sélectionnez une classe puis un élève pour afficher l'évolution des compétences.
                  </p>
                ) : (
                  <div ref={suiviEvolutionsPdfRef} className="mt-3 print:mt-0">
                    {(() => {
                    const classId = classe.name;
                    const studentName = selectedStudentForSuivi;

                    const waitingOtherYear =
                      trainingYear === "premiere"
                        ? !deuxiemeBootstrapped
                        : !premiereBootstrapped;

                    if (waitingOtherYear) {
                      return (
                        <p className="text-sm text-neutral-600 dark:text-neutral-300">
                          Chargement des données de l'autre année…
                        </p>
                      );
                    }

                    // Données année 1 (première) + année 2 (deuxième)
                    const y1Skills = trainingYear === "premiere" ? skillsDB : skillsDBPremiere;
                    const y1EvalsBase = trainingYear === "premiere" ? evalMetaList : evalMetaListPremiere;
                    const y1Notation = trainingYear === "premiere" ? notationDB : notationDBPremiere;

                    const y2Skills = trainingYear === "deuxieme" ? skillsDB : skillsDBDeuxieme;
                    const y2EvalsBase = trainingYear === "deuxieme" ? evalMetaList : evalMetaListDeuxieme;
                    const y2Notation = trainingYear === "deuxieme" ? notationDB : notationDBDeuxieme;

                    const normalizeEvals = (list: EvalMeta[]) =>
                      list
                        .filter(
                          (ev) =>
                            ev.group === classId &&
                            ev.semester !== "Ne pas utiliser de semestre"
                        )
                        .slice()
                        .sort((a, b) => {
                          if (a.semester !== b.semester) {
                            if (a.semester === "S1") return -1;
                            if (b.semester === "S1") return 1;
                          }
                          return (a.createdAt || "").localeCompare(b.createdAt || "");
                        });

                    const evalsY1 = normalizeEvals(y1EvalsBase);
                    const evalsY2 = normalizeEvals(y2EvalsBase);

                    const pickLatestSchoolYear = (ndb: NotationDB) => {
                      const keys = Object.keys(ndb || {});
                      if (!keys.length) return getCurrentSchoolYear();
                      const scoreKey = (k: string) => {
                        const m = k.match(/^(\d{4})/);
                        return m ? parseInt(m[1], 10) : 0;
                      };
                      return keys.slice().sort((a, b) => scoreKey(b) - scoreKey(a))[0];
                    };

                    const schoolYearY1 = pickLatestSchoolYear(y1Notation);
                    const schoolYearY2 = pickLatestSchoolYear(y2Notation);

                    const studentRecordY1: any = (y1Skills as any)?.[classId]?.[studentName] || {};
                    const studentRecordY2: any = (y2Skills as any)?.[classId]?.[studentName] || {};

                    const getLevelFromSkillsRecord = (
                      record: any,
                      ev: EvalMeta,
                      compCode: string
                    ): number | null => {
                      if (!record) return null;
                      for (const [rawLabel, semLevelsAny] of Object.entries(record)) {
                        if (typeof rawLabel !== "string" || !rawLabel.includes("||")) continue;
                        const [idOrName, compPart] = rawLabel.split("||");
                        if (!idOrName || !compPart) continue;
                        if (idOrName !== ev.id && idOrName !== ev.name) continue;
                        if (compactCode(compPart) !== compCode) continue;

                        // Valeur directe
                        if (typeof (semLevelsAny as any) === "number") return semLevelsAny as any;

                        const v = (semLevelsAny as any)?.[ev.semester as any];
                        if (typeof v === "number") return v;
                      }

                      // Fallback : niveau de synthèse (clé sans "||")
                      for (const [rawLabel, semLevelsAny] of Object.entries(record)) {
                        if (typeof rawLabel !== "string" || rawLabel.includes("||")) continue;
                        if (compactCode(rawLabel) !== compCode) continue;

                        if (typeof (semLevelsAny as any) === "number") return semLevelsAny as any;
                        const v = (semLevelsAny as any)?.[ev.semester as any];
                        if (typeof v === "number") return v;
                      }

                      return null;
                    };

                    const getScore20FromNotation = (
                      ndb: NotationDB,
                      schoolYear: string,
                      ev: EvalMeta,
                      compCode: string
                    ): number | null => {
                      const bucket: any =
                        (ndb as any)?.[schoolYear]?.[classId]?.[ev.id]?.[studentName];
                      const legacyBucket: any =
                        (ndb as any)?.[schoolYear]?.[classId]?.[ev.name]?.[studentName];
                      const rec: any = bucket || legacyBucket;

                      const status = rec?.status;
                      if (status === "AB" || status === "N.NOT") return null;

                      const scores: any = rec?.scoresByCriteria;
                      if (!scores || typeof scores !== "object") return null;

                      let sum = 0;
                      let count = 0;

                      for (const [k, v] of Object.entries(scores)) {
                        if (typeof v !== "number") continue;
                        const right = String(k).split("||")[1] || "";
                        const compPart = right.split("::")[0] || "";
                        if (compactCode(compPart) !== compCode) continue;
                        sum += v;
                        count += 1;
                      }

                      if (!count) return null;

                      // scoresByCriteria est sur 4 → conversion /20
                      const avgOn4 = sum / count;
                      return Math.max(0, Math.min(20, avgOn4 * 5));
                    };

                    const getScore20FromSkillsRecord = (
                      record: any,
                      ev: EvalMeta,
                      compCode: string
                    ): number | null => {
                      const lvl = getLevelFromSkillsRecord(record, ev, compCode);
                      if (lvl == null) return null;

                      // skillsDB stocke généralement un niveau 1..4. Si > 4.5, on considère que c'est déjà une note /20.
                      const score20 = lvl > 4.5 ? lvl : (lvl / 4) * 20;
                      return Math.max(0, Math.min(20, score20));
                    };


                    // Mapping compétence -> groupe (COMMUNIQUER / RÉALISER / SPÉCIFIQUES) via les tâches
                    const compFirstTaskNum: Record<string, number> = {};
                    for (const [taskLabel, comps] of Object.entries(tcMap)) {
                      const n = taskNumber(taskLabel);
                      if (!n) continue;
                      (comps || []).forEach((c) => {
                        const code = compactCode(String(c));
                        if (!code) return;
                        const prev = compFirstTaskNum[code];
                        if (prev == null || n < prev) compFirstTaskNum[code] = n;
                      });
                    }

                    const groupForCode = (code: string): GroupKey | "OTHER" => {
                      const n = compFirstTaskNum[code];
                      if (!n) return "OTHER";
                      const g = GROUPS.find((x) => n >= x.range[0] && n <= x.range[1]);
                      return (g?.key as any) || "OTHER";
                    };

                    // Regroupement alternatif par épreuves (EP1/EP2/EP3)
                    const epByComp = {
                      EP1: new Set(["C1.01", "C2.01", "C2.02"]),
                      EP2: new Set([
                        "C2.03",
                        "C3.01",
                        "C3.02",
                        "C3.04",
                        "C3.06",
                        "C3.09",
                        "C3.10",
                        "C3.11",
                        "C3.12",
                        "C3.15",
                        "C3.16",
                        "C3.17",
                        "C4.01",
                        "C4.02",
                      ]),
                      EP3: new Set(["C1.02", "C3.03", "C3.05", "C3.07", "C3.08", "C3.13", "C3.14"]),
                    } as const;

                    const getEpForComp = (code: string): "EP1" | "EP2" | "EP3" | null => {
                      if (epByComp.EP1.has(code)) return "EP1";
                      if (epByComp.EP2.has(code)) return "EP2";
                      if (epByComp.EP3.has(code)) return "EP3";
                      return null;
                    };

                    const groupKeyForCode = (code: string): string => {
                      if (evolutionGroupMode === "ep") return getEpForComp(code) ?? "OTHER";
                      return String(groupForCode(code));
                    };

                    const allCompLabels = Array.from(
                      new Set([
                        ...Object.values(tcMap).flat().map(String),
                        ...(critResDB ? Object.keys(critResDB) : []),
                      ])
                    );

                    const stripLabel = (label: string) =>
                      label
                        .replace(/^C\s*\d\.?\d{2}\s*:\s*/i, "")
                        .replace(/^C\s*\d\s*\.\s*\d{2}\s*:\s*/i, "")
                        .trim();

                    type Card = {
                      code: string;
                      label: string;
                      group: string;
                      bars: EvolutionBar[];
                      hasData: boolean;
                    };

                    const cards: Card[] = allCompLabels
                      .map((label) => {
                        const code = compactCode(label);
                        return { code, label };
                      })
                      .filter((x) => !!x.code)
                      .map(({ code, label }) => {
                        const bars: EvolutionBar[] = [];

                        evalsY1.forEach((ev, i) => {
                          const score =
                            getScore20FromNotation(y1Notation, schoolYearY1, ev, code) ??
                            getScore20FromSkillsRecord(studentRecordY1, ev, code);

                          const label = String((ev as any)?.name || `Devoir ${i + 1}`);
                          bars.push({
                            label,
                            fullLabel: label,
                            value: score,
                          });
                        });

                        evalsY2.forEach((ev, i) => {
                          const score =
                            getScore20FromNotation(y2Notation, schoolYearY2, ev, code) ??
                            getScore20FromSkillsRecord(studentRecordY2, ev, code);

                          const label = String(
                            (ev as any)?.name || `Devoir ${evalsY1.length + i + 1}`
                          );
                          bars.push({
                            label,
                            fullLabel: label,
                            value: score,
                          });
                        });

                        const hasData = bars.some((b) => b.value != null);
                        return {
                          code,
                          label,
                          group: groupKeyForCode(code),
                          bars,
                          hasData,
                        };
                      });

                    const totalEvals = evalsY1.length + evalsY2.length;

                    if (!totalEvals) {
                      return (
                        <p className="text-sm text-neutral-600 dark:text-neutral-300">
                          Aucun devoir (S1/S2) n'est disponible pour cette classe sur la 1ère ou la 2ème année.
                        </p>
                      );
                    }

                    if (!cards.length) {
                      return (
                        <p className="text-sm text-neutral-600 dark:text-neutral-300">
                          Aucune compétence n'est disponible (référentiel) pour afficher l'évolution.
                        </p>
                      );
                    }

                    const hasAnyData = cards.some((c) => c.hasData);

                    const grouped: Record<string, Card[]> = {};
                    cards.forEach((c) => {
                      const k = c.group;
                      if (!grouped[k]) grouped[k] = [];
                      grouped[k].push(c);
                    });

                    const activityOrder: Array<{ key: string; title: string }> = [
                      { key: "G1", title: GROUPS.find((g) => g.key === "G1")?.title || "G1" },
                      { key: "G2", title: GROUPS.find((g) => g.key === "G2")?.title || "G2" },
                      { key: "G3", title: GROUPS.find((g) => g.key === "G3")?.title || "G3" },
                      { key: "OTHER", title: "AUTRES" },
                    ];

                    const order: Array<{ key: string; title: string }> =
                      evolutionGroupMode === "ep"
                        ? (EP_GROUP_ORDER as any)
                        : activityOrder;

                    const getHeaderStyle = (key: string) => {
                      if (evolutionGroupMode === "ep") {
                        return (EP_GROUP_STYLES as any)[key] || EP_GROUP_STYLES.OTHER;
                      }
                      if (key !== "OTHER") {
                        return (GROUP_STYLES as any)[key] as any;
                      }
                      return EP_GROUP_STYLES.OTHER;
                    };

                    const EP_BADGE_STYLES: Record<string, string> = {
                      EP1: "border-sky-200 bg-sky-50 dark:bg-sky-950/35 text-sky-800 dark:text-sky-500 dark:border-sky-400/40",
                      EP2: "border-emerald-200 bg-emerald-50 dark:bg-emerald-950/35 text-emerald-800 dark:text-emerald-100 dark:border-emerald-400/40",
                      EP3: "border-amber-200 bg-amber-50 dark:bg-amber-950/35 text-amber-900 dark:text-amber-100 dark:border-amber-400/40",
                      OTHER: "border-neutral-200 dark:border-sky-400/35 bg-neutral-50 dark:bg-[#1f2d42] text-neutral-700 dark:text-neutral-300",
                    };

                    const ACT_BADGE_STYLES: Record<string, string> = {
                      G1: "border-indigo-200 bg-indigo-50 dark:bg-indigo-950/35 text-indigo-800 dark:text-indigo-100 dark:border-indigo-400/40",
                      G2: "border-fuchsia-200 bg-fuchsia-50 dark:bg-fuchsia-950/35 text-fuchsia-800 dark:text-fuchsia-100 dark:border-fuchsia-400/40",
                      G3: "border-rose-200 bg-rose-50 dark:bg-rose-950/35 text-rose-800 dark:text-rose-100 dark:border-rose-400/40",
                      OTHER: "border-neutral-200 dark:border-sky-400/35 bg-neutral-50 dark:bg-[#1f2d42] text-neutral-700 dark:text-neutral-300",
                    };

                    const ACT_BADGE_LABELS: Record<string, string> = {
                      G1: "COMMUNIQUER / PRÉPARER",
                      G2: "RÉALISER / CONTRÔLER",
                      G3: "RÉALISER SPÉC.",
                      OTHER: "AUTRES",
                    };


                    const getOppositeBadge = (code: string) => {
                      if (evolutionGroupMode === "activite") {
                        const ep = getEpForComp(code) ?? "OTHER";
                        const cls = EP_BADGE_STYLES[ep] || EP_BADGE_STYLES.OTHER;
                        return {
                          text: ep === "OTHER" ? "AUTRE" : ep,
                          className: cls,
                          title: ep === "OTHER" ? "Épreuve non définie" : `Épreuve ${ep}`,
                        };
                      }
                      const k = String(groupForCode(code));
                      const cls = ACT_BADGE_STYLES[k] || ACT_BADGE_STYLES.OTHER;
                      const title =
                        k !== "OTHER" ? GROUPS.find((g) => g.key === k)?.title || k : "AUTRES";
                      return {
                        text: ACT_BADGE_LABELS[k] || (k === "OTHER" ? "AUTRES" : k),
                        className: cls,
                        title,
                      };
                    };

                    return (
                      <div className="space-y-6">
                        <div className="flex items-start justify-between gap-3">
                          <div className="no-print min-w-0">
                            <div className="mt-1 text-xs text-neutral-500 dark:text-neutral-300 font-semibold">
                              {evolutionGroupMode === "ep" ? "Épreuves (EP1/EP2/EP3)" : "Activités"} · Moyenne positionnée d'acquisition du niveau 3 : {Math.round(evolutionCapLine * 10) / 10}/20
                            </div>
                          </div>

                          <button
                            type="button"
                            onClick={() => setEvolutionSettingsOpen(true)}
                            className="h-8 shrink-0 inline-flex items-center gap-2 rounded-md border border-neutral-300 dark:border-sky-400/35 bg-white hover:bg-amber-100/70 dark:bg-[#182433] px-3 text-xs font-semibold text-neutral-800 dark:text-neutral-300 hover:bg-amber-100/70 dark:bg-[#182433]"
                          >
                            <Settings2 className="h-4 w-4" />
                            Paramètres
                          </button>
                        </div>

                        <Drawer
                          open={evolutionSettingsOpen}
                          onClose={() => setEvolutionSettingsOpen(false)}
                          side="right"
                          className="w-[360px]"
                        >
                          <div className="p-4 space-y-4 text-neutral-900 dark:text-neutral-300">
                            <div className="flex items-center justify-between">
                              <div className="text-sm font-semibold">Paramètres — Évolutions</div>
                              <button
                                type="button"
                                onClick={() => setEvolutionSettingsOpen(false)}
                                className="h-8 w-8 inline-flex items-center justify-center rounded-md border border-neutral-200 dark:border-sky-400/35 bg-white hover:bg-amber-100/70 dark:bg-[#182433] hover:bg-amber-100/70 dark:bg-[#182433] text-neutral-300 dark:text-white"
                                aria-label="Fermer"
                              >
                                <X className="h-4 w-4" />
                              </button>
                            </div>

                            <div className="space-y-2">
                              <Label className="text-xs">Afficher les devoirs dans les graphiques</Label>
                              <label className="flex items-center gap-2 text-xs text-neutral-800 dark:text-neutral-300">
                                <input
                                  type="checkbox"
                                  className="h-4 w-4 rounded border border-neutral-300 dark:border-sky-400/35"
                                  checked={evolutionShowDevoirs}
                                  onChange={(e) => setEvolutionShowDevoirs(e.target.checked)}
                                />
                                <span>Afficher les devoirs dans les graphiques</span>
                              </label>                             <div className="text-[11px] text-neutral-500 dark:text-neutral-300">
                                Désactive le nom des devoirs.
                              </div>
                            </div>

                            <div className="space-y-2">
                              <Label className="text-xs">Position de la ligne CAP (niveau 3) — note /20</Label>
                              <div className="flex items-center gap-2">
                                <Input
                                  type="number"
                                  min={0}
                                  max={20}
                                  step={0.5}
                                  value={String(evolutionCapLine)}
                                  onChange={(e) => {
                                    const raw = (e.target.value || "").replace(",", ".");
                                    const n = raw === "" ? 0 : parseFloat(raw);
                                    if (!isFinite(n)) return;
                                    setEvolutionCapLine(Math.max(0, Math.min(20, n)));
                                  }}
                                  className="h-8"
                                />
                                <div className="text-xs text-neutral-500 dark:text-white whitespace-nowrap">/ 20</div>
                              </div>
                              <div className="flex flex-wrap gap-2">
                             {[].map((v) => (
                                  <button
                                    key={v}
                                    type="button"
                                    onClick={() => setEvolutionCapLine(v)}
                                    className={classNames(
                                      "h-7 px-2 rounded-md border text-xs",
                                      Math.round(evolutionCapLine) === v
                                        ? "border-neutral-900 bg-neutral-900 text-white"
                                        : "border-neutral-300 dark:border-sky-400/35 bg-white hover:bg-amber-100/70 dark:bg-[#182433] text-neutral-800 dark:text-neutral-300 hover:bg-amber-100/70 dark:bg-[#182433]"
                                    )}
                                  >
                                    {v}
                                  </button>
                                ))}
                              </div>
                            </div>

                            <div className="space-y-2">
                              <Label className="text-xs">Affichage des fenêtres (regroupement)</Label>
                              <select
                                className="block w-full border border-neutral-300 dark:border-sky-400/35 rounded-md bg-white dark:bg-[#182433] px-2 py-1 text-xs"
                                value={evolutionGroupMode}
                                onChange={(e) => setEvolutionGroupMode(e.target.value as any)}
                              >
                                <option value="activite">Par activités (Communiquer / Préparer / Réaliser…)</option>
                                <option value="ep">Par épreuves (EP1 / EP2 / EP3)</option>
                              </select>
                              <div className="text-[11px] text-neutral-500 dark:text-neutral-300">
                                Ces paramètres sont enregistrés sur cet appareil.
                              </div>
                            </div>

                            <div className="space-y-2">
                              <Label className="text-xs">Affichage des tableaux — nombre par ligne</Label>
                              <select
                                className="block w-full border border-neutral-300 dark:border-sky-400/35 rounded-md bg-white dark:bg-[#182433] px-2 py-1 text-xs"
                                value={String(evolutionCardsPerRow)}
                                onChange={(e) => {
                                  const n = parseInt(e.target.value, 10);
                                  if (!isFinite(n)) return;
                                  setEvolutionCardsPerRow(Math.max(1, Math.min(10, n)));
                                }}
                              >
                                {[1, 2, 3, 4, 5, 6, 8, 10].map((n) => (
                                  <option key={n} value={n}>
                                    {n} par ligne
                                  </option>
                                ))}
                              </select>
                              <div className="text-[11px] text-neutral-500 dark:text-neutral-300">
                                Ajuste la taille des cartes sur l’écran.
                              </div>
                            </div>
</div>
                        </Drawer>

                        {!hasAnyData && (
                          <div className="rounded-lg border border-amber-200 bg-amber-50 dark:bg-amber-950/35 px-3 py-2 text-xs text-amber-800">
                            Aucun niveau n'a été trouvé pour cet élève sur ces devoirs (barres vides). Vérifiez que les devoirs ont des notes enregistrées ou que le suivi a été alimenté.
                          </div>
                        )}

                        {order.map(({ key, title }) => {
                          const list = (grouped as any)[key] as Card[] | undefined;
                          if (!list || !list.length) return null;
                          const gStyle = getHeaderStyle(String(key));
                          return (
                            <section key={String(key)} className="space-y-3">
                              <div
                                className={classNames(
                                  "flex items-center justify-between rounded-lg border px-3 py-2",
                                  gStyle ? gStyle.headerBg : "bg-neutral-50 dark:bg-[#1f2d42]",
                                  gStyle ? gStyle.accentBorder : ""
                                )}
                              >
                                <h3
                                  className={classNames(
                                    "text-xs font-semibold tracking-wide",
                                    gStyle ? gStyle.headerText : "text-neutral-700 dark:text-neutral-300"
                                  )}
                                >
                                  {title}
                                </h3>
                                <div className="text-[11px] text-neutral-600 dark:text-neutral-300">
                                  {list.length} compétence(s)
                                </div>
                              </div>

                              <div className="grid gap-4" style={{ gridTemplateColumns: `repeat(${evolutionCardsPerRow}, minmax(0, 1fr))` }}>
                                {list
                                  .slice()
                                  .sort((a, b) => a.code.localeCompare(b.code))
                                  .map((card) => {
                                    const badge = getOppositeBadge(card.code);
                                    return (
                                    <div
                                      key={card.code}
                                      className="rounded-lg border border-neutral-200 dark:border-sky-400/35 bg-white dark:bg-[#182433] keep-light pt-3 px-3 pb-2 shadow-sm min-w-0 overflow-hidden"
                                      title={card.label}
                                    >
                                      <div className="flex items-start justify-between gap-2">
                                        <div className="min-w-0">
                                          <div className="flex items-center gap-2 min-w-0">
                                            <div className="text-[11px] font-semibold text-neutral-900 dark:text-neutral-300 shrink-0">
                                              {card.code}
                                            </div>
                                            <div className="text-[10px] text-neutral-700 dark:text-neutral-300 truncate">
                                              {stripLabel(card.label)}
                                            </div>
                                          </div>
                                        </div>
                                        <div className="flex flex-col items-end gap-1 shrink-0">
                                          <div
                                            className={classNames(
                                              "no-print h-3 px-1 rounded-full border text-[10px] font-semibold leading-3",
                                              badge.className
                                            )}
                                            title={badge.title}
                                          >
                                            {badge.text}
                                          </div>
                                        </div>
                                      </div>

                                      <div className="mt-2">
                                        <MiniEvolutionChart
                                          bars={card.bars}
                                          splitIndex={evalsY1.length}
                                          capLine={evolutionCapLine}
                                          showDevoirs={evolutionShowDevoirs}
                                        />
                                      </div>
                                    </div>
                                  );
                                  })}
                              </div>
                            </section>
                          );
                        })}
                      </div>
                    );
                  })()}
                  </div>
                )
              )}

              {/* === BILAN PÉRIODIQUE === */}
              {suiviMode === "bilan" && (
                !classe || !selectedStudentForSuivi ? (
                  <p className="text-sm text-neutral-600 dark:text-neutral-300">
                    Sélectionnez une classe puis un élève pour afficher le bilan périodique.
                  </p>
                ) : (
                  <div className="mt-4 space-y-4">
                    {(() => {
                      const classId = classe.name;
                      const studentName = selectedStudentForSuivi;
                      const schoolYear = bilanSchoolYear;

                      const evalsForClass = evalMetaList
                        .filter(
                          (ev) =>
                            ev.group === classId &&
                            ev.semester !== "Ne pas utiliser de semestre"
                        )
                        .slice()
                        .sort((a, b) => {
                          if (a.semester !== b.semester) {
                            if (a.semester === "S1") return -1;
                            if (b.semester === "S1") return 1;
                          }
                          return (a.createdAt || "").localeCompare(b.createdAt || "");
                        });

                      const sem = bilanSemester === "S2" ? "S2" : "S1";
                      const evalsForSem = evalsForClass.filter((ev: EvalMeta) => ev.semester === sem);
                      const allowedEvalIds = new Set<string>(evalsForSem.map((ev: EvalMeta) => ev.id));
                      const allowedEvalNames = new Set<string>(evalsForSem.map((ev: EvalMeta) => ev.name));

                      // Compétences de référence (issues du mapping des tâches)
                      const allCompetenceDefs = Array.from(
                        new Set(Object.values(tcMap).flat())
                      )
                        .map((compStr) => {
                          const code = compactCode(String(compStr));
                          const label = String(compStr)
                            .replace(/^C\s*\d+\.\d+\s*[:.]\s*/i, "")
                            .trim();
                          return { code, label };
                        })
                        .filter((d) => !!d.code)
                        .sort((a, b) =>
                          a.code.localeCompare(b.code, "fr", {
                            numeric: true,
                            sensitivity: "base",
                          })
                        );

                      const defByCode: Record<string, { label: string }> = {};
                      allCompetenceDefs.forEach((d) => {
                        defByCode[d.code] = { label: d.label };
                      });

                      // Fallback : construit un agrégat depuis les notes (notationDB) si le suivi manuel (skillsDB) n'est pas renseigné
                      const buildAggFromNotationForStudent = (stName: string): SemesterAgg => {
                        const agg: SemesterAgg = {};
                        const classBucketAny: any = (notationDB as any)?.[schoolYear]?.[classId] || {};

                        for (const [evalKey, evalBucketAny] of Object.entries(classBucketAny || {})) {
                          const evalBucket: any = evalBucketAny as any;

                          // Tolérant aux différences mineures d’écriture du nom (espaces, casse)
                          const normName = (x: any) =>
                            String(x ?? "")
                              .normalize("NFKC")
                              .replace(/\u00A0/g, " ")
                              .replace(/\s+/g, " ")
                              .trim()
                              .toLowerCase();

                          let entry: any = evalBucket?.[stName];
                          if (!entry) {
                            const target = normName(stName);
                            const matchKey = Object.keys(evalBucket || {}).find(
                              (k) => normName(k) === target
                            );
                            if (matchKey) entry = (evalBucket as any)?.[matchKey];
                          }
                          if (!entry) continue;
                          if (entry?.status && entry.status !== "OK") continue;

                          const entrySem: any = entry?.semester;
                          if (entrySem && String(entrySem) !== String(sem)) continue;

                          const scores: Record<string, any> = entry?.scoresByCriteria || {};
                          const weightKey = String(entry?.evalId || evalKey);
                          const weights: Record<string, any> =
                            (weightsByEvalId as any)?.[weightKey] || {};

                          const perComp: Record<string, { w: number; tw: number }> = {};

                          Object.entries(scores).forEach(([critKey, score]) => {
                            if (typeof score !== "number") return;
                            if (!isFinite(score) || score <= 0) return;

                            const right = String(critKey).includes("||")
                              ? (String(critKey).split("||")[1] || "")
                              : String(critKey);
                            const compLabel = (right.split("::")[0] || "").trim();
                            const code = compactCode(compLabel);
                            if (!code) return;

                            const wRaw = (weights as any)[critKey];
                            const w =
                              typeof wRaw === "number" && isFinite(wRaw) && wRaw > 0
                                ? wRaw
                                : 1;

                            if (!perComp[code]) perComp[code] = { w: 0, tw: 0 };
                            perComp[code].w += score * w;
                            perComp[code].tw += w;
                          });

                          Object.entries(perComp).forEach(([code, a]) => {
                            if (!a || a.tw <= 0) return;
                            const avg = a.w / a.tw;
                            if (!agg[code]) {
                              agg[code] = {
                                label: defByCode[code]?.label || "",
                                S1Vals: [],
                                S2Vals: [],
                              };
                            }
                            if (sem === "S1") agg[code].S1Vals.push(avg);
                            else agg[code].S2Vals.push(avg);
                          });
                        }

                        return agg;
                      };

                      const normalizeItemLabel = (v: any): string =>
                        String(v ?? "")
                          .normalize("NFKC")
                          .replace(/\u00A0/g, " ")
                          .replace(/[’‘]/g, "'")
                          .replace(/[“”«»]/g, '"')
                          .replace(/[‐‑‒–—−]/g, "-")
                          .replace(/\s+/g, " ")
                          .trim()
                          .replace(/^((élève|eleve)\s+est\s+capable\s+de\s*:?\s*)/i, "")
                          .replace(/^(?:ê|e)tre\s+capable\s+de\s*:?\s*/i, "")
                          .replace(/^\-\s*/, "")
                          // Normalisation “robuste” pour matcher les libellés
                          // (référentiel vs clés de notation : parenthèses, ":" final, etc.)
                          .replace(/\([^)]*\)/g, " ")
                          .replace(/\s+/g, " ")
                          .trim()
                          .replace(/\s*[:：;,.]+\s*$/g, "")
                          .trim()
                          .toLowerCase();

                      // ✅ Source principale : skillsDB (validations)
                      // On agrège les niveaux par compétence sur le semestre sélectionné.
                      const buildAggFromSkillsForStudent = (stName: string): SemesterAgg => {
                        const agg: SemesterAgg = {};
                        const studentRec: any = (skillsDB as any)?.[classId]?.[stName] || {};

                        Object.entries(studentRec).forEach(([rawKey, semRecAny]) => {
                          const semRec: any = semRecAny || {};
                          const lvl = semRec?.[sem];
                          if (typeof lvl !== "number" || !isFinite(lvl) || lvl <= 0) return;

                          // Clé typique : evalId||C 1.01 : ...
                          let compLabelPart = String(rawKey);
                          if (compLabelPart.includes("||")) {
                            const parts = compLabelPart.split("||");
                            const left = parts[0] || "";
                            const right = parts.slice(1).join("||");
                            const looksLikeEvalId =
                              left.length >= 6 && !compactCode(left) && !!compactCode(right);
                            if (looksLikeEvalId) compLabelPart = right;
                          }

                          const code = compactCode(compLabelPart);
                          if (!code) return;

                          if (!agg[code]) {
                            const fallbackLabel = String(compLabelPart)
                              .replace(/^C\s*\d+\.\d+\s*[:.]\s*/i, "")
                              .trim();
                            agg[code] = {
                              label: defByCode[code]?.label || fallbackLabel || "",
                              S1Vals: [],
                              S2Vals: [],
                            };
                          }

                          if (sem === "S1") agg[code].S1Vals.push(lvl);
                          else agg[code].S2Vals.push(lvl);
                        });

                        return agg;
                      };


                      const buildAggForStudent = (stName: string): SemesterAgg => {
                        const fromNotation = buildAggFromNotationForStudent(stName);
                        const fromSkills = buildAggFromSkillsForStudent(stName);

                        // ✅ Mix : on conserve les niveaux manuels (skillsDB) pour les compétences
                        // qui n'ont pas (encore) de notes critériées, et on laisse la notation
                        // prioritaire quand elle existe.
                        return { ...fromSkills, ...fromNotation };
                      };

                      const studentAgg = buildAggForStudent(studentName);

                      // --- Critères (items) par compétence, comme dans le PDF ---
                      // On récupère la liste des items depuis critResDB (référentiel),
                      // puis on calcule les niveaux via la notation (scoresByCriteria).
                      const critResKeyByCode: Record<string, string> = {};
                      if (critResDB) {
                        Object.keys(critResDB).forEach((k) => {
                          const code = compactCode(String(k));
                          if (!code) return;
                          if (!critResKeyByCode[code]) critResKeyByCode[code] = String(k);
                        });
                      }

                      type ItemAgg = { weighted: number; totalW: number; count: number };
                      const buildItemAggFromNotationForStudent = (stName: string) => {
                        const map: Record<string, ItemAgg> = {};
                        const classBucketAny: any = (notationDB as any)?.[schoolYear]?.[classId] || {};

                        for (const [evalKey, evalBucketAny] of Object.entries(classBucketAny || {})) {
                          const evalBucket: any = evalBucketAny as any;

                          // Tolérant aux différences mineures d’écriture du nom (espaces, casse)
                          const normName = (x: any) =>
                            String(x ?? "")
                              .normalize("NFKC")
                              .replace(/\u00A0/g, " ")
                              .replace(/\s+/g, " ")
                              .trim()
                              .toLowerCase();

                          let entry: any = evalBucket?.[stName];
                          if (!entry) {
                            const target = normName(stName);
                            const matchKey = Object.keys(evalBucket || {}).find(
                              (k) => normName(k) === target
                            );
                            if (matchKey) entry = (evalBucket as any)?.[matchKey];
                          }
                          if (!entry) continue;
                          if (entry?.status && entry.status !== "OK") continue;

                          const entrySem: any = entry?.semester;
                          if (entrySem && String(entrySem) !== String(sem)) continue;

                          const scores: Record<string, any> = entry?.scoresByCriteria || {};
                          const weightKey = String(entry?.evalId || evalKey);
                          const weights: Record<string, any> =
                            (weightsByEvalId as any)?.[weightKey] || {};

                          Object.entries(scores).forEach(([critKey, score]) => {
                            if (typeof score !== "number") return;
                            if (!isFinite(score) || score <= 0) return;

                            const right = String(critKey).includes("||")
                              ? (String(critKey).split("||")[1] || "")
                              : String(critKey);

                            const parts = right.split("::");
                            const compLabel = (parts[0] || "").trim();
                            const itemLabel = normalizeItemLabel(parts[1] || "");
                            if (!compLabel || !itemLabel) return;

                            const code = compactCode(compLabel);
                            if (!code) return;

                            const k = `${code}||${itemLabel}`;
                            const wRaw = (weights as any)[critKey];
                            const w =
                              typeof wRaw === "number" && isFinite(wRaw) && wRaw > 0 ? wRaw : 1;

                            if (!map[k]) map[k] = { weighted: 0, totalW: 0, count: 0 };
                            map[k].weighted += score * w;
                            map[k].totalW += w;
                            map[k].count += 1;
                          });
                        }

                        return map;
                      };

                      const studentItemAgg = buildItemAggFromNotationForStudent(studentName);

                      // 🔹 Sert à détecter si une compétence a déjà au moins un critère noté
                      // (pour éviter de "cocher" tous les critères restants par héritage).
                      const codesWithAnyItemData = new Set<string>();
                      Object.keys(studentItemAgg || {}).forEach((k) => {
                        const code = String(k).split("||")[0];
                        if (code) codesWithAnyItemData.add(code);
                      });

                      // Regroupement par pôle (basé sur la famille C1/C2/C3/C4)
type PoleKey = "COMMUNIQUER" | "PRÉPARER" | "RÉALISER" | "CONTRÔLER" | "OTHER";

const poleForCode = (code: string): PoleKey => {
  const m = String(code || "").match(/^C\s*([1-4])\./i);
  if (!m) return "OTHER";
  const n = Number(m[1]);
  if (n === 1) return "COMMUNIQUER";
  if (n === 2) return "PRÉPARER";
  if (n === 3) return "RÉALISER";
  if (n === 4) return "CONTRÔLER";
  return "OTHER";
};

const groupOrder: Record<PoleKey, number> = { "COMMUNIQUER": 1, "PRÉPARER": 2, "RÉALISER": 3, "CONTRÔLER": 4, "OTHER": 9 };
const groupTitle = (g: PoleKey) => (g === "OTHER" ? "AUTRES" : g);

const rows = allCompetenceDefs
                        .map((def) => {
                          const d: any = (studentAgg as any)?.[def.code];
                          const vals: number[] = d
                            ? (sem === "S1" ? (d.S1Vals || []) : (d.S2Vals || []))
                            : [];
                          const avg = vals.length ? mean(vals) : 0;
                          const lvl: Level1to4 = vals.length ? (avg <= 0 ? 1 : levelFromAvg(avg)) : 0;
                          const group = poleForCode(def.code);

                          const hasAnyCritDataForComp = codesWithAnyItemData.has(def.code);

                          const compKey = critResKeyByCode[def.code];
                          const itemsDef: string[] = compKey && critResDB ? Object.keys(critResDB[compKey] || {}) : [];
                          const items = itemsDef.map((it) => {
                            const normIt = normalizeItemLabel(it);
                            const a = studentItemAgg[`${def.code}||${normIt}`];
                            const hasData = !!(a && a.totalW > 0 && (a.count || 0) > 0);
                            const aAvg = hasData ? a.weighted / a.totalW : 0;
                            // Niveau de l'item ("Être capable de…") :
                            // - uniquement à partir des notes critériées (scoresByCriteria)
                            // - si aucun critère n'a été noté pour cet item : non évalué (niveau 0)
                            const inherit = false;
                            const itemLvl: Level1to4 = hasData
                              ? (aAvg <= 0 ? 1 : levelFromAvg(aAvg))
                              : 0;

                            return {
                              item: it,
                              avg: aAvg,
                              lvl: itemLvl,
                              count: a?.count || 0,
                              inherited: inherit,
                            };
                          });
                          return {
                            code: def.code,
                            label: def.label || d?.label || "",
                            avg,
                            lvl,
                            group,
                            groupTitle: groupTitle(group as any),
                            count: vals.length,
                            items,
                          };
                        })
                        .sort((a, b) => {
                          const ga = (groupOrder as any)[String(a.group)] ?? 9;
                          const gb = (groupOrder as any)[String(b.group)] ?? 9;
                          if (ga !== gb) return ga - gb;
                          return a.code.localeCompare(b.code, "fr", {
                            numeric: true,
                            sensitivity: "base",
                          });
                        });

                                            // === Graphique : toutes les compétences (/20) + comparaison période précédente ===
                                            const toScore20 = (avgOn4: number) =>
                                              Math.max(0, Math.min(20, (avgOn4 || 0) * 5));

                                            type SumCount = { sum: number; count: number };
                                            const initSumCountMap = (): Record<string, SumCount> => {
                                              const m: Record<string, SumCount> = {};
                                              (allCompetenceDefs || []).forEach((d) => (m[d.code] = { sum: 0, count: 0 }));
                                              return m;
                                            };

                                            const computeStudentSumCountByCode = (
                                              stName: string,
                                              semWanted: SemesterKey,
                                              yearWanted: TrainingYear,
                                              schoolYearWanted: string
                                            ): Record<string, SumCount> => {
                                              const out = initSumCountMap();

                                              const ndb: NotationDB =
                                                yearWanted === trainingYear
                                                  ? (notationDB as any)
                                                  : yearWanted === "premiere"
                                                    ? (notationDBPremiere as any)
                                                    : (notationDBDeuxieme as any);

                                              const sdb: SkillsDB =
                                                yearWanted === trainingYear
                                                  ? (skillsDB as any)
                                                  : yearWanted === "premiere"
                                                    ? (skillsDBPremiere as any)
                                                    : (skillsDBDeuxieme as any);

                                              // 1) skillsDB (validations manuelles)
                                              const skillsMap = initSumCountMap();
                                              const studentRec: any = (sdb as any)?.[classId]?.[stName] || {};
                                              Object.entries(studentRec).forEach(([rawKey, semRecAny]) => {
                                                const semRec: any = semRecAny || {};
                                                const rawLvl = semRec?.[semWanted];
                                                if (typeof rawLvl !== "number" || !isFinite(rawLvl) || rawLvl <= 0) return;

                                                // Si on a enregistré une note /20 dans skillsDB, on reconvertit vers /4.
                                                let lvlOn4 = rawLvl;
                                                if (rawLvl > 4.5) lvlOn4 = (rawLvl / 20) * 4;

                                                // Clé typique : evalId||C 1.01 : ...
                                                let compLabelPart = String(rawKey);
                                                if (compLabelPart.includes("||")) {
                                                  const parts = compLabelPart.split("||");
                                                  const left = parts[0] || "";
                                                  const right = parts.slice(1).join("||");
                                                  const looksLikeEvalId = left.length >= 6 && !compactCode(left) && !!compactCode(right);
                                                  if (looksLikeEvalId) compLabelPart = right;
                                                }

                                                const code = compactCode(compLabelPart);
                                                if (!code) return;

                                                if (!skillsMap[code]) skillsMap[code] = { sum: 0, count: 0 };
                                                skillsMap[code].sum += lvlOn4;
                                                skillsMap[code].count += 1;
                                              });

                                              // 2) notationDB (scoresByCriteria) — prioritaire si présent
                                              const notationMap = initSumCountMap();
                                              const classBucketAny: any = (ndb as any)?.[schoolYearWanted]?.[classId] || {};

                                              const normName = (x: any) =>
                                                String(x ?? "")
                                                  .normalize("NFKC")
                                                  .replace(/\u00A0/g, " ")
                                                  .replace(/\s+/g, " ")
                                                  .trim()
                                                  .toLowerCase();

                                              for (const [evalKey, evalBucketAny] of Object.entries(classBucketAny || {})) {
                                                const evalBucket: any = evalBucketAny as any;

                                                let entry: any = evalBucket?.[stName];
                                                if (!entry) {
                                                  const target = normName(stName);
                                                  const matchKey = Object.keys(evalBucket || {}).find((k) => normName(k) === target);
                                                  if (matchKey) entry = (evalBucket as any)?.[matchKey];
                                                }
                                                if (!entry) continue;
                                                if (entry?.status && entry.status !== "OK") continue;

                                                const entrySem: any = entry?.semester;
                                                if (entrySem && String(entrySem) !== String(semWanted)) continue;

                                                const scores: Record<string, any> = entry?.scoresByCriteria || {};
                                                const weightKey = String(entry?.evalId || evalKey);
                                                const weights: Record<string, any> = (weightsByEvalId as any)?.[weightKey] || {};

                                                const perComp: Record<string, { w: number; tw: number }> = {};

                                                Object.entries(scores).forEach(([critKey, score]) => {
                                                  if (typeof score !== "number") return;
                                                  // NR (=0) ou non noté → ignoré
                                                  if (!isFinite(score) || score <= 0) return;

                                                  const right = String(critKey).includes("||")
                                                    ? (String(critKey).split("||")[1] || "")
                                                    : String(critKey);
                                                  const compLabel = (right.split("::")[0] || "").trim();
                                                  const code = compactCode(compLabel);
                                                  if (!code) return;

                                                  const wRaw = (weights as any)[critKey];
                                                  const w = typeof wRaw === "number" && isFinite(wRaw) && wRaw > 0 ? wRaw : 1;

                                                  if (!perComp[code]) perComp[code] = { w: 0, tw: 0 };
                                                  perComp[code].w += score * w;
                                                  perComp[code].tw += w;
                                                });

                                                Object.entries(perComp).forEach(([code, a]) => {
                                                  if (!a || a.tw <= 0) return;
                                                  const avg = a.w / a.tw;

                                                  if (!notationMap[code]) notationMap[code] = { sum: 0, count: 0 };
                                                  notationMap[code].sum += avg;
                                                  notationMap[code].count += 1;
                                                });
                                              }

                                              // 3) Merge : notation prioritaire (sinon skills)
                                              (allCompetenceDefs || []).forEach((d) => {
                                                const code = d.code;
                                                const n = notationMap[code];
                                                const s = skillsMap[code];

                                                if (n && n.count > 0) out[code] = n;
                                                else if (s && s.count > 0) out[code] = s;
                                                else out[code] = { sum: 0, count: 0 };
                                              });

                                              return out;
                                            };

                                            const computeClassAvgOn4ByCode = (semWanted: SemesterKey): Record<string, number | null> => {
                                              const sum: Record<string, number> = {};
                                              const cnt: Record<string, number> = {};
                                              (allCompetenceDefs || []).forEach((d) => {
                                                sum[d.code] = 0;
                                                cnt[d.code] = 0;
                                              });

                                              (students || []).forEach((st) => {
                                                const sc = computeStudentSumCountByCode(st, semWanted, trainingYear, schoolYear);
                                                (allCompetenceDefs || []).forEach((d) => {
                                                  const a = sc[d.code];
                                                  if (!a || a.count <= 0) return;
                                                  const avg = a.sum / a.count;
                                                  if (!isFinite(avg) || avg <= 0) return;
                                                  sum[d.code] += avg;
                                                  cnt[d.code] += 1;
                                                });
                                              });

                                              const out: Record<string, number | null> = {};
                                              (allCompetenceDefs || []).forEach((d) => {
                                                out[d.code] = cnt[d.code] ? sum[d.code] / cnt[d.code] : null;
                                              });
                                              return out;
                                            };

                                            // Référence : période précédente (selon les règles demandées)
                                            const refConfig = (() => {
                                              if (trainingYear === "premiere") {
                                                if (sem === "S2") return { label: "Semestre 1", kind: "prev" as const };
                                                return { label: "", kind: "none" as const };
                                              }
                                              // 2ème année
                                              if (sem === "S1") return { label: "Moyenne de 1ère année", kind: "premiereAvg" as const };
                                              return { label: "Semestre 1", kind: "prev" as const };
                                            })();

                                            const schoolYearPremiereRef = pickLatestSchoolYearFromNotationDB(
                                              notationDBPremiere,
                                              getCurrentSchoolYear()
                                            );

                                            const refSumCountByCode: Record<string, SumCount> = (() => {
                                              if (refConfig.kind === "prev") {
                                                return computeStudentSumCountByCode(studentName, "S1", trainingYear, schoolYear);
                                              }
                                              if (refConfig.kind === "premiereAvg") {
                                                const s1 = computeStudentSumCountByCode(studentName, "S1", "premiere", schoolYearPremiereRef);
                                                const s2 = computeStudentSumCountByCode(studentName, "S2", "premiere", schoolYearPremiereRef);
                                                const out = initSumCountMap();
                                                (allCompetenceDefs || []).forEach((d) => {
                                                  out[d.code] = {
                                                    sum: (s1[d.code]?.sum || 0) + (s2[d.code]?.sum || 0),
                                                    count: (s1[d.code]?.count || 0) + (s2[d.code]?.count || 0),
                                                  };
                                                });
                                                return out;
                                              }
                                              return initSumCountMap();
                                            })();

                                            const currentSumCountByCode = computeStudentSumCountByCode(studentName, sem, trainingYear, schoolYear);
                                            const classAvgOn4ByCode = computeClassAvgOn4ByCode(sem);

                                            const chartData = (allCompetenceDefs || []).map((d) => {
                                              const cur = currentSumCountByCode[d.code];
                                              const ref = refSumCountByCode[d.code];

                                              const curAvg4 = cur && cur.count ? cur.sum / cur.count : null;
                                              const refAvg4 = ref && ref.count ? ref.sum / ref.count : null;
                                              const clsAvg4 = classAvgOn4ByCode[d.code];

                                              return {
                                                competence: d.code,
                                                label: d.label || "",
                                                Reference: refAvg4 != null ? round1(toScore20(refAvg4)) : null,
                                                Eleve: curAvg4 != null ? round1(toScore20(curAvg4)) : null,
                                                Classe: clsAvg4 != null ? round1(toScore20(clsAvg4)) : null,
                                              };
                                            });

                                            const studentGlobal = (() => {
                                              const arr = (chartData || [])
                                                .map((x: any) => x?.Eleve)
                                                .filter((v: any) => typeof v === "number" && isFinite(v));
                                              return arr.length ? mean(arr) : 0;
                                            })();

                                            const classGlobal = (() => {
                                              const arr = (chartData || [])
                                                .map((x: any) => x?.Classe)
                                                .filter((v: any) => typeof v === "number" && isFinite(v));
                                              return arr.length ? mean(arr) : 0;
                                            })();

// Absences + Motivation (à partir de l'onglet NOTE)
                      const classBucket: any = (notationDB as any)?.[schoolYear]?.[classId] || {};
                      let absencesCount = 0;
                      const motivationScores: number[] = [];
                      
                      for (const ev of evalsForSem) {
                        const evalBucket: any = classBucket?.[ev.id] || classBucket?.[ev.name] || {};
                        const entry: any = evalBucket?.[studentName];
                        const status = entry?.status;
                        if (status === "AB") absencesCount += 1;
                        if (status !== "OK") continue;
                        const level = entry?.engagementLevel as EngagementLevel | undefined;
                        if (!level) continue;
                        const score = ENGAGEMENT_SCORE[level];
                        if (typeof score === "number" && isFinite(score) && score > 0) motivationScores.push(score);
}

                      const motivationAvg = motivationScores.length ? mean(motivationScores) : 0;
                      const motivationResult = motivationScores.length ? engagementLabelFromAvg(motivationAvg) : "—";


                      const legend = [
                        levelBadge(0),
                        levelBadge(1),
                        levelBadge(2),
                        levelBadge(3),
                        levelBadge(4),
                      ];

                      const renderCompetencesPanel = () => (
                        <div className="rounded-xl border border-neutral-200 dark:border-sky-400/35 bg-white dark:bg-[#1f2d42] p-4 shadow-sm bilan-competences">
                                                                                    <div className="flex items-center justify-between">
                                                                                    </div>

                                                                                    <div className="mt-2 flex flex-wrap gap-3">
                                                                                      {legend.map((b) => (
                                                                                        <div
                                                                                          key={b.text}
                                                                                          className="inline-flex items-center gap-2 text-[11px] text-neutral-800 dark:text-neutral-300"
                                                                                          title={b.title}
                                                                                        >
                                                                                          <span
                                                                                            className={classNames("w-4 h-4 rounded-sm border", b.className)}
                                                                                            aria-hidden="true"
                                                                                          />
                                                                                          <span className="whitespace-nowrap">{b.text}</span>
                                                                                        </div>
                                                                                      ))}
                                                                                    </div>

                                                                                    {!evalsForSem.length && (
                                                                                      <div className="mt-3 rounded-lg border border-amber-200 bg-amber-50 dark:bg-amber-950/35 px-3 py-2 text-xs text-amber-800">
                                                                                        Aucun devoir n'est associé à ce semestre pour cette classe.
                                                                                      </div>
                                                                                    )}

                                                                                    {rows.length ? (
                                                                                      <div className="mt-3 space-y-3">
                                                                                        {(() => {
                                                                                          const groups: Array<{ key: string; title: string; rows: any[] }> = [];
                                                                                          let lastKey: string | null = null;

                                                                                          rows.forEach((r: any) => {
                                                                                            const title =
                                                                                              (r as any).groupTitle ||
                                                                                              ((r as any).group === "OTHER" ? "AUTRES" : String((r as any).group));
                                                                                            const key = String((r as any).group ?? title);

                                                                                            if (key !== lastKey) {
                                                                                              groups.push({ key, title: String(title), rows: [] });
                                                                                              lastKey = key;
                                                                                            }

                                                                                            groups[groups.length - 1].rows.push(r);
                                                                                          });

                                                                                          return groups.map((g) => {
                                                                                            const chip = libelleChipMeta(String(g.title));

                                                                                            return (
                                                                                              <div
                                                                                                key={g.key}
                                                                                                className={classNames("rounded-xl bg-white dark:bg-[#1f2d42] shadow-sm overflow-hidden border-2 bilan-group", chip.border)}
                                                                                              >
                                                                                                <div className={classNames("px-3 py-2 border-b flex items-center justify-between gap-2 bilan-group-header", chip.headerBg, chip.line)}>
                                                                                                  <span
                                                                                                    className={classNames(
                                                                                                      "inline-flex items-center gap-2 rounded-full border px-2 py-0.5 text-[10px] font-semibold",
                                                                                                      chip.bubble
                                                                                                    )}
                                                                                                  >
                                                                                                    <span className={classNames("w-2 h-2 rounded-full", chip.dot)} aria-hidden="true" />
                                                                                                    <span className="whitespace-nowrap">{String(g.title)}</span>
                                                                                                  </span>

                                                                                                  <span className="text-[11px] text-neutral-500 dark:text-neutral-300">{g.rows.length} compétence(s)</span>
                                                                                                </div>

                                                                                                <div className="p-3 grid grid-cols-1 md:grid-cols-2 print:grid-cols-2 gap-2 bilan-group-grid dark:bg-[#182438]">
                                                                                                  {g.rows.map((r: any) => {
                                                                                                    const badge = levelBadge(r.lvl);
                                                                                                    const hasItems = Array.isArray(r.items) && r.items.length > 0;

                                                                                                    return (
                                                                                                      <div key={r.code} className={classNames("border rounded-xl shadow-sm overflow-hidden bilan-competence-card", chip.cardBorder)}>
                                                                                                        <div className="px-2 py-1 border-b border-neutral-200 dark:border-sky-400/35 bg-white dark:bg-[#1f2d42] flex items-start justify-between gap-3 bilan-competence-head">
                                                                                                          <div className="min-w-0 flex items-start gap-2">
                                                                                                            <div className="text-[11px] font-bold text-neutral-900 dark:text-neutral-300 shrink-0 whitespace-nowrap">
                                                                                                              {r.code}
                                                                                                            </div>
                                                                                                            <div className="text-[11px] font-bold text-neutral-900 dark:text-neutral-300 min-w-0 break-words">{r.label || "—"}</div>
                                                                                                          </div>

                                                                                                          <span className="shrink-0 inline-flex items-center gap-2" title={badge.title}>
                                                                                                            <span
                                                                                                              className={classNames("w-4 h-4 rounded-sm border", badge.className)}
                                                                                                              aria-hidden="true"
                                                                                                            />
                                                                                                            <span className="text-[11px] font-semibold text-neutral-800 dark:text-neutral-300">{badge.text}</span>
                                                                                                          </span>
                                                                                                        </div>

                                                                                                        {hasItems ? (
                                                                                                          <div className="px-2 py-1 space-y-0.5 bg-white dark:bg-[#1f2d42] bilan-competence-items">
                                                                                                            {(r.items as any[]).map((it: any, j: number) => {
                                                                                                              const b = levelBadge(it.lvl);

                                                                                                              return (
                                                                                                                <div
                                                                                                                  key={`${r.code}::item::${j}`}
                                                                                                                  className={classNames(
                                                                                                                    "flex items-start justify-between gap-2 text-[10px] leading-tight rounded-md border px-1 py-0.5 bilan-competence-item",
                                                                                                                    levelRowTint(it.lvl)
                                                                                                                  )}
                                                                                                                >
                                                                                                                  <div className="min-w-0 break-words leading-tight">{it.item || "—"}</div>
                                                                                                                  <span
                                                                                                                    className={classNames("inline-block w-3.5 h-3.5 rounded-sm border", b.className)}
                                                                                                                    title={b.text}
                                                                                                                    aria-label={b.text}
                                                                                                                  />
                                                                                                                </div>
                                                                                                              );
                                                                                                            })}
                                                                                                          </div>
                                                                                                        ) : (
                                                                                                          <div className="px-2 py-2 text-[11px] text-neutral-500 italic bg-white dark:bg-[#182433]">
                                                                                                            Aucun critère.
                                                                                                          </div>
                                                                                                        )}
                                                                                                      </div>
                                                                                                    );
                                                                                                  })}
                                                                                                </div>
                                                                                              </div>
                                                                                            );
                                                                                          });
                                                                                        })()}
                                                                                      </div>
                                                                                    ) : (
                                                                                      <div className="mt-3 rounded-lg border border-neutral-200 dark:border-sky-400/35 bg-neutral-50 dark:bg-[#182433] px-3 py-2 text-xs text-neutral-700 dark:text-neutral-300">
                                                                                        Aucun niveau enregistré pour cet élève sur ce semestre.
                                                                                      </div>
                                                                                    )}
                                                                                  </div>
                      );

                      return (
                        <>
<div className="flex items-start justify-between gap-3 flex-wrap">
  <div className="min-w-0 flex-1">
    <h2 className="text-sm font-semibold text-neutral-900 dark:text-neutral-300">
      Bilan périodique – {studentName}
    </h2>

	    <div className="mt-0.5 flex flex-wrap items-center justify-between md:justify-start gap-x-3 md:gap-x-12 gap-y-2">
      <div className="text-[11px] text-neutral-600 dark:text-neutral-300 whitespace-nowrap">
        Année scolaire : {schoolYear} • {trainingYearLabel(trainingYear)}
      </div>

      {/* Légende de l'histogramme (déplacée à droite de l'année scolaire, au-dessus du graphe) */}
	      <div className="mt-0.5 flex flex-wrap items-center justify-between md:justify-start gap-x-3 md:gap-x-7 gap-y-2 text-[11px]">
        {refConfig.kind !== "none" && (
          <div className="inline-flex items-center gap-2">
            <span
	              className="w-2.5 h-2.5 md:w-3 md:h-3 rounded-sm border border-neutral-300 dark:border-sky-400/35"
              style={{ backgroundColor: "#6d28d9" }}
            />
	            <span className="max-w-[260px] leading-tight">{refConfig.label}</span>
          </div>
        )}
        <div className="inline-flex items-center gap-2">
          <span
	            className="w-2.5 h-2.5 md:w-3 md:h-3 rounded-sm border border-neutral-300 dark:border-sky-400/35"
            style={{ backgroundColor: "#16a34a" }}
          />
          <span className="whitespace-nowrap">Élève</span>
        </div>
        <div className="inline-flex items-center gap-2">
          <span
	            className="w-2.5 h-2.5 md:w-3 md:h-3 rounded-sm border border-neutral-300 dark:border-sky-400/35"
            style={{ backgroundColor: "#6b7280" }}
          />
          <span className="whitespace-nowrap">Moy.Classe</span>
        </div>
      </div>
    </div>
  </div>

                            <div className="inline-flex rounded-full border border-neutral-200 dark:border-sky-400/35 bg-neutral-50 dark:bg-[#182133] p-1 text-xs ">
                              <button
                                type="button"
                                onClick={() => setBilanSemester("S1")}
                                className={classNames(
                                  "px-3 py-1 rounded-full transition",
                                  sem === "S1" ? "bg-neutral-900 text-white" : "bg-transparent text-neutral-700 dark:text-neutral-300 hover:bg-amber-100/70 dark:bg-[#182433]  dark:hover:bg-[#3d2707]"
                                )}
                              >
                                Semestre 1
                              </button>
                              <button
                                type="button"
                                onClick={() => setBilanSemester("S2")}
                                className={classNames(
                                  "px-3 py-1 rounded-full transition",
                                  sem === "S2" ? "bg-neutral-900 text-white" : "bg-transparent text-neutral-700 dark:text-neutral-300 hover:bg-amber-100/70 dark:bg-[#182433]  dark:hover:bg-[#3d2707]"
                                )}
                              >
                                Semestre 2
                              </button>
                            </div>
                          </div>

                                                    <div ref={suiviBilanPdfRef} className="space-y-3 bilan-print-root">

  {/* Livret périodique (impression) — visuel type "Camara Lanciné" */}
  <div className="hidden print-only bilan-livret">
    {(() => {
      const normCode = (c: any) => String(c ?? "").replace(/\s+/g, "");
      const isPage1Code = (code: string) => {
        const c = normCode(code);
        const m = c.match(/^C([1-4])\.(\d+)/i);
        if (!m) return false;
        const major = Number(m[1]);
        const minor = Number(m[2]);
        // Modèle Camara : page 1 = C3.11→C3.17 + C4.1→C4.2
        if (major === 4) return minor === 1 || minor === 2;
        if (major === 3) return minor >= 11 && minor <= 17;
        return false;
      };

      const page1Rows = (rows || []).filter((r: any) => isPage1Code(String(r.code)));
      const page2Rows = (rows || []).filter((r: any) => !isPage1Code(String(r.code)));

      const isPage2Right = (code: string) => {
        const c = normCode(code);
        const m = c.match(/^C([1-4])\.(\d+)/i);
        if (!m) return false;
        const major = Number(m[1]);
        const minor = Number(m[2]);
        return major === 3 && minor >= 2 && minor <= 10;
      };

      const page2LeftRows = (page2Rows || []).filter((r: any) => !isPage2Right(String(r.code)));
      const page2RightRows = (page2Rows || []).filter((r: any) => isPage2Right(String(r.code)));

      const semLabel = sem === "S1" ? "PREMIER SEMESTRE" : "DEUXIÈME SEMESTRE";

      const prettyCompCode = (code: string) => {
        const c = normCode(code);
        const m = c.match(/^C(\d)\.(\d+)/i);
        if (!m) return String(code || "");
        const major = Number(m[1]);
        const minor = Number(m[2]);
        return `C${major}.${minor}`;
      };

      const lvlToBucket = (lvl: Level1to4): "NE" | "NA" | "EA" | "A" => {
        if (lvl === 0) return "NE";
        if (lvl === 1) return "NA";
        if (lvl === 2) return "EA";
        return "A"; // 3 ou 4 → acquis
      };

      const overallBucket = (items: any[]): "NE" | "NA" | "EA" | "A" => {
        const lvls = (items || [])
          .map((it: any) => Number(it?.lvl ?? 0))
          .filter((n: number) => isFinite(n) && n > 0);
        if (!lvls.length) return "NE";
        const avg = lvls.reduce((a: number, b: number) => a + b, 0) / lvls.length;
        if (avg < 1.5) return "NA";
        if (avg < 2.5) return "EA";
        return "A";
      };

      // Affichage des niveaux : carré coloré (sans "X")
      const Status = ({ b }: { b: "NE" | "NA" | "EA" | "A" }) => (
        <span className={classNames("lp-status", b)} aria-label={b} />
      );

      const renderCompList = (rs: any[]) => (
        <div>
          {(rs || []).map((r: any, idx: number) => {
            const items = Array.isArray(r.items) && r.items.length ? r.items : [{ item: "", lvl: 0 }];
            const bHead = overallBucket(items);
            return (
              <div key={String(r.code) + "__" + idx} className="lp-compBlock" style={idx === 0 ? { marginTop: 0 } : undefined}>
                <div className="lp-compHead">
                  <div>
                    <span>{prettyCompCode(String(r.code))} </span>
                    <span>{String(r.label ?? "")}</span>
                  </div>
                  <div className="text-right">
                    <Status b={bHead} />
                  </div>
                </div>

                {(items || []).map((it: any, j: number) => {
                  const b = lvlToBucket(it?.lvl as any);
                  const txt = String(it?.item ?? "").trim();
                  if (!txt) return null;
                  return (
                    <div key={`${r.code}__${j}`} className="lp-compItem">
                      <div style={{ paddingLeft: 10 }}>{txt}</div>
                      <div className="text-right">
                        <Status b={b} />
                      </div>
                    </div>
                  );
                })}
              </div>
            );
          })}
        </div>
      );

      // Activités réalisées (d'après les tâches associées aux devoirs du semestre)
      const tasksDoneCodes = new Set<string>();

      const toTaskCode = (val: any): string | null => {
        const raw = String(val ?? "").trim();
        const m = raw.match(/T\s*0*(\d+)/i);
        if (!m) return null;
        const n = Number(m[1]);
        if (!isFinite(n) || n <= 0) return null;
        return `T${String(n).padStart(2, "0")}`;
      };

      // Agrège toutes les tâches sélectionnées dans les devoirs du semestre affiché
      (evalsForSem || []).forEach((ev: any) => {
        const arr = (tasksByEvalId as any)?.[String(ev.id)] || [];
        (arr || []).forEach((t: any) => {
          const code = toTaskCode(t);
          if (code) tasksDoneCodes.add(code);
        });
      });

      // Liste exhaustive (T01 → T17) à partir du référentiel tcMap
      const allTasks = Object.keys(tcMap || {})
        .filter((t: any) => {
          const code = toTaskCode(t);
          if (!code) return false;
          const n = Number(code.replace(/^T/i, ""));
          return isFinite(n) && n >= 1 && n <= 17;
        })
        .sort((a, b) => taskNumber(a) - taskNumber(b));

      const splitTask = (t: string) => {
        const raw = String(t || "").trim();
        const m = raw.match(/^T\s*0*(\d+)\s*/i);
        if (!m) return { code: raw, label: "", codeKey: raw };
        const n = Number(m[1]);
        const codeKey = `T${String(n).padStart(2, "0")}`;
        const code = `T ${String(n).padStart(2, "0")}`;
        const label = raw.replace(/^T\s*0*\d+\s*/i, "").trim();
        return { code, label, codeKey };
      };

      const renderTasksList = () => (
        <div style={{ marginTop: 6 }}>
          {allTasks.map((t: string) => {
            const { code, label, codeKey } = splitTask(t);
            return (
              <div key={t} className="lp-taskRow">
                <div className="lp-taskCode">{code}</div>
                <div>{label || " "}</div>
                <div className="lp-taskMark">{tasksDoneCodes.has(codeKey) ? "X" : ""}</div>
              </div>
            );
          })}
        </div>
      );

      const bars = Array.isArray(chartData) ? chartData : [];
      const CHART_CODES = [
        "C1.01","C1.02","C2.01","C2.02","C2.03","C3.01","C3.02","C3.03","C3.04","C3.05","C3.06","C3.07","C3.08","C3.09","C3.10","C3.11","C3.12","C3.13","C3.14","C3.15","C3.16","C3.17","C4.01","C4.02"
      ];
      const byCode = new Map<string, any>();
      (bars || []).forEach((d: any) => {
        const k = String(d?.competence ?? d?.Competence ?? "").trim();
        if (k) byCode.set(k, d);
      });
      const barItems = CHART_CODES.map((code) => ({ code, d: byCode.get(code) }));

      const light = bilanAbsencesTrafficAuto as any;
      const dotClass = (c: "red" | "yellow" | "green") =>
        classNames("lp-trafficDot", light === c ? c : "");

      const appreciationText = (bilanAppreciationNote || "").trim() ? bilanAppreciationNote : " ";
      const absAutoSummary = bilanAbsencesAuto
        ? (bilanAbsencesAuto.denom > 0
            ? `AB: ${bilanAbsencesAuto.ab} (${Math.round(bilanAbsencesAuto.abPct * 10) / 10}%) • RT: ${bilanAbsencesAuto.rt} (${Math.round(bilanAbsencesAuto.rtPct * 10) / 10}%)`
            : "")
        : "";
      const absNote = (bilanAbsencesNote || "").trim();
      const absText = [absAutoSummary, absNote].filter(Boolean).join(" — ") || " ";

      const legendLine = (
        <div className="lp-legendLine">
          <span className="lp-legItem">« <Status b="NA" /> » Compétence non acquise</span>
          <span className="lp-legItem">« <Status b="A" /> » Compétence acquise</span>
          <span className="lp-legItem">« <Status b="EA" /> » Compétence en voie d&apos;acquisition</span>
          <span className="lp-legItem">« <Status b="NE" /> » Compétence non évaluée</span>
        </div>
      );

      return (
        <div>
          {/* PAGE 1 */}
          <div className="livret-page lp-page">
            <div className="lp-grid">
              <div className="lp-col">{renderCompList(page1Rows)}</div>

              <div className="lp-col">
                <div className="lp-rightTitle">Livret périodique d&apos;évaluation {schoolYear}</div>
                <div className="lp-sem">{semLabel}</div>
                <div className="lp-nameBox">{studentName}</div>
                <div className="lp-centerInfo">
                  {(() => {
                    const classKey = selectedClassIdForSuivi || "";
                    const referent =
                      (generalSettings.classReferents?.[classKey] || generalSettings.defaultReferents || "—");
                    const etab = generalSettings.establishmentName || "—";
                    const loc = (generalSettings.establishmentLocation || "").trim();
                    const locLines = loc
                      ? loc
                          .replace(/[—–]/g, "-")
                          .split(/\r?\n/)
                          .flatMap((l) => l.split(/\s*-\s*/))
                          .map((s) => s.trim())
                          .filter(Boolean)
                      : [];
                    return (
                      <>
                        <div>Référent {referent}</div>
                        <div className="lp-etabRow">
                          <span className="lp-etabLabel">Établissement </span>
                          <span className="lp-etabName">{etab}</span>
                        </div>
                        {locLines.map((line, idx) => (
                          <div key={idx} className="lp-etabLine">{line}</div>
                        ))}
                      </>
                    );
                  })()}
                </div>

                <div className="lp-chartFrame">
                  <div className="lp-chart">
                    <div className="lp-plot">
                      <div className="lp-band top" />
                      <div className="lp-band mid" />
                      <div className="lp-band bot" />
                      <div className="lp-midLine" />
                      <div className="lp-bars">
                        {barItems.map(({ code, d }: any, i: number) => {
                          const vE = Number(d?.Eleve ?? d?.eleve ?? 0);
                          const vC = Number(d?.Classe ?? d?.classe ?? 0);
                          const hE = Math.max(0, Math.min(1, vE / 20));
                          const hC = Math.max(0, Math.min(1, vC / 20));
                          return (
                            <div key={`${code}__${i}`} className="lp-barWrap">
                              <div className="lp-barPair">
                                <div className="lp-bar" style={{ height: `${hE * 100}%` }} />
                                <div className="lp-bar gray" style={{ height: `${hC * 100}%` }} />
                              </div>
                            </div>
                          );
                        })}
                      </div>
                    </div>

                    <div className="lp-labels">
                      {barItems.map(({ code }: any, i: number) => (
                        <div key={`${code}__lbl__${i}`} className="lp-labelWrap">
                          <div className="lp-xlbl">{code}</div>
                        </div>
                      ))}
                    </div>
                  </div>
                </div>

                <div className="lp-absBox">
                  <div className="lp-traffic">
                    <span className={dotClass("red")} />
                    <span className={dotClass("yellow")} />
                    <span className={dotClass("green")} />
                  </div>
                  <div className="lp-absText">{absText}</div>
                </div>

                <div className="lp-motivTitle">Intérêt pour la pratique professionnelle</div>
                <div
                  className={classNames(
                    "lp-motivBox",
                    !motivationScores.length
                      ? ""
                      : motivationAvg >= 3.5
                        ? "good"
                        : motivationAvg >= 2.5
                          ? "mid"
                          : "bad"
                  )}
                >
                  {motivationResult}
                </div>

                <div className="lp-appTitle">Appréciation générale de l&apos;équipe pédagogique</div>
                <div className="lp-appBox">{appreciationText}</div>

                <table className="lp-signTable">
                  <thead>
                    <tr>
                      <th>Equipe pédagogique</th>
                      <th>Elève</th>
                      <th>Responsables légaux</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td className="lp-signBlank" />
                      <td className="lp-signBlank" />
                      <td className="lp-signBlank" />
                    </tr>
                  </tbody>
                </table>
              </div>
            </div>
          </div>

          {/* PAGE 2 */}
          <div className="livret-page lp-page">
            <div className="lp-grid">
              <div className="lp-col">
                <div className="lp-grayTitle">ACTIVITÉ RÉALISÉES</div>
                <div className="lp-note">« X » VUE EN COURS DE PRATIQUE PROFESSIONNELLE</div>
                {renderTasksList()}

                <div style={{ marginTop: 12 }} className="lp-grayTitle">RELEVÉ DES COMPÉTENCES</div>
                {legendLine}
                {renderCompList(page2LeftRows)}
              </div>

              <div className="lp-col">{renderCompList(page2RightRows)}</div>
            </div>
          </div>
        </div>
      );
    })()}
  </div>

  <div className="bilan-screen-layout">
                            {/* Synthèse */}
                            <div className="space-y-3 bilan-page-1">
                                                          <div className="grid grid-cols-1 lg:grid-cols-12 print:grid-cols-12 print:items-start gap-3">
                                                            <div className="lg:col-span-9 print:col-span-9 h-full flex min-h-0 min-w-0">
                                                            <div className="rounded-lg border border-neutral-200 dark:border-sky-400/35 bg-white dark:bg-[#182433] keep-light p-2 shadow-sm h-full flex flex-col min-h-0 flex-1 min-w-0">                         
                                                                                                                        <div className="mt-0 bilan-chart-wrap flex-1 min-h-[140px] print:min-h-[200px] min-w-0 w-full overflow-hidden">
                                                                                                                          <div
                                                                                                                            style={{
                                                                                                                              width: "100%",
                                                                                                                              height: "100%",
                                                                                                                            }}
                                                                                                                          >
                                                                                                                            <ResponsiveContainer width="100%" height="100%">
                                                                                                                              <BarChart data={chartData} margin={{ top: 0, right: 6, left: 0, bottom: 4 }}>
                                                                                                                                {/* Zones (mêmes couleurs que l'histogramme "Évolutions") */}
                                                                                                                                {/* Découverte */}
                                                                                                                                <ReferenceArea y1={0} y2={5} fill={theme === "dark" ? "#3b2315" : "#FDE7D8"} fillOpacity={theme === "dark" ? 0.35 : 1} />
                                                                                                                                {/* Apprentissage */}
                                                                                                                                <ReferenceArea y1={5} y2={10} fill={theme === "dark" ? "#102a3d" : "#E1F2FA"} fillOpacity={theme === "dark" ? 0.35 : 1} />
                                                                                                                                {/* Acquisition */}
                                                                                                                                <ReferenceArea y1={10} y2={20} fill={theme === "dark" ? "#123221" : "#E7F6EC"} fillOpacity={theme === "dark" ? 0.35 : 1} />
                                                                                                                                <ReferenceLine y={10} stroke={theme === "dark" ? "rgba(226,232,240,0.7)" : "#111827"} strokeWidth={1} strokeOpacity={0.9} />
                            
                                                                                                                                <CartesianGrid stroke={theme === "dark" ? "rgba(148,163,184,0.22)" : "rgba(17,24,39,0.16)"} strokeDasharray="3 3" />
                                                                                                                                <XAxis
                                                                                                                                  dataKey="competence"
                                                                                                                                  interval={0}
                                                                                                                                  angle={-25}
                                                                                                                                  textAnchor="end"
                                                                                                                                  height={28}
                                                                                                                                  tickMargin={2}
                                                                                                                                  tick={{ fontSize: 8, fill: theme === "dark" ? "#e5e7eb" : "#111827" }}
                                                                                                                                  axisLine={{ stroke: theme === "dark" ? "rgba(148,163,184,0.35)" : "rgba(17,24,39,0.25)" }}
                                                                                                                                  tickLine={{ stroke: theme === "dark" ? "rgba(148,163,184,0.35)" : "rgba(17,24,39,0.25)" }}
                                                                                                                                />
                                                                                                                                <YAxis domain={[0, 20]} hide width={0} />
                                                                                                                                <Tooltip
                                                                                                                                  contentStyle={{
                                                                                                                                    backgroundColor: theme === "dark" ? "#0b1220" : "#ffffff",
                                                                                                                                    border: theme === "dark" ? "1px solid rgba(148,163,184,0.35)" : "1px solid rgba(17,24,39,0.15)",
                                                                                                                                    borderRadius: 8,
                                                                                                                                    color: theme === "dark" ? "#e5e7eb" : "#111827",
                                                                                                                                    fontSize: 12,
                                                                                                                                    padding: "8px 10px",
                                                                                                                                  }}
                                                                                                                                  labelStyle={{
                                                                                                                                    color: theme === "dark" ? "#e5e7eb" : "#111827",
                                                                                                                                    fontWeight: 700,
                                                                                                                                  }}
                                                                                                                                  itemStyle={{
                                                                                                                                    color: theme === "dark" ? "#e5e7eb" : "#111827",
                                                                                                                                  }}
                                                                                                                                  cursor={{ fill: theme === "dark" ? "rgba(148,163,184,0.12)" : "rgba(17,24,39,0.06)" }}
                                                                                                                                  labelFormatter={(code: any) => {
                                                                                                                                    const found = (chartData as any[])?.find((d: any) => d?.competence === code);
                                                                                                                                    return found?.label ? `${String(code)} — ${String(found.label)}` : String(code);
                                                                                                                                  }}
                                                                                                                                  formatter={(v: any, name: any) => {
                                                                                                                                    if (typeof v !== "number" || !isFinite(v)) return ["—", name];
                                                                                                                                    return [`${v.toFixed(1)} /20`, name];
                                                                                                                                  }}
                                                                                                                                />
                                                                                                                                
                                                                                                                                {refConfig.kind !== "none" && (
																					<Bar name={refConfig.label} dataKey="Reference" fill="#6d28d9" />
                                                                                                                                )}
																				<Bar name="Élève" dataKey="Eleve" fill="#16a34a" />
																				<Bar name="Moy.Classe" dataKey="Classe" fill="#6b7280" />
                                                                                                                              </BarChart>
                                                                                                                            </ResponsiveContainer>
                                                                                                                          </div>
                                                                                                                        </div>

																					<div className="hidden print-only mt-1 flex flex-wrap items-center justify-center gap-x-3 gap-y-1 text-[10px] text-neutral-700 dark:text-neutral-300">
																					  {refConfig.kind !== "none" && (
																					    <div className="inline-flex items-center gap-2">
																					      <span className="w-2.5 h-2.5 rounded-sm border border-neutral-300 dark:border-sky-400/35" style={{ backgroundColor: "#6d28d9" }} />
																					      <span className="max-w-[260px] leading-tight">{refConfig.label}</span>
																					    </div>
																					  )}
																					  <div className="inline-flex items-center gap-2">
																					    <span className="w-2.5 h-2.5 rounded-sm border border-neutral-300 dark:border-sky-400/35" style={{ backgroundColor: "#16a34a" }} />
																					    <span className="whitespace-nowrap">Élève</span>
																					  </div>
																					  <div className="inline-flex items-center gap-2">
																					    <span className="w-2.5 h-2.5 rounded-sm border border-neutral-300 dark:border-sky-400/35" style={{ backgroundColor: "#6b7280" }} />
																					    <span className="whitespace-nowrap">Moy.Classe</span>
																					  </div>
																					</div>
                                                                                                                      </div>
                                                            </div>
                                                            <div className="lg:col-span-3 print:col-span-3 print:self-start space-y-3">
                                                            <div className="rounded-lg border border-neutral-200 dark:border-sky-400/35 bg-white dark:bg-[#182433] keep-light p-2 shadow-sm">
  <div className="flex items-start gap-2">
    <div className="shrink-0 pt-0.5">
      {/* Écran : sélecteur (interactif) */}
      <div className="no-print">
        <TrafficLightPicker
  value={bilanAbsencesTrafficAuto}
  onChange={() => {}}
  className="pointer-events-none opacity-90"
/>

      </div>

      {/* Impression / aperçu : rendu statique (les <button> sont masqués dans le CSS d'impression) */}
      <div className="hidden print-only">
        <div className="inline-flex flex-col items-center gap-0.5 rounded-md border border-neutral-200 dark:border-sky-400/35 bg-white dark:bg-[#1f2d42] px-0.5 py-0.5">
          {(
            [
              { v: "green" as const, colorClass: "bg-emerald-500", label: "Vert" },
              { v: "yellow" as const, colorClass: "bg-amber-400", label: "Orange" },
              { v: "red" as const, colorClass: "bg-red-500", label: "Rouge" },
            ]
          ).map((it) => {
            const active = bilanAbsencesTrafficAuto === it.v;
            return (
              <span key={it.v} title={it.label} aria-label={it.label} className="rounded-full p-0.5">
                <span
                  className={classNames(
                    "block h-3 w-3 rounded-full border border-neutral-300 dark:border-sky-400/35",
                    it.colorClass,
                    active ? "opacity-100 ring-2 ring-inset ring-neutral-900/30" : "opacity-30"
                  )}
                />
              </span>
            );
          })}
        </div>
      </div>
    </div>

    <div className="min-w-0 flex-1">
      <h3 className="text-xs font-semibold tracking-wide text-neutral-900 dark:text-neutral-300">Absences / retards</h3>

      <div className="mt-1 text-xs text-neutral-700 dark:text-neutral-300">
        {bilanAbsencesAuto ? (
          bilanAbsencesAuto.denom > 0 ? (
            <div className="space-y-0.5">
              <div>
                Période : <b>{bilanAbsencesAuto.periodLabel}</b> • Jours de cours effectifs : <b>{bilanAbsencesAuto.denom}</b>
              </div>
              <div>
                Absences : <b>{bilanAbsencesAuto.ab}</b> ({Math.round(bilanAbsencesAuto.abPct * 10) / 10}%) • Retards :{" "}
                <b>{bilanAbsencesAuto.rt}</b> ({Math.round(bilanAbsencesAuto.rtPct * 10) / 10}%)
              </div>
            </div>
          ) : (
            <div className="text-neutral-500 dark:text-neutral-300">
              Aucun jour de cours effectif sur la période (planning / vacances / PFMP).
            </div>
          )
        ) : (
          <div className="text-neutral-500 dark:text-neutral-300">—</div>
        )}
      </div>

      <div className="mt-1">


        <div className="hidden print-only mt-1 min-h-[48px] rounded-md border border-neutral-200 dark:border-sky-400/35 bg-white dark:bg-[#1f2d42] px-2 py-1 text-xs text-neutral-900 dark:text-neutral-300 whitespace-pre-wrap">
          {(bilanAbsencesNote || "").trim() ? bilanAbsencesNote : "—"}
        </div>
        <div className="hidden print-only mt-2">
          <div className="text-[10px] font-semibold tracking-wide text-neutral-900 dark:text-neutral-300">
            Intérêt pour la pratique professionnelle
          </div>
          <div
            className={classNames(
              "mt-1 inline-flex items-center justify-center rounded-md border-2 bg-white dark:bg-[#1f2d42] px-2 py-1 text-[11px] font-extrabold tracking-wide text-neutral-900 dark:text-neutral-300",
              !motivationScores.length
                ? "border-neutral-200 dark:border-sky-400/35"
                : motivationAvg >= 3.5
                  ? "border-emerald-500"
                  : motivationAvg >= 2.5
                    ? "border-amber-400"
                    : "border-red-500"
            )}
          >
            {motivationResult}
          </div>
        </div>

      </div>
    </div>
  </div>
</div>
<div className="no-print rounded-lg border border-neutral-200 dark:border-sky-400/35 bg-white dark:bg-[#182433] keep-light p-2 shadow-sm">
                                                              <h3 className="text-xs font-semibold tracking-wide text-neutral-900 dark:text-neutral-300">
                                                                Intérêt pour la pratique professionnelle
                                                              </h3>
                                                              <div
                                                                className={classNames(
                                                                  "mt-2 flex items-center justify-center rounded-md border-2 bg-white dark:bg-[#1f2d42] p-2 text-center",
                                                                  !motivationScores.length
                                                                    ? "border-neutral-200 dark:border-sky-400/35"
                                                                    : motivationAvg >= 3.5
                                                                      ? "border-emerald-500"
                                                                      : motivationAvg >= 2.5
                                                                        ? "border-amber-400"
                                                                        : "border-red-500"
                                                                )}
                                                              >
                                                                <div className="text-lg font-extrabold tracking-wide text-neutral-900 dark:text-neutral-300">{motivationResult}</div>
                                                              </div>
                                                            </div>
<div className="rounded-lg border border-neutral-200 dark:border-sky-400/35 bg-white dark:bg-[#182433] keep-light  p-2 shadow-sm">
  <h3 className="text-xs font-semibold tracking-wide text-neutral-900 dark:text-neutral-300">Appréciation générale</h3>
  <div className="mt-1">
    <Textarea
      value={bilanAppreciationNote}
      onChange={(e) => setBilanAppreciationNote(e.target.value)}
      placeholder="Ex : Progrès constants, sérieux et implication satisfaisante."
      className="no-print min-h-[72px] text-xs bg-white text-neutral-900 placeholder:text-neutral-500 border border-neutral-200 focus-visible:ring-0 focus-visible:ring-offset-0 dark:!bg-[#1f2d42] dark:!text-neutral-50 dark:placeholder:text-neutral-400 dark:!border-neutral-700/60"
    />
    <div className="hidden print-only mt-1 min-h-[72px] rounded-md border border-neutral-200 dark:border-sky-400/35 bg-white dark:bg-[#1f2d42] px-2 py-1 text-xs text-neutral-900 dark:text-neutral-300 whitespace-pre-wrap">
      {(bilanAppreciationNote || "").trim() ? bilanAppreciationNote : "—"}
    </div>
  </div>
</div>

                                                          </div>
                                                          {/* Relevé des compétences (impression) */}
                                                          <div className="hidden print-only bilan-page-2 print:col-span-12">
                                                            {renderCompetencesPanel()}
                                                          </div>
                                                          </div>
                                                        </div>
                            {/* Relevé des compétences (écran) */}
                            <div className="no-print bilan-page-2">
                              {renderCompetencesPanel()}
                            </div>
                          </div>
                          </div>
                        </>
                      );
                    })()}
                  </div>
                )
              )}


              {suiviMode === "classe" && (
                !classe ? (
                  <p className="text-sm text-neutral-600 dark:text-neutral-300">
                    Sélectionnez une classe pour afficher la vue d'ensemble.
                  </p>
                ) : (
<div ref={suiviClassePdfRef} className="mt-4 space-y-4">
  <div className="no-print flex items-center justify-between">
    <div>
      <h2 className="text-sm font-semibold text-neutral-900 dark:text-neutral-300">
        Vue d&apos;ensemble – {classe.name}
      </h2>
    </div>
  </div>

  {/* ... ton contenu existant (TasksVoletTotal + DoubleSemesterMatrix) ... */}


                     <div className="flex gap-2 items-start overflow-x-auto pb-6">
                      {/* Colonne de boutons (Tâches) */}
                      <div className="flex flex-col items-center mt-10 space-y-2">
                        <button
                          type="button"
                          onClick={() => setShowTasksVolet((prev) => !prev)}
                          className="w-8 h-16 flex items-center justify-center rounded-r-lg border border-neutral-300 dark:border-sky-400/35 bg-white hover:bg-amber-100/70 dark:bg-[#182433] shadow-sm hover:bg-amber-100/70 dark:bg-[#182433]"
                          title={
                            showTasksVolet
                              ? "Masquer le volet des tâches"
                              : "Afficher le volet des tâches"
                          }
                        >
                          <span
                            className={
                              "text-[10px] font-semibold tracking-wide " +
                              (showTasksVolet ? "text-neutral-900 dark:text-neutral-300" : "text-neutral-500")
                            }
                            style={{
                              writingMode: "vertical-rl",
                              transform: "rotate(180deg)",
                              whiteSpace: "normal",      // ✅ autorise le retour à la ligne
                              wordBreak: "break-word",   // ✅ casse les mots longs si besoin
                              maxHeight: 96,             // optionnel : limite la hauteur du texte dans le header
                              overflow: "hidden",
                            }}
                          >
                            TÂCHES
                          </span>
                        </button>
                      </div>

                      {/* Volet Tâches TOTAL repliable */}
                      <div className="flex flex-col gap-2">
                        <div
                          className={`transition-all duration-200 ease-in-out ${
                            showTasksVolet
                              ? "opacity-100 translate-x-0 w-auto min-w-[260px]"
                              : "opacity-0 -translate-x-4 w-0 pointer-events-none"
                          }`}
                        >
                          {showTasksVolet && (
                            <TasksVoletTotal selectedClassId={selectedClassIdForSuivi} />
                          )}
                        </div>
                      </div>

                      {/* Zone principale : tableau combiné S1 + S2 */}
                      <div className="flex flex-col gap-4 flex-1 min-w-[600px]">
                        <DoubleSemesterMatrix
                          allCompetences={allCompetencesForSuivi}
                          evalMetaList={evalMetaList}
                          selectedClassId={selectedClassIdForSuivi}
                          compsByEvalId={compsByEvalId}
                          onAddDevoirS1={() => {
                            setClasseSemesterForSuivi("S1");
                            handleOpenDevoirDatabase();
                          }}
                          onAddDevoirS2={() => {
                            setClasseSemesterForSuivi("S2");
                            handleOpenDevoirDatabase();
                          }}
                          onRemoveDevoir={(ev) => {
                            handleRemoveEvalFromClasseSemester(ev.id);
                          }}
                          onOpenDevoir={handleOpenClasseDevoir}
                        />
                      </div>
                    </div>
                  </div>
                )
              )}
            </div>
          </>
        );
      })()}
    </section>
  </>

) : activeView === "suivi_eleves" ? (
  <>
    {/* 🗂️ VUE : SUIVI D'ÉLÈVES (DOCUMENTS PDF) */}
    <section className="space-y-4 px-2 sm:px-3 lg:px-4 pt-2 pb-12">
      {(() => {
        const classe = classGroups.find((c) => c.name === selectedClassIdForSuiviDocs);
        const students = classe
          ? (classe.students || "")
              .split("\n")
              .map((s) => s.trim())
              .filter(Boolean)
          : [];

        // Absences / retards : s'appuie sur la sélection de classe du suivi (selectedClassIdForSuivi)
        const classeAbs = classGroups.find((c) => c.name === selectedClassIdForSuivi);
        const studentsAbs = classeAbs
          ? (classeAbs.students || "")
              .split("\n")
              .map((s) => s.trim())
              .filter(Boolean)
          : [];
          
        const studentsAbsFiltered = studentsAbs;
        const ready = Boolean(classe && selectedStudentForDocs);

        const DOC_ROOT = "suivi_eleves_docs";
        const folders = docFolders;

        const basePath = (folderKey: string) => {
          const classPart = sanitizeFileNamePart(selectedClassIdForSuiviDocs || "classe");
          const studentPart = sanitizeFileNamePart(selectedStudentForDocs || "eleve");
          const folderPart = sanitizeFileNamePart(folderKey);
          return `${DOC_ROOT}/${trainingYear}/${classPart}/${studentPart}/${folderPart}`;
        };

        const handleUploadPdf = async (folderKey: string) => {
          if (!ready) return;
          if (!isTauriRuntime()) {
            alert("L'ajout de PDF est disponible uniquement dans la version installée (Tauri).");
            return;
          }

          const picked = await open({
            multiple: false,
            filters: [{ name: "PDF", extensions: ["pdf"] }],
          });

          const srcPath = Array.isArray(picked) ? picked[0] : picked;
          if (!srcPath) return;

          const srcName = String(srcPath).split(/[\\/]/).pop() || "document.pdf";
          const safeName = sanitizeFileNamePart(srcName.replace(/\.pdf$/i, "")) + ".pdf";
          const destDir = basePath(folderKey);
          const destName = `${tsForFileName()}_${safeName}`;
          const destRel = `${destDir}/${destName}`;

          try {
            await mkdir(destDir, { baseDir: BaseDirectory.AppLocalData, recursive: true });
            const bytes = await readFile(srcPath);
            await writeFile(destRel, bytes, { baseDir: BaseDirectory.AppLocalData });
            setDocsRefreshNonce((n) => n + 1);
          } catch (e: any) {
            alert(`Impossible d'ajouter le PDF.\n${e?.message || e}`);
          }
        };

        const handleViewPdf = async (relPath: string) => {
          try {
            const bytes = await readFile(relPath, { baseDir: BaseDirectory.AppLocalData });
            const blob = new Blob([bytes], { type: "application/pdf" });
            const url = URL.createObjectURL(blob);
            const name = String(relPath).split(/[\\/]/).pop() || "document.pdf";
            setPdfViewer({ url, name, relPath });
          } catch (e: any) {
            alert(`Impossible d'ouvrir le PDF.\n${e?.message || e}`);
          }
        };

        const handleDeletePdf = async (relPath: string) => {
          const ok = await confirm("Supprimer ce PDF ?", { title: "Suppression", kind: "warning" });
          if (!ok) return;
          try {
            await remove(relPath, { baseDir: BaseDirectory.AppLocalData });
            setDocsRefreshNonce((n) => n + 1);
          } catch (e: any) {
            alert(`Impossible de supprimer.\n${e?.message || e}`);
          }
        };

        return (
          <div className="flex gap-3">
            <div className="flex-1 flex flex-col gap-3 rounded-xl border border-neutral-200 dark:border-sky-400/35 bg-white dark:bg-[#1f2d42] px-3 py-3 shadow-sm">
              
              {/* Sous-onglets Suivi d'élèves + filtres (même ligne) */}
             <div className="flex flex-wrap items-center justify-between gap-2">
                <div className="inline-flex rounded-full border border-neutral-200 dark:border-sky-400/35 bg-neutral-50 dark:bg-[#182433] p-1 text-xs w-fit">
                  <button
                    type="button"
                    onClick={() => setSuiviElevesMode("docs")}
                    className={classNames(
                      "px-3 py-1 rounded-full transition",
                      suiviElevesMode === "docs"
                        ? "bg-neutral-900 text-white"
                        : "bg-transparent text-neutral-700 dark:text-neutral-300 hover:bg-amber-100/70 dark:hover:bg-[#3d2707]"
                    )}
                  >
                    📄 Documents
                  </button>
                  <button
                    type="button"
                    onClick={() => setSuiviElevesMode("absences")}
                    className={classNames(
                      "px-3 py-1 rounded-full transition",
                      suiviElevesMode === "absences"
                        ? "bg-neutral-900 text-white"
                        : "bg-transparent text-neutral-700 dark:text-neutral-300 hover:bg-amber-100/70 dark:hover:bg-[#3d2707]"
                    )}
                  >
                    ⏱️ Absences / retards
                  </button>
                </div>

                {(isAbsencesView || isDocsView) && (
                  <div className="flex flex-wrap items-center gap-2 justify-end">                    {/* 1ère / 2ème */}
                   {isDocsView && (
                      <Button
                        type="button"
                        className="h-8 px-2 text-xs border border-neutral-300 dark:border-sky-400/35 !bg-white dark:!bg-[#182433] !text-neutral-900 dark:!text-neutral-50 hover:!bg-amber-100/70 dark:hover:!bg-[#3d2707]"
                        onClick={handleAddDocFolder}
                        title="Ajouter un porte-document"
                      >
                        <Plus className="w-4 h-4 mr-1" /> Ajouter un dossier
                      </Button>
                    )}
 
                    <div className="inline-flex rounded-full border border-neutral-200 dark:border-sky-400/35 bg-neutral-50 dark:bg-[#182433] p-1 text-xs w-fit">
                     
                      <button
                        type="button"
                        onClick={() => switchTrainingYear("premiere")}
                        className={classNames(
                          "px-3 py-1 rounded-full transition",
                          trainingYear === "premiere"
                            ? "bg-neutral-900 text-white"
                            : "bg-transparent text-neutral-700 dark:text-neutral-300 hover:bg-amber-100/70 dark:hover:bg-[#3d2707]"
                        )}
                      >
                        1ère
                      </button>
                      <button
                        type="button"
                        onClick={() => switchTrainingYear("deuxieme")}
                        className={classNames(
                          "px-3 py-1 rounded-full transition",
                          trainingYear === "deuxieme"
                            ? "bg-neutral-900 text-white"
                            : "bg-transparent text-neutral-700 dark:text-neutral-300 hover:bg-amber-100/70 dark:hover:bg-[#3d2707]"
                        )}
                      >
                        2ème
                      </button>
                    </div>

                    {/* Classe */}
                    {isDocsView ? (
                      <select
                        className="h-8 w-[130px] sm:w-[180px] border border-neutral-300 dark:border-sky-400/35 rounded-md bg-white dark:bg-[#182433] px-2 text-xs"
                        value={selectedClassIdForSuiviDocs ?? ""}
                        onChange={(e) => {
                          const next = e.target.value || null;
                          setSelectedClassIdForSuiviDocs(next);
                          setSelectedStudentForDocs(null);
                        }}
                      >
                        <option value="" disabled>
                          Classe…
                        </option>
                        {classGroups.map((c) => (
                          <option key={c.id} value={c.name}>
                            {c.name}
                          </option>
                        ))}
                      </select>
                    ) : (
                      <select
                        className="h-8 w-[130px] sm:w-[180px] border border-neutral-300 dark:border-sky-400/35 rounded-md bg-white dark:bg-[#182433] px-2 text-xs"
                        value={selectedClassIdForSuivi ?? ""}
                        onChange={(e) => {
                          const next = e.target.value || null;
                          setSelectedClassIdForSuivi(next);
                          setSelectedStudentForSuivi(null);
                          setSelectedEvalIdForClasse(null);
                        }}
                      >
                        <option value="" disabled>
                          Classe…
                        </option>
                        {classGroups.map((c) => (
                          <option key={c.id} value={c.name}>
                            {c.name}
                          </option>
                        ))}
                      </select>
                    )}

                    {/* Élève */}
                    {isDocsView ? (
                      <select
                        className="h-8 w-[190px] sm:w-[200px] border border-neutral-300 dark:border-sky-400/35 rounded-md bg-white dark:bg-[#182433] px-2 text-xs disabled:opacity-60"
                        value={selectedStudentForDocs ?? ""}
                        onChange={(e) => setSelectedStudentForDocs(e.target.value || null)}
                        disabled={!classe || students.length === 0}
                      >
                        <option value="" disabled>
                          Élève…
                        </option>
                        {students.map((st) => (
                          <option key={st} value={st}>
                            {st}
                          </option>
                        ))}
                      </select>
                    ) : !isAbsencesView ? (
                       (() => {
                        const classe = classGroups.find((c) => c.name === selectedClassIdForSuivi);
                        const students = classe
                          ? (classe.students || "")
                              .split("\n")
                              .map((s) => s.trim())
                              .filter(Boolean)
                          : [];
                        const disabled = !classe || students.length === 0;

                        return (
                          <select
                            className="h-8 w-[130px] sm:w-[200px] border border-neutral-300 dark:border-sky-400/35 rounded-md bg-white dark:bg-[#182433] px-2 text-xs disabled:opacity-60"
                            value={selectedStudentForSuivi ?? ""}
                            onChange={(e) => setSelectedStudentForSuivi(e.target.value)}
                            disabled={disabled}
                          >
                            <option value="">Tous les élèves</option>
                            {students.map((st) => (
                              <option key={st} value={st}>
                                {st}
                              </option>
                            ))}
                          </select>
                        );
                            })()
) : null}

                 </div>
                )}


              </div>



              {isAbsencesView && (
                !classeAbs ? (
                  <p className="text-sm text-neutral-600 dark:text-neutral-300">
                    Sélectionnez une classeAbs pour afficher le planning annuel.
                  </p>
                ) : (
                  (() => {
                    const classId = classeAbs.name;
                    const classLabel = sanitizeAbsencesClassName(classId);
                    const yearBucket =
                      (absencesStore.records?.[absencesSchoolYear]?.[classId] || {}) as Record<
                        string,
                        Record<string, AttendanceStatus>
                      >;

                    const startYmd = absencesPlanningSettings.startYmd;
                    const endYmd = absencesPlanningSettings.endYmd;

                    const vacationRanges: VacationRange[] =
                      absencesPlanningSettings.vacationsMode === "auto"
                        ? absencesAutoVacationsForKey || []
                        : (absencesPlanningSettings.vacationsManual || []).map((r) => ({
                            startYmd: r.startYmd,
                            endYmdExclusive: addDaysYmd(r.endYmd, 1),
                            label: r.label || "Vacances",
                          }));

                    const stageRanges: VacationRange[] = (absencesPlanningSettings.stages || []).map((r) => ({
                      startYmd: r.startYmd,
                      endYmdExclusive: addDaysYmd(r.endYmd, 1),
                      label: r.label || "Stage",
                    }));

                    // Base de calcul des % : jours de COURS effectifs (hors vacances et PFMP), du début jusqu'à aujourd'hui
                    const cutoffYmd = todayYmd < endYmd ? todayYmd : endYmd;
                    const effectiveCourseYmdSet = (() => {
                      const set = new Set<string>();
                      const s = fromYmd(startYmd);
                      const e = fromYmd(cutoffYmd);
                      if (!s || !e) return set;
                      for (let d = new Date(s.getTime()); d <= e; d = addDays(d, 1)) {
                        const wdKey = weekdayKeyFromDate(d);
                        if (!absencesPlanningSettings.courseDays?.[wdKey]) continue;
                        const ymd = toYmd(d);
                        if (findLabelInRanges(ymd, vacationRanges)) continue;
                        if (findLabelInRanges(ymd, stageRanges)) continue;
                        set.add(ymd);
                      }
                      return set;
                    })();
                    const effectiveCourseDaysSoFar = effectiveCourseYmdSet.size;


                    // Comptages AB/RT par jour
                    const dayCounts: Record<string, { ab: number; rt: number }> = {};
                    for (const st of studentsAbsFiltered) {
                      const byDate = yearBucket?.[st] || {};
                      for (const [ymd, status] of Object.entries(byDate)) {
                        if (status !== "AB" && status !== "RT") continue;
                        if (!dayCounts[ymd]) dayCounts[ymd] = { ab: 0, rt: 0 };
                        if (status === "AB") dayCounts[ymd].ab += 1;
                        else dayCounts[ymd].rt += 1;
                      }
                    }

                    // Comptages AB/RT par élève (sur la période, jusqu'à aujourd'hui)
                    const studentCounts: Record<string, { ab: number; rt: number }> = {};
                    for (const st of studentsAbsFiltered) {
                      const byDate = yearBucket?.[st] || {};
                      let ab = 0;
                      let rt = 0;
                      for (const [ymd, status] of Object.entries(byDate)) {
                        if (ymd < startYmd || ymd > endYmd) continue;
                        if (!effectiveCourseYmdSet.has(ymd)) continue;
                        if (status === "AB") ab += 1;
                        else if (status === "RT") rt += 1;
                      }
                      studentCounts[st] = { ab, rt };
                    }

                    const studentRisk = (st: string) => {
                      const c = studentCounts[st] || { ab: 0, rt: 0 };
                      const abPct = effectiveCourseDaysSoFar > 0 ? (c.ab / effectiveCourseDaysSoFar) * 100 : 0;
                      const rtPct = effectiveCourseDaysSoFar > 0 ? (c.rt / effectiveCourseDaysSoFar) * 100 : 0;

                      const tooAb = absencesAlertAbsPct > 0 && abPct >= absencesAlertAbsPct;
                      const tooRt = absencesAlertRtPct > 0 && rtPct >= absencesAlertRtPct;
                      const midAb = absencesWarnAbsPct > 0 && abPct >= absencesWarnAbsPct;
                      const midRt = absencesWarnRtPct > 0 && rtPct >= absencesWarnRtPct;
                      const severity: TrafficLightColor = (tooAb || tooRt) ? "red" : (midAb || midRt) ? "yellow" : "green";
                      return { ...c, abPct, rtPct, tooAb, tooRt, midAb, midRt, severity };
                    };

                    const studentTintClass = (st: string) => {
                      const r = studentRisk(st);
                      if (r.severity === "red") return "bg-red-50 dark:bg-red-950/30 text-red-900 dark:text-red-50";
                      if (r.severity === "yellow") return "bg-amber-50 dark:bg-amber-950/30 text-amber-900 dark:text-amber-50";
                      return "bg-white dark:bg-[#1f2d42] text-neutral-900 dark:text-neutral-300";
                    };

                    const studentCardTintClass = (st: string) => {
                      const r = studentRisk(st);
                      if (r.severity === "red") return "border-red-300 bg-red-50/60 dark:bg-red-950/20 dark:border-red-500/40";
                      if (r.severity === "yellow") return "border-amber-300 bg-amber-50/60 dark:bg-amber-950/20 dark:border-amber-500/40";
                      return "border-neutral-200 dark:border-sky-400/35";
                    };

                    const selectedDateRaw = absencesSelectedDateYmd;

                    // Timeline (style "progression") : colonnes = jours de cours entre début/fin
                    const MONTHS_FR_SHORT = ["jan","fév","mar","avr","mai","juin","juil","août","sept","oct","nov","déc"];

                    const getIsoWeekInfo = (d: Date) => {
                      // ISO week based on UTC (robuste autour des changements d'année)
                      const dt = new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate()));
                      const dayNum = dt.getUTCDay() || 7; // 1..7 (lundi..dimanche)
                      dt.setUTCDate(dt.getUTCDate() + 4 - dayNum); // jeudi de la semaine courante
                      const isoYear = dt.getUTCFullYear();
                      const yearStart = new Date(Date.UTC(isoYear, 0, 1));
                      const weekNo = Math.ceil((((dt.getTime() - yearStart.getTime()) / 86400000) + 1) / 7);
                      const key = `${isoYear}-W${String(weekNo).padStart(2, "0")}`;
                      return { isoYear, weekNo, key };
                    };

                    type AbsTimelineCol = {
                      ymd: string;
                      date: Date;
                      y: number;
                      m0: number;
                      day: number;
                      wdLabel: string;
                      isoWeekKey: string;
                      isoWeekNo: number;
                      isoYear: number;
                      vacLabel: string | null;
                      stageLabel: string | null;
                    };

                    const timelineDaysAll: AbsTimelineCol[] = (() => {
                      const s = fromYmd(startYmd);
                      const e = fromYmd(endYmd);
                      if (!s || !e) return [];
                      const out: AbsTimelineCol[] = [];
                      const wdLabels = ["L", "M", "M", "J", "V", "S", "D"];
                      for (let d = new Date(s.getTime()); d <= e; d = addDays(d, 1)) {
                        const wdKey = weekdayKeyFromDate(d);
                        if (!absencesPlanningSettings.courseDays?.[wdKey]) continue;
                        const ymd = toYmd(d);
                        const iso = getIsoWeekInfo(d);
                        out.push({
                          ymd,
                          date: new Date(d.getTime()),
                          y: d.getFullYear(),
                          m0: d.getMonth(),
                          day: d.getDate(),
                          wdLabel: wdLabels[weekdayIndexMon0(d)] || "",
                          isoWeekKey: iso.key,
                          isoWeekNo: iso.weekNo,
                          isoYear: iso.isoYear,
                          vacLabel: findLabelInRanges(ymd, vacationRanges),
                          stageLabel: findLabelInRanges(ymd, stageRanges),
                        });
                      }
                      return out;
                    })();

                    // Démarrage d'affichage : semaine en cours (lundi) → fin
                    const currentWeekStartYmd = (() => {
                      const td = fromYmd(todayYmd);
                      if (!td) return todayYmd;
                      return toYmd(addDays(td, -weekdayIndexMon0(td)));
                    })();

                    const displayStartYmd = (() => {
                      if (absencesShowAllWeeks) return startYmd;
                      if (!timelineDaysAll.length) return startYmd;
                      const anchor = absencesDisplayStartYmd || currentWeekStartYmd;
                      const first = timelineDaysAll.find((c) => c.ymd >= anchor);
                      if (first) return first.ymd;
                      // si on est après la période, on montre la dernière semaine disponible
                      const idx = Math.max(0, timelineDaysAll.length - 5);
                      return timelineDaysAll[idx].ymd;
                    })();

                    const timelineDays: AbsTimelineCol[] = absencesShowAllWeeks
                      ? timelineDaysAll
                      : timelineDaysAll.filter((c) => c.ymd >= displayStartYmd);

                    // Date sélectionnée : si hors affichage (filtré), on prend la 1ère date visible
                    const selectedDate = (() => {
                      if (!timelineDays.length) return selectedDateRaw;
                      if (timelineDays.some((d) => d.ymd === selectedDateRaw)) return selectedDateRaw;
                      return timelineDays[0].ymd;
                    })();

                    const selectedCounts = dayCounts[selectedDate] || { ab: 0, rt: 0 };

                    const selectedDateObj = fromYmd(selectedDate);
                    const selectedWeekday =
                      selectedDateObj ? WEEKDAYS_FR_SHORT[weekdayIndexMon0(selectedDateObj)] : "";

                    const selectedVacationLabel = findLabelInRanges(selectedDate, vacationRanges);
                    const selectedStageLabel = findLabelInRanges(selectedDate, stageRanges);

                    const monthSegments = (() => {
                      const segs: Array<{ key: string; label: string; span: number }> = [];
                      for (const col of timelineDays) {
                        const k = `${col.y}-${col.m0}`;
                        const label =
                          (MONTHS_FR[col.m0] ? MONTHS_FR[col.m0].slice(0, 1).toUpperCase() + MONTHS_FR[col.m0].slice(1) : `M${col.m0 + 1}`) +
                          " " +
                          col.y;
                        const last = segs[segs.length - 1];
                        if (!last || last.key !== k) segs.push({ key: k, label, span: 1 });
                        else last.span += 1;
                      }
                      return segs;
                    })();

                    const weekSegments = (() => {
                      const segs: Array<{ key: string; isoWeekNo: number; isoYear: number; startYmd: string; endYmd: string; span: number }> = [];
                      for (const col of timelineDays) {
                        const last = segs[segs.length - 1];
                        if (!last || last.key !== col.isoWeekKey) {
                          segs.push({ key: col.isoWeekKey, isoWeekNo: col.isoWeekNo, isoYear: col.isoYear, startYmd: col.ymd, endYmd: col.ymd, span: 1 });
                        } else {
                          last.span += 1;
                          last.endYmd = col.ymd;
                        }
                      }
                      return segs;
                    })();

                    type PeriodKind = "PFMP" | "VACANCES" | "COURS";
                    const periodKindOf = (col: AbsTimelineCol): PeriodKind =>
                      col.stageLabel ? "PFMP" : col.vacLabel ? "VACANCES" : "COURS";

                    type AbsWeekCol = {
                      key: string;
                      isoWeekNo: number;
                      isoYear: number;
                      startYmd: string;
                      endYmd: string;
                      days: AbsTimelineCol[];
                      kind: PeriodKind;
                      label: string;
                      mixed: boolean;
                    };

                    const weekCols: AbsWeekCol[] = (() => {
                      const out: AbsWeekCol[] = [];
                      for (const day of timelineDays) {
                        const last = out[out.length - 1];
                        if (!last || last.key !== day.isoWeekKey) {
                          out.push({
                            key: day.isoWeekKey,
                            isoWeekNo: day.isoWeekNo,
                            isoYear: day.isoYear,
                            startYmd: day.ymd,
                            endYmd: day.ymd,
                            days: [day],
                            kind: "COURS",
                            label: "",
                            mixed: false,
                          });
                        } else {
                          last.days.push(day);
                          last.endYmd = day.ymd;
                        }
                      }

                      for (const w of out) {
                        const kinds = w.days.map(periodKindOf);
                        const allSameKind = kinds.every((k) => k === kinds[0]);
                        const containsVac = kinds.includes("VACANCES");
                        const containsStage = kinds.includes("PFMP");

                        if (allSameKind && kinds[0] !== "COURS") {
                          w.kind = kinds[0];
                          if (w.kind === "VACANCES") {
                            const labels = w.days.map((d) => d.vacLabel || "Vacances");
                            const first = labels[0];
                            w.label = labels.every((x) => x === first) ? first : "Vacances";
                          } else if (w.kind === "PFMP") {
                            const labels = w.days.map((d) => d.stageLabel || "PFMP");
                            const first = labels[0];
                            w.label = labels.every((x) => x === first) ? first : "PFMP";
                          }
                          w.mixed = false;
                        } else if (!containsVac && !containsStage) {
                          w.kind = "COURS";
                          w.label = "";
                          w.mixed = false;
                        } else {
                          w.kind = "COURS";
                          w.label = "Mixte";
                          w.mixed = true;
                        }
                      }

                      return out;
                    })();

                    
                                        type SemesterKey = "S1" | "S2";
                    type SemesterInfo = {
                      key: SemesterKey;
                      title: string;
                      startYmd: string;
                      endYmdExclusive: string;
                    };

                    const yearEndExclusive = addDaysYmd(endYmd, 1);

                    const winterVac = vacationRanges.find((r) => /vacances.*hiver/i.test(r.label || ""));
                    const summerVac = vacationRanges.find((r) => /vacances.*(ete|été)/i.test(r.label || ""));

                    const syParsed = parseSchoolYearString(absencesSchoolYear);
                    const fallbackWinterStart = syParsed ? `${syParsed.endYear}-02-01` : `${new Date().getFullYear()}-02-01`;

                    const clampYmd = (ymdIn: string, minYmd: string, maxYmd: string) => {
                      if (ymdIn < minYmd) return minYmd;
                      if (ymdIn > maxYmd) return maxYmd;
                      return ymdIn;
                    };

                    const s1StartYmd = startYmd;
                    const s1EndExclYmd = clampYmd(winterVac?.startYmd || fallbackWinterStart, startYmd, yearEndExclusive);
                    const s2StartYmd = clampYmd(winterVac?.endYmdExclusive || s1EndExclYmd, startYmd, yearEndExclusive);
                    const s2EndExclYmd = clampYmd(summerVac?.startYmd || yearEndExclusive, startYmd, yearEndExclusive);

                    const semestersBase: SemesterInfo[] = [
  { key: "S1", title: "Semestre 1", startYmd: s1StartYmd, endYmdExclusive: s1EndExclYmd },
  { key: "S2", title: "Semestre 2", startYmd: s2StartYmd, endYmdExclusive: s2EndExclYmd },
];

const semesters: SemesterInfo[] = semestersBase.map((s): SemesterInfo => {
  let st = clampYmd(s.startYmd, startYmd, yearEndExclusive);
  let en = clampYmd(s.endYmdExclusive, startYmd, yearEndExclusive);
  if (en <= st) en = addDaysYmd(st, 1);
  return { ...s, startYmd: st, endYmdExclusive: en };
});

                    const semS1: SemesterInfo =
                      semesters.find((s) => s.key === "S1") ||
                      semesters[0] ||
                      { key: "S1", title: "Semestre 1", startYmd: startYmd, endYmdExclusive: addDaysYmd(startYmd, 1) };

                    const semS2: SemesterInfo =
                      semesters.find((s) => s.key === "S2") ||
                      semesters[1] ||
                      { key: "S2", title: "Semestre 2", startYmd: addDaysYmd(startYmd, 1), endYmdExclusive: addDaysYmd(startYmd, 2) };

                    const currentSemesterKey: SemesterKey = (() => {
                      if (todayYmd >= semS2.startYmd) return "S2";
                      return "S1";
                    })();

                    const formatSemesterRangeShort = (sem: SemesterInfo) => {
                      const endIncl = addDaysYmd(sem.endYmdExclusive, -1);
                      return formatWeekRangeShort(sem.startYmd, endIncl);
                    };

                    const plannedCourseDaysBySemester: Record<SemesterKey, number> = (() => {
                      const out: Record<SemesterKey, number> = { S1: 0, S2: 0 };
                      for (const day of timelineDaysAll) {
                        if (periodKindOf(day) !== "COURS") continue;
                        for (const sem of semesters) {
                          if (day.ymd >= sem.startYmd && day.ymd < sem.endYmdExclusive) out[sem.key] += 1;
                        }
                      }
                      return out;
                    })();

                    const effectiveCourseDaysBySemesterSoFar: Record<SemesterKey, number> = (() => {
                      const out: Record<SemesterKey, number> = { S1: 0, S2: 0 };
                      for (const ymd of effectiveCourseYmdSet) {
                        for (const sem of semesters) {
                          if (ymd >= sem.startYmd && ymd < sem.endYmdExclusive) out[sem.key] += 1;
                        }
                      }
                      return out;
                    })();

                    const studentSemesterCounts: Record<string, Record<SemesterKey, { ab: number; rt: number }>> = (() => {
                      const out: Record<string, Record<SemesterKey, { ab: number; rt: number }>> = {};
                      for (const st of studentsAbsFiltered) {
                        const byDate = yearBucket?.[st] || {};
                        const semMap: Record<SemesterKey, { ab: number; rt: number }> = {
                          S1: { ab: 0, rt: 0 },
                          S2: { ab: 0, rt: 0 },
                        };

                        for (const [ymd, status] of Object.entries(byDate)) {
                          if (status !== "AB" && status !== "RT") continue;
                          if (ymd < startYmd || ymd > cutoffYmd) continue;
                          if (!effectiveCourseYmdSet.has(ymd)) continue;

                          const sem = semesters.find((s) => ymd >= s.startYmd && ymd < s.endYmdExclusive);
                          if (!sem) continue;

                          if (status === "AB") semMap[sem.key].ab += 1;
                          else semMap[sem.key].rt += 1;
                        }

                        out[st] = semMap;
                      }
                      return out;
                    })();

const absencesWeekColPx = Math.max(34, absencesDayColPx);
                    const absencesMergedDayColPx = 12; // largeur fixe pour les jours fusionnés (vacances / PFMP)
                    const absencesMergedWeekDayColPx = 4; // largeur par jour quand la semaine est 100% VACANCES / PFMP (vue compacte)
                    const mergedWeekKeys = new Set(weekCols.filter((w) => w.kind !== "COURS").map((w) => w.key));

                    const colPxForDay = (col: AbsTimelineCol) => {
                      if (periodKindOf(col) === "COURS") return absencesDayColPx;
                      if (mergedWeekKeys.has(col.isoWeekKey)) return absencesMergedWeekDayColPx;
                      return absencesMergedDayColPx;
                    };
const monthSegmentsWeeks = (() => {
                      const segs: Array<{ key: string; label: string; span: number }> = [];
                      for (const w of weekCols) {
                        const d = fromYmd(w.startYmd);
                        if (!d) continue;
                        const y = d.getFullYear();
                        const m0 = d.getMonth();
                        const k = `${y}-${m0}`;
                        const label =
                          (MONTHS_FR[m0] ? MONTHS_FR[m0].slice(0, 1).toUpperCase() + MONTHS_FR[m0].slice(1) : `M${m0 + 1}`) +
                          " " +
                          y;
                        const last = segs[segs.length - 1];
                        if (!last || last.key !== k) segs.push({ key: k, label, span: 1 });
                        else last.span += 1;
                      }
                      return segs;
                    })();

                    const borderLeftWeekClass = (idx: number) => {
                      if (idx === 0) return "";
                      const prev = weekCols[idx - 1];
                      const cur = weekCols[idx];
                      const prevD = fromYmd(prev.startYmd);
                      const curD = fromYmd(cur.startYmd);
                      if (prevD && curD) {
                        if (prevD.getMonth() !== curD.getMonth() || prevD.getFullYear() !== curD.getFullYear()) {
                          return "border-l-4 border-l-neutral-900/80 dark:border-l-neutral-200/70";
                        }
                      }
                      return "border-l-2 border-l-neutral-900/70 dark:border-l-neutral-200/60";
                    };

                    type DaySeg =
                      | { kind: "MERGED"; period: Exclude<PeriodKind, "COURS">; label: string; startIdx: number; span: number; startYmd: string; endYmd: string }
                      | { kind: "DAY"; idx: number };

                    const daySegments: DaySeg[] = (() => {
                      const segs: DaySeg[] = [];

                      for (let i = 0; i < timelineDays.length; ) {
                        const col = timelineDays[i];
                        const k = periodKindOf(col);

                        // COURS => 1 cellule par jour
                        if (k === "COURS") {
                          segs.push({ kind: "DAY", idx: i });
                          i += 1;
                          continue;
                        }

                        // VACANCES ou PFMP => fusion des jours consécutifs avec même kind ET même label
                        const label =
                          k === "PFMP"
                            ? (col.stageLabel || "PFMP")
                            : (col.vacLabel || "Vacances");

                        let j = i + 1;
                        while (j < timelineDays.length) {
                          const c2 = timelineDays[j];
                          const k2 = periodKindOf(c2);
                          if (k2 !== k) break;

                          const prevDay = timelineDays[j - 1];
                          if (c2.isoWeekKey !== prevDay.isoWeekKey) break; // coupe à chaque changement de semaine

                          if (c2.m0 !== prevDay.m0 || c2.y !== prevDay.y) break; // coupe à chaque changement de mois

                          const label2 =
                            k2 === "PFMP"
                              ? (c2.stageLabel || "PFMP")
                              : (c2.vacLabel || "Vacances");

                          if (label2 !== label) break;
                          j += 1;
                        }

                        segs.push({
                          kind: "MERGED",
                          period: k as Exclude<PeriodKind, "COURS">,
                          label,
                          startIdx: i,
                          span: j - i,
                          startYmd: timelineDays[i].ymd,
                          endYmd: timelineDays[j - 1].ymd,
                        });

                        i = j;
                      }

                      return segs;
                    })();

                    const periodBgClass = (kind: PeriodKind) => {
                      if (kind === "PFMP") return "bg-orange-200/90 text-orange-900 dark:bg-orange-900/25 dark:text-orange-100";
                      if (kind === "VACANCES") return "bg-blue-800/90 text-white dark:bg-blue-900/45 dark:text-white";
                      return "bg-white dark:bg-[#1f2d42] text-neutral-900 dark:text-neutral-300";
                    };


                    const weekCellBgClass = (w: AbsWeekCol) => {
                      if (w.mixed) return "bg-neutral-100 dark:bg-[#22324a] text-neutral-900 dark:text-neutral-300";
                      return periodBgClass(w.kind);
                    };

                    const formatWeekRangeShort = (startYmdIn: string, endYmdIn: string) => {
                      const sD = fromYmd(startYmdIn);
                      const eD = fromYmd(endYmdIn);
                      if (!sD || !eD) return `${formatYmdFr(startYmdIn)} → ${formatYmdFr(endYmdIn)}`;
                      const sd = String(sD.getDate()).padStart(2, "0");
                      const ed = String(eD.getDate()).padStart(2, "0");
                      const sm = MONTHS_FR_SHORT[sD.getMonth()] || "";
                      const em = MONTHS_FR_SHORT[eD.getMonth()] || "";
                      if (sD.getMonth() === eD.getMonth()) return `du ${sd} au ${ed} ${sm}`;
                      return `du ${sd} ${sm} au ${ed} ${em}`;
                    };

                    const monthBandBgClass = (m0: number) =>
                      m0 % 2 === 0 ? "bg-white dark:bg-[#1f2d42]" : "bg-neutral-100 dark:bg-[#22324a]";

                    const monthHeaderBgClass = (key: string) => {
                      const parts = key.split("-");
                      const m0 = parseInt(parts[1] ?? "0", 10);
                      return monthBandBgClass(Number.isFinite(m0) ? m0 : 0);
                    };

                    const cellBgClass = (col: AbsTimelineCol) => {
                      const k = periodKindOf(col);
                      if (k === "COURS") return classNames(monthBandBgClass(col.m0), "text-neutral-900 dark:text-neutral-300");
                      return periodBgClass(k);
                    };

                    const borderLeftClass = (idx: number) => {
                      if (idx === 0) return "";
                      const prev = timelineDays[idx - 1];
                      const cur = timelineDays[idx];
                      if (prev.isoWeekKey !== cur.isoWeekKey) return "border-l-2 border-l-neutral-900/70 dark:border-l-neutral-200/60";
                      if (prev.m0 !== cur.m0 || prev.y !== cur.y) return ""; // mois différenciés par fond (pas de barre noire)
                      return "";
                    };

const isMonthStartIdx = (idx: number) => {
                      if (idx <= 0) return true;
                      const prev = timelineDays[idx - 1];
                      const cur = timelineDays[idx];
                      return prev.m0 !== cur.m0 || prev.y !== cur.y;
                    };

                    const isMonthEndIdx = (idx: number) => {
                      if (idx >= timelineDays.length - 1) return true;
                      const cur = timelineDays[idx];
                      const next = timelineDays[idx + 1];
                      return cur.m0 !== next.m0 || cur.y !== next.y;
                    };

                    const monthFrameLeftClass = (idx: number) =>
                      isMonthStartIdx(idx) ? "border-l-2 border-l-neutral-400 dark:border-l-neutral-500" : "";

                    const monthFrameRightClass = (idx: number) =>
                      isMonthEndIdx(idx) ? "border-r-2 border-r-neutral-400 dark:border-r-neutral-500" : "";

                                        const renderProgressionTable = () => {
                      if (!timelineDays.length) {
                        return (
                          <p className="text-xs text-neutral-500 dark:text-neutral-300">
                            Aucune date dans la plage.
                          </p>
                        );
                      }

                                            if (absencesTimelineView === "week") {
                        // Vue "Semaine" : on garde les semaines en en-tête, mais on conserve le détail Jour (Lun..Ven)
                        // et on fusionne verticalement (rowSpan) les périodes VACANCES / PFMP.
                        return (
                          <div className="rounded-xl border border-neutral-200 dark:border-sky-400/35 bg-white dark:bg-[#1f2d42] overflow-hidden">
                            <div className="overflow-x-auto">
                              <table className="absences-grid border-collapse text-[10px] table-fixed w-max">

                                <colgroup>
                                  <col style={{ width: 200 }} />
                                  {timelineDays.map((col) => (
                                    <col key={col.ymd} style={{ width: colPxForDay(col) }} />
                                  ))}
                                </colgroup>

                                <thead className="sticky top-0 bg-white dark:bg-[#1f2d42] z-10">
                                  <tr>
                                    <th className="sticky left-0 z-20 bg-white dark:bg-[#1f2d42] border border-neutral-200 dark:border-sky-400/35 w-[200px] min-w-[200px] max-w-[200px] px-2 py-1 text-[11px] font-semibold text-neutral-700 dark:text-neutral-300">
                                      CALENDRIER {absencesSchoolYear}
                                    </th>
                                    {monthSegments.map((m) => (
                                      <th
                                        key={m.key}
                                        colSpan={m.span}
                                        className={classNames("border border-neutral-200 dark:border-sky-400/35 px-2 py-1 text-[11px] font-semibold text-neutral-900 dark:text-neutral-300 text-center", monthHeaderBgClass(m.key))}
                                      >
                                        {m.label}
                                      </th>
                                    ))}
                                  </tr>

                                  <tr>
                                    <th className="sticky left-0 z-20 bg-white dark:bg-[#1f2d42] border border-neutral-200 dark:border-sky-400/35 w-[200px] min-w-[200px] max-w-[200px] px-2 py-1 text-[11px] font-semibold text-neutral-700 dark:text-neutral-300">
                                      SEMAINE
                                    </th>
                                 {weekSegments.map((w) => (
  <th
    key={w.key}
    colSpan={w.span}
    className="border border-neutral-200 dark:border-sky-400/35 px-0 py-1 text-[10px] text-neutral-700 dark:text-neutral-300 text-center align-middle"
  >
    <div className="w-full h-full flex items-center justify-center">
      <span
        className="px-1 leading-none inline-block"
        style={{ writingMode: "vertical-rl", transform: "rotate(180deg)" }}
      >
        {formatWeekRangeShort(w.startYmd, w.endYmd)}
      </span>
    </div>
  </th>
))}

                                  </tr>

                                  <tr>
                                    <th className="sticky left-0 z-20 bg-white dark:bg-[#1f2d42] border border-neutral-200 dark:border-sky-400/35 w-[200px] min-w-[200px] max-w-[200px] px-2 py-1 text-[11px] font-semibold text-neutral-700 dark:text-neutral-300">
                                      SEMAINE N°
                                    </th>
                                    {weekSegments.map((w) => (
                                      <th
                                        key={w.key + "-no"}
                                        colSpan={w.span}
                                        className="border border-neutral-200 dark:border-sky-400/35 px-0 py-1 text-[11px] font-semibold text-neutral-900 dark:text-neutral-300 text-center"
                                      >
                                        <div className="relative w-full h-full">
                                          {w.endYmd < todayYmd && (
                                            <svg
                                              aria-hidden
                                              className="absolute inset-0 w-full h-full pointer-events-none"
                                              viewBox="0 0 100 40"
                                              preserveAspectRatio="none"
                                            >
                                              <line
                                                x1="0"
                                                y1="0"
                                                x2="100"
                                                y2="40"
                                                stroke="currentColor"
                                                strokeWidth="4"
                                                className="text-neutral-900/70 dark:text-neutral-300/70"
                                              />
                                              <line
                                                x1="0"
                                                y1="40"
                                                x2="100"
                                                y2="0"
                                                stroke="currentColor"
                                                strokeWidth="4"
                                                className="text-neutral-900/70 dark:text-neutral-300/70"
                                              />
                                            </svg>
                                          )}
                                          <div className="relative z-10 flex items-center justify-center">{w.isoWeekNo}</div>
                                        </div>
                                      </th>
                                    ))}
                                  </tr>

                                  <tr>
                                    <th className="sticky left-0 z-20 bg-white dark:bg-[#1f2d42] border border-neutral-200 dark:border-sky-400/35 w-[200px] min-w-[200px] max-w-[200px] px-2 py-1 text-[11px] font-semibold text-neutral-700 dark:text-neutral-300">
                                      JOUR
                                    </th>

                                    {daySegments.map((seg) => {
                                      if (seg.kind === "MERGED") {
                                        const sD = fromYmd(seg.startYmd);
                                        const eD = fromYmd(seg.endYmd);
                                        const dom =
                                          sD && eD
                                            ? sD.getMonth() === eD.getMonth()
                                              ? `${String(sD.getDate()).padStart(2, "0")}–${String(eD.getDate()).padStart(2, "0")}`
                                              : `${String(sD.getDate()).padStart(2, "0")}${MONTHS_FR_SHORT[sD.getMonth()]}–${String(eD.getDate()).padStart(2, "0")}${MONTHS_FR_SHORT[eD.getMonth()]}`
                                            : "";

                                        const first = timelineDays[seg.startIdx];
                                        return (
                                          <th
                                            key={`dom-${seg.period}-${seg.startYmd}`}
                                            colSpan={seg.span}
                                            style={{ height: absencesDayColPx }}
                                            className={classNames(
                                              "border border-neutral-200 dark:border-sky-400/35 text-center font-semibold",
                                              cellBgClass(first),
                                              borderLeftClass(seg.startIdx), monthFrameLeftClass(seg.startIdx), monthFrameRightClass(seg.startIdx + seg.span - 1)
                                            )}
                                            title={`${formatYmdFr(seg.startYmd)} → ${formatYmdFr(seg.endYmd)} — ${seg.period}: ${seg.label}`}
                                          >
                                            {dom}
                                          </th>
                                        );
                                      }

                                      const col = timelineDays[seg.idx];
                                      const idx = seg.idx;
                                      return (
                                        <th
                                          key={col.ymd + "-dom"}
                                          style={{ height: absencesDayColPx }}
                                          className={classNames(
                                            "border border-neutral-200 dark:border-sky-400/35 text-center font-semibold",
                                            cellBgClass(col),
                                            borderLeftClass(idx), monthFrameLeftClass(idx), monthFrameRightClass(idx)
                                          )}
                                          title={formatYmdFr(col.ymd)}
                                        >
                                          {col.date.getDate()}
                                        </th>
                                      );
                                    })}
                                  </tr>

                                  <tr>
                                    <th className="sticky left-0 z-20 bg-white dark:bg-[#1f2d42] border border-neutral-200 dark:border-sky-400/35 w-[200px] min-w-[200px] max-w-[200px] px-2 py-1 text-[11px] font-semibold text-neutral-700 dark:text-neutral-300">
                                      JOURS SEMAINE
                                    </th>

                                    {daySegments.map((seg) => {
                                      // pour VACANCES / PFMP : pas de libellé ici (il est dans la cellule fusionnée du tbody)
                                      if (seg.kind === "MERGED") {
                                        const first = timelineDays[seg.startIdx];
                                        return (
                                          <th
                                            key={`h-week-${seg.period}-${seg.startYmd}`}
                                            colSpan={seg.span}
                                            style={{ height: absencesDayColPx }}
                                            className={classNames(
                                              "border border-neutral-200 dark:border-sky-400/35 text-center font-semibold",
                                              cellBgClass(first),
                                              borderLeftClass(seg.startIdx), monthFrameLeftClass(seg.startIdx), monthFrameRightClass(seg.startIdx + seg.span - 1)
                                            )}
                                            title={`${formatYmdFr(seg.startYmd)} → ${formatYmdFr(seg.endYmd)} — ${seg.period}: ${seg.label}`}
                                          />
                                        );
                                      }

                                      const col = timelineDays[seg.idx];
                                      const idx = seg.idx;

                                      return (
                                        <th
                                          key={col.ymd}
                                          style={{ height: absencesDayColPx }}
                                          className={classNames(
                                            "border border-neutral-200 dark:border-sky-400/35 text-center font-semibold",
                                            cellBgClass(col),
                                            borderLeftClass(idx), monthFrameLeftClass(idx), monthFrameRightClass(idx)
                                          )}
                                          title={`${formatYmdFr(col.ymd)}${col.stageLabel ? ` — PFMP: ${col.stageLabel}` : ""}${col.vacLabel ? ` — Vacances: ${col.vacLabel}` : ""}`}
                                        >
                                          <button type="button" className="w-full h-full" onClick={() => setAbsencesSelectedDateYmd(col.ymd)}>
                                            {col.wdLabel}
                                          </button>
                                        </th>
                                      );
                                    })}
                                  </tr>
                                </thead>

                                <tbody>
                                  {studentsAbsFiltered.map((st, stIdx) => (
                                    <tr key={st}>
                                      <td
  className={classNames(
    "sticky left-0 z-10 border border-neutral-200 dark:border-sky-400/35 w-[200px] min-w-[200px] max-w-[200px] px-2 py-1 text-[13px] font-medium whitespace-nowrap",
    studentTintClass(st)
  )}
>
  <div className="student-name-row flex items-center justify-between gap-2 min-w-0">
    <span className="student-name truncate flex-1 min-w-0">{st}</span>
    {(() => {
      const r = studentRisk(st);
      if (!r.ab && !r.rt) return null;
      const abp = Math.round(r.abPct || 0);
      const rtp = Math.round(r.rtPct || 0);
    })()}
  </div>
</td>

                                      {daySegments.map((seg) => {
                                        // VACANCES / PFMP : 1 seule cellule sur toute la hauteur + colSpan sur la plage
                                        if (seg.kind === "MERGED") {
                                          if (stIdx !== 0) return null;
                                          const first = timelineDays[seg.startIdx];

                                          return (
                                            <td
                                              key={`merged-${seg.period}-${seg.startYmd}`}
                                              rowSpan={Math.max(1, studentsAbs.length)}
                                              colSpan={seg.span}
                                              style={{ height: absencesDayColPx }}
                                              className={classNames(
                                                "border border-neutral-200 dark:border-sky-400/35 text-center select-none cursor-pointer",
                                                cellBgClass(first),
                                                borderLeftClass(seg.startIdx), monthFrameLeftClass(seg.startIdx), monthFrameRightClass(seg.startIdx + seg.span - 1)
                                              )}
                                              onClick={() => setAbsencesSelectedDateYmd(seg.startYmd)}
                                              title={`${formatYmdFr(seg.startYmd)} → ${formatYmdFr(seg.endYmd)} — ${seg.period}: ${seg.label}`}
                                            >
                                              <div
                                                className="mx-auto flex items-center justify-center h-full w-[12px] min-w-[12px] max-w-[12px] overflow-hidden px-0 text-[10px] font-semibold"
                                                style={{ writingMode: "vertical-rl", transform: "rotate(180deg)" }}
                                              >
                                                {seg.label}
                                              </div>
                                            </td>
                                          );
                                        }

                                        // jour normal => cellule cliquable AB/RT
                                        const col = timelineDays[seg.idx];
                                        const idx = seg.idx;

                                        const curStatus = yearBucket?.[st]?.[col.ymd] || null;
                                        const isSel = col.ymd === selectedDate;
                                        const nextStatus: AttendanceStatus | null =
                                          curStatus === "RT" ? "AB" : curStatus === "AB" ? null : "RT";

                                        return (
                                          <td
                                            key={st + "-" + col.ymd}
                                            style={{ height: absencesDayColPx }}
                                            className={classNames(
                                              "border border-neutral-200 dark:border-sky-400/35 text-center cursor-pointer select-none",
                                              cellBgClass(col),
                                              borderLeftClass(idx), monthFrameLeftClass(idx), monthFrameRightClass(idx),
                                              isSel && "ring-2 ring-inset ring-neutral-900 dark:ring-neutral-200"
                                            )}
                                            onClick={() => {
                                              setAbsencesSelectedDateYmd(col.ymd);
                                              setAbsenceStatus(absencesSchoolYear, classId, st, col.ymd, nextStatus);
                                            }}
                                            title={`${st} — ${formatYmdFr(col.ymd)}`}
                                          >
                                            {curStatus === "AB" ? (
                                              <span className="text-[10px] font-bold text-red-600 dark:text-red-200">AB</span>
                                            ) : curStatus === "RT" ? (
                                              <span className="text-[10px] font-bold text-amber-700 dark:text-amber-200">RT</span>
                                            ) : (
                                              ""
                                            )}
                                          </td>
                                        );
                                      })}
                                    </tr>
                                  ))}
                                </tbody>
                              </table>
                            </div>
                          </div>
                        );
                      }




                      return (
                        <div className="rounded-xl border border-neutral-200 dark:border-sky-400/35 bg-white dark:bg-[#1f2d42] overflow-hidden">
                          <div className="overflow-x-auto">
                            <table className="absences-grid border-collapse text-[10px] table-fixed w-max">

                              <colgroup>
                                <col style={{ width: 200 }} />
                                {timelineDays.map((col) => (
                                  <col key={col.ymd} style={{ width: colPxForDay(col) }} />
                                ))}
                              </colgroup>
                              <thead className="sticky top-0 bg-white dark:bg-[#1f2d42] z-10">
                                <tr>
                                  <th className="sticky left-0 z-20 bg-white dark:bg-[#1f2d42] border border-neutral-200 dark:border-sky-400/35 w-[200px] min-w-[200px] max-w-[200px] px-2 py-1 text-[11px] font-semibold text-neutral-700 dark:text-neutral-300"></th>
                                  CALENDRIER {absencesSchoolYear} 
                                  {monthSegments.map((m) => (
                                    <th
                                      key={m.key}
                                      colSpan={m.span}
                                      className={classNames("border border-neutral-200 dark:border-sky-400/35 px-2 py-1 text-[11px] font-semibold text-neutral-900 dark:text-neutral-300 text-center", monthHeaderBgClass(m.key))}
                                    >
                                      {m.label}
                                    </th>
                                  ))}
                                </tr>

     <tr className="h-24">
  <th className="sticky left-0 z-20 bg-white dark:bg-[#1f2d42] border border-neutral-200 dark:border-sky-400/35 w-[200px] min-w-[200px] max-w-[200px] px-2 py-1 text-[11px] font-semibold text-neutral-700 dark:text-neutral-300 align-middle">
    SEMAINE
  </th>

{weekSegments.map((w) => (
  <th
    key={w.key}
    colSpan={w.span}
    className="border border-neutral-200 dark:border-sky-400/35 px-0 py-1 text-[10px] text-neutral-700 dark:text-neutral-300 text-center align-middle"
  >
    <div className="w-full h-full flex items-center justify-center">
      <span
        className="px-1 leading-none inline-block"
        style={{ writingMode: "vertical-rl", transform: "rotate(180deg)" }}
      >
        {formatWeekRangeShort(w.startYmd, w.endYmd)}
      </span>
    </div>
  </th>
))}

</tr>


                                <tr>
                                  <th className="sticky left-0 z-20 bg-white dark:bg-[#1f2d42] border border-neutral-200 dark:border-sky-400/35 w-[200px] min-w-[200px] max-w-[200px] px-2 py-1 text-[11px] font-semibold text-neutral-700 dark:text-neutral-300">
                                    SEMAINE N°
                                  </th>
                                  {weekSegments.map((w) => (
                                    <th
                                      key={w.key + "-no"}
                                      colSpan={w.span}
                                      className="border border-neutral-200 dark:border-sky-400/35 px-0 py-1 text-[11px] font-semibold text-neutral-900 dark:text-neutral-300 text-center"
                                    >
                                      <div className="relative w-full h-full">
                                        {w.endYmd < todayYmd && (
                                          <svg
                                            aria-hidden
                                            className="absolute inset-0 w-full h-full pointer-events-none"
                                            viewBox="0 0 100 40"
                                            preserveAspectRatio="none"
                                          >
                                            <line
                                              x1="0"
                                              y1="0"
                                              x2="100"
                                              y2="40"
                                              stroke="currentColor"
                                              strokeWidth="4"
                                              className="text-neutral-900/70 dark:text-neutral-300/70"
                                            />
                                            <line
                                              x1="0"
                                              y1="40"
                                              x2="100"
                                              y2="0"
                                              stroke="currentColor"
                                              strokeWidth="4"
                                              className="text-neutral-900/70 dark:text-neutral-300/70"
                                            />
                                          </svg>
                                        )}
                                        <div className="relative z-10 flex items-center justify-center">{w.isoWeekNo}</div>
                                      </div>
                                    </th>
                                  ))}
                                </tr>

                                <tr>
                                  <th className="sticky left-0 z-20 bg-white dark:bg-[#1f2d42] border border-neutral-200 dark:border-sky-400/35 w-[200px] min-w-[200px] max-w-[200px] px-2 py-1 text-[11px] font-semibold text-neutral-700 dark:text-neutral-300">
                                    Élèves
                                  </th>
                                                                    {daySegments.map((seg) => {
                                    // cellule fusionnée (VACANCES ou PFMP)
                                    if (seg.kind === "MERGED") {
                                      const first = timelineDays[seg.startIdx];

                                      return (
                                        <th
                                          key={`h-${seg.period}-${seg.startYmd}`}
                                          colSpan={seg.span}
                                          style={{ height: absencesDayColPx }}
                                          className={classNames(
                                            "border border-neutral-200 dark:border-sky-400/35 text-center font-semibold",
                                            cellBgClass(first),
                                            borderLeftClass(seg.startIdx), monthFrameLeftClass(seg.startIdx), monthFrameRightClass(seg.startIdx + seg.span - 1)
                                          )}
                                          title={`${formatYmdFr(seg.startYmd)} → ${formatYmdFr(seg.endYmd)} — ${seg.period}: ${seg.label}`}
                                        >
                                          <button
                                            type="button"
                                            className="w-full h-full"
                                            onClick={() => setAbsencesSelectedDateYmd(seg.startYmd)}
                                          >
                                            {seg.label}
                                          </button>
                                        </th>
                                      );
                                    }

                                    // jour normal
                                    const col = timelineDays[seg.idx];
                                    const idx = seg.idx;

                                    return (
                                      <th
                                        key={col.ymd}
                                        style={{ height: absencesDayColPx }}
                                        className={classNames(
                                          "border border-neutral-200 dark:border-sky-400/35 text-center font-semibold",
                                          cellBgClass(col),
                                          borderLeftClass(idx), monthFrameLeftClass(idx), monthFrameRightClass(idx)
                                        )}
                                        title={`${formatYmdFr(col.ymd)}${col.vacLabel ? ` — Vacances: ${col.vacLabel}` : ""}${col.stageLabel ? ` — PFMP: ${col.stageLabel}` : ""}`}
                                      >
                                        <button
                                          type="button"
                                          className="w-full h-full"
                                          onClick={() => setAbsencesSelectedDateYmd(col.ymd)}
                                        >
                                          {col.wdLabel}
                                        </button>
                                      </th>
                                    );
                                  })}
                                </tr>
                              </thead>

                              <tbody>
                                {studentsAbsFiltered.map((st, stIdx) => (
                                  <tr key={st}>
                                    <td
  className={classNames(
    "sticky left-0 z-10 border border-neutral-200 dark:border-sky-400/35 w-[200px] min-w-[200px] max-w-[200px] px-2 py-1 text-[11px] font-medium whitespace-nowrap",
    studentTintClass(st)
  )}
>
  <div className="flex items-center justify-between gap-2">
    <span className="truncate">{st}</span>
    {(() => {
      const r = studentRisk(st);
      if (!r.ab && !r.rt) return null;
      const abp = Math.round(r.abPct || 0);
      const rtp = Math.round(r.rtPct || 0);
      return (
        <span className="text-[10px] font-semibold opacity-80 whitespace-nowrap shrink-0">
          {r.ab}AB {abp}% · {r.rt}RT {rtp}%
        </span>
      );
    })()}
  </div>
</td>

                                                                        {daySegments.map((seg) => {
                                                                            // cellule fusionnée (VACANCES ou PFMP) : 1 seule cellule sur toute la hauteur (rowSpan) + colSpan sur la plage
                                      if (seg.kind === "MERGED") {
                                        if (stIdx !== 0) return null;
                                        const first = timelineDays[seg.startIdx];

                                        return (
                                          <td
                                            key={`merged-${seg.period}-${seg.startYmd}`}
                                            rowSpan={Math.max(1, studentsAbs.length)}
                                            colSpan={seg.span}
                                            style={{ height: absencesDayColPx }}
                                            className={classNames(
                                              "border border-neutral-200 dark:border-sky-400/35 text-center select-none cursor-pointer",
                                              cellBgClass(first),
                                              borderLeftClass(seg.startIdx), monthFrameLeftClass(seg.startIdx), monthFrameRightClass(seg.startIdx + seg.span - 1)
                                            )}
                                            onClick={() => setAbsencesSelectedDateYmd(seg.startYmd)}
                                            title={`${formatYmdFr(seg.startYmd)} → ${formatYmdFr(seg.endYmd)} — ${seg.period}: ${seg.label}`}
                                          >
                                            <div
                                              className="mx-auto flex items-center justify-center h-full w-[12px] min-w-[12px] max-w-[12px] overflow-hidden px-0 text-[10px] font-semibold"
                                              style={{ writingMode: "vertical-rl", transform: "rotate(180deg)" }}
                                            >
                                              {seg.label}
                                            </div>
                                          </td>
                                        );
                                      }
// jour normal => cellule cliquable AB/RT
                                      const col = timelineDays[seg.idx];
                                      const idx = seg.idx;

                                      const curStatus = yearBucket?.[st]?.[col.ymd] || null;
                                      const isSel = col.ymd === selectedDate;
                                      const nextStatus: AttendanceStatus | null =
                                        curStatus === "RT" ? "AB" : curStatus === "AB" ? null : "RT";

                                      return (
                                        <td
                                          key={st + "-" + col.ymd}
                                          style={{ height: absencesDayColPx }}
                                          className={classNames(
                                            "border border-neutral-200 dark:border-sky-400/35 text-center cursor-pointer select-none",
                                            cellBgClass(col),
                                            borderLeftClass(idx), monthFrameLeftClass(idx), monthFrameRightClass(idx),
                                            isSel && "ring-2 ring-inset ring-neutral-900 dark:ring-neutral-200"
                                          )}
                                          onClick={() => {
                                            setAbsencesSelectedDateYmd(col.ymd);
                                            setAbsenceStatus(absencesSchoolYear, classId, st, col.ymd, nextStatus);
                                          }}
                                          title={`${st} — ${formatYmdFr(col.ymd)}`}
                                        >
                                          {curStatus === "AB" ? (
                                            <span className="text-[10px] font-bold text-red-600 dark:text-red-200">AB</span>
                                          ) : curStatus === "RT" ? (
                                            <span className="text-[10px] font-bold text-amber-700 dark:text-amber-200">RT</span>
                                          ) : (
                                            ""
                                          )}
                                        </td>
                                      );
                                    })}
                                  </tr>
                                ))}
                              </tbody>
                            </table>
                          </div>
                        </div>
                      );
                    };

                    return (
                      <div ref={suiviAbsencesPdfRef} className="mt-0 space-y-3 absences-print-root">
                        <div className="hidden print-only rounded-md border border-neutral-300 bg-white px-3 py-3 text-[22px] leading-snug text-neutral-900">
                          <div className="text-[24px] font-extrabold leading-tight">Absences / retards{classLabel ? ` — ${classLabel}` : ""}</div>
                          <div className="mt-1 text-[18px]">
                            Année scolaire : {absencesSchoolYear} • Période : {formatYmdFr(absencesShowAllWeeks ? startYmd : (timelineDays[0]?.ymd || startYmd))} → {formatYmdFr(endYmd)} • Vue : {absencesTimelineView === "day" ? "Jour" : "Semaine"}
                          </div>
                          <div className="mt-2 flex flex-wrap gap-3 items-center text-[13px] font-medium">
                            <span className="inline-flex items-center gap-2">
                              <span className="h-3 w-3 rounded-sm bg-blue-800/90" /> Vacances
                            </span>
                            <span className="inline-flex items-center gap-2">
                              <span className="h-3 w-3 rounded-sm bg-orange-200" /> PFMP
                            </span>
                            <span className="inline-flex items-center gap-2">
                              <span className="h-3 w-3 rounded-sm bg-white border border-neutral-300" /> Cours
                            </span>
                            <span className="inline-flex items-center gap-2">
                              <span className="h-3 w-3 rounded-full bg-red-500" /> AB
                            </span>
                            <span className="inline-flex items-center gap-2">
                              <span className="h-3 w-3 rounded-full bg-amber-500" /> RT
                            </span>
                          </div>
                        </div>

                        <div className="absences-controls flex flex-col gap-2 sm:flex-row sm:items-end sm:justify-between">
                          <div className="flex flex-wrap items-end gap-2">
                            <div className="space-y-1">
                              <Input
                                value={absencesSchoolYear}
                                onChange={(e) => setAbsencesSchoolYear(e.target.value)}
                                className="h-8 w-[132px] text-xs bg-white dark:bg-[#182433] border border-neutral-300 dark:border-sky-400/35"
                                placeholder="2025-2026"
                              />
                            </div>

                            <Button
                              type="button"
                              variant="outline"
                              onClick={() => setAbsencesSettingsOpen(true)}
                              className="h-8 px-3 text-xs border border-neutral-300 dark:border-sky-400/35 bg-white hover:bg-amber-100/70 dark:bg-[#182433] text-neutral-900 dark:text-neutral-300 hover:bg-amber-100/70 dark:hover:bg-[#3d2707]"
                            >
                              Paramètres du planning
                            </Button>

                            <Button
                              type="button"
                              variant="outline"
                              onClick={() => setAbsencesRecapOpen(true)}
                              className="h-8 px-3 text-xs border border-neutral-300 dark:border-sky-400/35 bg-white hover:bg-amber-100/70 dark:bg-[#182433] text-neutral-900 dark:text-neutral-300 hover:bg-amber-100/70 dark:hover:bg-[#3d2707]"
                            >
                              Récap absence/retard
                            </Button>
                          </div>

                          <div className="text-[11px] text-neutral-500 dark:text-neutral-300 flex flex-wrap gap-2 items-center">
                          <div className="inline-flex items-center gap-1 rounded-md border border-neutral-300 dark:border-sky-400/35 bg-white hover:bg-amber-100/70 dark:bg-[#182433] px-1 py-1">
                            <button
                              type="button"
                              className="h-6 w-6 rounded border border-neutral-300 dark:border-sky-400/35 bg-white hover:bg-amber-100/70 dark:bg-[#182433] text-neutral-900 dark:text-neutral-300 text-xs font-semibold leading-none hover:bg-amber-100/70 dark:hover:bg-[#3d2707]"
                              onClick={() => setAbsencesDayColPx((v) => Math.max(12, v - 4))}
                              title="Rétrécir les colonnes"
                            >
                              −
                            </button>
                            <span className="px-1 text-[11px] text-neutral-600 dark:text-neutral-300 whitespace-nowrap">
                              Taille
                            </span>
                            <button
                              type="button"
                              className="h-6 w-6 rounded border border-neutral-300 dark:border-sky-400/35 bg-white hover:bg-amber-100/70 dark:bg-[#182433] text-neutral-900 dark:text-neutral-300 text-xs font-semibold leading-none hover:bg-amber-100/70 dark:hover:bg-[#3d2707]"
                              onClick={() => setAbsencesDayColPx((v) => Math.min(80, v + 4))}
                              title="Agrandir les colonnes"
                            >
                              +
                            </button>
                          </div>

                            <span className="inline-flex items-center gap-1">
                              <span className="h-2 w-2 rounded-sm bg-blue-800/90 dark:bg-blue-900/45" /> Vacances
                            </span>
                            <span className="inline-flex items-center gap-1">
                              <span className="h-2 w-2 rounded-sm bg-orange-200 dark:bg-orange-900/25" /> PFMP
                            </span>
                            <span className="inline-flex items-center gap-1">
                              <span className="h-2 w-2 rounded-sm bg-white border border-neutral-300 dark:bg-[#182433] dark:border-neutral-600" /> Cours
                            </span>
                            <span className="inline-flex items-center gap-1">
                              <span className="h-2 w-2 rounded-full bg-red-500" /> AB
                            </span>
                            <span className="inline-flex items-center gap-1">
                              <span className="h-2 w-2 rounded-full bg-amber-500" /> RT
                            </span>
                          </div>
                        </div>

                        {!absencesBootstrapped ? (
                          <p className="text-xs text-neutral-500">
                            Chargement de la base absences / retards…
                          </p>
                        ) : (
                          <div className="absences-grid grid grid-cols-1 lg:grid-cols-[1fr_360px] gap-3">
                            <div className="min-w-0">
                              {renderProgressionTable()}
                              <div className="hidden print-only" data-absences-recap-anchor="1" />
                            </div>

                            <div className="absences-sidepanel rounded-xl border border-neutral-200 dark:border-sky-400/35 bg-white dark:bg-[#1f2d42] p-3 h-fit lg:sticky lg:top-[140px]">
                              <div className="flex items-start justify-between gap-2">
                                <div>
                                  <div className="text-xs font-semibold text-neutral-900 dark:text-neutral-300">
                                    {selectedWeekday} {formatYmdFr(selectedDate)}
                                  </div>
                                  <div className="text-[11px] text-neutral-500 dark:text-neutral-300">
                                    AB : {selectedCounts.ab} • RT : {selectedCounts.rt}
                                  </div>
                                  {(selectedVacationLabel || selectedStageLabel) && (
                                    <div className="mt-1 text-[11px] text-neutral-600 dark:text-neutral-300">
                                      {selectedVacationLabel ? `Vacances : ${selectedVacationLabel}` : ""}
                                      {selectedVacationLabel && selectedStageLabel ? " • " : ""}
                                      {selectedStageLabel ? `PFMP : ${selectedStageLabel}` : ""}
                                    </div>
                                  )}
                                </div>
                              </div>

                              <div className="mt-3 flex flex-wrap gap-2">
                                <Button
                                  type="button"
                                  variant="outline"
                                  onClick={() =>
                                    setAbsenceStatusForAllStudents(
                                      absencesSchoolYear,
                                      classId,
                                      studentsAbs,
                                      selectedDate,
                                      null
                                    )
                                  }
                                  className="h-7 px-2 text-[11px] border border-neutral-300 dark:border-sky-400/35 bg-white hover:bg-amber-100/70 dark:bg-[#182433] text-neutral-900 dark:text-white hover:bg-amber-100/70 dark:hover:bg-[#3d2707]"

                                >
                                  Tous présents
                                </Button>
                                <Button
                                  type="button"
                                  variant="outline"
                                  onClick={() =>
                                    setAbsenceStatusForAllStudents(
                                      absencesSchoolYear,
                                      classId,
                                      studentsAbs,
                                      selectedDate,
                                      "RT"
                                    )
                                  }
                                  className="h-7 px-2 text-[11px] border border-neutral-300 dark:border-sky-400/35 bg-white hover:bg-amber-100/70 dark:bg-[#182433] text-neutral-900 dark:text-white hover:bg-amber-100/70 dark:hover:bg-[#3d2707]"
                                >
                                  Tous RT
                                </Button>
                                <Button
                                  type="button"
                                  variant="outline"
                                  onClick={() =>
                                    setAbsenceStatusForAllStudents(
                                      absencesSchoolYear,
                                      classId,
                                      studentsAbs,
                                      selectedDate,
                                      "AB"
                                    )
                                  }
                                  className="h-7 px-2 text-[11px] border border-neutral-300 dark:border-sky-400/35 bg-white hover:bg-amber-100/70 dark:bg-[#182433] text-neutral-900 dark:text-white hover:bg-amber-100/70 dark:hover:bg-[#3d2707]"

                                >
                                  Tous AB
                                </Button>
                              </div>

                              <div className="mt-3">
                                {studentsAbs.length === 0 ? (
                                  <p className="text-xs text-neutral-500">
                                    Ajoutez des élèves via le menu 📚 Classe.
                                  </p>
                                ) : (
                                  <div className="space-y-2 max-h-[560px] overflow-auto pr-1">
                                    {studentsAbsFiltered.map((st) => {
                                      const cur = yearBucket?.[st]?.[selectedDate] || null;
                                      const isP = !cur;
                                      const isR = cur === "RT";
                                      const isA = cur === "AB";

                                      const r = studentRisk(st);
                                      const abp = Math.round(r.abPct || 0);

                                      const btnBase =
                                        "h-7 px-2 text-[11px] border border-neutral-300 dark:border-sky-400/35";
                                      const btnOn =
                                        "bg-neutral-900 text-white dark:bg-neutral-50 dark:text-neutral-300";
                                      const btnOff =
                                        "bg-white dark:bg-[#1f2d42] text-neutral-700 dark:text-neutral-300 hover:bg-amber-100/70 dark:hover:bg-[#3d2707]";

                                      return (
                                        <div
                                          key={st}
                                          className={classNames(
                                            "flex items-center justify-between gap-2 rounded-lg border px-2 py-1.5 bg-white dark:bg-[#182433]",
                                            studentCardTintClass(st)
                                          )}
                                        >
                                          <div className="min-w-0">
                                            <div className="flex items-center justify-between gap-2 min-w-0">
                                              <div className="text-xs font-medium text-neutral-900 dark:text-neutral-300 truncate">
                                                {st}
                                              </div>
                                              <div
                                                className={classNames(
                                                  "shrink-0 text-[10px] font-semibold tabular-nums",
                                                  r.tooAb
                                                    ? "text-red-700 dark:text-red-200"
                                                    : "text-neutral-600 dark:text-neutral-300"
                                                )}
                                                title={`Absences: ${r.ab} / ${effectiveCourseDaysSoFar} jours de cours`}
                                              >
                                                {effectiveCourseDaysSoFar > 0 ? `${abp}%` : "—%"}
                                              </div>
                                            </div>

                                            {(r.ab || r.rt) ? (
                                              <div className="text-[10px] text-neutral-600 dark:text-neutral-300 whitespace-nowrap">
                                                AB {r.ab} • RT {r.rt}
                                              </div>
                                            ) : null}
                                          </div>

                                          <div className="inline-flex rounded-md overflow-hidden">
                                            <button
                                              type="button"
                                              onClick={() =>
                                                setAbsenceStatus(
                                                  absencesSchoolYear,
                                                  classId,
                                                  st,
                                                  selectedDate,
                                                  null
                                                )
                                              }
                                              className={classNames(btnBase, isP ? btnOn : btnOff)}
                                              title="Présent"
                                            >
                                              ✓
                                            </button>
                                            <button
                                              type="button"
                                              onClick={() =>
                                                setAbsenceStatus(
                                                  absencesSchoolYear,
                                                  classId,
                                                  st,
                                                  selectedDate,
                                                  "RT"
                                                )
                                              }
                                              className={classNames(btnBase, isR ? btnOn : btnOff)}
                                              title="Retard"
                                            >
                                              RT
                                            </button>
                                            <button
                                              type="button"
                                              onClick={() =>
                                                setAbsenceStatus(
                                                  absencesSchoolYear,
                                                  classId,
                                                  st,
                                                  selectedDate,
                                                  "AB"
                                                )
                                              }
                                              className={classNames(btnBase, isA ? btnOn : btnOff)}
                                              title="Absent"
                                            >
                                              AB
                                            </button>
                                          </div>
                                        </div>
                                      );
                                    })}
                                  </div>
                                )}
                              </div>

                              {absencesPlanningSettings.vacationsMode === "auto" && (
                                <div className="mt-3 text-[11px] text-neutral-500 dark:text-neutral-300">
                                  Vacances auto (zone {absencesPlanningSettings.zone}) :{" "}
                                  {absencesAutoVacIsLoading ? "chargement…" : vacationRanges.length + " période(s)"}
                                </div>
                              )}
                            </div>
                          </div>
                        )}

                        {/* Drawer Paramètres planning */}
                        <Drawer
                          open={absencesSettingsOpen}
                          onClose={() => setAbsencesSettingsOpen(false)}
                          side="right"
                          className="w-[360px] sm:w-[520px]"
                        >
                          <div className="px-4 py-3 border-b border-neutral-200 dark:border-sky-400/35">
                            <div className="text-sm font-semibold text-neutral-900 dark:text-neutral-300">
                              Planning annuel — Absences / retards
                            </div>
                            <div className="text-xs text-neutral-500 dark:text-neutral-300 mt-0.5">
                              Année scolaire : {absencesSchoolYear}
                            </div>
                          </div>

                          <div className="p-4 space-y-4 text-neutral-900 dark:text-neutral-300">
                            {!selectedClassIdForSuivi ? (
                              <p className="text-sm text-neutral-600 dark:text-neutral-300">
                                Sélectionnez une classeAbs pour régler le planning.
                              </p>
                            ) : (
                              <>
                                <div className="grid grid-cols-2 gap-3">
                                  <div className="space-y-1">
                                    <Label className="text-xs">Début d'année</Label>
                                    <Input
                                      type="date"
                                      value={absencesPlanningSettings.startYmd}
                                      onChange={(e) =>
                                        updateAbsencesPlanning(absencesSchoolYear, selectedClassIdForSuivi, (cur) => ({
                                          ...cur,
                                          startYmd: e.target.value || cur.startYmd,
                                        }))
                                      }
                                      className="h-9 text-xs bg-white dark:bg-[#182433]"
                                    />
                                  </div>
                                  <div className="space-y-1">
                                    <Label className="text-xs">Fin d'année</Label>
                                    <Input
                                      type="date"
                                      value={absencesPlanningSettings.endYmd}
                                      onChange={(e) =>
                                        updateAbsencesPlanning(absencesSchoolYear, selectedClassIdForSuivi, (cur) => ({
                                          ...cur,
                                          endYmd: e.target.value || cur.endYmd,
                                        }))
                                      }
                                      className="h-9 text-xs bg-white dark:bg-[#182433]"
                                    />
                                  </div>
                                </div>

                                <div className="space-y-2">
                                  <Label className="text-xs">Selectionner les journées de cours</Label>
                                  {(() => {
                                    const dayDefs: Array<{ k: keyof PlanningWeekdays; label: string }> = [
                                      { k: "mon", label: "L" },
                                      { k: "tue", label: "M" },
                                      { k: "wed", label: "M" },
                                      { k: "thu", label: "J" },
                                      { k: "fri", label: "V" },
                                    ];
                                    return (
                                      <div className="grid grid-cols-7 gap-2">
                                        {dayDefs.map((d) => (
                                          <label
                                            key={d.k}
                                            className="flex items-center justify-center gap-1 rounded-md border border-neutral-200 dark:border-sky-400/35 px-2 py-2 text-xs dark:bg-[#182433]"
                                          >
                                            <input
                                              type="checkbox"
                                              checked={!!absencesPlanningSettings.courseDays?.[d.k]}
                                              onChange={(e) =>
                                                updateAbsencesPlanning(absencesSchoolYear, selectedClassIdForSuivi, (cur) => ({
                                                  ...cur,
                                                  courseDays: { ...cur.courseDays, [d.k]: e.target.checked },
                                                }))
                                              }
                                            />
                                            <span>{d.label}</span>
                                          </label>
                                        ))}
                                      </div>
                                    );
                                  })()}
                                </div>

                                <div className="flex items-center justify-end">
                                </div>


                                <div className="space-y-2 border-t border-neutral-200 dark:border-sky-400/35 pt-3">
                                  <div className="flex items-center justify-between gap-2">
                                    <Label className="text-xs">Vacances</Label>
                                    <div className="inline-flex rounded-full border border-neutral-200 dark:border-sky-400/35 bg-neutral-50 dark:bg-[#182433] p-1 text-xs">
                                      <button
                                        type="button"
                                        onClick={() =>
                                          updateAbsencesPlanning(absencesSchoolYear, selectedClassIdForSuivi, (cur) => ({
                                            ...cur,
                                            vacationsMode: "auto",
                                          }))
                                        }
                                        className={classNames(
                                          "px-3 py-1 rounded-full transition",
                                          absencesPlanningSettings.vacationsMode === "auto"
                                            ? "bg-neutral-900 text-white"
                                            : "bg-transparent text-neutral-700 dark:text-neutral-300 hover:bg-amber-100/70 dark:hover:bg-[#3d2707]"
                                        )}
                                      >
                                        Auto
                                      </button>
                                      <button
                                        type="button"
                                        onClick={() =>
                                          updateAbsencesPlanning(absencesSchoolYear, selectedClassIdForSuivi, (cur) => ({
                                            ...cur,
                                            vacationsMode: "manual",
                                          }))
                                        }
                                        className={classNames(
                                          "px-3 py-1 rounded-full transition",
                                          absencesPlanningSettings.vacationsMode === "manual"
                                            ? "bg-neutral-900 text-white"
                                            : "bg-transparent text-neutral-700 dark:text-neutral-300 hover:bg-amber-100/70 dark:hover:bg-[#3d2707]"
                                        )}
                                      >
                                        Manuel
                                      </button>
                                    </div>
                                  </div>

                                  {absencesPlanningSettings.vacationsMode === "auto" ? (
                                    <div className="space-y-2">
                                      <div className="space-y-1">
<label className="text-neutral-900 dark:!text-neutral-50">Zone scolaire</label>

<select
  className="w-full rounded-md border border-neutral-200 bg-white px-3 py-2 text-sm text-neutral-900
             dark:border-sky-400/35 dark:bg-[#1f2d42] dark:text-neutral-300"
  value={absencesPlanningSettings.zone}
  onChange={(e) => {
    if (!selectedClassIdForSuivi) return;
    updateAbsencesPlanning(absencesSchoolYear, selectedClassIdForSuivi, (cur) => ({
      ...cur,
      zone: e.target.value as PlanningZone,
    }));
  }}
>
  <option value="A">Zone A</option>
  <option value="B">Zone B</option>
  <option value="C">Zone C</option>
</select>


                                      </div>

                                      <div className="text-xs text-neutral-500 dark:text-neutral-300">
                                        Vacances auto — zone {absencesPlanningSettings.zone}.
                                        <div className="mt-1">
                                          {absencesAutoVacIsLoading
                                            ? "Chargement en cours…"
                                            : `${vacationRanges.length} période(s) chargée(s).`}
                                        </div>
                                        {absencesAutoVacErrorForKey && (
                                          <div className="mt-1 text-[11px] text-red-700 dark:text-red-300">
                                            Erreur: {absencesAutoVacErrorForKey}
                                          </div>
                                        )}
                                      </div>

                                      <Button
                                        type="button"
                                        variant="outline"
                                        onClick={() => {
                                          // Force reload
                                          setAbsencesAutoVacCache((prev) => {
                                            const n = { ...prev };
                                            delete n[absencesAutoVacKey];
                                            return n;
                                          });
                                        }}
                                        className="h-9 px-3 text-xs border border-neutral-300 dark:border-sky-400/35 bg-white hover:bg-amber-100/70 dark:bg-[#182433] text-neutral-300 dark:text-white"
                                      >
                                        Charger ou recharger les vacances scolaires
                                      </Button>
                                    </div>
                                  ) : (
                                    <div className="space-y-2">
                                      {(absencesPlanningSettings.vacationsManual || []).length === 0 ? (
                                        <p className="text-xs text-neutral-500 dark:text-neutral-300">
                                          Aucune période saisie.
                                        </p>
                                      ) : (
                                        <div className="space-y-2">
                                          {(absencesPlanningSettings.vacationsManual || []).map((r, idx) => (
                                            <div
                                              key={String(idx)}
                                              className="rounded-lg border border-neutral-200 dark:border-sky-400/35 p-2 space-y-2"
                                            >
                                              <div className="grid grid-cols-2 gap-2">
                                                <Input
                                                  type="date"
                                                  value={r.startYmd}
                                                  onChange={(e) =>
                                                    updateAbsencesPlanning(absencesSchoolYear, selectedClassIdForSuivi, (cur) => {
                                                      const next = (cur.vacationsManual || []).slice();
                                                      next[idx] = { ...next[idx], startYmd: e.target.value };
                                                      return { ...cur, vacationsManual: next };
                                                    })
                                                  }
                                                  className="h-9 text-xs bg-white dark:bg-[#182433]"
                                                />
                                                <Input
                                                  type="date"
                                                  value={r.endYmd}
                                                  onChange={(e) =>
                                                    updateAbsencesPlanning(absencesSchoolYear, selectedClassIdForSuivi, (cur) => {
                                                      const next = (cur.vacationsManual || []).slice();
                                                      next[idx] = { ...next[idx], endYmd: e.target.value };
                                                      return { ...cur, vacationsManual: next };
                                                    })
                                                  }
                                                  className="h-9 text-xs bg-white dark:bg-[#182433]"
                                                />
                                              </div>

                                              <div className="flex items-center gap-2">
                                                <Input
                                                  value={r.label || ""}
                                                  onChange={(e) =>
                                                    updateAbsencesPlanning(absencesSchoolYear, selectedClassIdForSuivi, (cur) => {
                                                      const next = (cur.vacationsManual || []).slice();
                                                      next[idx] = { ...next[idx], label: e.target.value };
                                                      return { ...cur, vacationsManual: next };
                                                    })
                                                  }
                                                  placeholder="Label (ex: Vacances Noël)"
                                                  className="h-9 text-xs bg-white dark:bg-[#182433] flex-1"
                                                />
                                                <Button
                                                  type="button"
                                                  variant="outline"
                                                  onClick={() =>
                                                    updateAbsencesPlanning(absencesSchoolYear, selectedClassIdForSuivi, (cur) => {
                                                      const next = (cur.vacationsManual || []).slice();
                                                      next.splice(idx, 1);
                                                      return { ...cur, vacationsManual: next };
                                                    })
                                                  }
                                                  className="h-9 px-2 text-xs border border-neutral-300 dark:border-sky-400/35 bg-white hover:bg-amber-100/70 dark:bg-[#182433] text-neutral-300 dark:text-white"
                                                  title="Supprimer"
                                                >
                                                  <X className="h-4 w-4" />
                                                </Button>
                                              </div>
                                            </div>
                                          ))}
                                        </div>
                                      )}

                                      <Button
                                        type="button"
                                        variant="outline"
                                        onClick={() =>
                                          updateAbsencesPlanning(absencesSchoolYear, selectedClassIdForSuivi, (cur) => ({
                                            ...cur,
                                            vacationsManual: [
                                              ...(cur.vacationsManual || []),
                                              { startYmd: cur.startYmd, endYmd: cur.startYmd, label: "Vacances" },
                                            ],
                                          }))
                                        }
                                        className="h-9 px-3 text-xs border border-neutral-300 dark:border-sky-400/35 bg-white hover:bg-amber-100/70 dark:bg-[#182433] text-neutral-300 dark:text-white"
                                      >
                                        Ajouter une période
                                      </Button>
                                    </div>
                                  )}
                                </div>


                                <div className="space-y-2 border-t border-neutral-200 dark:border-sky-400/35 pt-3">
                                  <div className="flex items-center justify-between gap-2">
                                    <Label className="text-xs">PFMP</Label>
                                    <Button
                                      type="button"
                                      variant="outline"
                                      onClick={() =>
                                        updateAbsencesPlanning(absencesSchoolYear, selectedClassIdForSuivi, (cur) => ({
                                          ...cur,
                                          stages: [
                                            ...(cur.stages || []),
                                            { startYmd: cur.startYmd, endYmd: cur.startYmd, label: "PFMP" },
                                          ],
                                        }))
                                      }
                                      className="h-8 px-3 text-xs border border-neutral-300 dark:border-sky-400/35 bg-white hover:bg-amber-100/70 dark:bg-[#182433]  text-neutral-300 dark:text-white"
                                    >
                                      Ajouter
                                    </Button>
                                  </div>

                                  {(absencesPlanningSettings.stages || []).length === 0 ? (
                                    <p className="text-xs text-neutral-500 dark:text-neutral-300">
                                      Aucune période de stage.
                                    </p>
                                  ) : (
                                    <div className="space-y-2">
                                      {(absencesPlanningSettings.stages || []).map((r, idx) => (
                                        <div
                                          key={String(idx)}
                                          className="rounded-lg border border-neutral-200 dark:border-sky-400/35 p-2 space-y-2"
                                        >
                                          <div className="grid grid-cols-2 gap-2">
                                            <Input
                                              type="date"
                                              value={r.startYmd}
                                              onChange={(e) =>
                                                updateAbsencesPlanning(absencesSchoolYear, selectedClassIdForSuivi, (cur) => {
                                                  const next = (cur.stages || []).slice();
                                                  next[idx] = { ...next[idx], startYmd: e.target.value };
                                                  return { ...cur, stages: next };
                                                })
                                              }
                                              className="h-9 text-xs bg-white dark:bg-[#182433]"
                                            />
                                            <Input
                                              type="date"
                                              value={r.endYmd}
                                              onChange={(e) =>
                                                updateAbsencesPlanning(absencesSchoolYear, selectedClassIdForSuivi, (cur) => {
                                                  const next = (cur.stages || []).slice();
                                                  next[idx] = { ...next[idx], endYmd: e.target.value };
                                                  return { ...cur, stages: next };
                                                })
                                              }
                                              className="h-9 text-xs bg-white dark:bg-[#182433]"
                                            />
                                          </div>

                                          <div className="flex items-center gap-2">
                                            <Input
                                              value={r.label || ""}
                                              onChange={(e) =>
                                                updateAbsencesPlanning(absencesSchoolYear, selectedClassIdForSuivi, (cur) => {
                                                  const next = (cur.stages || []).slice();
                                                  next[idx] = { ...next[idx], label: e.target.value };
                                                  return { ...cur, stages: next };
                                                })
                                              }
                                              placeholder="Label (ex: PFMP 1)"
                                              className="h-9 text-xs bg-white dark:bg-[#182433] flex-1"
                                            />
                                            <Button
                                              type="button"
                                              variant="outline"
                                              onClick={() =>
                                                updateAbsencesPlanning(absencesSchoolYear, selectedClassIdForSuivi, (cur) => {
                                                  const next = (cur.stages || []).slice();
                                                  next.splice(idx, 1);
                                                  return { ...cur, stages: next };
                                                })
                                              }
                                              className="h-9 px-2 text-xs border border-neutral-300 dark:border-sky-400/35 bg-white hover:bg-amber-100/70 dark:bg-[#182433] text-neutral-300 dark:text-white"
                                              title="Supprimer"
                                            >
                                              <X className="h-4 w-4" />
                                            </Button>
                                          </div>
                                        </div>
                                      ))}
                                    </div>
                                  )}
                                </div>
                                <div className="rounded-lg border border-neutral-200 dark:border-sky-400/35 bg-white dark:bg-[#182433] p-3 space-y-2">
                                  <div className="text-xs font-semibold text-neutral-900 dark:text-neutral-300">
                                    Alertes Absences et retards
                                  </div>
                                  <div className="text-[11px] text-neutral-500 dark:text-neutral-300">
                                    Seuils en pourcentage calculés sur les <b>{effectiveCourseDaysSoFar}</b> jours de cours effectifs (hors vacances et PFMP), du début de l'année jusqu’à aujourd’hui.
                                  </div>
                                  <div className="grid grid-cols-1 sm:grid-cols-2 gap-3">
                                    <div className="space-y-2">
                                      <div className="text-xs font-medium text-neutral-800 dark:text-neutral-300">Absences</div>
                                      <div className="grid grid-cols-2 gap-2">
                                        <div className="space-y-1">
                                          <Label className="text-xs">Orange (%)</Label>
                                          <Input
                                            type="number"
                                            min={0}
                                            max={100}
                                            step={0.5}
                                            value={String(absencesWarnAbsPct)}
                                            onChange={(e) => {
                                              const raw = (e.target.value || "0").replace(",", ".");
                                              const n = parseFloat(raw);
                                              if (!Number.isFinite(n)) return;
                                              setAbsencesWarnAbsPct(n);
                                            }}
                                            className="h-9 text-xs bg-white dark:bg-[#1f2d42]"
                                          />
                                        </div>

                                        <div className="space-y-1">
                                          <Label className="text-xs">Rouge (%)</Label>
                                          <Input
                                            type="number"
                                            min={0}
                                            max={100}
                                            step={0.5}
                                            value={String(absencesAlertAbsPct)}
                                            onChange={(e) => {
                                              const raw = (e.target.value || "0").replace(",", ".");
                                              const n = parseFloat(raw);
                                              if (!Number.isFinite(n)) return;
                                              setAbsencesAlertAbsPct(n);
                                            }}
                                            className="h-9 text-xs bg-white dark:bg-[#1f2d42]"
                                          />
                                        </div>
                                      </div>
                                      <div className="text-[11px] text-neutral-500 dark:text-neutral-300">
                                        Vert = &lt; Orange • Orange = ≥ Orange • Rouge = ≥ Rouge
                                      </div>
                                    </div>

                                    <div className="space-y-2">
                                      <div className="text-xs font-medium text-neutral-800 dark:text-neutral-300">Retards</div>
                                      <div className="grid grid-cols-2 gap-2">
                                        <div className="space-y-1">
                                          <Label className="text-xs">Orange (%)</Label>
                                          <Input
                                            type="number"
                                            min={0}
                                            max={100}
                                            step={0.5}
                                            value={String(absencesWarnRtPct)}
                                            onChange={(e) => {
                                              const raw = (e.target.value || "0").replace(",", ".");
                                              const n = parseFloat(raw);
                                              if (!Number.isFinite(n)) return;
                                              setAbsencesWarnRtPct(n);
                                            }}
                                            className="h-9 text-xs bg-white dark:bg-[#1f2d42]"
                                          />
                                        </div>

                                        <div className="space-y-1">
                                          <Label className="text-xs">Rouge (%)</Label>
                                          <Input
                                            type="number"
                                            min={0}
                                            max={100}
                                            step={0.5}
                                            value={String(absencesAlertRtPct)}
                                            onChange={(e) => {
                                              const raw = (e.target.value || "0").replace(",", ".");
                                              const n = parseFloat(raw);
                                              if (!Number.isFinite(n)) return;
                                              setAbsencesAlertRtPct(n);
                                            }}
                                            className="h-9 text-xs bg-white dark:bg-[#1f2d42]"
                                          />
                                        </div>
                                      </div>
                                      <div className="text-[11px] text-neutral-500 dark:text-neutral-300">
                                        Vert = &lt; Orange • Orange = ≥ Orange • Rouge = ≥ Rouge
                                      </div>
                                    </div>
                                  </div>
                                </div>
                                <div className="pt-3 flex justify-end">
                                  <Button
                                    type="button"
                                    onClick={() => setAbsencesSettingsOpen(false)}
                                    className="h-9 px-4 text-xs"
                                  >
                                    Fermer
                                  </Button>
                                </div>
                              </>
                            )}
                          </div>
                        </Drawer>
                          {/* Drawer Récap absence/retard */}
                        <Drawer
                          open={absencesRecapOpen}
                          onClose={() => setAbsencesRecapOpen(false)}
                          side="right"
                          className="w-[360px] sm:w-[860px]"
                        >
                          <div className="px-4 py-3 border-b border-neutral-200 dark:border-sky-400/35">
                            <div className="flex items-center justify-between gap-2">
                              <div className="min-w-0">
                                <div className="text-sm font-semibold text-neutral-900 dark:text-neutral-300">
                                  Récap absence/retard{classLabel ? ` — ${classLabel}` : ""}
                                </div>
                                <div className="text-xs text-neutral-500 dark:text-neutral-300 mt-0.5">
                                  Année scolaire : {absencesSchoolYear} • Zone : {absencesPlanningSettings.zone} •
                                  {" "}S1 ({formatSemesterRangeShort(semS1)}) • S2 ({formatSemesterRangeShort(semS2)})
                                </div>
                                <div className="text-[11px] text-neutral-500 dark:text-neutral-300 mt-0.5">
                                  Semestres calculés automatiquement : S1 = début d’année → début des vacances d’hiver (zone) ; S2 = fin des vacances d’hiver → début des vacances d’été.
                                </div>
                              </div>

                              <button
                                type="button"
                                onClick={() => setAbsencesRecapOpen(false)}
                                className="h-8 w-8 inline-flex items-center justify-center rounded-md border border-neutral-200 dark:border-sky-400/35 bg-white dark:bg-[#1f2d42] text-neutral-900 dark:text-neutral-300 hover:bg-amber-100/70 dark:hover:bg-[#3d2707] text-neutral-300 dark:text-white"
                                aria-label="Fermer"
                              >
                                <X className="h-4 w-4" />
                              </button>
                            </div>
                          </div>

                          <div className="p-4 space-y-4 text-neutral-900 dark:text-neutral-300">
                            <div className="grid grid-cols-1 sm:grid-cols-[1fr_auto] gap-3 items-end">
                              <div className="space-y-1">
                                <Label className="text-xs">Période</Label>
                                <select
                                  className="block w-full border border-neutral-300 dark:border-sky-400/35 rounded-md bg-white dark:bg-[#182433] text-neutral-900 dark:text-neutral-300 px-2 py-2 text-xs"
                                  value={absencesRecapSemesterKey}
                                  onChange={(e) => setAbsencesRecapSemesterKey(e.target.value as any)}
                                >
                                  <option value="ALL">Année scolaire</option>
                                  <option value="S1">Semestre 1</option>
                                  <option value="S2">Semestre 2</option>
                                </select>
                              </div>

                            </div>

                            {(() => {
                              const mode = absencesRecapSemesterKey;

                              const denomEffS1 = effectiveCourseDaysBySemesterSoFar.S1 || 0;
                              const denomEffS2 = effectiveCourseDaysBySemesterSoFar.S2 || 0;

                              const denomPlannedS1 = plannedCourseDaysBySemester.S1 || 0;
                              const denomPlannedS2 = plannedCourseDaysBySemester.S2 || 0;

                              const pct = (n: number, d: number) => (d > 0 ? (n / d) * 100 : null);

                              const rows = studentsAbs
                                .map((st) => {
                                  const sc = studentSemesterCounts[st] || { S1: { ab: 0, rt: 0 }, S2: { ab: 0, rt: 0 } };

                                  const abPctS1 = pct(sc.S1.ab, denomEffS1);
                                  const rtPctS1 = pct(sc.S1.rt, denomEffS1);
                                  const abPctS2 = pct(sc.S2.ab, denomEffS2);
                                  const rtPctS2 = pct(sc.S2.rt, denomEffS2);

                                  const tooAbS1 = absencesAlertAbsPct > 0 && abPctS1 != null && abPctS1 >= absencesAlertAbsPct;
                                  const tooRtS1 = absencesAlertRtPct > 0 && rtPctS1 != null && rtPctS1 >= absencesAlertRtPct;
                                  const tooAbS2 = absencesAlertAbsPct > 0 && abPctS2 != null && abPctS2 >= absencesAlertAbsPct;
                                  const tooRtS2 = absencesAlertRtPct > 0 && rtPctS2 != null && rtPctS2 >= absencesAlertRtPct;

                                  const midAbS1 = absencesWarnAbsPct > 0 && abPctS1 != null && abPctS1 >= absencesWarnAbsPct;
                                  const midRtS1 = absencesWarnRtPct > 0 && rtPctS1 != null && rtPctS1 >= absencesWarnRtPct;
                                  const midAbS2 = absencesWarnAbsPct > 0 && abPctS2 != null && abPctS2 >= absencesWarnAbsPct;
                                  const midRtS2 = absencesWarnRtPct > 0 && rtPctS2 != null && rtPctS2 >= absencesWarnRtPct;

                                  const maxAb = Math.max(abPctS1 ?? -1, abPctS2 ?? -1);
                                  const maxRt = Math.max(rtPctS1 ?? -1, rtPctS2 ?? -1);

                                  return {
                                    st,
                                    S1: { ...sc.S1, abPct: abPctS1, rtPct: rtPctS1, tooAb: tooAbS1, tooRt: tooRtS1, midAb: midAbS1, midRt: midRtS1 },
                                    S2: { ...sc.S2, abPct: abPctS2, rtPct: rtPctS2, tooAb: tooAbS2, tooRt: tooRtS2, midAb: midAbS2, midRt: midRtS2 },
                                    anyRed: tooAbS1 || tooRtS1 || tooAbS2 || tooRtS2,
                                    anyOrange: (midAbS1 || midRtS1 || midAbS2 || midRtS2) && !(tooAbS1 || tooRtS1 || tooAbS2 || tooRtS2),
                                    maxAb,
                                    maxRt,
                                  };
                                })
                                .sort((a, b) => {
                                  if (mode === "S1") {
                                    const ap = (b.S1.abPct ?? -1) - (a.S1.abPct ?? -1);
                                    if (ap !== 0) return ap;
                                    const rp = (b.S1.rtPct ?? -1) - (a.S1.rtPct ?? -1);
                                    if (rp !== 0) return rp;
                                  } else if (mode === "S2") {
                                    const ap = (b.S2.abPct ?? -1) - (a.S2.abPct ?? -1);
                                    if (ap !== 0) return ap;
                                    const rp = (b.S2.rtPct ?? -1) - (a.S2.rtPct ?? -1);
                                    if (rp !== 0) return rp;
                                  } else {
                                    const ap = (b.maxAb ?? -1) - (a.maxAb ?? -1);
                                    if (ap !== 0) return ap;
                                    const rp = (b.maxRt ?? -1) - (a.maxRt ?? -1);
                                    if (rp !== 0) return rp;
                                  }
                                  return a.st.localeCompare(b.st);
                                });

                              const fmtPct = (v: number | null) => (v == null ? "—" : `${Math.round(v * 10) / 10}%`);

                              const rowBg = (r: any) =>
                                r.anyRed
                                  ? "bg-red-50 dark:bg-red-950/25"
                                  : r.anyOrange
                                    ? "bg-amber-50 dark:bg-amber-950/25"
                                    : "bg-white dark:bg-[#1f2d42]";

                              const infoLine = () => {
                                if (mode === "S1") {
                                  return (
                                    <div className="text-[11px] text-neutral-600 dark:text-neutral-300">
                                      Jours de cours effectifs (jusqu’à aujourd’hui) : <b>{denomEffS1}</b>{" "}
                                      <span className="text-neutral-500 dark:text-neutral-300">
                                        (prévu : {denomPlannedS1})
                                      </span>
                                    </div>
                                  );
                                }
                                if (mode === "S2") {
                                  return (
                                    <div className="text-[11px] text-neutral-600 dark:text-neutral-300">
                                      SJours de cours effectifs (jusqu’à aujourd’hui) : <b>{denomEffS2}</b>{" "}
                                      <span className="text-neutral-500 dark:text-neutral-300">
                                        (prévu : {denomPlannedS2})
                                      </span>
                                    </div>
                                  );
                                }
                               };

                              return (
                                <div className="space-y-2">
                                  {infoLine()}

                                  <div className="rounded-lg border border-neutral-200 dark:border-sky-400/35 overflow-hidden">
                                    <div className="max-h-[70vh] overflow-auto">
                                      <table className="w-full border-collapse text-xs">
                                        <thead className="sticky top-0 bg-white dark:bg-[#1f2d42] z-10">
                                          {mode === "ALL" ? (
                                            <>
                                              <tr>
                                                <th className="text-left px-2 py-2 border-b border-neutral-200 dark:border-sky-400/35 w-[240px]" rowSpan={2}>
                                                  Élève
                                                </th>
                                                <th className="text-center px-2 py-2 border-b border-neutral-200 dark:border-sky-400/35" colSpan={4}>
                                                  Semestre 1 (S1)
                                                </th>
                                                <th className="text-center px-2 py-2 border-b border-neutral-200 dark:border-sky-400/35" colSpan={4}>
                                                  Semestre 2 (S2)
                                                </th>
                                              </tr>
                                              <tr>
                                                <th className="text-center px-2 py-2 border-b border-neutral-200 dark:border-sky-400/35 w-[70px]">AB</th>
                                                <th className="text-center px-2 py-2 border-b border-neutral-200 dark:border-sky-400/35 w-[80px]">AB %</th>
                                                <th className="text-center px-2 py-2 border-b border-neutral-200 dark:border-sky-400/35 w-[70px]">RT</th>
                                                <th className="text-center px-2 py-2 border-b border-neutral-200 dark:border-sky-400/35 w-[80px]">RT %</th>

                                                <th className="text-center px-2 py-2 border-b border-neutral-200 dark:border-sky-400/35 w-[70px]">AB</th>
                                                <th className="text-center px-2 py-2 border-b border-neutral-200 dark:border-sky-400/35 w-[80px]">AB %</th>
                                                <th className="text-center px-2 py-2 border-b border-neutral-200 dark:border-sky-400/35 w-[70px]">RT</th>
                                                <th className="text-center px-2 py-2 border-b border-neutral-200 dark:border-sky-400/35 w-[80px]">RT %</th>
                                              </tr>
                                            </>
                                          ) : (
                                            <tr>
                                              <th className="text-left px-2 py-2 border-b border-neutral-200 dark:border-sky-400/35 w-[260px]">
                                                Élève
                                              </th>
                                              <th className="text-center px-2 py-2 border-b border-neutral-200 dark:border-sky-400/35 w-[80px]">
                                                ABSENCE
                                              </th>
                                              <th className="text-center px-2 py-2 border-b border-neutral-200 dark:border-sky-400/35 w-[90px]">
                                                ABSENCE %
                                              </th>
                                              <th className="text-center px-2 py-2 border-b border-neutral-200 dark:border-sky-400/35 w-[80px]">
                                                RETARD 
                                              </th>
                                              <th className="text-center px-2 py-2 border-b border-neutral-200 dark:border-sky-400/35 w-[90px]">
                                                RETARD %
                                              </th>
                                            </tr>
                                          )}
                                        </thead>

                                        <tbody>
                                          {rows.map((r) => {
                                            const bg = rowBg(r);

                                            if (mode === "S1") {
                                              return (
                                                <tr key={r.st} className={bg}>
                                                  <td className="px-2 py-2 border-b border-neutral-200 dark:border-sky-400/35 whitespace-nowrap">
                                                    <span className="truncate inline-block max-w-[260px]" title={r.st}>
                                                      {r.st}
                                                    </span>
                                                  </td>
                                                  <td className="px-2 py-2 text-center border-b border-neutral-200 dark:border-sky-400/35 tabular-nums">{r.S1.ab}</td>
                                                  <td className="px-2 py-2 text-center border-b border-neutral-200 dark:border-sky-400/35 tabular-nums">{fmtPct(r.S1.abPct)}</td>
                                                  <td className="px-2 py-2 text-center border-b border-neutral-200 dark:border-sky-400/35 tabular-nums">{r.S1.rt}</td>
                                                  <td className="px-2 py-2 text-center border-b border-neutral-200 dark:border-sky-400/35 tabular-nums">{fmtPct(r.S1.rtPct)}</td>
                                                </tr>
                                              );
                                            }

                                            if (mode === "S2") {
                                              return (
                                                <tr key={r.st} className={bg}>
                                                  <td className="px-2 py-2 border-b border-neutral-200 dark:border-sky-400/35 whitespace-nowrap">
                                                    <span className="truncate inline-block max-w-[260px]" title={r.st}>
                                                      {r.st}
                                                    </span>
                                                  </td>
                                                  <td className="px-2 py-2 text-center border-b border-neutral-200 dark:border-sky-400/35 tabular-nums">{r.S2.ab}</td>
                                                  <td className="px-2 py-2 text-center border-b border-neutral-200 dark:border-sky-400/35 tabular-nums">{fmtPct(r.S2.abPct)}</td>
                                                  <td className="px-2 py-2 text-center border-b border-neutral-200 dark:border-sky-400/35 tabular-nums">{r.S2.rt}</td>
                                                  <td className="px-2 py-2 text-center border-b border-neutral-200 dark:border-sky-400/35 tabular-nums">{fmtPct(r.S2.rtPct)}</td>
                                                </tr>
                                              );
                                            }

                                            return (
                                              <tr key={r.st} className={bg}>
                                                <td className="px-2 py-2 border-b border-neutral-200 dark:border-sky-400/35 whitespace-nowrap">
                                                  <span className="truncate inline-block max-w-[260px]" title={r.st}>
                                                    {r.st}
                                                  </span>
                                                </td>

                                                <td className="px-2 py-2 text-center border-b border-neutral-200 dark:border-sky-400/35 tabular-nums">{r.S1.ab}</td>
                                                <td className="px-2 py-2 text-center border-b border-neutral-200 dark:border-sky-400/35 tabular-nums">{fmtPct(r.S1.abPct)}</td>
                                                <td className="px-2 py-2 text-center border-b border-neutral-200 dark:border-sky-400/35 tabular-nums">{r.S1.rt}</td>
                                                <td className="px-2 py-2 text-center border-b border-neutral-200 dark:border-sky-400/35 tabular-nums">{fmtPct(r.S1.rtPct)}</td>

                                                <td className="px-2 py-2 text-center border-b border-neutral-200 dark:border-sky-400/35 tabular-nums">{r.S2.ab}</td>
                                                <td className="px-2 py-2 text-center border-b border-neutral-200 dark:border-sky-400/35 tabular-nums">{fmtPct(r.S2.abPct)}</td>
                                                <td className="px-2 py-2 text-center border-b border-neutral-200 dark:border-sky-400/35 tabular-nums">{r.S2.rt}</td>
                                                <td className="px-2 py-2 text-center border-b border-neutral-200 dark:border-sky-400/35 tabular-nums">{fmtPct(r.S2.rtPct)}</td>
                                              </tr>
                                            );
                                          })}
                                        </tbody>
                                      </table>
                                    </div>
                                  </div>

                                </div>
                              );
                            })()}
                          </div>
                        </Drawer>
</div>
                    );
                  })()
                )
              )}

              {/* === VUE CLASSE === */}
              
              {suiviElevesMode === "docs" && (
                <>
              {!isTauriRuntime() && (
                <div className="rounded-lg border border-amber-200 bg-amber-50 dark:bg-amber-950/35 px-3 py-2 text-xs text-amber-800">
                  L&apos;enregistrement des PDF est disponible uniquement dans la version installée (Tauri).
                </div>
              )}

              {!ready ? (

              <p className="text-sm text-neutral-600 dark:text-neutral-300">
                Sélectionnez une classe puis un élève pour afficher ses documents.
              </p>
            ) : (
                            <div className="flex gap-3 items-start">
                <div className="flex-1 min-w-0">
                  <div className="grid grid-cols-1 gap-3">
                    {folders.map((f) => {
                      const files = docsFilesByFolder[f.key] || [];
                      return (
                        <div
                          key={f.key}
                          className="rounded-xl border border-neutral-200 dark:border-sky-400/35 bg-neutral-50 dark:bg-[#0f1b2d] p-3"
                        >
                          <div className="flex items-start justify-between gap-2">
                            <div>
                              <div className="text-sm font-semibold">{f.label}</div>
                            </div>

                            <Button
                              type="button"
                              className="h-7 px-2 text-xs border border-neutral-200 dark:border-sky-400/35 !bg-white dark:!bg-[#243554] !text-neutral-900 dark:!text-neutral-50 hover:!bg-amber-100/70 dark:hover:!bg-[#3d2707]"
                              onClick={() => handleUploadPdf(f.key)}
                              disabled={!isTauriRuntime()}
                              title="Ajouter un PDF"
                            >
                              <Plus className="w-4 h-4 mr-1" /> Ajouter
                            </Button>
                          </div>

                          {files.length === 0 ? (
                            <p className="mt-3 text-xs text-neutral-500 dark:text-neutral-300">
                              Aucun PDF dans ce dossier.
                            </p>
                          ) : (
                            <div className="mt-3 space-y-2">
                              {files.map((it) => (
                                <div
                                  key={it.path}
                                  className="flex items-stretch rounded-lg border border-neutral-200 dark:border-sky-400/35 bg-white dark:bg-[#1f2d42] overflow-hidden"
                                >
                                  <button
                                    type="button"
                                    className="flex-1 text-left px-3 py-2 text-xs text-neutral-900 dark:text-neutral-300 hover:bg-amber-100/70 dark:hover:bg-[#3d2707]"
                                    onClick={() => handleViewPdf(it.path)}
                                    title="Ouvrir"
                                  >
                                    <div className="font-medium text-[12px] line-clamp-1">{it.name}</div>
                                  </button>
                                  <Button
                                    type="button"
                                    variant="ghost"
                                    className="h-auto px-2 rounded-none text-red-600 dark:text-red-300 hover:text-red-700 dark:hover:text-red-200 hover:bg-amber-100/70 dark:hover:bg-red-950/30"
                                    title="Supprimer"
                                    onClick={(e) => {
                                      e.stopPropagation();
                                      handleDeletePdf(it.path);
                                    }}
                                  >
                                    <Trash2 className="w-4 h-4" />
                                  </Button>
                                </div>
                              ))}
                            </div>
                          )}
                        </div>
                      );
                    })}
                  </div>
                </div>

                {pdfViewer ? (
                  <aside className="w-[650px] h-[700px] shrink-0 hidden lg:flex flex-col rounded-xl border border-neutral-200 dark:border-sky-400/35 bg-white dark:bg-[#1f2d42] shadow-sm overflow-hidden">
                    <div className="flex items-center justify-between gap-2 px-3 py-2 border-b border-neutral-200 dark:border-sky-400/35">
                      <div className="min-w-0">
                        <div className="text-[11px] text-neutral-500 dark:text-neutral-300">Aperçu PDF</div>
                        <div className="text-xs font-semibold truncate" title={pdfViewer.name}>{pdfViewer.name}</div>
                      </div>
                      <div className="flex items-center gap-2">
                        <button
                          type="button"
                          className="px-2 py-1 rounded-md border border-neutral-200 dark:border-sky-400/35 text-[11px] bg-white dark:bg-[#182433] hover:bg-amber-100/70"
                          onClick={() => window.open(pdfViewer.url, "_blank", "noopener,noreferrer")}
                          title="Ouvrir dans une nouvelle fenêtre"
                        >
                          Ouvrir
                        </button>
                        <button
                          type="button"
                          className="h-8 w-8 inline-flex items-center justify-center rounded-md border border-neutral-200 dark:border-sky-400/35 bg-white dark:bg-[#182433] hover:bg-amber-100/70"
                          onClick={() => setPdfViewer(null)}
                          aria-label="Fermer l'aperçu"
                          title="Fermer"
                        >
                          <X className="h-4 w-4" />
                        </button>
                      </div>
                    </div>

                    <div className="flex-1 bg-white dark:bg-[#182433] overflow-auto p-3">
                      <div className="mx-auto w-full max-w-[660px] aspect-[148/210] bg-white rounded-xl shadow-sm border border-neutral-200 dark:border-sky-400/35 overflow-hidden">
                        <iframe
                          title={pdfViewer.name}
                          src={pdfViewer.url}
                          className="w-full h-full"
                        />
                      </div>
                    </div>
                  </aside>
                ) : (
                  <aside className="w-[420px] shrink-0 hidden lg:flex flex-col items-center justify-center rounded-xl border border-dashed border-neutral-200 dark:border-sky-400/35 bg-white/50 dark:bg-[#1f2d42] text-xs text-neutral-500 dark:text-neutral-300">
                    Cliquez sur un PDF pour l&apos;afficher ici.
                  </aside>
                )}
              </div>
            )}
                </>
              )}

            </div>

          </div>
        );
      })()}
    </section>
  </>
) : (

  <>
    {/* 🧮 VUE NOTE – tableau élèves × devoirs */}
      {/* Sélection de la classe + mode NOTE */}
{/* Sélection de la classe + mode NOTE – bandeau fixe */}
<div
  className="sticky top-[67px] z-50 backdrop-blur border-b border-black dark:border-sky-400/35 bg-white/70 dark:bg-[#1f2d42]/70 dark:bg-[#1f2d42]/95 dark:border-[#1b467a] dark:text-white night-banner"
>
  <div className="flex flex-col gap-4 sm:flex-row sm:items-end py-2 px-2 sm:px-4 lg:px-6">
    {/* 🔁 Mode NOTE : Tableau / Notation */}
    <div className="flex-1 space-y-1">
      <div className="inline-flex rounded-full border border-neutral-200 dark:border-sky-400/35 bg-neutral-50 dark:bg-[#182433] p-1 text-xs">
        <button
          type="button"
          onClick={() => setNotesMode("devoirs")}
          className={classNames(
            "px-3 py-1 rounded-full transition inline-flex items-center gap-1.5",
            notesMode === "devoirs"
              ? "bg-neutral-900 text-white"
              : "bg-transparent text-neutral-700 dark:text-neutral-300 hover:bg-amber-100/70 dark:bg-[#182433] dark:hover:bg-[#3d2707]"
          )}
        >
          <span className="mr-1" aria-hidden="true">📁</span><span>Devoirs par classe</span>
        </button>

        <button
          type="button"
          onClick={() => setNotesMode("tableau")}
          className={classNames(
            "px-3 py-1 rounded-full transition inline-flex items-center gap-1.5",
            notesMode === "tableau"
              ? "bg-neutral-900 text-white"
              : "bg-transparent text-neutral-700 dark:text-neutral-300 hover:bg-amber-100/70 dark:bg-[#182433] dark:hover:bg-[#3d2707]"
          )}
        >
          <span className="mr-1" aria-hidden="true">📊</span><span>Récapitulatif des notes</span>
        </button>

        <button
          type="button"
          onClick={() => setNotesMode("notation")}
          className={classNames(
            "px-3 py-1 rounded-full transition inline-flex items-center gap-1.5",
            notesMode === "notation"
              ? "bg-neutral-900 text-white"
              : "bg-transparent text-neutral-700 dark:text-neutral-300 hover:bg-amber-100/70 dark:bg-[#182433] dark:hover:bg-[#3d2707]"
          )}
        >
          <span className="mr-1" aria-hidden="true">🎯</span><span>Notation des compétences</span>
        </button>
      </div>
    </div>

    {/* Année / Classe / Élève (au même niveau que les sous-onglets) */}
    <div className="flex flex-wrap items-end gap-2 sm:ml-auto sm:justify-end">
      {/* Année : 1ère / 2ème */}
      <div className="inline-flex rounded-full border border-neutral-200 dark:border-sky-400/35 bg-neutral-50 dark:bg-[#182433] p-1 text-xs">
        <button
          type="button"
          onClick={() => switchTrainingYear("premiere")}
          className={classNames(
            "px-3 py-1 rounded-full transition",
            trainingYear === "premiere"
              ? "bg-neutral-900 text-white"
              : "bg-transparent text-neutral-700 dark:text-neutral-300 hover:bg-amber-100/70 dark:hover:bg-[#3d2707]"
          )}
        >
          1ère
        </button>
        <button
          type="button"
          onClick={() => switchTrainingYear("deuxieme")}
          className={classNames(
            "px-3 py-1 rounded-full transition",
            trainingYear === "deuxieme"
              ? "bg-neutral-900 text-white"
              : "bg-transparent text-neutral-700 dark:text-neutral-300 hover:bg-amber-100/70 dark:hover:bg-[#3d2707]"
          )}
        >
          2ème
        </button>
      </div>

      {/* Classe */}
      <select
        className="h-8 w-[170px] sm:w-[220px] border border-neutral-300 dark:border-sky-400/35 rounded-md bg-white dark:bg-[#182433] px-2 text-xs"
        value={selectedClassIdForSuivi ?? ""}
        onChange={(e) => {
          const next = e.target.value || null;
          setSelectedClassIdForSuivi(next);
          setSelectedStudentForSuivi(null);
          setSelectedEvalIdForClasse(null);
        }}
      >
        <option value="" disabled>
          Classe…
        </option>
        {classGroups.map((c) => (
          <option key={c.id} value={c.name}>
            {c.name}
          </option>
        ))}
      </select>

      {/* Élève */}
      {(() => {
        const classe = classGroups.find((c) => c.name === selectedClassIdForSuivi);
        const students = classe
          ? (classe.students || "")
              .split("\n")
              .map((s) => s.trim())
              .filter(Boolean)
          : [];
        const disabled = !classe || students.length === 0;

        return (
          <select
            className="h-8 w-[130px] sm:w-[160px] border border-neutral-300 dark:border-sky-400/35 rounded-md bg-white dark:bg-[#182433] px-2 text-xs disabled:opacity-60"
            value={selectedStudentForSuivi ?? ""}
            onChange={(e) => setSelectedStudentForSuivi(e.target.value)}
            disabled={disabled}
          >
            <option value="" disabled>
              Élève…
            </option>
            {students.map((st) => (
              <option key={st} value={st}>
                {st}
              </option>
            ))}
          </select>
        );
      })()}
    </div>

    </div>
  </div>

{/* 👉 Contenu sous le bandeau */}
<div className="mt-4">
  {(() => {
    const classe = classGroups.find((c) => c.name === selectedClassIdForSuivi);

    if (!classe) {
      return (
        <p className="text-sm text-neutral-600 dark:text-neutral-300 px-2 sm:px-4 lg:px-6">
          Choisissez une classe pour afficher le tableau des notes.
        </p>
      );
    }

        if (notesMode === "devoirs") {
      return (
        <div ref={suiviClassePdfRef} className="mt-4 space-y-4">
          <div className="no-print flex items-center justify-between">
            <div>
              <h2 className="text-sm font-semibold text-neutral-900 dark:text-neutral-300">
                Devoirs par classe – {classe.name}
              </h2>
            </div>
          </div>

          <div className="flex gap-2 items-start overflow-x-auto pb-6">
                                {/* Colonne de boutons (Tâches) */}
                                <div className="flex flex-col items-center mt-10 space-y-2">
                                  <button
                                    type="button"
                                    onClick={() => setShowTasksVolet((prev) => !prev)}
                                    className="w-8 h-16 flex items-center justify-center rounded-r-lg border border-neutral-300 dark:border-sky-400/35 bg-white hover:bg-amber-100/70 dark:bg-[#182433] shadow-sm hover:bg-amber-100/70 dark:bg-[#182433]"
                                    title={
                                      showTasksVolet
                                        ? "Masquer le volet des tâches"
                                        : "Afficher le volet des tâches"
                                    }
                                  >
                                    <span
                                      className={
                                        "text-[10px] font-semibold tracking-wide " +
                                        (showTasksVolet ? "text-neutral-900 dark:text-neutral-300" : "text-neutral-500")
                                      }
                                      style={{
                                        writingMode: "vertical-rl",
                                        transform: "rotate(180deg)",
                                        whiteSpace: "normal",      // ✅ autorise le retour à la ligne
                                        wordBreak: "break-word",   // ✅ casse les mots longs si besoin
                                        maxHeight: 96,             // optionnel : limite la hauteur du texte dans le header
                                        overflow: "hidden",
                                      }}
                                    >
                                      TÂCHES
                                    </span>
                                  </button>
                                </div>

                                {/* Volet Tâches TOTAL repliable */}
                                <div className="flex flex-col gap-2">
                                  <div
                                    className={`transition-all duration-200 ease-in-out ${
                                      showTasksVolet
                                        ? "opacity-100 translate-x-0 w-auto min-w-[260px]"
                                        : "opacity-0 -translate-x-4 w-0 pointer-events-none"
                                    }`}
                                  >
                                    {showTasksVolet && (
                                      <TasksVoletTotal selectedClassId={selectedClassIdForSuivi} />
                                    )}
                                  </div>
                                </div>

                                {/* Zone principale : tableau combiné S1 + S2 */}
                                <div className="flex flex-col gap-4 flex-1 min-w-[600px]">
                                  <DoubleSemesterMatrix
                                    allCompetences={allCompetencesForSuivi}
                                    evalMetaList={evalMetaList}
                                    selectedClassId={selectedClassIdForSuivi}
                                    compsByEvalId={compsByEvalId}
                                    onAddDevoirS1={() => {
                                      setClasseSemesterForSuivi("S1");
                                      handleOpenDevoirDatabase();
                                    }}
                                    onAddDevoirS2={() => {
                                      setClasseSemesterForSuivi("S2");
                                      handleOpenDevoirDatabase();
                                    }}
                                    onRemoveDevoir={(ev) => {
                                      handleRemoveEvalFromClasseSemester(ev.id);
                                    }}
                                    onOpenDevoir={handleOpenClasseDevoir}
                                  />
                                </div>
                              </div>
        </div>
      );
    }

const students = (classe.students || "")
      .split("\n")
      .map((s) => s.trim())
      .filter(Boolean);

    const evalsForClass = evalMetaList.filter(
      (ev) =>
        ev.group === classe.name &&
        ev.semester !== "Ne pas utiliser de semestre"
    );

    const schoolYear = getCurrentSchoolYear();
    const notationsForYear = notationDB[schoolYear]?.[classe.name] || {};

    if (students.length === 0) {
      return (
        <p className="text-sm text-neutral-600 dark:text-neutral-300 px-2 sm:px-4 lg:px-6">
          Aucun élève n&apos;est renseigné pour cette classe. Ajoutez-les via 📚 CLASSE.
        </p>
      );
    }

    if (evalsForClass.length === 0) {
      return (
        <p className="text-sm text-neutral-600 dark:text-neutral-300 px-2 sm:px-4 lg:px-6">
          Aucun devoir n&apos;est encore associé à cette classe.
        </p>
      );
    }

    const evalsS1 = evalsForClass.filter((ev) => ev.semester === "S1");
    const evalsS2 = evalsForClass.filter((ev) => ev.semester === "S2");

    // ✅ Important: orderedEvals reste dispo pour le mode "notation"
    const orderedEvals = [...evalsS1, ...evalsS2];

    if (notesMode === "tableau") {
      const renderNotesTable = (label: string, evals: EvalMeta[]) => {
        if (evals.length === 0) return null;

        return (
          <div className="space-y-2">
            <div className="text-xs font-semibold text-neutral-700 dark:text-neutral-300">
              {label}
            </div>

            <div className="border rounded-xl bg-white dark:bg-[#1f2d42] shadow-sm overflow-x-auto">
              <table className="w-full border-collapse table-fixed">
                <thead>
                  <tr className="bg-neutral-50 dark:bg-[#1f2d42]">
                    <th className="border px-2 py-1 text-left min-w-[160px]">
                      Élèves
                    </th>

                    {evals.map((ev) => (
                      <th
                        key={ev.id}
                        className="border px-2 py-1 text-center min-w-[120px]"
                      >
                        <div className="font-semibold truncate">{ev.name}</div>
                      </th>
                    ))}
                  </tr>
                </thead>

                <tbody>
                  {students.map((st) => (
                    <tr key={st} className="odd:bg-white dark:bg-[#1f2d42] even:bg-neutral-50/60 dark:bg-[#1f2d42]/60">
                      <td className="border px-2 py-1 text-xs">{st}</td>

                      {evals.map((ev) => {
                        const evalBucket = (notationsForYear as any)[ev.id] || {};
                        const entry = evalBucket[st] as NotationEntry | undefined;
                        const mark = entry?.markOn20;
                        const engagement = entry?.engagementLevel ?? null;
                        const status = entry?.status;

                        const display =
                          status === "AB"
                            ? "AB"
                            : status === "N.NOT"
                              ? "N.NOT"
                              : typeof mark === "number"
                              ? mark.toFixed(2).replace(".", ",")
                              : "—";

                        const cellMarkBgClass =
                          (status === "AB" || status === "N.NOT")
                            ? "bg-neutral-200 dark:bg-[#243554] text-neutral-800 dark:text-neutral-300 font-semibold"
                            : getMarkCellBg4Classes(mark);
const cellEngagementRingClass = engagement
                          ? engagement === "volontaire"
                            ? "ring-2 ring-emerald-500/70"
                            : engagement === "engage"
                            ? "ring-2 ring-emerald-400/60"
                            : engagement === "normal"
                            ? "ring-2 ring-neutral-400/50"
                            : engagement === "attente"
                            ? "ring-2 ring-amber-400/60"
                            : "ring-2 ring-red-400/60"
                          : "";

                        return (
                          <td
                            key={ev.id + "-" + st}
                            className={classNames(
                              "border px-2 py-1 text-center text-[11px] relative transition-colors",
                              mark != null ? "text-neutral-800 dark:text-neutral-300" : "text-neutral-400",
                              cellMarkBgClass,
                              cellEngagementRingClass,
                              engagement ? "ring-inset" : ""
                            )}
                          >
                            {display}
                          </td>
                        );
                      })}
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          </div>
        );
      };

      return (
        <div className="px-2 sm:px-4 lg:px-6 space-y-6 pb-20">
          {renderNotesTable("SEMESTRE 1", evalsS1)}
          {renderNotesTable("SEMESTRE 2", evalsS2)}
        </div>
      );
    }

    // 🧩 Mode NOTE = "notation"
    return (
      <div className="border rounded-xl bg-white dark:bg-[#1f2d42] shadow-sm p-4 text-sm text-neutral-600 dark:text-neutral-300 space-y-4 mx-6 sm:mx-6 lg:mx-auto lg:max-w-8xl">
        {/* Sélecteurs ÉLÈVE + DEVOIR */}
        <div className="grid gap-4 sm:grid-cols-2">
          {/* Élève */}
          <div className="space-y-1">
            <select
              className="block w-full border border-neutral-300 dark:border-sky-400/35 rounded-md bg-white dark:bg-[#182433] px-2 py-1 text-xs"
              value={selectedNoteStudent ?? ""}
              onChange={(e) => setSelectedNoteStudent(e.target.value || null)}
            >
              <option value="">Sélectionner un élève</option>
              {students.map((st) => (
                <option key={st} value={st}>
                  {st}
                </option>
              ))}
            </select>
          </div>

          {/* Devoir */}
          <div className="space-y-1">
            <select
              className="block w-full border border-neutral-300 dark:border-sky-400/35 rounded-md bg-white dark:bg-[#182433] px-2 py-1 text-xs"
              value={selectedNoteEvalId ?? ""}
              onChange={(e) => setSelectedNoteEvalId(e.target.value || null)}
            >
              <option value="">Sélectionner un devoir</option>
              {(() => {
                const s1 = orderedEvals.filter((ev) => ev.semester === "S1");
                const s2 = orderedEvals.filter((ev) => ev.semester === "S2");
                const other = orderedEvals.filter(
                  (ev) => ev.semester !== "S1" && ev.semester !== "S2"
                );

                return (
                  <>
                    {s1.length > 0 && (
                      <optgroup label="Semestre 1">
                        {s1.map((ev) => (
                          <option key={ev.id} value={ev.id}>
                            {ev.name}
                          </option>
                        ))}
                      </optgroup>
                    )}

                    {s2.length > 0 && (
                      <optgroup label="Semestre 2">
                        {s2.map((ev) => (
                          <option key={ev.id} value={ev.id}>
                            {ev.name}
                          </option>
                        ))}
                      </optgroup>
                    )}

                    {other.length > 0 && (
                      <optgroup label="Autres">
                        {other.map((ev) => (
                          <option key={ev.id} value={ev.id}>
                            {ev.name}
                          </option>
                        ))}
                      </optgroup>
                    )}
                  </>
                );
              })()}</select>
          </div>
        </div>

        {/* Petit rappel (notation élève) */}
        <div className="flex items-center justify-between gap-2 mt-1 min-h-[1.5rem]">
          <div className="text-xs text-neutral-500">
            {selectedNoteStudent && selectedNoteEvalId && (
              <span>
                Tu notes actuellement <strong>{selectedNoteStudent}</strong> sur le devoir{" "}
                <strong>
                  {orderedEvals.find((ev) => ev.id === selectedNoteEvalId)?.name}
                </strong>.
              </span>
            )}
          </div>

          <div>
          </div>
        </div>

        {selectedNoteEvalId ? (
          <div className="mt-2">{renderNotationCriteree({ lockWeights: true })}</div>
        ) : (
          <div className="mt-2 text-xs text-neutral-500">
            Choisis un devoir pour afficher la grille de notation.
          </div>
        )}
      </div>
    );
  })()}
</div>

  </>
)}


      {/* Drawer Base des devoirs */}
      <Drawer
        open={devoirDBOpen}
        onClose={() => setDevoirDBOpen(false)}
        side="right"
        className="w-[380px] sm:w-[460px] bg-neutral-50 dark:bg-[#0f1b2d]"
      >
        <div className="px-4 py-3 border-b border-neutral-200 dark:border-sky-400/35 font-semibold bg-white dark:bg-[#1f2d42] text-neutral-900 dark:text-neutral-300">
          Base des devoirs
        </div>

        <div className="p-3 space-y-3 bg-neutral-50 dark:bg-[#0f1b2d]">
          {!isTauriRuntime() && (
            <p className="text-xs text-red-600">
              La base des devoirs est disponible uniquement dans la version installée (Tauri).
            </p>
          )}

{isTauriRuntime() && (
  <>
    <div className="flex items-center justify-between gap-2">
      <p className="text-xs text-neutral-600 dark:text-neutral-300">
        Liste des devoirs enregistrés dans le dossier <code>devoir</code>.
      </p>
      <Button
        type="button"
        className="h-7 px-2 text-xs border border-neutral-200 dark:border-sky-400/35 !bg-neutral-100 dark:!bg-[#243554] !text-neutral-900 dark:!text-neutral-50 hover:!bg-amber-100/70 dark:hover:!bg-[#3d2707]"
        onClick={handleOpenDevoirDatabase}
      >
        🔄 Actualiser
      </Button>
    </div>

    {/* ✅ ICI : on met directement les Tabs (pas besoin du if savedDevoirs.length) */}
<div className="w-full">
  <Tabs
    value={devoirDBTab}
    onValueChange={(v) => setDevoirDBTab(v as "devoirs" | "corbeille")}
  >
      <TabsList className="w-full !bg-neutral-100 dark:!bg-[#0f1b2d] border border-neutral-200 dark:border-sky-400/35">
        <TabsTrigger
          value="devoirs"
          className="flex-1 !text-neutral-900 dark:!text-neutral-50 !bg-transparent dark:!bg-transparent data-[state=active]:!bg-white data-[state=active]:!text-neutral-900 dark:data-[state=active]:!bg-sky-500/35 dark:data-[state=active]:!text-neutral-50 dark:data-[state=active]:shadow-[inset_0_0_0_1px_rgba(56,189,248,0.55)] hover:!bg-amber-100/70 dark:hover:!bg-[#3d2707]"
        >
          Devoirs
        </TabsTrigger>
        <TabsTrigger
          value="corbeille"
          className="flex-1 !text-neutral-900 dark:!text-neutral-50 !bg-transparent dark:!bg-transparent data-[state=active]:!bg-white data-[state=active]:!text-neutral-900 dark:data-[state=active]:!bg-sky-500/35 dark:data-[state=active]:!text-neutral-50 dark:data-[state=active]:shadow-[inset_0_0_0_1px_rgba(56,189,248,0.55)] hover:!bg-amber-100/70 dark:hover:!bg-[#3d2707]"
        >
          Corbeille
        </TabsTrigger>
      </TabsList>

      <TabsContent value="devoirs" className="mt-2">
        {savedDevoirs.length === 0 ? (
          <p className="text-xs text-neutral-500 dark:text-neutral-300 mt-2">
            Aucun devoir enregistré pour l’instant.
          </p>
        ) : (
          <div className="space-y-2 mt-2">
            {savedDevoirs.map((dv) => (
              <div
                key={dv.fileName}
                className="w-full border border-neutral-200 dark:border-sky-400/35 rounded-lg bg-white dark:bg-[#1f2d42] shadow-sm hover:bg-amber-100/70 dark:hover:bg-[#3d2707] flex items-stretch"
              >
                <button
                  type="button"
                  onClick={() => handleSelectDevoirFromDatabase(dv)}
                  className="flex-1 text-left px-3 py-2 text-xs text-neutral-900 dark:text-neutral-300"
                >
                  <div className="font-medium text-[13px]">{dv.title}</div>
                  <div className="text-[11px] text-neutral-500 dark:text-neutral-300">
                    Fichier : {dv.fileName}
                  </div>
                  {dv.group && (
                    <div className="text-[11px] text-neutral-500 dark:text-neutral-300">
                      Classe : {dv.group}
                    </div>
                  )}
                  {dv.evaluationType && (
                    <div className="text-[11px] text-neutral-500 dark:text-neutral-300">
                      Type : {dv.evaluationType}
                    </div>
                  )}
                </button>

                <Button
                  type="button"
                  variant="ghost"
                  className="h-auto px-2 rounded-none rounded-r-lg text-red-600 dark:text-red-300 hover:text-red-700 dark:hover:text-red-200 hover:bg-amber-100/70 dark:hover:bg-red-950/30"
                  title="Mettre à la corbeille"
                  onClick={(e) => {
                    e.stopPropagation();
                    moveDevoirToTrash(dv);
                  }}
                >
                  <Trash2 className="w-4 h-4" />
                </Button>
              </div>
            ))}
          </div>
        )}
      </TabsContent>

      <TabsContent value="corbeille" className="mt-2">
        {savedDevoirsTrash.length === 0 ? (
          <p className="text-xs text-neutral-500 dark:text-neutral-300 mt-2">Corbeille vide.</p>
        ) : (
          <div className="space-y-2 mt-2">
            {savedDevoirsTrash.map((dv) => (
              <div
                key={dv.fileName}
                className="w-full border border-neutral-200 dark:border-sky-400/35 rounded-lg bg-white dark:bg-[#182433] shadow-sm hover:bg-amber-100/70 dark:hover:bg-[#3d2707] px-3 py-2 text-xs text-neutral-900 dark:text-neutral-300"
              >
                <div className="font-medium text-[13px]">{dv.title}</div>
                <div className="text-[11px] text-neutral-500 dark:text-neutral-300">
                  Fichier : {dv.fileName}
                </div>

                <div className="mt-2 flex items-center gap-2">
                  <Button
                    type="button"
                    variant="outline"
                    className="h-7 px-2 text-xs border border-neutral-200 dark:border-sky-400/35 bg-white dark:bg-[#22344d] text-neutral-900 dark:text-neutral-300 hover:bg-amber-100/70 dark:hover:bg-[#3d2707]"
                    onClick={() => restoreDevoirFromTrash(dv)}
                  >
                    Restaurer
                  </Button>

                  <Button
                    type="button"
                    className="h-7 px-2 text-xs bg-red-600 text-white hover:bg-amber-100/70 dark:bg-red-500/80 dark:hover:bg-red-500"
                    onClick={() => deleteDevoirPermanently(dv)}
                  >
                    Supprimer définitivement
                  </Button>
                </div>
              </div>
            ))}
          </div>
        )}
      </TabsContent>
    </Tabs>
    </div>
  </>
)}

        </div>
      </Drawer>

      {/* Drawer de gestion de bibliothèque */}
      <Drawer
        open={!!manageKey}
        onClose={() => setManageKey(null)}
        side="right"
        className="w-full max-w-lg p-6 bg-white dark:bg-[#1f2d42] dark:bg-neutral-950"
      >
        <div className="flex items-center justify-between">
          <h3 className="text-lg font-semibold text-neutral-900 dark:text-neutral-300">Gérer les exigences</h3>
          <Button
            variant="ghost"
            className="h-9 w-9 p-0"
            onClick={() => setManageKey(null)}
            aria-label="Fermer"
          >
            <X className="w-5 h-5" />
          </Button>
        </div>

        {manageKey &&
          (() => {
            const { task, comp, item } = parseScopedCritKey(manageKey!);
            return (
              <div className="mt-2 text-xs text-neutral-500">
                {task && (
                  <div>
                    <span className="font-medium">Tâche :</span> {task}
                  </div>
                )}
                <div>
                  <span className="font-medium">Compétence :</span> {comp}
                </div>
                <div>
                  <span className="font-medium">Être capable :</span> {item}
                </div>
              </div>
            );
          })()}

        <div className="mt-4 flex items-center gap-2">
          <Input
            placeholder="Nouvelle exigence"
            value={drawerInput}
            onChange={(e) => setDrawerInput(e.target.value)}
          />
          <Button onClick={addDrawerExigence}>
            <Plus className="w-4 h-4 mr-1" />
            Ajouter
          </Button>
        </div>

        <div className="mt-4 space-y-2">
          {(manageKey ? (customExigences[manageKey] ?? []) : []).length === 0 ? (
            <div className="text-sm text-neutral-500">
              Aucune exigence personnalisée pour ce sous-critère.
            </div>
          ) : (
            (manageKey ? (customExigences[manageKey] ?? []) : []).map((ex, idx) => (
              <div key={idx} className="flex items-center gap-2">
                <div className="flex-1 text-sm">{ex}</div>
                <Button
                  className="h-9 w-9 p-0 bg-red-600 text-white hover:bg-amber-100/70"
                  onClick={() => removeDrawerExigence(idx)}
                  title="Supprimer définitivement de ma bibliothèque"
                >
                  <Trash2 className="w-4 h-4" />
                </Button>
              </div>
            ))
          )}
        </div>

        <div className="mt-6 text-xs text-neutral-500">
          Ici, la corbeille supprime de votre <strong>bibliothèque personnelle</strong> la
          sélection de la <strong>cellule</strong>, sans toucher à la bibliothèque.
        </div>
      </Drawer>

      <footer className="no-print fixed bottom-0 left-0 right-0 h-12 border-t bg-white/60 dark:bg-[#1f2d42]/60 backdrop-blur z-40">
        <div className="w-full px-2 py-4 text-xs text-neutral-500 flex items-center justify-between">
          <div>
            © {new Date().getFullYear()} · Prototype - P.Lecouillard — Évaluation CAP Maçonnerie
          </div>
        </div>
      </footer>
    </div>
  );
}