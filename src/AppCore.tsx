import React, { useState, useEffect } from "react";
import { createPortal } from "react-dom";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import { Label } from "@/components/ui/label";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
// NOTE: Les menus Radix/Shadcn (Select) peuvent provoquer un "reflow"/d√©calage du bandeau
// selon les conteneurs (overflow/transform). Pour garantir qu'aucune liste ne pousse la page,
// on utilise des <select> natifs pour les 3 s√©lecteurs (Classe / √âl√®ve / √âpreuve) dans l'en-t√™te CCF.
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import {
  DropdownMenu,
  DropdownMenuCheckboxItem,
  DropdownMenuContent,
  DropdownMenuLabel,
  DropdownMenuItem,
  DropdownMenuSeparator, DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import {
  Image as ImageIcon,
  ChevronRight,
  ChevronLeft,
  Sun,
  Moon,
  Plus,
  X,
  Trash2,
  Settings2,
  Download,
  Upload,
  Search,              // ‚Üê ajout√©
} from "lucide-react";
import { appDataDir, appLocalDataDir, join } from '@tauri-apps/api/path';
import {
  ResponsiveContainer,
  BarChart,
  Bar,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  Legend,
  ReferenceArea,
  ReferenceLine,
} from "recharts";

// FS ‚Üí plugin-fs
import {
  mkdir,
  writeTextFile,
  writeFile,
  readTextFile,
  readDir,
  exists,
  BaseDirectory,
  rename,
  remove,
  readFile,
  stat,
} from '@tauri-apps/plugin-fs';

// DIALOG ‚Üí plugin-dialog
import { open, confirm, save } from '@tauri-apps/plugin-dialog';

// Excel parsing
import * as ExcelJS from "exceljs";
import JSZip from "jszip";

import { WebviewWindow } from '@tauri-apps/api/webviewWindow';
import { getCurrentWindow } from '@tauri-apps/api/window';
import FirstRunHelp from "./components/FirstRunHelp";

import { CCF_TEMPLATES, type CcfTemplates } from "./ccfTemplates";
import { fetch as tauriFetch } from "@tauri-apps/plugin-http";
import { check } from "@tauri-apps/plugin-updater";
import { relaunch } from "@tauri-apps/plugin-process";


function classNames(...s: (string | false | null | undefined)[]) {
  return s.filter(Boolean).join(" ");
}

// Lit une variable CSS depuis :root (permet de piloter des couleurs via le CSS)
function getCssVar(name: string, fallback: string) {
  if (typeof window === "undefined") return fallback;
  try {
    const v = getComputedStyle(document.documentElement).getPropertyValue(name).trim();
    return v || fallback;
  } catch {
    return fallback;
  }
}

function parseCompetencyFamily(compLabel: string): "C1" | "C2" | "C3" | "C4" | "OTHER" {
  const m = compLabel.match(/C\s*(\d)\s*\./);
  if (!m) return "OTHER";
  const n = Number(m[1]);
  if (n === 1) return "C1";
  if (n === 2) return "C2";
  if (n === 3) return "C3";
  if (n === 4) return "C4";
  return "OTHER";
}
function compactCode(compLabel: string) {
  const m = compLabel.match(/C\s*(\d)\s*\.(\d+)/);
  if (!m) return compLabel;
  return `C${m[1]}.${m[2]}`;
}
function taskNumber(taskLabel: string) {
  const m = String(taskLabel || "").match(/T\s*0*(\d+)/i);
  return m ? Number(m[1]) : Number.MAX_SAFE_INTEGER;
}
function sortByTaskNumber(labels: string[]) {
  return labels.slice().sort((a, b) => taskNumber(a) - taskNumber(b));
}
function parseScopedCritKey(key: string): { task: string | null; comp: string; item: string } {
  const [left, item] = key.split("::");
  if (left.includes("||")) {
    const [task, comp] = left.split("||");
    return { task, comp, item };
  }
  return { task: null, comp: left, item };
}


// =====================
// √âduscol ‚Äî index des dipl√¥mes (pour autocomplete "Nom du r√©f√©rentiel")
// Source: pages "Formations" (CAP/) sur sti.eduscol.education.fr
// =====================
type EduscolDiploma = { title: string; url: string; category: string };

function stripDiacritics(input: string) {
  return (input || "")
    .normalize("NFD")
    .replace(/[\u0300-\u036f]/g, "");
}

function normKey(input: string) {
  return stripDiacritics(String(input || ""))
    .toLowerCase()
    .replace(/['‚Äô]/g, " ")
    .replace(/[^a-z0-9\s-]/g, " ")
    .replace(/\s+/g, " ")
    .trim();
}

function normalizeEduscolUrl(href: string) {
  const h = String(href || "").trim();
  if (!h) return "";
  if (h.startsWith("http://") || h.startsWith("https://")) return h;
  if (h.startsWith("//")) return `https:${h}`;
  return `https://sti.eduscol.education.fr${h.startsWith("/") ? "" : "/"}${h}`;
}

const DIPLOMA_STOPWORDS = new Set([
  "cap","de","du","des","d","l","la","le","les","et","en","a","au","aux","pour","sur","dans","√†"
]);

function scoreDiplomaTitle(title: string, query: string) {
  const t = normKey(title);
  const q = normKey(query);
  if (!q) return -1;

  // tokenisation "d√©but de mot" en ignorant CAP/BAC/PRO/etc.
  const tokens = t.split(" ").filter(Boolean);
  const significant = tokens.filter(tok => tok.length >= 2 && !DIPLOMA_STOPWORDS.has(tok));

  // 0 = meilleur score
  if (significant.some(tok => tok.startsWith(q))) return 0;
  if (tokens.some(tok => tok.startsWith(q))) return 1;
  if (t.startsWith(q)) return 2;
  if (t.includes(q)) return 3;
  return -1;
}

async function tauriFetchText(url: string): Promise<string> {
  // plugin-http : Response compatible Fetch.
  // IMPORTANT: certains sites (ex: Legifrance) filtrent fortement selon User-Agent/Accept.
  //
  // ‚úÖ Mode "logiciel" (sans config utilisateur) :
  // pour les URLs Legifrance contenant un identifiant (JORFTEXT/LEGITEXT/...), on d√©l√®gue au proxy backend
  // (qui garde le client_secret PISTE et appelle l'API L√©gifrance).
  try {
    const u = new URL(url);
    const host = (u.hostname || "").toLowerCase();
    const idMatch = String(url).match(/\b(JORFTEXT\d{12}|LEGITEXT\d{12}|LEGIARTI\d{12}|JORFARTI\d{12}|JORFCONT\d{12}|LEGISCTA\d{12})\b/);
    if (host.includes("legifrance.gouv.fr") && idMatch) {
      const proxyBaseRaw =
        (import.meta as any).env?.VITE_LEGIFRANCE_PROXY_BASE ||
        (window as any).__LEGIFRANCE_PROXY_BASE__ ||
        "http://localhost:8787";
      const proxyBase = String(proxyBaseRaw).replace(/\/$/, "");

      const r = await fetch(`${proxyBase}/legifrance/import`, {
        method: "POST",
        headers: { "Content-Type": "application/json", Accept: "application/json" },
        body: JSON.stringify({ url }),
      });

      const txt = await r.text();
      if (!r.ok) throw new Error(`Proxy HTTP ${r.status} - ${txt}`);

      let json: any;
      try {
        json = JSON.parse(txt);
      } catch {
        // Si jamais le proxy renvoie autre chose qu'un JSON, on renvoie brut
        return txt;
      }

      const data = json?.data ?? json;

      // Best-effort: cherche une string "HTML-like" dans la r√©ponse consult.
      const looksHtml = (s: any) =>
        typeof s === "string" && /<\/?(html|body|table|main|article|div)\b/i.test(s);

      const bfs = (root: any, maxNodes = 2000): string | null => {
        const q: any[] = [root];
        let seen = 0;
        while (q.length && seen < maxNodes) {
          const cur = q.shift();
          seen++;
          if (looksHtml(cur)) return cur;
          if (!cur) continue;
          if (typeof cur === "object") {
            if (Array.isArray(cur)) {
              for (const it of cur) q.push(it);
            } else {
              for (const k of Object.keys(cur)) q.push((cur as any)[k]);
            }
          }
        }
        return null;
      };

      const html = bfs(data);
      if (html) return html;

      // fallback: certaines r√©ponses renvoient du texte sans balises
      const maybe = data?.text || data?.texte || data?.content;
      if (typeof maybe === "string" && maybe.trim()) return maybe;

      throw new Error("Legifrance (proxy): aucun contenu HTML/texte exploitable dans la r√©ponse.");
    }
  } catch {
    // si URL invalide ou autre, on retombe sur la strat√©gie standard ci-dessous
  }

  const res: any = await tauriFetch(url, {
    method: "GET",
    headers: {
      "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64)",
      Accept: "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
      "Accept-Language": "fr-FR,fr;q=0.9,en;q=0.8",
    },
  });

  const status = res?.status ?? res?.statusCode ?? 0;
  if (status && status >= 400) {
    const t = (await res.text?.()) || "";
    throw new Error(`HTTP ${status} - ${t.slice(0, 300)}`);
  }
  return await res.text();
}

function parseDiplomasFromFormationListHtml(html: string, category: string): EduscolDiploma[] {
  const doc = new DOMParser().parseFromString(html, "text/html");

  // Sur ces pages, les dipl√¥mes sont g√©n√©ralement des liens dans la zone de contenu principal.
  const main =
    doc.querySelector("main") ||
    doc.querySelector("#content") ||
    doc.body;

  const links = Array.from(main.querySelectorAll<HTMLAnchorElement>("a[href]"));

  const out: EduscolDiploma[] = [];
  const seen = new Set<string>();

  for (const a of links) {
    const rawHref = a.getAttribute("href") || "";
    const url = normalizeEduscolUrl(rawHref);
    const title = (a.textContent || "").trim().replace(/\s+/g, " ");
    if (!title || title.length < 6) continue;

    // On garde surtout les liens vers le portail formations (les fiches dipl√¥mes)
    // Exemple : /formations/formations/cap-agent-de-...
    if (!url.includes("sti.eduscol.education.fr/formations/")) continue;

    const key = `${title}@@${url}`;
    if (seen.has(key)) continue;
    seen.add(key);

    out.push({ title, url, category });
  }

  return out;
}

async function buildEduscolDiplomaIndex(): Promise<EduscolDiploma[]> {
  // Pages listes "dipl√¥mes" (rendu HTML simple, contrairement au portail global qui est en template)
  const sources: Array<{ category: string; url: string }> = [
    { category: "CAP", url: "https://sti.eduscol.education.fr/formations/formations/cap" },
    // (optionnel) d'autres listes existent, mais celles-ci couvrent d√©j√† l'immense majorit√© des dipl√¥mes.
  ];

  const all: EduscolDiploma[] = [];
  for (const src of sources) {
    const html = await tauriFetchText(src.url);
    if (!html) continue;
    all.push(...parseDiplomasFromFormationListHtml(html, src.category));
  }

  // D√©dup URL (il peut y avoir des doublons entre cat√©gories/options)
  const byUrl = new Map<string, EduscolDiploma>();
  for (const d of all) {
    if (!byUrl.has(d.url)) byUrl.set(d.url, d);
  }
  return Array.from(byUrl.values()).sort((a, b) => a.title.localeCompare(b.title, "fr", { sensitivity: "base" }));
}


function TrafficLightPicker(props: {
  value: TrafficLightColor;
  onChange: (v: TrafficLightColor) => void;
  className?: string;
}) {
  const { value, onChange, className } = props;
  const items: Array<{ v: Exclude<TrafficLightColor, "none">; colorClass: string; label: string }> = [
    // Invers√©: Vert en haut, Rouge en bas
    { v: "green", colorClass: "bg-emerald-500", label: "Vert" },
    { v: "yellow", colorClass: "bg-amber-400", label: "Orange" },
    { v: "red", colorClass: "bg-red-500", label: "Rouge" },
  ];

  return (
    <div className={classNames("inline-flex flex-col items-center gap-0.5 rounded-md border px-0.5 py-0.5 app-border app-surface", className)}>
      {items.map((it) => {
        const active = value === it.v;
        return (
          <button
            key={it.v}
            type="button"
            onClick={() => onChange(active ? "none" : it.v)}
            className="rounded-full p-0 focus:outline-none focus-visible:ring-2 focus-visible:ring-neutral-900/30"
            aria-label={it.label}
            title={it.label}
          >
            <span
              className={classNames(
                "block h-3 w-3 rounded-full border app-border",
                it.colorClass,
                active ? "opacity-100 ring-2 ring-inset ring-neutral-900/30" : "opacity-30"
              )}
            />
          </button>
        );
      })}
    </div>
  );
}

function formatEvalLabel(task: string, _comp: string): string {
  return task;
}


// =====================
// Ann√©e de formation (1√®re / 2√®me ann√©e) ‚Äî s√©paration des fichiers & dossiers
// =====================
type TrainingYear = "premiere" | "deuxieme";

type PreviewTargetOptions = { mode?: "modal" | "popup"; autoPrint?: boolean; target?: "preview" | "print" | "printWindow" };
type PrintHeaderMeta = {
  viewTitle: string;
  studentName?: string;
  classId?: string;
  trainingYear?: "premiere" | "deuxieme";
  schoolYear?: string;
};

function trainingYearLabel(year?: "premiere" | "deuxieme") {
  if (year === "deuxieme") return "2√®me ann√©e";
  if (year === "premiere") return "1√®re ann√©e";
  return "";
}

// Utilise une fonction d‚Äô√©chappement fournie par l‚Äôappelant (esc/escapeHtml)
function buildPrintHeaderHtml(esc: (s: string) => string, meta: PrintHeaderMeta) {
  const titleRightParts = [
    meta.classId ? `Classe : ${meta.classId}` : "",
    meta.trainingYear ? `Ann√©e de formation : ${trainingYearLabel(meta.trainingYear)}` : "",
  ].filter(Boolean);

  const displayTitle = meta.studentName
    ? `${meta.viewTitle} ‚Äî Suivi de ${meta.studentName}`
    : meta.viewTitle;

  return `
    <div class="print-header" style="
      font-family: ui-sans-serif, system-ui;
      border-radius:10px;
      padding:10px 12px;
      margin:0 0 4px 0;
      background:var(--print-header-bg);
    ">
      <div style="display:flex;align-items:baseline;justify-content:space-between;gap:12px;">
        <div style="font-size:16px;font-weight:800;color:var(--print-header-title);">
          ${esc(displayTitle)}
        </div>
        ${titleRightParts.length ? `
          <div style="font-size:12px;color:var(--print-header-meta);text-align:right;white-space:nowrap;">
            ${esc(titleRightParts.join(" ‚Ä¢ "))}
          </div>
        ` : ""}
      </div>
    </div>
  `;
}

// ‚úÖ Fichiers s√©par√©s par ann√©e (avec fallback sur l'ancien fichier "unique")
const LEGACY_SKILLS_FILE = "skills_db.json";
const LEGACY_SKILLS_CACHE = "skills_db";
const LEGACY_NOTATION_FILE = "notation_db.json";
const LEGACY_NOTATION_CACHE = "notation_db";
const LEGACY_EVALMETA_FILE = "evaluations_db.json";
const LEGACY_EVALMETA_CACHE = "evaluations_db_cache";

const skillsDbFileName = (year: TrainingYear) =>
  year === "premiere" ? "skills_db_premiere.json" : "skills_db_deuxieme.json";
const skillsDbCacheKey = (year: TrainingYear) =>
  year === "premiere" ? "skills_db_premiere" : "skills_db_deuxieme";

const notationDbFileName = (year: TrainingYear) =>
  year === "premiere" ? "notation_db_premiere.json" : "notation_db_deuxieme.json";
const notationDbCacheKey = (year: TrainingYear) =>
  year === "premiere" ? "notation_db_premiere" : "notation_db_deuxieme";

const evalMetaFileName = (year: TrainingYear) =>
  year === "premiere" ? "evaluations_db_premiere.json" : "evaluations_db_deuxieme.json";
const evalMetaCacheKey = (year: TrainingYear) =>
  year === "premiere" ? "evaluations_db_cache_premiere" : "evaluations_db_cache_deuxieme";
const absencesDbFileName = (year: TrainingYear) =>
  year === "premiere" ? "absences_retards_premiere.json" : "absences_retards_deuxieme.json";
const absencesDbCacheKey = (year: TrainingYear) =>
  year === "premiere" ? "absences_retards_premiere" : "absences_retards_deuxieme";

type AttendanceStatus = "AB" | "RT";
type AttendanceByDate = Record<string, AttendanceStatus>; // dateYmd -> status
// schoolYear -> classId -> studentName -> (dateYmd -> status)
type AttendanceDB = Record<string, Record<string, Record<string, AttendanceByDate>>>;

type PlanningZone = "A" | "B" | "C" | "CORSE";
type PlanningWeekdays = { mon: boolean; tue: boolean; wed: boolean; thu: boolean; fri: boolean; sat: boolean; sun: boolean };
type DateRange = { startYmd: string; endYmd: string; label?: string }; // endYmd inclusif
type PlanningSettings = {
  schoolYear: string;
  startYmd: string;
  endYmd: string;
  zone: PlanningZone;
  courseDays: PlanningWeekdays;
  vacationsMode: "auto" | "manual";
  vacationsManual: DateRange[];
  stages: DateRange[];
};
type AbsencesRetardsStore = {
  records: AttendanceDB;
  planning: Record<string, Record<string, PlanningSettings>>; // schoolYear -> classId -> settings
};

type VacationRange = { startYmd: string; endYmdExclusive: string; label: string };

const devoirDirName = (_year: TrainingYear) => "devoir";
const devoirTrashDirName = (_year: TrainingYear) => "devoir_corbeille";

// ---- Helpers export (nom de fichier + horodatage) ----
function sanitizeFileNamePart(input: string): string {
  const safe = String(input || "")
    .normalize("NFKD")
    .replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-zA-Z0-9 _-]/g, "")
    .trim()
    .replace(/\s+/g, "_");
  return safe.length ? safe.slice(0, 80) : "classe";
}
function tsForFileName(d: Date = new Date()): string {
  const pad = (n: number) => String(n).padStart(2, "0");
  return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())}_${pad(d.getHours())}${pad(d.getMinutes())}${pad(d.getSeconds())}`;
}
function ensureJsonFileName(nameOrPath: string): string {
  const s = String(nameOrPath || "");
  return s.toLowerCase().endsWith(".json") ? s : `${s}.json`;
}

// ---- Safe JSON stringify (√©vite crash BigInt / cycles) ----
function safeJsonStringify(value: any, space: number = 2): string {
  const seen = new WeakSet<object>();
  return JSON.stringify(
    value,
    (_k, v) => {
      if (typeof v === "bigint") return String(v);
      if (v && typeof v === "object") {
        if (seen.has(v)) return "[Circular]";
        seen.add(v);
      }
      return v;
    },
    space
  );
}


// -- Helpers de normalisation pour lier la DB (cl√© normalis√©e "Comp√©tence II Sous-crit√®re")
const SEP_NORMALIZED = ' II ';
function normalizeCompItem(comp: string, item: string): string {
  const compClean = comp.trim().replace(/\s+/g, ' ');
  const itemClean = item.trim().replace(/\s+/g, ' ');
  return `${compClean} ${SEP_NORMALIZED} ${itemClean}`;
}
function normalizeKeyFromCritKey(critKey: string): string {
  const { comp, item } = parseScopedCritKey(critKey);
  return normalizeCompItem(comp, item);
}

// ==== Exigences Index Helpers (code+item normalis√©) ====
function __norm(s) {
  return String(s || '')
    .normalize('NFKD')
    .replace(/[\u0300-\u036f]/g, '')
    .toLowerCase()
    .replace(/[;:‚Äì‚Äî\-]/g, '')
    .replace(/\s+/g, '')
    .replace(/[^a-z0-9.]/g, '');
}
function __extractCode(raw) {
  const s = String(raw || '').replace(/\s+/g, ' ');
  const m = s.match(/\bC\s*\.?\s*\d+\.\d+\b/i);
  return m ? m[0] : null;
}
function __cleanItem(raw) {
  return String(raw || '').replace(/\s*[:;]+\s*$/, '').trim();
}
function buildExigencesIndex(db) {
  const idx = {};
  for (const [rawKey, list] of Object.entries(db || {})) {
    const k = String(rawKey || '').trim().replace(/\s+/g, ' ');
    const parts = k.split(' II ');
    const left = parts[0] || '';
    const right = parts[1] || k;
    const code = __extractCode(left);
    const item = __cleanItem(right);
    if (!code || !item) continue;
    const codeKey = __norm(code);
    const itemKey = __norm(item);
    if (!idx[codeKey]) idx[codeKey] = {};
    idx[codeKey][itemKey] = Array.isArray(list) ? list : [];
  }
  return idx;
}

// ==== Couleur de notation ====
function getMarkCellBg4Classes(mark: number | null | undefined): string {
  if (typeof mark !== "number" || Number.isNaN(mark)) return "";

  // 4 couleurs (rouge -> orange -> vert clair -> vert fonc√©)
  if (mark < 5) return "bg-red-50 dark:bg-red-950/25";
  if (mark < 10) return "bg-orange-50 dark:bg-orange-950/25";
  if (mark < 15) return "bg-emerald-50 dark:bg-emerald-950/20";
  return "bg-emerald-100 dark:bg-emerald-950/35";
}

// ---- Robust seed loader: tries /api/exigences, then /data/exigences_db.json (public) ----
async function __fetchExigencesSeed() {
  const tryFetch = async (url: string): Promise<any> => {
    const res = await tauriFetch(url, { method: "GET" });
    const ct = (res.headers.get('content-type') || '').toLowerCase();
    const text = await res.text();
    // guard against HTML responses (dev server 404 / index.html)
    const trimmed = text.trim();
    if (ct.includes('application/json') || trimmed.startsWith('{') || trimmed.startsWith('[')) {
      try {
        return JSON.parse(trimmed);
      } catch (e) {
        console.warn('Seed JSON parse failed for', url, e, 'payload head=', trimmed.slice(0,120));
        throw e;
      }
    } else {
      throw new Error(`Not JSON from ${url}: ${trimmed.slice(0,120)}`);
    }
  };
  try {
    return await tryFetch('/api/exigences');
  } catch (e1) {
    console.warn('API /api/exigences failed, falling back to static /data/exigences_db.json', e1);
    try {
      return await tryFetch('/data/exigences_db.json');
    } catch (e2) {
      console.error('Both seed endpoints failed.', { e1, e2 });
      throw e2;
    }
  }
}

interface DrawerProps {
  open: boolean;
  onClose: () => void;
  side?: 'left' | 'right';
  className?: string;
  children?: React.ReactNode;
}

const Drawer: React.FC<DrawerProps> = ({ open, onClose, side = 'left', className = '', children }) => {
  React.useEffect(() => {
    const root = document.documentElement as HTMLElement & { dataset: any };
    if (open) {
      const c = +(root.dataset.scrollLockCount || 0) + 1;
      root.dataset.scrollLockCount = String(c);
      if (c === 1) root.classList.add('overflow-hidden');
    }
    return () => {
      if (!open) return;
      const c = Math.max(0, +(root.dataset.scrollLockCount || 0) - 1);
      root.dataset.scrollLockCount = String(c);
      if (c === 0) root.classList.remove('overflow-hidden');
    };
  }, [open]);

  React.useEffect(() => {
    if (!open) return;
    const onKey = (e: KeyboardEvent) => { if (e.key === 'Escape') onClose(); };
    window.addEventListener('keydown', onKey);
    return () => window.removeEventListener('keydown', onKey);
  }, [open, onClose]);

  if (!open) return null;

  const align = side === 'left' ? 'left-0' : 'right-0';
  const borderSide = side === 'left' ? 'border-r' : 'border-l';
  return createPortal(
    <div className="fixed inset-0 z-50">
      <div className="absolute inset-0 bg-black/30" onClick={onClose} />
      <div
        className={classNames(
          `absolute inset-y-0 ${align} h-full ${borderSide} overflow-y-auto app-scrollContain app-surface app-border`,
          className
        )}
        onWheel={(e) => e.stopPropagation()}
      >
        {children}
      </div>
    </div>,
    document.body
  );
};

interface TCMap { [task: string]: string[] }
interface CriteresResultsDB {
  [competency: string]: {
    [item: string]: { resultats: string[]; exigences: string[] }
  }
}
type PolesMap = Record<string, string[]>;

const DEFAULT_CAP_POLES = [
  "COMMUNIQUER / PR√âPARER",
  "R√âALISER / CONTR√îLER (OUVRAGE COURANT)",
  "R√âALISER (TRAVAUX SP√âCIFIQUES)",
] as const;

function defaultPolesList(): string[] {
  return [...DEFAULT_CAP_POLES];
}

function defaultPolesMap(poles: string[] = defaultPolesList()): PolesMap {
  const out: PolesMap = {};
  for (const p of poles) out[p] = [];
  return out;
}

function normalizePolesList(input: any, polesMapInput?: any): string[] {
  const arr = (Array.isArray(input) ? input : [])
    .map((x: any) => String(x || "").trim())
    .filter(Boolean);
  if (arr.length > 0) return __dedupe(arr);

  const keys = polesMapInput && typeof polesMapInput === "object"
    ? Object.keys(polesMapInput).map((k) => String(k || "").trim()).filter(Boolean)
    : [];
  if (keys.length > 0) return __dedupe(keys);

  return defaultPolesList();
}

function normalizePolesMap(input: any, poles: string[], tasks: string[]): PolesMap {
  const out = defaultPolesMap(poles);
  const taskSet = new Set((tasks || []).map((t) => String(t)));
  if (!input || typeof input !== "object") return out;

  for (const p of poles) {
    const raw = (input as any)[p];
    const arr = (Array.isArray(raw) ? raw : [])
      .map((x: any) => String(x || "").trim())
      .filter(Boolean)
      .filter((t: string) => taskSet.has(t));
    out[p] = __dedupe(arr);
  }
  return out;
}

interface ClassGroup {
  id: string;
  name: string;
  students: string; // un √©l√®ve par ligne
}
type SemesterKey = "Ne pas utiliser de semestre" | "S1" | "S2";

/**
 * R√©f√©rentiel CAP (modifiable par l'utilisateur)
 * - tcMap: { "T√¢che": ["Comp√©tence", ...] }
 * - critResDB: { "Comp√©tence": { "√ätre capable de...": { resultats:[], exigences:[] } } }
 *
 * On persiste un bundle unique, mais on maintient aussi 2 caches legacy pour compatibilit√©.
 */
const REFERENTIEL_CAP_FILE = "referentiel_cap.json";
const REFERENTIEL_CAP_CACHE_KEY = "referentiel_cap_cache_v1";
const TC_MAP_CACHE_KEY = "taches_competences_cache";
const CRITRES_CACHE_KEY = "criteres_resultats_cache";

type ReferentielCapBundle = {
  schema: "referentiel_cap_v1";
  name: string;
  tcMap: TCMap;
  critResDB: CriteresResultsDB;
  poles: string[];
  polesMap: PolesMap;
};

const __dedupe = (arr: string[]) => Array.from(new Set((arr || []).filter(Boolean)));

function __compCode(label: string) {
  const m = String(label || "").match(/\bC\s*(\d)\s*\.\s*(\d+)\b/i);
  return m ? `C${m[1]}.${m[2]}` : "";
}

function __cleanCompLabel(label: string) {
  // Nettoyage minimal et stable (utilis√© aussi lors du chargement de bundles)
  let s = String(label || "").replace(/\s+/g, " ").trim();
  // supprime les s√©ries de X et ponctuation finale
  s = s
    .replace(/\bX(?:\s+X){1,}\b/gi, " ")
    .replace(/\.+\s*$/g, "")
    .replace(/\s+/g, " ")
    .trim();
  // recolle les c√©sures fr√©quentes
  s = s.replace(/(\p{L}{2,})\s*[-‚Äì‚Äî]\s*(\p{L}{2,})/gu, "$1$2");
  return s;
}

function __dedupeCompsByCode(comps: string[]) {
  const byCode = new Map<string, string>();
  const order: string[] = [];
  for (const raw of comps || []) {
    const cleaned = __cleanCompLabel(raw);
    const code = __compCode(cleaned);
    if (!code) continue;
    if (!byCode.has(code)) {
      byCode.set(code, cleaned);
      order.push(code);
    } else {
      // garde la variante la plus longue (souvent la moins tronqu√©e)
      const prev = byCode.get(code) || cleaned;
      const prevTitle = (prev.split(/\s*:\s*/, 2)[1] || "").trim();
      const nextTitle = (cleaned.split(/\s*:\s*/, 2)[1] || "").trim();
      if (nextTitle.length > prevTitle.length + 2) byCode.set(code, cleaned);
    }
  }
  return order.map((c) => byCode.get(c) || c);
}

function normalizeTcMap(input: any): TCMap {
  const out: TCMap = {};
  if (!input || typeof input !== "object") return out;

  for (const [rawTask, rawComps] of Object.entries(input)) {
    const task = String(rawTask || "").trim();
    if (!task) continue;

    const comps = (Array.isArray(rawComps) ? rawComps : [])
      .map((c) => String(c || "").trim())
      .filter(Boolean);

    // D√©doublonne par code (C1.1) m√™me si les libell√©s varient (".", " X", etc.)
    out[task] = __dedupeCompsByCode(comps);
  }
  return out;
}

function normalizeCritResDB(input: any): CriteresResultsDB {
  const out: CriteresResultsDB = {};
  if (!input || typeof input !== "object") return out;

  // Fusionne les variantes OCR d'une m√™me comp√©tence (m√™me code Cx.y)
  const canonicalByCode = new Map<string, string>();

  for (const [rawComp, rawItems] of Object.entries(input)) {
    const compRaw = String(rawComp || "").trim();
    if (!compRaw) continue;

    const compClean = __cleanCompLabel(compRaw);
    const code = __compCode(compClean);
    const comp = code ? (canonicalByCode.get(code) || compClean) : compClean;
    if (code && !canonicalByCode.has(code)) canonicalByCode.set(code, comp);

    const itemsObj: any = rawItems && typeof rawItems === "object" ? rawItems : {};
    if (!out[comp]) out[comp] = {};

    for (const [rawItem, rawNode] of Object.entries(itemsObj)) {
      const item = String(rawItem || "").trim();
      if (!item) continue;

      const node: any = rawNode && typeof rawNode === "object" ? rawNode : {};
      const resultats = (Array.isArray(node.resultats) ? node.resultats : [])
        .map((s: any) => String(s || "").trim())
        .filter(Boolean);

      const exigences = (Array.isArray(node.exigences) ? node.exigences : [])
        .map((s: any) => String(s || "").trim())
        .filter(Boolean);

      const prev = out[comp][item] || { resultats: [], exigences: [] };
      out[comp][item] = {
        resultats: __dedupe([...prev.resultats, ...resultats]),
        exigences: __dedupe([...prev.exigences, ...exigences]),
      };
    }
  }
  return out;
}

function parseReferentielCapBundle(raw: any): ReferentielCapBundle | null {
  if (!raw || typeof raw !== "object") return null;
  if (raw.schema !== "referentiel_cap_v1") return null;
  const name = typeof raw.name === "string" ? raw.name.trim() : "";
  const tcMap = normalizeTcMap(raw.tcMap);
  const critResDB = normalizeCritResDB(raw.critResDB);
  const poles = normalizePolesList((raw as any).poles, (raw as any).polesMap);
  const polesMap = normalizePolesMap((raw as any).polesMap, poles, Object.keys(tcMap));
  return { schema: "referentiel_cap_v1", name, tcMap, critResDB, poles, polesMap };
}

async function loadReferentielCapFromStore(): Promise<ReferentielCapBundle | null> {
  // 1) Disque (Tauri)
  if (isTauriRuntime()) {
    try {
      const txt = await readTextFile(REFERENTIEL_CAP_FILE, { baseDir: BaseDirectory.AppLocalData });
      const parsed = parseReferentielCapBundle(JSON.parse(txt));
      if (parsed) return parsed;
    } catch {}
  }

  // 2) Cache navigateur
  try {
    const txt = localStorage.getItem(REFERENTIEL_CAP_CACHE_KEY);
    if (txt) {
      const parsed = parseReferentielCapBundle(JSON.parse(txt));
      if (parsed) return parsed;
    }
  } catch {}

  return null;
}

async function saveReferentielCapToStore(bundle: ReferentielCapBundle): Promise<void> {
  const payload = JSON.stringify(bundle, null, 2);

  // Caches (web + compat)
  try {
    localStorage.setItem(REFERENTIEL_CAP_CACHE_KEY, payload);
    localStorage.setItem(TC_MAP_CACHE_KEY, JSON.stringify(bundle.tcMap));
    localStorage.setItem(CRITRES_CACHE_KEY, JSON.stringify(bundle.critResDB));
  } catch {}

  // Fichier (Tauri)
  if (isTauriRuntime()) {
    try {
      await writeTextFile(REFERENTIEL_CAP_FILE, payload, { baseDir: BaseDirectory.AppLocalData });
    } catch (e) {
      console.warn("Impossible d'√©crire le r√©f√©rentiel dans AppLocalData", e);
    }
  }
}

async function clearReferentielCapFromStore(): Promise<void> {
  try {
    localStorage.removeItem(REFERENTIEL_CAP_CACHE_KEY);
    localStorage.removeItem(TC_MAP_CACHE_KEY);
    localStorage.removeItem(CRITRES_CACHE_KEY);
  } catch {}

  if (isTauriRuntime()) {
    try {
      await remove(REFERENTIEL_CAP_FILE, { baseDir: BaseDirectory.AppLocalData });
    } catch {}
  }
}


/**
 * Catalogue de r√©f√©rentiels CAP (plusieurs r√©f√©rentiels sauvegard√©s)
 * - Un fichier unique contient la liste + l'ID actif.
 * - "Base" = /data/*.json (non stock√© dans le catalogue).
 */
const REFERENTIEL_CAP_CATALOG_FILE = "referentiels_cap_catalog.json";
const REFERENTIEL_CAP_CATALOG_CACHE_KEY = "referentiels_cap_catalog_cache_v1";

type ReferentielCapCatalogItem = {
  id: string;
  name: string;
  updatedAt: string;
  tcMap: TCMap;
  critResDB: CriteresResultsDB;
  poles: string[];
  polesMap: PolesMap;
};

type ReferentielCapCatalog = {
  schema: "referentiels_cap_catalog_v1";
  activeId: string | null;
  items: ReferentielCapCatalogItem[];
};

function __makeId(): string {
  return `${Date.now().toString(36)}_${Math.random().toString(36).slice(2, 10)}`;
}

function parseReferentielCapCatalog(raw: any): ReferentielCapCatalog | null {
  if (!raw || typeof raw !== "object") return null;
  if (raw.schema !== "referentiels_cap_catalog_v1") return null;

  const itemsIn = Array.isArray(raw.items) ? raw.items : [];
  const items: ReferentielCapCatalogItem[] = [];
  const seen = new Set<string>();

  for (const it of itemsIn) {
    if (!it || typeof it !== "object") continue;
    const id = typeof (it as any).id === "string" ? String((it as any).id) : "";
    if (!id || seen.has(id)) continue;
    seen.add(id);

    const name = typeof (it as any).name === "string" ? String((it as any).name).trim() : "";
    const updatedAt = typeof (it as any).updatedAt === "string" ? String((it as any).updatedAt) : "";
    const tcMap = normalizeTcMap((it as any).tcMap);
    const critResDB = normalizeCritResDB((it as any).critResDB);
    const poles = normalizePolesList((it as any).poles, (it as any).polesMap);
    const polesMap = normalizePolesMap((it as any).polesMap, poles, Object.keys(tcMap));

    items.push({ id, name, updatedAt, tcMap, critResDB, poles, polesMap });
  }

  let activeId: string | null = typeof (raw as any).activeId === "string" ? String((raw as any).activeId) : null;
  if (activeId && !items.some((i) => i.id === activeId)) activeId = null;

  return { schema: "referentiels_cap_catalog_v1", activeId, items };
}

async function loadReferentielCapCatalog(): Promise<ReferentielCapCatalog | null> {
  // 1) Disque (Tauri)
  if (isTauriRuntime()) {
    try {
      const txt = await readTextFile(REFERENTIEL_CAP_CATALOG_FILE, { baseDir: BaseDirectory.AppLocalData });
      const parsed = parseReferentielCapCatalog(JSON.parse(txt));
      if (parsed) return parsed;
    } catch {}
  }

  // 2) Cache navigateur
  try {
    const txt = localStorage.getItem(REFERENTIEL_CAP_CATALOG_CACHE_KEY);
    if (txt) {
      const parsed = parseReferentielCapCatalog(JSON.parse(txt));
      if (parsed) return parsed;
    }
  } catch {}

  return null;
}

async function saveReferentielCapCatalog(cat: ReferentielCapCatalog): Promise<void> {
  const payload = JSON.stringify(cat, null, 2);

  try {
    localStorage.setItem(REFERENTIEL_CAP_CATALOG_CACHE_KEY, payload);
  } catch {}

  if (isTauriRuntime()) {
    try {
      await writeTextFile(REFERENTIEL_CAP_CATALOG_FILE, payload, { baseDir: BaseDirectory.AppLocalData });
    } catch (e) {
      console.warn("Impossible d'√©crire le catalogue de r√©f√©rentiels", e);
    }
  }
}

async function loadBaseReferentielCap(): Promise<{ tcMap: TCMap; critResDB: CriteresResultsDB; poles: string[]; polesMap: PolesMap }> {
  let tc: TCMap = {};
  let db: CriteresResultsDB = {};

  try {
    const r1 = await fetch("/data/taches_competences.json");
    if (r1.ok) tc = normalizeTcMap(await r1.json());
  } catch {}

  if (!tc || Object.keys(tc).length === 0) {
    try {
      tc = JSON.parse(JSON.stringify(DEFAULT_TACHES_COMPETENCES));
    } catch {
      tc = {};
    }
  }

  try {
    const r2 = await fetch("/data/criteres_resultats.json");
    if (r2.ok) db = normalizeCritResDB(await r2.json());
  } catch {}

  if (!db) db = {};

  const poles = defaultPolesList();
  return { tcMap: tc, critResDB: db, poles, polesMap: defaultPolesMap(poles) };
}



type GeneralSettings = {
  establishmentName: string;
  establishmentLocation: string; // ex: "Ville" ou "Adresse courte"
  defaultReferents: string;      // si aucune valeur n‚Äôest d√©finie pour la classe
  classReferents: Record<string, string>; // cl√© = nom de classe
};

const DEFAULT_GENERAL_SETTINGS: GeneralSettings = {
  establishmentName: "",
  establishmentLocation: "",
  defaultReferents: "",
  classReferents: {},
};

const GENERAL_SETTINGS_FILE = "parametres_generaux.json";
const GENERAL_SETTINGS_CACHE_KEY = "parametres_generaux_cache";


type EvaluationCategory = "D√©couverte professionnel" | "Apprentissage des fondamentaux" | "Professionnalisation de niveau 3";
type Level1to4 = 0 | 1 | 2 | 3 | 4;
type EngagementLevel = "volontaire" | "engage" | "normal" | "attente" | "absence";

type TrafficLightColor = "none" | "green" | "yellow" | "red";

const ENGAGEMENT_FACTORS: Record<EngagementLevel, number> = {
  volontaire: 1.1,  
  engage: 1.05,     
  normal: 1,         
  attente: 0.95,    
  absence: 0.9,     
};

function computeEngagementFactor(level: EngagementLevel | null | undefined): number {
  if (!level) return 1;
  return ENGAGEMENT_FACTORS[level];
}

function getEngagementCellClasses(level: EngagementLevel | null | undefined): string {
  if (!level) return "";

  switch (level) {
    case "volontaire":
      return "bg-emerald-100";
    case "engage":
      return "bg-green-100";
    case "normal":
      return "bg-sky-50 dark:bg-sky-950/35";
    case "attente":
      return "bg-yellow-100";
    case "absence":
      return "bg-red-100";
    default:
      return "";
  }
}

// ==== Helpers : Bilan p√©riodique (moyennes comp√©tences / motivation) ====
type SemesterAgg = Record<string, { label: string; S1Vals: number[]; S2Vals: number[] }>;

function mean(nums: number[]): number {
  if (!nums.length) return 0;
  let s = 0;
  for (const n of nums) s += n;
  return s / nums.length;
}

function round1(n: number): number {
  return Math.round(n * 10) / 10;
}

function levelFromAvg(avg: number): Level1to4 {
  if (!isFinite(avg) || avg <= 0) return 0;
  if (avg < 1.5) return 1;
  if (avg < 2.5) return 2;
  if (avg < 3.5) return 3;
  return 4;
}

function levelBadge(level: Level1to4): { text: string; className: string; title: string } {
  switch (level) {
    case 0:
      return { text: "Non √©valu√©e", className: "bg-neutral-100 text-neutral-700 border-neutral-200 dark:bg-[var(--night-panel)] dark:text-neutral-300 dark:border-sky-400/35", title: "Aucun niveau enregistr√©" };
    case 1:
      return { text: "Non acquise", className: "bg-red-100 text-red-900 border-red-200 dark:bg-red-500/20 dark:text-red-100 dark:border-red-400/40", title: "Niveau 1" };
    case 2:
      return { text: "En voie", className: "bg-amber-100 dark:bg-amber-950/45 text-amber-900 border-amber-200 dark:bg-amber-500/20 dark:text-amber-100 dark:border-amber-400/40", title: "Niveau 2" };
    case 3:
      return { text: "Acquise", className: "bg-emerald-100 text-emerald-900 border-emerald-200 dark:bg-emerald-500/20 dark:text-emerald-100 dark:border-emerald-400/40", title: "Niveau 3" };
    case 4:
      return { text: "Ma√Ætris√©e", className: "bg-green-200 text-green-950 border-green-300 dark:bg-green-500/20 dark:text-green-100 dark:border-green-400/40", title: "Niveau 4" };
    default:
      return { text: "‚Äî", className: "bg-neutral-100 text-neutral-700 border-neutral-200 dark:bg-[var(--night-panel)] dark:text-neutral-300 dark:border-sky-400/35", title: "" };
  }
}

function levelRowTint(level: Level1to4): string {
  switch (level) {
    case 0:
      return "bg-neutral-50 text-neutral-700 border-neutral-200 dark:bg-[var(--night-panel)] dark:text-neutral-300 dark:border-neutral-700/40";
    case 1:
      return "bg-red-50 text-red-900 border-red-200 dark:bg-red-500/10 dark:text-red-100 dark:border-red-400/25";
    case 2:
      return "bg-amber-50 dark:bg-amber-950/35 text-amber-900 border-amber-200 dark:bg-amber-500/10 dark:text-amber-100 dark:border-amber-400/25";
    case 3:
      return "bg-emerald-50 text-emerald-900 border-emerald-200 dark:bg-emerald-500/10 dark:text-emerald-100 dark:border-emerald-400/25";
    case 4:
      return "bg-green-50 text-green-950 border-green-200 dark:bg-green-500/10 dark:text-green-100 dark:border-green-400/25";
    default:
      return "bg-neutral-50 text-neutral-700 border-neutral-200 dark:bg-[var(--night-panel)] dark:text-neutral-300 dark:border-neutral-700/40";
  }
}

function libelleChipMeta(title: string): { bubble: string; dot: string; border: string; line: string; headerBg: string; cardBorder: string } {
  const n = __norm(title);

  // P√¥les attendus : Communiquer (bleu), Pr√©parer (orange), R√©aliser (vert), Contr√¥ler (violet)
  if (n.includes("communiquer") || n.includes("communication")) {
    return {
      bubble: "bg-sky-50 dark:bg-sky-950/35 text-sky-900 border-sky-200 dark:bg-sky-950/20 dark:text-sky-200 dark:border-sky-800/50",
      dot: "bg-sky-500",
      border: "border-sky-200 dark:border-sky-800/50",
      line: "border-sky-200 dark:border-sky-800/50",
      headerBg: "bg-sky-50/70 dark:bg-sky-950/20",
      cardBorder: "border-sky-200/80 dark:border-sky-800/40",
    };
  }
  if (n.includes("preparer") || n.includes("preparation")) {
    return {
      bubble: "bg-amber-50 dark:bg-amber-950/35 text-amber-900 border-amber-200 dark:bg-amber-950/20 dark:text-amber-200 dark:border-amber-800/50",
      dot: "bg-amber-500",
      border: "border-amber-200 dark:border-amber-800/50",
      line: "border-amber-200 dark:border-amber-800/50",
      headerBg: "bg-amber-50/70 dark:bg-amber-950/20",
      cardBorder: "border-amber-200/80 dark:border-amber-800/40",
    };
  }
  if (n.includes("realiser") || n.includes("realisation")) {
    return {
      bubble: "bg-emerald-50 text-emerald-900 border-emerald-200 dark:bg-emerald-950/20 dark:text-emerald-200 dark:border-emerald-800/50",
      dot: "bg-emerald-500",
      border: "border-emerald-200 dark:border-emerald-800/50",
      line: "border-emerald-200 dark:border-emerald-800/50",
      headerBg: "bg-emerald-50/70 dark:bg-emerald-950/20",
      cardBorder: "border-emerald-200/80 dark:border-emerald-800/40",
    };
  }
  if (n.includes("controler") || n.includes("controle")) {
    return {
      bubble: "bg-violet-50 dark:bg-violet-950/35 text-violet-900 border-violet-200 dark:bg-violet-950/20 dark:text-violet-200 dark:border-violet-800/50",
      dot: "bg-violet-500",
      border: "border-violet-200 dark:border-violet-800/50",
      line: "border-violet-200 dark:border-violet-800/50",
      headerBg: "bg-violet-50/70 dark:bg-violet-950/20",
      cardBorder: "border-violet-200/80 dark:border-violet-800/40",
    };
  }

  return {
    bubble: "bg-neutral-100 dark:bg-[var(--night-panel)] text-neutral-800 dark:text-neutral-300 border-neutral-200 dark:border-sky-400/35 dark:bg-neutral-900/30 dark:text-neutral-300 dark:border-sky-400/35",
    dot: "bg-neutral-50 dark:bg-[var(--night-panel)]0",
    border: "border-neutral-200 dark:border-sky-400/35 dark:border-sky-400/35",
    line: "border-neutral-200 dark:border-sky-400/35 dark:border-sky-400/35",
    headerBg: "bg-neutral-50/80 dark:bg-[var(--night-panel)]/80 dark:bg-neutral-900/30",
    cardBorder: "border-neutral-200 dark:border-sky-400/35/80 dark:border-sky-400/35",
  };
}


function buildSemesterAggFromStudentRecord(
  studentRecord: StudentSkillRecord,
  allowedEvalIds: Set<string>,
  allowedEvalNames: Set<string>
): SemesterAgg {
  const semesterAgg: SemesterAgg = {};

  Object.entries(studentRecord || {}).forEach(([rawLabel, semLevels]) => {
    let compPart = rawLabel;
    if (rawLabel.includes("||")) {
      const [idOrName, compMaybe] = rawLabel.split("||");
      if (!idOrName || !compMaybe) return;
      if (!allowedEvalIds.has(idOrName) && !allowedEvalNames.has(idOrName)) return;
      compPart = compMaybe;
    }

    const code = compactCode(compPart);
    const text = String(compPart)
      .replace(/^C\s*\d\s*\.\s*\d+\s*:\s*/i, "")
      .trim();
    if (!code) return;

    if (!semesterAgg[code]) semesterAgg[code] = { label: text, S1Vals: [], S2Vals: [] };

    // Valeur directe (legacy)
    if (typeof (semLevels as any) === "number") {
      const v = semLevels as any;
      semesterAgg[code].S1Vals.push(v);
      semesterAgg[code].S2Vals.push(v);
      return;
    }

    const s1 = (semLevels as any)?.S1;
    const s2 = (semLevels as any)?.S2;
    if (typeof s1 === "number") semesterAgg[code].S1Vals.push(s1);
    if (typeof s2 === "number") semesterAgg[code].S2Vals.push(s2);
  });

  return semesterAgg;
}

const ENGAGEMENT_SCORE: Record<EngagementLevel, number> = {
  volontaire: 5,
  engage: 4,
  normal: 3,
  attente: 2,
  absence: 1,
};

function engagementLabelFromAvg(avg: number): string {
  if (!isFinite(avg) || avg <= 0) return "‚Äî";
  if (avg >= 4.5) return "Tr√®s engag√©";
  if (avg >= 3.5) return "Engag√©";
  if (avg >= 2.5) return "Normal";
  if (avg >= 1.5) return "En attente";
  return "Peu engag√©";
}

type StudentSkillRecord = {
  [competenceLabel: string]: {
    [semester in SemesterKey]?: Level1to4;
  };
};

type SkillsDB = {
  [classId: string]: {
    [studentName: string]: StudentSkillRecord;
  };
};
interface SavedDevoirMeta {
  fileName: string;        // nom du fichier JSON (ex: devoir-123.json)
  title: string;           // titre de l'√©valuation
  group?: string;          // classe (CAP1, CAP2, ...)
  evaluationType?: string; // type d'√©valuation (auto, crit√©ri√©, ...)
}

interface EvalMeta {
  id: string;         // identifiant interne de l'√©valuation
  name: string;       // titre de l'√©valuation
  fileName: string;   // nom du fichier JSON (devoir-123.json)
  group: string;      // ex : "GROUPE"
  semester: SemesterKey; // "Ne pas utiliser de semestre" = pas utilis√©, sinon "S1" ou "S2"
  createdAt: string;  // date de cr√©ation (ISO)
}
type NotationEntry = {
  markOn20: number;
  totalWeightForStudent: number;
  semester: SemesterKey;
  evalId: string;
  evalName: string;
  className: string;
  studentName: string;
  savedAt: string;
    // üîπ Nouveau : scores d√©taill√©s par crit√®re (cl√© = critKey, valeur = 0..4)
  scoresByCriteria?: Record<string, number>;
  engagementLevel?: EngagementLevel;
  status?: "OK" | "AB" | "N.NOT";
};

type NotationDB = {
  [schoolYear: string]: {
    [className: string]: {
      [evalId: string]: {
        [studentName: string]: NotationEntry;
      };
    };
  };
};

function getCurrentSchoolYear(): string {
  const today = new Date();
  const year = today.getFullYear();
  const month = today.getMonth(); // 0 = janvier

  // Ann√©e scolaire = septembre -> ao√ªt
  if (month >= 8) {
    // septembre √† d√©cembre
    return `${year}-${year + 1}`;
  } else {
    // janvier √† ao√ªt
    return `${year - 1}-${year}`;
  }
}

// Retourne l'ann√©e scolaire la plus r√©cente pr√©sente dans une base de notation.
// Permet d'afficher correctement les donn√©es d'une ann√©e pass√©e (ex : 1√®re ann√©e)
// m√™me si la date courante est d√©j√† sur l'ann√©e scolaire suivante.
function pickLatestSchoolYearFromNotationDB(ndb: NotationDB | null | undefined, fallback?: string): string {
  const keys = Object.keys((ndb as any) || {});
  if (!keys.length) return fallback || getCurrentSchoolYear();
  const scoreKey = (k: string) => {
    const m = String(k || "").match(/^(\d{4})/);
    return m ? parseInt(m[1], 10) : 0;
  };
  return keys.slice().sort((a, b) => scoreKey(b) - scoreKey(a))[0];
}


function toYmd(d: Date): string {
  const pad = (n: number) => String(n).padStart(2, "0");
  return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())}`;
}

function fromYmd(ymd: string): Date | null {
  const m = String(ymd || "").match(/^(\d{4})-(\d{2})-(\d{2})$/);
  if (!m) return null;
  const y = parseInt(m[1], 10);
  const mo = parseInt(m[2], 10) - 1;
  const da = parseInt(m[3], 10);
  const d = new Date(y, mo, da);
  // validation simple
  if (d.getFullYear() !== y || d.getMonth() !== mo || d.getDate() !== da) return null;
  return d;
}

function addDays(d: Date, days: number): Date {
  const out = new Date(d.getTime());
  out.setDate(out.getDate() + days);
  return out;
}

function addDaysYmd(ymd: string, days: number): string {
  const d = fromYmd(ymd);
  if (!d) return ymd;
  return toYmd(addDays(d, days));
}

const MONTHS_FR = [
  "janvier", "f√©vrier", "mars", "avril", "mai", "juin",
  "juillet", "ao√ªt", "septembre", "octobre", "novembre", "d√©cembre",
];

const WEEKDAYS_FR_SHORT = ["Lun", "Mar", "Mer", "Jeu", "Ven", "Sam", "Dim"];

function formatYmdFr(ymd: string): string {
  const m = String(ymd || "").match(/^(\d{4})-(\d{2})-(\d{2})$/);
  if (!m) return ymd;
  return `${m[3]}/${m[2]}/${m[1]}`;
}

function weekdayIndexMon0(d: Date): number {
  // JS: 0=dim,1=lun,...6=sam -> Mon=0..Sun=6
  return (d.getDay() + 6) % 7;
}

function weekdayKeyFromDate(d: Date): keyof PlanningWeekdays {
  const js = d.getDay(); // 0 dim
  switch (js) {
    case 1: return "mon";
    case 2: return "tue";
    case 3: return "wed";
    case 4: return "thu";
    case 5: return "fri";
    case 6: return "sat";
    default: return "sun";
  }
}

function isYmdBetweenInclusive(ymd: string, startYmd: string, endYmd: string): boolean {
  return ymd >= startYmd && ymd <= endYmd;
}

function monthsBetweenYmd(startYmd: string, endYmd: string): Array<{ year: number; month0: number }> {
  const s = fromYmd(startYmd);
  const e = fromYmd(endYmd);
  if (!s || !e) return [];
  const out: Array<{ year: number; month0: number }> = [];
  let y = s.getFullYear();
  let m = s.getMonth();
  const endY = e.getFullYear();
  const endM = e.getMonth();

  while (y < endY || (y === endY && m <= endM)) {
    out.push({ year: y, month0: m });
    m += 1;
    if (m > 11) { m = 0; y += 1; }
    // garde-fou
    if (out.length > 36) break;
  }
  return out;
}

function findLabelInRanges(ymd: string, ranges: VacationRange[]): string | null {
  for (const r of ranges || []) {
    if (ymd >= r.startYmd && ymd < r.endYmdExclusive) return r.label || "";
  }
  return null;
}

function parseSchoolYearString(schoolYear: string): { startYear: number; endYear: number } | null {
  // Accepte : "2025-2026", "2025 ‚Äì 2026", "2025/2026", "2025 - 2026", "2025-26"
  const raw = String(schoolYear || "").trim();
  const norm = raw
    .replace(/[‚Äì‚Äî]/g, "-")
    .replace(/\//g, "-")
    .replace(/\s+/g, "");

  // 2025-2026
  let m = norm.match(/^(\d{4})-(\d{4})$/);
  if (m) {
    const a = parseInt(m[1], 10);
    const b = parseInt(m[2], 10);
    if (!a || !b) return null;
    return { startYear: a, endYear: b };
  }

  // 2025-26
  m = norm.match(/^(\d{4})-(\d{2})$/);
  if (m) {
    const a = parseInt(m[1], 10);
    const yy = parseInt(m[2], 10);
    if (!a || Number.isNaN(yy)) return null;
    const century = Math.floor(a / 100) * 100;
    let b = century + yy;
    if (b < a) b += 100; // s√©curit√© (ex: 1999-00)
    return { startYear: a, endYear: b };
  }

  return null;
}

function defaultPlanningSettings(schoolYear: string, zone: PlanningZone = "B"): PlanningSettings {
  const parsed = parseSchoolYearString(schoolYear);
  const startYear = parsed?.startYear ?? new Date().getFullYear();
  const endYear = parsed?.endYear ?? startYear + 1;

  return {
    schoolYear,
    startYmd: `${startYear}-09-01`,
    endYmd: `${endYear}-08-31`,
    zone,
    courseDays: { mon: true, tue: true, wed: true, thu: true, fri: true, sat: false, sun: false },
    vacationsMode: "auto",
    vacationsManual: [],
    stages: [],
  };
}

function getIcsUrlForZone(zone: PlanningZone): string {
  // Source officielle OpenDataSoft (Minist√®re) ‚Äì ICS par zone
  // Exemples : Zone-B.ics / Corse.ics
  const base = "https://fr.ftp.opendatasoft.com/openscol/fr-en-calendrier-scolaire";
  if (zone === "CORSE") return `${base}/Corse.ics`;
  return `${base}/Zone-${zone}.ics`;
}

function parseIcsDateLineValue(value: string): string | null {
  // Accepte VALUE=DATE:YYYYMMDD ou YYYYMMDDT...Z
  const v = String(value || "").trim();
  const m = v.match(/(\d{4})(\d{2})(\d{2})/);
  if (!m) return null;
  return `${m[1]}-${m[2]}-${m[3]}`;
}

async function fetchVacationsForSchoolYearFromIcs(zone: PlanningZone, schoolYear: string): Promise<VacationRange[]> {
  const sy = parseSchoolYearString(schoolYear);
  if (!sy) return [];

  const schoolStart = `${sy.startYear}-09-01`;
  const schoolEndExclusive = addDaysYmd(`${sy.endYear}-08-31`, 1);

  const url = getIcsUrlForZone(zone) + `?_=${Date.now()}`;

  const res = isTauriRuntime()
    ? await tauriFetch(url, { method: "GET" })
    : await fetch(url, { method: "GET" });

  if (!res.ok) throw new Error(`ICS fetch failed: ${res.status}`);

  const ics = await res.text();

  // RFC5545: "unfold" (lignes repli√©es qui commencent par espace / tab)
  const rawLines = ics.replace(/\r\n/g, "\n").split("\n");
  const lines: string[] = [];
  for (const ln of rawLines) {
    if (!ln) continue;
    if ((ln.startsWith(" ") || ln.startsWith("\t")) && lines.length) {
      lines[lines.length - 1] += ln.slice(1);
    } else {
      lines.push(ln.trimEnd());
    }
  }

  const out: VacationRange[] = [];

  let inEvent = false;
  let dtStart: string | null = null;
  let dtEndExcl: string | null = null;
  let summary = "";

  const flush = () => {
    if (!dtStart || !dtEndExcl) return;

    const label = (summary || "").trim();

    // On garde surtout les vacances (et les "ponts" si pr√©sents dans l'ICS)
    const keep = /vacances/i.test(label) || /pont/i.test(label);
    if (!keep) return;

    // Overlap ann√©e scolaire
    if (dtEndExcl <= schoolStart) return;
    if (dtStart >= schoolEndExclusive) return;

    const start = dtStart < schoolStart ? schoolStart : dtStart;
    const end = dtEndExcl > schoolEndExclusive ? schoolEndExclusive : dtEndExcl;

    if (start < end) {
      out.push({
        startYmd: start,
        endYmdExclusive: end,
        label: label || "Vacances",
      });
    }
  };

  for (const line of lines) {
    if (line === "BEGIN:VEVENT") {
      inEvent = true;
      dtStart = null;
      dtEndExcl = null;
      summary = "";
      continue;
    }
    if (line === "END:VEVENT") {
      if (inEvent) flush();
      inEvent = false;
      continue;
    }
    if (!inEvent) continue;

    if (line.startsWith("DTSTART")) {
      const value = line.split(":").pop() || "";
      dtStart = parseIcsDateLineValue(value);
      continue;
    }
    if (line.startsWith("DTEND")) {
      const value = line.split(":").pop() || "";
      dtEndExcl = parseIcsDateLineValue(value);
      continue;
    }
    if (line.startsWith("SUMMARY")) {
      const idx = line.indexOf(":");
      summary = idx >= 0 ? line.slice(idx + 1) : "";
      continue;
    }
  }

  out.sort((a, b) => (a.startYmd < b.startYmd ? -1 : a.startYmd > b.startYmd ? 1 : 0));
  return out;
}

const DEFAULT_TACHES_COMPETENCES: TCMap = {
  "T1 ‚Äî Prendre connaissance des informations li√©es √† son intervention": [
    "C 1.01 : Compl√©ter et transmettre des documents",
    "C 1.02 : √âchanger et rendre compte oralement",
    "C 2.01 : D√©coder un dossier technique",
    "C 3.03 : Intervenir √† proximit√© des r√©seaux",
  ],
  "T10 ‚Äî R√©aliser des ouvrages en ma√ßonnerie de petits √©l√©ments": [
    "C 1.02 : √âchanger et rendre compte oralement",
    "C 2.01 : D√©coder un dossier technique",
    "C 2.02 : Choisir les mat√©riels et les outillages",
    "C 2.03 : D√©terminer des quantit√©s de mat√©riaux et composants",
    "C 3.01 : Organiser son poste de travail",
    "C 3.02 : S√©curiser son intervention",
    "C 3.04 : Monter, d√©monter et utiliser un √©chafaudage",
    "C 3.12 : R√©aliser des ma√ßonneries de petits √©l√©ments",
    "C 3.13 : Intervenir sur le b√¢ti existant",
  ],
};

const GROUPS = [
  { key: "G1", title: "COMMUNIQUER / PR√âPARER", range: [1, 6] },
  { key: "G2", title: "R√âALISER / CONTR√îLER (OUVRAGE COURANT)", range: [7, 13] },
  { key: "G3", title: "R√âALISER (TRAVAUX SP√âCIFIQUES)", range: [14, 17] },
] as const;

type GroupKey = typeof GROUPS[number]["key"];
const GROUP_STYLES: Record<GroupKey, { accentBorder: string; headerBg: string; headerText: string; buttonSelected: string; buttonHover: string; chipBg: string; chipText: string; bullet: string; }> = {
  G1: {
    accentBorder: "border-l-4 border-sky-400",
    headerBg: "bg-sky-50 dark:bg-sky-950/35",
    headerText: "text-sky-800 dark:text-sky-100",
    buttonSelected: "bg-sky-600 border-sky-600 text-white shadow-sm ring-2 ring-sky-200/50 ring-offset-1 ring-offset-white dark:bg-sky-400/30 dark:border-sky-400/35/60 dark:text-sky-50 dark:ring-sky-300/45 dark:ring-offset-[var(--night-ring-offset)]",
    buttonHover: "hover:bg-sky-50 dark:hover:bg-sky-400/15",
    chipBg: "bg-sky-100 dark:bg-sky-950/45",
    chipText: "text-sky-700 dark:text-sky-200",
    bullet: "bg-sky-400",
  },
  G2: {
    accentBorder: "border-l-4 border-amber-400",
    headerBg: "bg-amber-50 dark:bg-amber-950/35",
    headerText: "text-amber-800 dark:text-amber-100",
    buttonSelected: "bg-amber-600 border-amber-600 text-white shadow-sm ring-2 ring-amber-200/50 ring-offset-1 ring-offset-white dark:bg-amber-400/25 dark:border-amber-300/60 dark:text-amber-50 dark:ring-amber-300/40 dark:ring-offset-[var(--night-ring-offset)]",
    buttonHover: "hover:bg-amber-50 dark:hover:bg-amber-400/15",
    chipBg: "bg-amber-100 dark:bg-amber-950/45",
    chipText: "text-amber-700 dark:text-amber-200",
    bullet: "bg-amber-400",
  },
  G3: {
    accentBorder: "border-l-4 border-violet-400",
    headerBg: "bg-violet-50 dark:bg-violet-950/35",
    headerText: "text-violet-800 dark:text-violet-100",
    buttonSelected: "bg-violet-600 border-violet-600 text-white shadow-sm ring-2 ring-violet-200/50 ring-offset-1 ring-offset-white dark:bg-violet-400/25 dark:border-violet-300/60 dark:text-violet-50 dark:ring-violet-300/40 dark:ring-offset-[var(--night-ring-offset)]",
    buttonHover: "hover:bg-violet-50 dark:hover:bg-violet-400/15",
    chipBg: "bg-violet-100 dark:bg-violet-950/45",
    chipText: "text-violet-700 dark:text-violet-200",
    bullet: "bg-violet-400",
  },
};

// --- Groupes par √©preuves (option "EP1/EP2/EP3" dans la vue √âvolutions) ---
const EP_GROUP_ORDER = [
  { key: "EP1", title: "√âPREUVE EP1" },
  { key: "EP2", title: "√âPREUVE EP2" },
  { key: "EP3", title: "√âPREUVE EP3" },
  { key: "OTHER", title: "AUTRES" },
] as const;

const EP_GROUP_STYLES: Record<string, { accentBorder: string; headerBg: string; headerText: string }> = {
  EP1: { accentBorder: "border-l-4 border-emerald-400", headerBg: "bg-emerald-50 dark:bg-emerald-950/35", headerText: "text-emerald-800 dark:text-emerald-100" },
  EP2: { accentBorder: "border-l-4 border-amber-400", headerBg: "bg-amber-50 dark:bg-amber-950/35", headerText: "text-amber-800 dark:text-amber-100" },
  EP3: { accentBorder: "border-l-4 border-violet-400", headerBg: "bg-violet-50 dark:bg-violet-950/35", headerText: "text-violet-800 dark:text-violet-100" },
  OTHER: { accentBorder: "border-l-4 border-neutral-300 dark:border-sky-400/35", headerBg: "bg-neutral-50 dark:bg-[var(--night-panel)]", headerText: "text-neutral-700 dark:text-neutral-300" },
};

const FAMILY_STYLES: Record<'C1'|'C2'|'C3'|'C4', {
  headerText: string; chipBg: string; chipText: string; bullet: string; selectedBg: string; hoverBg: string; border: string; hoverBorder: string; ring: string; accentBorder?: string;
  codeSelectedBg: string; codeSelectedText: string; selectedDarkBg: string; selectedDarkText: string;
}> = {
  C1: { headerText:"text-sky-700 dark:text-sky-300", chipBg:"bg-sky-50 dark:bg-sky-950/35", chipText:"text-sky-700", bullet:"bg-sky-400", selectedBg:"bg-sky-100 text-sky-800", hoverBg:"hover:bg-sky-100", border:"border-sky-300", hoverBorder:"hover:border-sky-400", ring:"ring-sky-400", accentBorder:"border-l-4 border-sky-400", codeSelectedBg:"bg-sky-600", codeSelectedText:"text-white-900", selectedDarkBg:"bg-sky-600", selectedDarkText:"text-white" },
  C2: { headerText:"text-amber-700 dark:text-amber-300", chipBg:"bg-amber-50 dark:bg-amber-950/35", chipText:"text-amber-700", bullet:"bg-amber-400", selectedBg:"bg-amber-100 dark:bg-amber-950/45 text-amber-800", hoverBg:"hover:bg-amber-100 dark:bg-amber-950/45", border:"border-amber-300", hoverBorder:"hover:border-amber-400", ring:"ring-amber-400", accentBorder:"border-l-4 border-amber-400", codeSelectedBg:"bg-amber-600", codeSelectedText:"text-white-900", selectedDarkBg:"bg-amber-600", selectedDarkText:"text-white" },
  C3: { headerText:"text-lime-700 dark:text-lime-300", chipBg:"bg-lime-50 dark:bg-lime-950/35", chipText:"text-lime-700", bullet:"bg-lime-400", selectedBg:"bg-lime-100 dark:bg-lime-950/45 text-lime-800", hoverBg:"hover:bg-lime-100 dark:bg-lime-950/45", border:"border-lime-300", hoverBorder:"hover:border-lime-400", ring:"ring-lime-400", accentBorder:"border-l-4 border-lime-400", codeSelectedBg:"bg-lime-600", codeSelectedText:"text-white-900", selectedDarkBg:"bg-lime-600", selectedDarkText:"text-white" },
  C4: { headerText:"text-fuchsia-700 dark:text-fuchsia-300", chipBg:"bg-fuchsia-50 dark:bg-fuchsia-950/35", chipText:"text-fuchsia-700", bullet:"bg-fuchsia-400", selectedBg:"bg-fuchsia-100 text-fuchsia-800", hoverBg:"hover:bg-fuchsia-100", border:"border-fuchsia-300", hoverBorder:"hover:border-fuchsia-400", ring:"ring-fuchsia-400", accentBorder:"border-l-4 border-fuchsia-400", codeSelectedBg:"bg-fuchsia-600", codeSelectedText:"text-white-900", selectedDarkBg:"bg-fuchsia-600", selectedDarkText:"text-white" },
};
const CLASS_BUBBLE_STYLES: Array<{ bubble: string; dot: string }> = [
  { bubble: "bg-sky-100 text-sky-900 border-sky-200 dark:bg-sky-500/20 dark:text-sky-100 dark:border-sky-400/40", dot: "bg-sky-500" },
  { bubble: "bg-amber-100 text-amber-900 border-amber-200 dark:bg-amber-500/20 dark:text-amber-100 dark:border-amber-400/40", dot: "bg-amber-500" },
  { bubble: "bg-emerald-100 text-emerald-900 border-emerald-200 dark:bg-emerald-500/20 dark:text-emerald-100 dark:border-emerald-400/40", dot: "bg-emerald-500" },
  { bubble: "bg-violet-100 text-violet-900 border-violet-200 dark:bg-violet-500/20 dark:text-violet-100 dark:border-violet-400/40", dot: "bg-violet-500" },
  { bubble: "bg-rose-100 text-rose-900 border-rose-200 dark:bg-rose-500/20 dark:text-rose-100 dark:border-rose-400/40", dot: "bg-rose-500" },
];


// ---- Tauri FS resolver (v1/v2) ----
type FsModule = {
  readTextFile: (...args: any[]) => Promise<string>;
  writeTextFile: (...args: any[]) => Promise<void>;
  mkdir?: (...args: any[]) => Promise<void>;
  stat?: (...args: any[]) => Promise<any>;
  exists?: (...args: any[]) => Promise<boolean>;
};

// --- Helpers d'import opaques (Vite ne les pr√©-bundle pas)
const importDyn = (m: string) => (new Function('m', 'return import(m)'))(m);

async function getTauriFs(): Promise<FsModule | null> {
  try { return await importDyn(['@tauri-apps','plugin-fs'].join('/')) as any; } catch {}
  try { return await importDyn(['@tauri-apps','api','fs'].join('/')) as any; } catch {}
  return null;
}

function isTauriRuntime(): boolean {
  const w = window as any;
  return !!(w.__TAURI__ || w.__TAURI_INTERNALS__);
}

// R√©cup√®re BaseDirectory depuis @tauri-apps/api/path (compatible v1/v2)
async function getBaseDirectory() {
  try {
    const p = await importDyn(['@tauri-apps', 'api', 'path'].join('/'));
    return p?.BaseDirectory ?? null;
  } catch {
    return null;
  }
}

// --- Dialog (Tauri v2 plugin ou v1 api)
async function getTauriDialogOpen(): Promise<((opts: any) => Promise<string | string[] | null>) | null> {
  try { const m = await importDyn(['@tauri-apps','plugin-dialog'].join('/')); return (m as any).open ?? null; } catch {}
  try { const m = await importDyn(['@tauri-apps','api','dialog'].join('/'));   return (m as any).open ?? null; } catch {}
  return null;
}

// --- Paths absolus vers AppData/devoir
async function getPathHelpers() {
  try {
    const p = await importDyn('@tauri-apps/api/path');
    return {
      join: (p as any).join as (...parts: string[]) => Promise<string>,
      appDataDir: (p as any).appDataDir as () => Promise<string>,
    };
  } catch {
    // Fallback neutre (non-Tauri)
    return { join: async (...parts: string[]) => parts.join('/'), appDataDir: async () => '' };
  }
}

async function loadExigencesFromTauri(): Promise<Record<string, string[]>> {
  try {
    const fs = await getTauriFs(); if (!fs) return {};
    const BD = await getBaseDirectory();

    const file = 'exigences_db.json';
    const optsV2 = BD ? { baseDir: BD.AppData } : undefined; // plugin-fs (v2)
    const optsV1 = BD ? { dir: BD.AppData } : undefined;     // api/fs (v1)

    // exists()
    let exists = false;
    if (fs.exists) {
      try { exists = await fs.exists(file, optsV1 ?? optsV2); } catch {}
    }
    if (!exists) {
      try { await fs.readTextFile(file, optsV2); exists = true; } catch {}
      if (!exists) { try { await fs.readTextFile(file, optsV1); exists = true; } catch {} }
    }
    if (!exists) return {};

    // read
    let txt = '';
    try { txt = await (fs as any).readTextFile(file, optsV2); }
    catch { txt = await (fs as any).readTextFile(file, optsV1); }

    const data = JSON.parse(txt);
    return (data && typeof data === 'object') ? data as Record<string, string[]> : {};
  } catch { return {}; }
}

async function saveExigencesToTauri(data: Record<string, string[]>): Promise<void> {
  try {
    const fs = await getTauriFs(); if (!fs) return;
    const BD = await getBaseDirectory();
    const file = 'exigences_db.json';
    const payload = JSON.stringify(data, null, 2);
    const optsV2 = BD ? { baseDir: BD.AppData } : undefined;
    const optsV1 = BD ? { dir: BD.AppData } : undefined;

    // write v2 d'abord, puis fallback v1
    try { await (fs as any).writeTextFile(file, payload, optsV2); }
    catch { await (fs as any).writeTextFile({ path: file, contents: payload }, optsV1); }
  } catch {}
}

// === Gestion globale des classes / √©l√®ves (eleves.json) ===

async function loadElevesFromStore(): Promise<ClassGroup[]> {
  // 1) Mode Tauri : on tente de lire eleves.json dans AppLocalData
  if (isTauriRuntime()) {
    try {
      const txt = await readTextFile('eleves.json', {
        baseDir: BaseDirectory.AppLocalData,
      });

      if (txt && txt.trim().length > 0) {
        const parsed = JSON.parse(txt);
        if (Array.isArray(parsed)) {
          console.log('[TAURI] eleves.json charg√© depuis AppLocalData');
          return parsed as ClassGroup[];
        }
      }
    } catch (e) {
      // Fichier absent au 1er lancement ou autre ‚Üí on laisse filer et on passe aux fallbacks
      console.warn('loadElevesFromStore (Tauri) a √©chou√© :', e);
    }
  } else {
    console.log(
      '[WEB] Pas de runtime Tauri : on ne regarde pas eleves.json, uniquement localStorage / seed.'
    );
  }

  // 2) Fallback : cache navigateur (utile en dev ou en pur web)
  try {
    const cache = localStorage.getItem('eleves_json_cache');
    if (cache) {
      const parsed = JSON.parse(cache);
      if (Array.isArray(parsed)) {
        console.log('[WEB] Classes/√©l√®ves charg√©s depuis localStorage');
        return parsed as ClassGroup[];
      }
    }
  } catch (e) {
    console.warn('loadElevesFromStore (localStorage) a √©chou√© :', e);
  }

  // 3) Dernier fallback : seed initial depuis public/data/eleves.json
  try {
    const res = await fetch('/data/eleves.json');
    if (res.ok) {
      const text = await res.text();
      const trimmed = text.trim();
      if (trimmed) {
        const parsed = JSON.parse(trimmed);
        if (Array.isArray(parsed)) {
          console.log('[SEED] Classes/√©l√®ves initialis√©s depuis /data/eleves.json');
          return parsed as ClassGroup[];
        }
      }
    }
  } catch (e) {
    console.warn('Impossible de charger /data/eleves.json :', e);
  }

  return [];
}

async function saveElevesToStore(groups: ClassGroup[]): Promise<void> {
  const payload = JSON.stringify(groups, null, 2);

  // 1) Mode Tauri : on √©crit eleves.json dans AppLocalData
  if (isTauriRuntime()) {
    try {
      await writeTextFile('eleves.json', payload, {
        baseDir: BaseDirectory.AppLocalData,
      });
      console.log('[TAURI] eleves.json sauvegard√© dans AppLocalData');
    } catch (e) {
      console.warn('saveElevesToStore (Tauri) a √©chou√© :', e);
    }
  } else {
    console.log(
      '[WEB] Pas de runtime Tauri : sauvegarde uniquement dans localStorage (aucun eleves.json sur le disque).'
    );
  }

  // 2) Toujours : copie dans localStorage (pratique en dev)
  try {
    localStorage.setItem('eleves_json_cache', payload);
  } catch {
    // ignore
  }
}

// === Param√®tres g√©n√©raux (parametres_generaux.json) ===
function normalizeGeneralSettings(raw: any): GeneralSettings {
  const r = (raw && typeof raw === "object") ? raw : {};
  const classReferents = (r.classReferents && typeof r.classReferents === "object") ? r.classReferents : {};
  return {
    establishmentName: typeof r.establishmentName === "string" ? r.establishmentName : "",
    establishmentLocation: typeof r.establishmentLocation === "string" ? r.establishmentLocation : "",
    defaultReferents: typeof r.defaultReferents === "string" ? r.defaultReferents : "",
    classReferents: classReferents as Record<string, string>,
  };
}

async function loadGeneralSettingsFromStore(): Promise<GeneralSettings> {
  // 1) Mode Tauri : on tente de lire parametres_generaux.json dans AppLocalData
  if (isTauriRuntime()) {
    try {
      const txt = await readTextFile(GENERAL_SETTINGS_FILE, { baseDir: BaseDirectory.AppLocalData });
      if (txt && txt.trim().length > 0) {
        const parsed = JSON.parse(txt);
        console.log("[TAURI] parametres_generaux.json charg√© depuis AppLocalData");
        return normalizeGeneralSettings(parsed);
      }
    } catch (e) {
      console.warn("loadGeneralSettingsFromStore (Tauri) a √©chou√© :", e);
    }
  }

  // 2) Fallback : cache navigateur
  try {
    const cache = localStorage.getItem(GENERAL_SETTINGS_CACHE_KEY);
    if (cache) return normalizeGeneralSettings(JSON.parse(cache));
  } catch (e) {
    console.warn("loadGeneralSettingsFromStore (localStorage) a √©chou√© :", e);
  }

  return { ...DEFAULT_GENERAL_SETTINGS };
}

async function saveGeneralSettingsToStore(settings: GeneralSettings): Promise<void> {
  const payload = JSON.stringify(settings, null, 2);

  // 1) Mode Tauri : √©crit sur disque
  if (isTauriRuntime()) {
    try {
      await writeTextFile(GENERAL_SETTINGS_FILE, payload, { baseDir: BaseDirectory.AppLocalData });
      console.log("[TAURI] parametres_generaux.json sauvegard√© dans AppLocalData");
    } catch (e) {
      console.warn("saveGeneralSettingsToStore (Tauri) a √©chou√© :", e);
    }
  }

  // 2) Toujours : localStorage (utile en dev)
  try { localStorage.setItem(GENERAL_SETTINGS_CACHE_KEY, payload); } catch {}
}



// === Base des √©valuations (evaluations_db.json) ===
async function loadEvalMetaFromStore(year: TrainingYear): Promise<EvalMeta[]> {
  const file = evalMetaFileName(year);
  const cacheKey = evalMetaCacheKey(year);

  // Petit helper (√©vite de d√©pendre de ensureJsonName qui est d√©fini plus bas)
  const safeJsonName = (name: string) =>
    String(name || "").toLowerCase().endsWith(".json") ? String(name) : `${name}.json`;

  const filterByExistingDevoirFiles = async (list: EvalMeta[]) => {
    // En mode Web (sans FS), on ne peut pas v√©rifier l'existence des fichiers.
    if (!isTauriRuntime()) return list;

    const dir = devoirDirName(year);
    const checks = await Promise.all(
      list.map(async (ev) => {
        try {
          const p = `${dir}/${safeJsonName(ev.fileName)}`;
          return await exists(p, { baseDir: BaseDirectory.AppLocalData });
        } catch {
          // En cas d'erreur FS, on garde l'item (on √©vite de "perdre" des donn√©es)
          return true;
        }
      })
    );

    return list.filter((_, i) => checks[i]);
  };

  // 1) Mode Tauri : fichier sur le disque
  if (isTauriRuntime()) {
    try {
      const txt = await readTextFile(file, {
        baseDir: BaseDirectory.AppLocalData,
      });

      if (txt && txt.trim().length > 0) {
        const parsed = JSON.parse(txt);
        if (Array.isArray(parsed)) {
          return await filterByExistingDevoirFiles(parsed as EvalMeta[]);
        }
      }
    } catch (e) {
      console.warn("loadEvalMetaFromStore (Tauri) a √©chou√© :", e);
    }

    // üß© Migration/fallback : ancien fichier unique
    try {
      const legacyTxt = await readTextFile(LEGACY_EVALMETA_FILE, {
        baseDir: BaseDirectory.AppLocalData,
      });
      if (legacyTxt && legacyTxt.trim().length > 0) {
        const parsed = JSON.parse(legacyTxt);
        if (Array.isArray(parsed)) {
          return await filterByExistingDevoirFiles(parsed as EvalMeta[]);
        }
      }
    } catch {
      // ignore
    }
  }

  // 2) Fallback : cache navigateur (localStorage)
  try {
    const cache = localStorage.getItem(cacheKey);
    if (cache) {
      const parsed = JSON.parse(cache);
      if (Array.isArray(parsed)) {
        return await filterByExistingDevoirFiles(parsed as EvalMeta[]);
      }
    }
  } catch (e) {
    console.warn("loadEvalMetaFromStore (localStorage) a √©chou√© :", e);
  }

  // üß© Migration/fallback : ancien cache unique
  try {
    const legacyCache = localStorage.getItem(LEGACY_EVALMETA_CACHE);
    if (legacyCache) {
      const parsed = JSON.parse(legacyCache);
      if (Array.isArray(parsed)) {
        return await filterByExistingDevoirFiles(parsed as EvalMeta[]);
      }
    }
  } catch {
    // ignore
  }

  return [];
}

// === Suivi des comp√©tences (skills_db.json) ===

async function loadSkillsFromStore(year: TrainingYear): Promise<SkillsDB> {
  const file = skillsDbFileName(year);
  const cacheKey = skillsDbCacheKey(year);

  // 1) Mode Tauri : on tente de lire le bon fichier dans AppLocalData
  if (isTauriRuntime()) {
    try {
      const txt = await readTextFile(file, {
        baseDir: BaseDirectory.AppLocalData,
      });

      if (txt && txt.trim().length > 0) {
        const parsed = JSON.parse(txt);
        if (parsed && typeof parsed === "object") {
          console.log(`[TAURI] ${file} charg√© depuis AppLocalData`);
          return parsed as SkillsDB;
        }
      }
    } catch (e) {
      console.warn("loadSkillsFromStore (Tauri) a √©chou√© :", e);
    }

    // üß© Migration/fallback : ancien fichier unique
    try {
      const legacyTxt = await readTextFile(LEGACY_SKILLS_FILE, {
        baseDir: BaseDirectory.AppLocalData,
      });
      if (legacyTxt && legacyTxt.trim().length > 0) {
        const parsed = JSON.parse(legacyTxt);
        if (parsed && typeof parsed === "object") {
          console.log(`[TAURI] ${LEGACY_SKILLS_FILE} charg√© (fallback legacy)`);
          return parsed as SkillsDB;
        }
      }
    } catch {
      // ignore
    }
  } else {
    console.log(
      "[WEB] Pas de runtime Tauri : on ne regarde pas le disque, uniquement localStorage."
    );
  }

  // 2) Fallback : cache navigateur
  try {
    const cache = localStorage.getItem(cacheKey);
    if (cache) {
      const parsed = JSON.parse(cache);
      if (parsed && typeof parsed === "object") {
        console.log(`[WEB] ${cacheKey} charg√© depuis localStorage`);
        return parsed as SkillsDB;
      }
    }
  } catch (e) {
    console.warn("loadSkillsFromStore (localStorage) a √©chou√© :", e);
  }

  // üß© Migration/fallback : ancien cache unique
  try {
    const legacyCache = localStorage.getItem(LEGACY_SKILLS_CACHE);
    if (legacyCache) {
      const parsed = JSON.parse(legacyCache);
      if (parsed && typeof parsed === "object") {
        console.log(`[WEB] ${LEGACY_SKILLS_CACHE} charg√© (fallback legacy)`);
        return parsed as SkillsDB;
      }
    }
  } catch {
    // ignore
  }

  return {};
}

async function saveSkillsToStore(db: SkillsDB, year: TrainingYear): Promise<void> {
  const payload = JSON.stringify(db, null, 2);
  const file = skillsDbFileName(year);
  const cacheKey = skillsDbCacheKey(year);

  // 1) Mode Tauri : on √©crit le bon fichier dans AppLocalData
  if (isTauriRuntime()) {
    try {
      await writeTextFile(file, payload, {
        baseDir: BaseDirectory.AppLocalData,
      });
      console.log(`[TAURI] ${file} sauvegard√© dans AppLocalData`);
    } catch (e) {
      console.warn("saveSkillsToStore (Tauri) a √©chou√© :", e);
    }
  } else {
    console.log(
      "[WEB] Pas de runtime Tauri : sauvegarde du suivi uniquement dans localStorage."
    );
  }

  // 2) Toujours : copie dans localStorage
  try {
    localStorage.setItem(cacheKey, payload);
  } catch {
    // ignore
  }
}

async function saveEvalMetaToStore(list: EvalMeta[], year: TrainingYear): Promise<void> {
  const payload = JSON.stringify(list, null, 2);
  const file = evalMetaFileName(year);
  const cacheKey = evalMetaCacheKey(year);

  // 1) Tauri : on √©crit le bon fichier dans AppLocalData
  if (isTauriRuntime()) {
    try {
      await writeTextFile(file, payload, {
        baseDir: BaseDirectory.AppLocalData,
      });
      console.log(`[TAURI] ${file} sauvegard√© dans AppLocalData`);
    } catch (e) {
      console.warn("saveEvalMetaToStore (Tauri) a √©chou√© :", e);
    }
  } else {
    console.log(
      "[WEB] Pas de runtime Tauri : sauvegarde des √©valuations uniquement dans localStorage."
    );
  }

  // 2) Toujours : copie dans localStorage (pratique en dev)
  try {
    localStorage.setItem(cacheKey, payload);
  } catch (e) {
    console.warn("saveEvalMetaToStore (localStorage) a √©chou√© :", e);
  }
}
// === Notation des √©l√®ves (notation_db.json) === (notation_db.json) ===
async function loadNotationFromStore(year: TrainingYear): Promise<NotationDB> {
  const file = notationDbFileName(year);
  const cacheKey = notationDbCacheKey(year);

  // 1) Mode Tauri : fichier sur le disque
  if (isTauriRuntime()) {
    try {
      const txt = await readTextFile(file, {
        baseDir: BaseDirectory.AppLocalData,
      });

      if (txt && txt.trim().length > 0) {
        const parsed = JSON.parse(txt);
        if (parsed && typeof parsed === "object") {
          console.log(`[TAURI] ${file} charg√© depuis AppLocalData`);
          return parsed as NotationDB;
        }
      }
    } catch (e) {
      console.warn("loadNotationFromStore (Tauri) a √©chou√© :", e);
    }

    // üß© Migration/fallback : ancien fichier unique
    try {
      const legacyTxt = await readTextFile(LEGACY_NOTATION_FILE, {
        baseDir: BaseDirectory.AppLocalData,
      });
      if (legacyTxt && legacyTxt.trim().length > 0) {
        const parsed = JSON.parse(legacyTxt);
        if (parsed && typeof parsed === "object") {
          console.log(`[TAURI] ${LEGACY_NOTATION_FILE} charg√© (fallback legacy)`);
          return parsed as NotationDB;
        }
      }
    } catch {
      // ignore
    }
  } else {
    console.log(
      "[WEB] Pas de runtime Tauri : on ne regarde pas le disque, uniquement localStorage."
    );
  }

  // 2) Fallback : cache navigateur
  try {
    const cache = localStorage.getItem(cacheKey);
    if (cache) {
      const parsed = JSON.parse(cache);
      if (parsed && typeof parsed === "object") {
        console.log(`[WEB] ${cacheKey} charg√© depuis localStorage`);
        return parsed as NotationDB;
      }
    }
  } catch (e) {
    console.warn("loadNotationFromStore (localStorage) a √©chou√© :", e);
  }

  // üß© Migration/fallback : ancien cache unique
  try {
    const legacyCache = localStorage.getItem(LEGACY_NOTATION_CACHE);
    if (legacyCache) {
      const parsed = JSON.parse(legacyCache);
      if (parsed && typeof parsed === "object") {
        console.log(`[WEB] ${LEGACY_NOTATION_CACHE} charg√© (fallback legacy)`);
        return parsed as NotationDB;
      }
    }
  } catch {
    // ignore
  }

  return {};
}

async function saveNotationToStore(db: NotationDB, year: TrainingYear): Promise<void> {
  const payload = JSON.stringify(db, null, 2);
  const file = notationDbFileName(year);
  const cacheKey = notationDbCacheKey(year);

  // 1) Mode Tauri : √©criture sur le disque
  if (isTauriRuntime()) {
    try {
      await writeTextFile(file, payload, {
        baseDir: BaseDirectory.AppLocalData,
      });
      console.log(`[TAURI] ${file} sauvegard√© dans AppLocalData`);
    } catch (e) {
      console.warn("saveNotationToStore (Tauri) a √©chou√© :", e);
    }
  } else {
    console.log(
      "[WEB] Pas de runtime Tauri : sauvegarde de notation_db uniquement dans localStorage."
    );
  }

  // 2) Toujours : copie dans localStorage
  try {
    localStorage.setItem(cacheKey, payload);
  } catch {
    // ignore
  }
}

// === Absences / Retards (absences_retards_*.json) ===
async function loadAbsencesRetardsFromStore(year: TrainingYear): Promise<AbsencesRetardsStore> {
  const file = absencesDbFileName(year);
  const cacheKey = absencesDbCacheKey(year);

  if (isTauriRuntime()) {
    try {
      const txt = await readTextFile(file, { baseDir: BaseDirectory.AppLocalData });
      if (txt && txt.trim().length > 0) {
        const parsed = JSON.parse(txt);
        if (parsed && typeof parsed === "object") {
          return {
            records: (parsed as any).records && typeof (parsed as any).records === "object" ? (parsed as any).records : {},
            planning: (parsed as any).planning && typeof (parsed as any).planning === "object" ? (parsed as any).planning : {},
          } as AbsencesRetardsStore;
        }
      }
    } catch (e) {
      console.warn("loadAbsencesRetardsFromStore (Tauri) a √©chou√© :", e);
    }
  }

  try {
    const cache = localStorage.getItem(cacheKey);
    if (cache) {
      const parsed = JSON.parse(cache);
      if (parsed && typeof parsed === "object") {
        return {
          records: (parsed as any).records && typeof (parsed as any).records === "object" ? (parsed as any).records : {},
          planning: (parsed as any).planning && typeof (parsed as any).planning === "object" ? (parsed as any).planning : {},
        } as AbsencesRetardsStore;
      }
    }
  } catch {
    // ignore
  }

  return { records: {}, planning: {} };
}

async function saveAbsencesRetardsToStore(store: AbsencesRetardsStore, year: TrainingYear): Promise<void> {
  const payload = JSON.stringify(store, null, 2);
  const file = absencesDbFileName(year);
  const cacheKey = absencesDbCacheKey(year);

  if (isTauriRuntime()) {
    try {
      await writeTextFile(file, payload, { baseDir: BaseDirectory.AppLocalData });
    } catch (e) {
      console.warn("saveAbsencesRetardsToStore (Tauri) a √©chou√© :", e);
    }
  }

  try {
    localStorage.setItem(cacheKey, payload);
  } catch {
    // ignore
  }
}
// -- Version robuste Tauri v2/v1 : utilise d'abord plugin-dialog + plugin-fs, puis bascule vers api/dialog + api/fs v2/v1 : utilise d'abord plugin-dialog + plugin-fs, puis bascule vers api/dialog + api/fs
async function saveEvaluationToLocalFolder(
  filename: string,
  data: unknown,
  year: TrainingYear
) {
  try {
    if (!isTauriRuntime()) {
      console.warn("Hors runtime Tauri, pas de sauvegarde disque.");
      return;
    }

    const dir = devoirDirName(year);

    // üìÅ Cr√©e le dossier ann√©e dans AppLocalData
    await mkdir(dir, {
      baseDir: BaseDirectory.AppLocalData,
    }).catch(() => {
      // si le dossier existe d√©j√†, on ignore l'erreur
    });

    const safeName = filename.endsWith(".json") ? filename : `${filename}.json`;
    const json = JSON.stringify(data, null, 2);

    // üîí On √©crit TOUJOURS dans AppLocalData/<dir>/<nom>.json
    await writeTextFile(`${dir}/${safeName}`, json, {
      baseDir: BaseDirectory.AppLocalData,
    });

    alert("üíæ Devoir enregistr√© avec succ√®s !");
  } catch (err) {
    console.error("Erreur sauvegarde (Tauri):", err);
    alert("‚ùå Impossible d'enregistrer le devoir.");
  }
}



function parsePrintWindowParams() {
  try {
    const search = new URLSearchParams(window.location.search);
    const hash = window.location.hash || "";
    // Accept formats:
    //  - "#/?printWindow=1&job=...&autoPrint=1"
    //  - "#printWindow=1&job=...&autoPrint=1"
    //  - "?printWindow=1&job=...&autoPrint=1"
    let hashParams = new URLSearchParams();
    if (hash.startsWith("#")) {
      const raw = hash.slice(1);
      const qIdx = raw.indexOf("?");
      const qs = qIdx >= 0 ? raw.slice(qIdx + 1) : raw.replace(/^\/?/, "");
      hashParams = new URLSearchParams(qs);
    }
    const isPrintWindow = search.get("printWindow") === "1" || hashParams.get("printWindow") === "1";
    const job = search.get("job") || hashParams.get("job") || "";
    const autoPrint = (search.get("autoPrint") || hashParams.get("autoPrint")) === "1";
    return { isPrintWindow, job, autoPrint };
  } catch {
    return { isPrintWindow: false, job: "", autoPrint: false };
  }
}

function StandalonePrintWindow(props: { job: string; autoPrint: boolean }) {
  const { job, autoPrint } = props;
  const iframeRef = React.useRef<HTMLIFrameElement | null>(null);
  const [html, setHtml] = React.useState<string>("");
  const [error, setError] = React.useState<string | null>(null);

  React.useEffect(() => {
    let cancelled = false;
    (async () => {
      try {
        if (!job) {
          setError("Aucun contenu d'impression √† afficher (job manquant).");
          return;
        }
        const content = await readTextFile(job, { baseDir: BaseDirectory.AppLocalData });
        if (!cancelled) {
          setHtml(content);
          setError(null);
        }
      } catch (e) {
        console.error("StandalonePrintWindow readTextFile failed:", e);
        if (!cancelled) setError("Impossible de charger le contenu d'impression.");
      }
    })();
    return () => { cancelled = true; };
  }, [job]);

  const handleClose = async () => {
    try {
      await getCurrentWindow().close();
    } catch (e) {
      try { window.close(); } catch {}
    }
  };

  const handlePrint = () => {
    const iframe = iframeRef.current;
    if (!iframe) return;
    try {
      const win = iframe.contentWindow;
      if (win) {
        win.focus();
        win.print();
      }
    } catch (e) {
      console.warn("StandalonePrintWindow print failed:", e);
    }
  };

  React.useEffect(() => {
    if (!autoPrint || !html) return;
    const iframe = iframeRef.current;
    if (!iframe) return;

    const doPrint = () => {
      // Laisser un petit d√©lai pour que la page soit bien rendue
      setTimeout(() => {
        handlePrint();
      }, 250);
    };

    // Si d√©j√† charg√©, imprimer; sinon attendre l'event load
    const doc = iframe.contentDocument;
    if (doc && doc.readyState === "complete") {
      doPrint();
      return;
    }
    iframe.addEventListener("load", doPrint, { once: true });
  }, [autoPrint, html]);

  return (
    <div className="print-window-root">
      {/* Barre haute d√©di√©e √† la fen√™tre d'impression */}
      <div className="print-window-toolbar">
        <div className="print-window-title">Impression</div>
        <div className="print-window-actions">
          <button type="button" onClick={handlePrint} className="print-window-btn">
            Imprimer
          </button>
          <button type="button" onClick={handleClose} className="print-window-btn">
            Fermer
          </button>
        </div>
      </div>

      <div className="print-window-body">
        {error ? (
          <div className="print-window-error">{error}</div>
        ) : (
          <iframe
            ref={iframeRef}
            title="print"
            className="print-window-iframe"
            srcDoc={html}
          />
        )}
      </div>
    </div>
  );
}



export default function AppCore() {
  const __pw = parsePrintWindowParams();
  if (__pw.isPrintWindow) {
    return <StandalonePrintWindow job={__pw.job} autoPrint={__pw.autoPrint} />;
  }
  // --- Initial synchronous hydration from cache (improves first-render display) ---
  let __initPersistedExigences: Record<string, string[]> = {};
  try {
    const cache = localStorage.getItem('exigences_db_cache');
    if (cache) __initPersistedExigences = JSON.parse(cache);
  } catch (e) { /* ignore */ }
  let __initTrainingYear: TrainingYear = "premiere";
  try {
    const y = localStorage.getItem("training_year");
    if (y === "premiere" || y === "deuxieme") __initTrainingYear = y as TrainingYear;
  } catch {}

  let __initEvalMeta: EvalMeta[] = [];
  try {
    const cacheEval =
      localStorage.getItem(evalMetaCacheKey(__initTrainingYear)) ||
      localStorage.getItem(LEGACY_EVALMETA_CACHE);
    if (cacheEval) __initEvalMeta = JSON.parse(cacheEval);
  } catch (e) { /* ignore */ }

  // --- √âtats de persistance & donn√©es ---
  const [trainingYear, setTrainingYear] = React.useState<TrainingYear>(__initTrainingYear);
  const trainingYearRef = React.useRef<TrainingYear>(trainingYear);
  React.useEffect(() => {
    trainingYearRef.current = trainingYear;
  }, [trainingYear]);

  const [evalMetaBootstrapped, setEvalMetaBootstrapped] = React.useState(false);
  const DEVOIR_DIR = devoirDirName(trainingYear);
  const DEVOIR_TRASH_DIR = devoirTrashDirName(trainingYear);

  // Persistance du choix d'ann√©e (utile pour retrouver la m√™me vue au red√©marrage)
  React.useEffect(() => {
    try {
      localStorage.setItem("training_year", trainingYear);
    } catch {}
  }, [trainingYear]);


  const [persistedExigencesDB, setPersistedExigencesDB] = React.useState<Record<string, string[]>>(__initPersistedExigences);
  const [exigencesIndex, setExigencesIndex] = React.useState<Record<string, Record<string, string[]>>>(() => buildExigencesIndex(__initPersistedExigences));
  const [customExigences, setCustomExigences] = React.useState<Record<string, string[]>>({});
  const [selectedExigence, setSelectedExigence] = React.useState<Record<string, string[]>>({});
  const [critResDB, setCritResDB] = React.useState<CriteresResultsDB | null>(() => {
    try {
      const c = localStorage.getItem("criteres_resultats_cache");
      if (c) return JSON.parse(c) as CriteresResultsDB;
    } catch {}
    return null;
  });
  const [tcMap, setTcMap] = useState<TCMap>(DEFAULT_TACHES_COMPETENCES);
  const [capPoles, setCapPoles] = useState<string[]>(defaultPolesList());
  const [polesMap, setPolesMap] = useState<PolesMap>(() => defaultPolesMap(defaultPolesList()));
  const [referentielCapName, setReferentielCapName] = React.useState<string>("");
  const [referentielCapCatalog, setReferentielCapCatalog] = React.useState<ReferentielCapCatalog>({ schema: "referentiels_cap_catalog_v1", activeId: null, items: [] });
  const [referentielCapActiveId, setReferentielCapActiveId] = React.useState<string | null>(null);

    // Toutes les comp√©tences du r√©f√©rentiel (utilis√©es dans la vue "classe")
  const allCompetencesForSuivi = React.useMemo(
    () => (critResDB ? Object.keys(critResDB) : []),
    [critResDB]
  );

  const autosaveTimer = React.useRef<number | null>(null);
  const previewIframeRef = React.useRef<HTMLIFrameElement | null>(null);
  const printIframeRef = React.useRef<HTMLIFrameElement | null>(null);
  const printJobIframeRef = React.useRef<HTMLIFrameElement | null>(null);

  // Impression (mise en page sp√©cifique, ex. bilan p√©riodique)
  const [isPrinting, setIsPrinting] = React.useState(false);
  React.useEffect(() => {
    if (typeof window === "undefined" || typeof window.matchMedia !== "function") return;

    const mql = window.matchMedia("print");
    const onChange = (e: MediaQueryListEvent | MediaQueryList) => {
      // Safari peut appeler avec MediaQueryList
      const matches = "matches" in e ? (e as any).matches : (mql as any).matches;
      setIsPrinting(!!matches);
    };

    const before = () => setIsPrinting(true);
    const after = () => setIsPrinting(false);

    try {
      mql.addEventListener("change", onChange as any);
    } catch {
      // Safari < 14
      (mql as any).addListener?.(onChange);
    }

    window.addEventListener("beforeprint", before);
    window.addEventListener("afterprint", after);

    setIsPrinting(!!mql.matches);

    return () => {
      try {
        mql.removeEventListener("change", onChange as any);
      } catch {
        (mql as any).removeListener?.(onChange);
      }
      window.removeEventListener("beforeprint", before);
      window.removeEventListener("afterprint", after);
    };
  }, []);

  const [evalMetaList, setEvalMetaList] = React.useState<EvalMeta[]>(__initEvalMeta);
    // Notation par √©l√®ve / devoir / ann√©e scolaire
  const [notationDB, setNotationDB] = React.useState<NotationDB>({});
  const [notationBootstrapped, setNotationBootstrapped] = React.useState(false);

  // üîí R√©fs pour √©viter les pertes de donn√©es (ex: l'utilisateur saisit une note avant la fin du chargement)
  const notationDBRef = React.useRef<NotationDB>({});
  const notationDirtyRef = React.useRef(false);
  const notationLoadTokenRef = React.useRef(0);

  // Toujours garder une copie √† jour



// Absences / retards (par classe / ann√©e scolaire)
const [absencesStore, setAbsencesStore] = React.useState<AbsencesRetardsStore>({ records: {}, planning: {} });
const [absencesBootstrapped, setAbsencesBootstrapped] = React.useState(false);
const absencesStoreRef = React.useRef<AbsencesRetardsStore>({ records: {}, planning: {} });
const absencesLoadTokenRef = React.useRef(0);
const absencesSaveTimerRef = React.useRef<number | null>(null);

React.useEffect(() => {
  absencesStoreRef.current = absencesStore;
}, [absencesStore]);

// Charger la base Absences/Retards au d√©marrage + √† chaque changement d'ann√©e de formation
React.useEffect(() => {
  let mounted = true;
  const token = ++absencesLoadTokenRef.current;
  setAbsencesBootstrapped(false);

  (async () => {
    try {
      const db = await loadAbsencesRetardsFromStore(trainingYear);
      if (!mounted || absencesLoadTokenRef.current !== token) return;
      setAbsencesStore(db);
    } finally {
      if (!mounted || absencesLoadTokenRef.current !== token) return;
      setAbsencesBootstrapped(true);
    }
  })();

  return () => {
    mounted = false;
  };
}, [trainingYear]);

// Autosave (debounce)
React.useEffect(() => {
  if (!absencesBootstrapped) return;
  if (absencesSaveTimerRef.current) window.clearTimeout(absencesSaveTimerRef.current);
  absencesSaveTimerRef.current = window.setTimeout(() => {
    saveAbsencesRetardsToStore(absencesStoreRef.current, trainingYear);
  }, 500);
  return () => {
    if (absencesSaveTimerRef.current) window.clearTimeout(absencesSaveTimerRef.current);
  };
}, [absencesBootstrapped, absencesStore, trainingYear]);



  React.useEffect(() => {
    notationDBRef.current = notationDB;
  }, [notationDB]);

   // -- Expose debug helpers on window for DevTools --
  React.useEffect(() => {
    (window as any).__APP_DEBUG__ = {
      getPersistedExigencesFor,
      exigencesIndex,
      persistedExigencesDB,
      upsert: upsertPersonalExigences,
    };
    console.info('[DEBUG] __APP_DEBUG__ available: __APP_DEBUG__.getPersistedExigencesFor(code, item)');
  }, [exigencesIndex, persistedExigencesDB]);

// Charger la base des notations (selon l'ann√©e) au d√©marrage + √† chaque changement d'ann√©e
React.useEffect(() => {
  let mounted = true;
  const token = ++notationLoadTokenRef.current;
  setNotationBootstrapped(false);

  // Changement d'ann√©e ‚Üí on repart sur un √©tat "non modifi√©".
  notationDirtyRef.current = false;

  (async () => {
    try {
      const db = await loadNotationFromStore(trainingYear);
      // Si un autre chargement a √©t√© lanc√© entre-temps, on ignore celui-ci
      if (!mounted || notationLoadTokenRef.current !== token) return;

      // Si l'utilisateur a d√©j√† modifi√© des notes avant la fin du chargement,
      // on ne doit surtout pas √©craser ses saisies.
      if (notationDirtyRef.current) {
        console.warn(
          "[NOTE] Chargement notation ignor√© (l'utilisateur a d√©j√† modifi√© des notes)."
        );
        return;
      }

      if (db && typeof db === "object") {
        setNotationDB(db);
      } else {
        setNotationDB({});
      }
    } finally {
      if (mounted && notationLoadTokenRef.current === token) {
        setNotationBootstrapped(true);
      }
    }
  })();

  return () => {
    mounted = false;
  };
}, [trainingYear]);

// Sauvegarder la base des notations d√®s qu'elle change,
// mais seulement apr√®s le premier chargement (et dans le fichier de l'ann√©e courante)
React.useEffect(() => {
  if (!notationBootstrapped) return;
  const y = trainingYearRef.current;
  saveNotationToStore(notationDB, y);
}, [notationBootstrapped, notationDB]);

  // --- Lookup persistant normalis√© par code (C2.01) + item ---
  const getPersistedExigencesFor = React.useCallback((comp, item) => {
    const code = __extractCode(comp) || comp;
    const codeKey = __norm(code);
    const itemKey = __norm(__cleanItem(item));
    const bucket = exigencesIndex[codeKey] || {};
    return bucket[itemKey] || [];
  }, [exigencesIndex]);
  // --- Map (code,item) -> rawKey from persisted DB, to preserve existing keys when saving ---
  const rawKeyByPairRef = React.useRef<Record<string, string>>({});
  React.useEffect(() => {
    const map: Record<string, string> = {};
    for (const rawKey of Object.keys(persistedExigencesDB || {})) {
      const k = String(rawKey || '').trim().replace(/\s+/g, ' ');
      const parts = k.split(' II ');
      const left = parts[0] || '';
      const right = parts[1] || k;
      const code = __extractCode(left) || left;
      const item = __cleanItem(right);
      const codeKey = __norm(code);
      const itemKey = __norm(item);
      map[codeKey + '::' + itemKey] = rawKey;
    }
    rawKeyByPairRef.current = map;
  }, [persistedExigencesDB]);

  // --- Upsert: merges values and writes under existing rawKey when available, else canonical "CODE II item :" ---
  const upsertPersonalExigences = React.useCallback((code: string, item: string, values: string[]) => {
    const codeKey = __norm(code);
    const itemKey = __norm(__cleanItem(item));
    const pair = codeKey + '::' + itemKey;
    const rawKey = rawKeyByPairRef.current[pair] || `${code} II ${__cleanItem(item)} :`;
    const current = Array.isArray((persistedExigencesDB as any)?.[rawKey]) ? (persistedExigencesDB as any)[rawKey] as string[] : [];
    const merged = Array.from(new Set([...(current || []), ...(values || [])])).filter(Boolean);
    const next = { ...(persistedExigencesDB || {}) , [rawKey]: merged };
    setPersistedExigencesDB(next);
    setExigencesIndex(buildExigencesIndex(next));
    try { localStorage.setItem('exigences_db_cache', JSON.stringify(next)); } catch {}
    (async () => {
      try {
        if (isTauriRuntime() && await getTauriFs()) {
          await saveExigencesToTauri(next);
        }
      } catch (e) {
        console.warn('saveExigencesToTauri failed', e);
      }
    })();
  }, [persistedExigencesDB]);


  // --- √âtats UI / config ---
  const [step, setStep] = useState<"params" | 1 | 2 | 3 | 4>(1);
  const [updateBusy, setUpdateBusy] = useState(false);
  const [theme, setTheme] = useState<'light' | 'dark'>(() =>
    (typeof window !== 'undefined' ? (localStorage.getItem('theme') as 'light' | 'dark') || 'light' : 'light')
  );
  const [title, setTitle] = useState("√âvaluation CAP Ma√ßonnerie");
  const [project, setProject] = useState("");
  const [professionalSituation, setProfessionalSituation] = useState("");
  const [evaluator, setEvaluator] = useState("");
  const [group, setGroup] = useState("GROUPE");
  const [objectives, setObjectives] = useState("");
  const [logoDataUrl, setLogoDataUrl] = useState<string | null>(null);
  // Doit correspondre aux valeurs utilis√©es dans l'app :
  // "Auto-√©valuation" | "code-couleur" | "criterie"
  const [evaluationType, setEvaluationType] = useState<string>("criterie")
  const [evaluationId, setEvaluationId] = useState<string>(() =>
    `${Date.now()}-${Math.random().toString(16).slice(2)}`
  );
  const [evaluationSemester, setEvaluationSemester] = useState<SemesterKey>("Ne pas utiliser de semestre");
  const [loadedDevoirFileName, setLoadedDevoirFileName] = useState<string | null>(null);


  const [evaluationCategory, setEvaluationCategory] = useState<EvaluationCategory>("D√©couverte professionnel");
  const [selectedCompetences, setSelectedCompetences] = useState<string[]>([]);
  const [selectedCriteres, setSelectedCriteres] = useState<string[]>([]);
  const [selectedSubCrit, setSelectedSubCrit] = useState<string[]>([]);
  const [expandedTasks, setExpandedTasks] = useState<Record<string, boolean>>({});
  const [expandedCompetences, setExpandedCompetences] = useState<Record<string, boolean>>({});
  const [manageKey, setManageKey] = useState<string | null>(null);
  const [drawerInput, setDrawerInput] = useState<string>("");
  const [inlineAddKey, setInlineAddKey] = useState<string | null>(null);
  const [inlineAddValue, setInlineAddValue] = useState<string>("");
  const [activeTask, setActiveTask] = useState<string | null>(null);
  const [selectedTasks, setSelectedTasks] = useState<string[]>([]);
  const [previewOpen, setPreviewOpen] = useState(false);
  const [previewHtml, setPreviewHtml] = useState<string | null>(null);
  const [previewEvaluationType, setPreviewEvaluationType] = useState<string>(evaluationType);
  const [printOpen, setPrintOpen] = useState(false);
  const [printHtml, setPrintHtml] = useState<string | null>(null);
  const [printEvaluationType, setPrintEvaluationType] = useState<string>(evaluationType);
  const [autoPrintAfterPreview, setAutoPrintAfterPreview] = useState(false);
  const [autoPrintAfterPrint, setAutoPrintAfterPrint] = useState(false);
  const [printJobHtml, setPrintJobHtml] = useState<string | null>(null);
const closePreviewModal = () => {
  setAutoPrintAfterPreview(false);
  setPreviewOpen(false);
  setPreviewHtml(null);
};

const closePrintModal = () => {
  setAutoPrintAfterPrint(false);
  setPrintOpen(false);
  setPrintHtml(null);
  setPrintJobHtml(null);
};

const startPrintJob = (html: string | null) => {
  if (!html) return;
  // √âviter tout contenu "derri√®re" pendant le dialogue d'impression (syst√®me / WebView)
  closePreviewModal();
  setPrintOpen(false); // masquer la vue Impression avant d'ouvrir le dialogue syst√®me
  setPrintJobHtml(html);
};


  // Garder le type d'impression align√© avec le type d'√©valuation courant
  // (sans √©craser le choix manuel lorsque l'aper√ßu est ouvert).
  useEffect(() => {
    if (!previewOpen && !printOpen) {
      setPrintEvaluationType(evaluationType);
      setPreviewEvaluationType(evaluationType);
    }
  }, [evaluationType, previewOpen, printOpen]);

  // Impression automatique (utilis√©e par le bouton üñ®Ô∏è IMPRIMER du bandeau)
  useEffect(() => {
    if (!autoPrintAfterPreview || !previewOpen) return;

    const iframe = previewIframeRef.current;
    if (!iframe) return;

    const doPrint = () => {
      try {
        const win = iframe.contentWindow;
        if (win) {
          win.focus();
          win.print();
        }
      } catch (e) {
        console.warn("Auto print failed:", e);
      } finally {
        setAutoPrintAfterPreview(false);
      }
    };

    const doc = iframe.contentDocument;
    if (doc && doc.readyState === "complete") {
      setTimeout(doPrint, 0);
      return;
    }

    iframe.addEventListener("load", doPrint, { once: true });
  }, [autoPrintAfterPreview, previewOpen, previewHtml]);

  // Impression automatique ‚Äî fen√™tre Impression
  useEffect(() => {
    if (!autoPrintAfterPrint || !printOpen || !printHtml) return;
    setAutoPrintAfterPrint(false);
    startPrintJob(printHtml);
  }, [autoPrintAfterPrint, printOpen, printHtml]);

// Lancement de l'impression via un iframe cach√© (√©vite l'ouverture d'une "fen√™tre" derri√®re la vue Impression)
useEffect(() => {
  if (!printJobHtml) return;

  const iframe = printJobIframeRef.current;
  if (!iframe) return;

  const doPrint = () => {
    try {
      const win = iframe.contentWindow;
      if (!win) return;

      const cleanup = () => {
        try {
          closePrintModal();
        } catch {}
      };

      // afterprint se d√©clenche en cas d'impression OU d'annulation
      try {
        win.addEventListener("afterprint", cleanup, { once: true });
      } catch {}

      win.focus();
      win.print();
    } catch (e) {
      console.warn("Print job failed:", e);
      try {
        closePrintModal();
      } catch {}
    }
  };

  const doc = iframe.contentDocument;
  if (doc && doc.readyState === "complete") {
    setTimeout(doPrint, 0);
    return;
  }

  iframe.addEventListener("load", doPrint, { once: true });
}, [printJobHtml]);





  // Fen√™tre unique : si l'utilisateur clique sur la croix (fermeture fen√™tre),
// on ferme d'abord la fen√™tre Impression ou Aper√ßu au lieu de fermer l'application.
  const previewOpenRef = React.useRef(previewOpen);
  const printOpenRef = React.useRef(printOpen);
  useEffect(() => {
    previewOpenRef.current = previewOpen;
  }, [previewOpen]);
  useEffect(() => {
    printOpenRef.current = printOpen;
  }, [printOpen]);


  useEffect(() => {
    if (!isTauriRuntime()) return;

    let unlisten: any = null;
    let cancelled = false;

    const handler = (e: any) => {
      if (!previewOpenRef.current && !printOpenRef.current) return;
      try { e.preventDefault(); } catch {}
      try {
        if (printOpenRef.current) closePrintModal();
        else closePreviewModal();
      } catch {}
    };

    (async () => {
      // v1: appWindow
      try {
        const m1: any = await importDyn(['@tauri-apps','api','window'].join('/'));
        const w = m1?.appWindow;
        if (w?.onCloseRequested) {
          const u = await w.onCloseRequested(handler);
          if (!cancelled) unlisten = u;
          return;
        }
      } catch {}

      // v2: getCurrentWebviewWindow()
      try {
        const m2: any = await importDyn(['@tauri-apps','api','webviewWindow'].join('/'));
        const w =
          (typeof m2?.getCurrentWebviewWindow === "function" ? m2.getCurrentWebviewWindow() :
          (typeof m2?.getCurrent === "function" ? m2.getCurrent() : null));
        if (w?.onCloseRequested) {
          const u = await w.onCloseRequested(handler);
          if (!cancelled) unlisten = u;
        }
      } catch {}
    })();

    return () => {
      cancelled = true;
      try { if (typeof unlisten === "function") unlisten(); } catch {}
    };
  }, []);

  
  // Tauri : masquer temporairement le bandeau sup√©rieur (d√©corations de fen√™tre) quand l'aper√ßu est ouvert
  // afin d'√©viter la confusion avec la croix de fermeture de l'application pendant l'impression.
  const tauriMainWindowRef = React.useRef<any>(null);

  const setTauriMainDecorations = async (decorations: boolean) => {
    if (!isTauriRuntime()) return;
    try {
      if (!tauriMainWindowRef.current) {
        // v1: appWindow
        try {
          const m1: any = await importDyn(['@tauri-apps','api','window'].join('/'));
          if (m1?.appWindow) tauriMainWindowRef.current = m1.appWindow;
        } catch {}
        // v2: getCurrentWebviewWindow()
        if (!tauriMainWindowRef.current) {
          try {
            const m2: any = await importDyn(['@tauri-apps','api','webviewWindow'].join('/'));
            if (typeof m2?.getCurrentWebviewWindow === 'function') tauriMainWindowRef.current = m2.getCurrentWebviewWindow();
            else if (typeof m2?.getCurrent === 'function') tauriMainWindowRef.current = m2.getCurrent();
          } catch {}
        }
      }

      const w = tauriMainWindowRef.current;
      if (w && typeof w.setDecorations === 'function') {
        await w.setDecorations(decorations);
      }
    } catch (e) {
      // ignore
    }
  };


  const setTauriMainClosable = async (closable: boolean) => {
    if (!isTauriRuntime()) return;
    try {
      if (!tauriMainWindowRef.current) {
        // v1: appWindow
        try {
          const m1: any = await importDyn(['@tauri-apps','api','window'].join('/'));
          if (m1?.appWindow) tauriMainWindowRef.current = m1.appWindow;
        } catch {}
        // v2: getCurrentWebviewWindow()
        if (!tauriMainWindowRef.current) {
          try {
            const m2: any = await importDyn(['@tauri-apps','api','webviewWindow'].join('/'));
            if (typeof m2?.getCurrentWebviewWindow === 'function') tauriMainWindowRef.current = m2.getCurrentWebviewWindow();
            else if (typeof m2?.getCurrent === 'function') tauriMainWindowRef.current = m2.getCurrent();
          } catch {}
        }
      }

      const w = tauriMainWindowRef.current;
      if (w && typeof w.setClosable === 'function') {
        await w.setClosable(closable);
      }
    } catch {
      // ignore
    }
  };

  React.useEffect(() => {
    if (!isTauriRuntime()) return;
    const lock = previewOpen || printOpen;

    if (lock) {
      setTauriMainDecorations(false);
      try { setTauriMainClosable(false); } catch {}
    } else {
      setTauriMainDecorations(true);
      try { setTauriMainClosable(true); } catch {}
    }
  }, [previewOpen, printOpen]);


  // Helpers pour ouvrir l'aper√ßu en modal (dans l'app) ou dans une fen√™tre d√©tach√©e (popup)
  const injectAutoPrintScript = (html: string) => {
    const script = `
<script>
  (function () {
    function doPrint() {
      try { window.focus(); } catch (e) {}
      try { window.print(); } catch (e) {}
    }
    window.addEventListener('load', function () {
      setTimeout(doPrint, 250);
    });
    window.addEventListener('afterprint', function () {
      try { window.close(); } catch (e) {}
    });
  })();
</script>`;
    if (html.includes("</body>")) return html.replace("</body>", `${script}\n</body>`);
    return html + script;
  };

  const openDetachedHtmlWindow = (innerHtml: string, opts?: PreviewTargetOptions): boolean => {
    // Mode "fen√™tre unique" : on n'ouvre jamais de seconde fen√™tre.
    // On route vers Aper√ßu ou Impression selon opts.target.
    try {
      const target = opts?.target || "preview";

      if (target === "print") {
        // Assurer l‚Äôind√©pendance : on ne garde pas l‚ÄôAper√ßu ouvert quand on imprime
        closePreviewModal();

        setPrintHtml(innerHtml);
        setPrintOpen(true);
        if (opts?.autoPrint) setAutoPrintAfterPrint(true);
        return true;
      }

      // Assurer l‚Äôind√©pendance : on ne garde pas la fen√™tre Impression ouverte quand on ouvre l‚ÄôAper√ßu
      closePrintModal();

      setPreviewHtml(innerHtml);
      setPreviewOpen(true);
      if (opts?.autoPrint) setAutoPrintAfterPreview(true);
      return true;
    } catch (e) {
      console.warn("openDetachedHtmlWindow fallback failed:", e);
      return false;
    }
  };

  const openHtmlInPrintWebviewWindow = async (innerHtml: string, opts?: PreviewTargetOptions) => {
    // Impression dans une vraie fen√™tre du logiciel (Tauri), ind√©pendante de l'aper√ßu.
    const autoPrint = !!opts?.autoPrint;

    // Hors Tauri (mode navigateur) : fallback simple
    if (!isTauriRuntime()) {
      const w = window.open("", "_blank");
      if (!w) {
        alert("Impossible d'ouvrir la fen√™tre d'impression.");
        return false;
      }
      w.document.open();
      w.document.write(innerHtml);
      w.document.close();
      if (autoPrint) {
        setTimeout(() => {
          try { w.focus(); } catch {}
          try { w.print(); } catch {}
        }, 250);
      }
      return true;
    }

    try {
      await mkdir("print_jobs", { baseDir: BaseDirectory.AppLocalData, recursive: true });
      const jobId = `${Date.now()}-${Math.random().toString(16).slice(2)}`;
      const jobFile = `print_jobs/${jobId}.html`;
      await writeTextFile(jobFile, innerHtml, { baseDir: BaseDirectory.AppLocalData });

      const label = `print_${jobId}`;
      // IMPORTANT: passer les param√®tres dans le hash (√©vite les soucis d'assets avec querystring)
      const url = `index.html#/?printWindow=1&job=${encodeURIComponent(jobFile)}&autoPrint=${autoPrint ? "1" : "0"}`;

      const w = new WebviewWindow(label, {
        url,
        title: "Impression",
        width: 1200,
        height: 850,
        resizable: true,
        decorations: true,
      });

      w.once("tauri://created", async () => {
        try { await w.center(); } catch {}
        try { await w.setAlwaysOnTop(true); } catch {}
        try { await w.setFocus(); } catch {}
      });

      w.once("tauri://error", (e) => {
        console.error("Print window creation error:", e);
        alert("Impossible d'ouvrir la fen√™tre d'impression (v√©rifie les permissions Tauri).");
      });

      return true;
    } catch (e) {
      console.error("openHtmlInPrintWebviewWindow failed:", e);
      alert("Impossible d'ouvrir la fen√™tre d'impression (v√©rifie les permissions Tauri).");
      return false;
    }
  };

  const pushPreview = (html: string, opts?: PreviewTargetOptions) => {
    // Mode "fen√™tre unique" : par d√©faut on ouvre dans l'app.
    // target = "preview"     => bouton üëÅÔ∏è APERCU
    // target = "print"       => ancienne fen√™tre Impression (modal interne)
    // target = "printWindow" => fen√™tre d'impression Tauri ind√©pendante
    const target = opts?.target || "preview";

    if (target === "printWindow") {
      // Ne jamais r√©v√©ler un Aper√ßu derri√®re l‚Äôimpression
      closePreviewModal();
      closePrintModal();
      void openHtmlInPrintWebviewWindow(html, opts);
      return;
    }

    if (target === "print") {
      // Ne jamais r√©v√©ler un Aper√ßu derri√®re l‚Äôimpression (source de confusion)
      closePreviewModal();

      setPrintHtml(html);
      setPrintOpen(true);
      if (opts?.autoPrint) setAutoPrintAfterPrint(true);
      return;
    }

    // Ouvrir l‚ÄôAper√ßu => on ferme l‚Äôimpression si elle est ouverte
    closePrintModal();

    setPreviewHtml(html);
    setPreviewOpen(true);
    if (opts?.autoPrint) setAutoPrintAfterPreview(true);
  };

  const [classGroups, setClassGroups] = useState<ClassGroup[]>([]);
  const [elevesBootstrapped, setElevesBootstrapped] = useState(false);
  const [classDrawerOpen, setClassDrawerOpen] = useState(false);
  
  // Suivi des comp√©tences : base de donn√©es locale
  const [skillsDB, setSkillsDB] = React.useState<SkillsDB>({});
  const [skillsBootstrapped, setSkillsBootstrapped] = React.useState(false);

  // --- Donn√©es 1√®re ann√©e (lecture seule) affich√©es en 2√®me ann√©e ---
  const [skillsDBPremiere, setSkillsDBPremiere] = React.useState<SkillsDB>({});
  const [evalMetaListPremiere, setEvalMetaListPremiere] = React.useState<EvalMeta[]>([]);
  const [notationDBPremiere, setNotationDBPremiere] = React.useState<NotationDB>({});
  const [premiereBootstrapped, setPremiereBootstrapped] = React.useState(false);

  // --- Donn√©es 2√®me ann√©e (lecture seule) affich√©es en 1√®re ann√©e (utile pour la vue "√âvolutions") ---
  const [skillsDBDeuxieme, setSkillsDBDeuxieme] = React.useState<SkillsDB>({});
  const [evalMetaListDeuxieme, setEvalMetaListDeuxieme] = React.useState<EvalMeta[]>([]);
  const [notationDBDeuxieme, setNotationDBDeuxieme] = React.useState<NotationDB>({});
  const [deuxiemeBootstrapped, setDeuxiemeBootstrapped] = React.useState(false);



  const [selectedClassIdForSuivi, setSelectedClassIdForSuivi] = useState<string | null>(null);
  const [selectedClassIdForSuiviDocs, setSelectedClassIdForSuiviDocs] = useState<string | null>(null);
  const [selectedStudentForDocs, setSelectedStudentForDocs] = useState<string | null>(null);
  const [docsRefreshNonce, setDocsRefreshNonce] = useState(0);
  const [docsFilesByFolder, setDocsFilesByFolder] = useState<Record<string, { name: string; path: string }[]>>({});
  const [docsFilesLoading, setDocsFilesLoading] = useState(false);

  type DocFolderDef = { key: string; label: string };
  const DOC_FOLDERS_CACHE_KEY = "suivi_docs_folders_v1";
  const DEFAULT_DOC_FOLDERS: DocFolderDef[] = [
    { key: "bulletin", label: "Bulletin de notes" },
    { key: "bilan_atelier", label: "Bilan de comp√©tences atelier" },
    { key: "pfmp", label: "Convention & Notation PFMP" },
  ];

  const [docFolders, setDocFolders] = useState<DocFolderDef[]>(() => {
    try {
      const raw = localStorage.getItem(DOC_FOLDERS_CACHE_KEY);
      if (!raw) return DEFAULT_DOC_FOLDERS;
      const parsed = JSON.parse(raw);
      if (Array.isArray(parsed) && parsed.every((x) => x && typeof x.key === "string" && typeof x.label === "string")) {
        // Merge : garantit la pr√©sence des 3 dossiers par d√©faut (compat)
        const byKey = new Map<string, DocFolderDef>();
        for (const f of DEFAULT_DOC_FOLDERS) byKey.set(f.key, f);
        for (const f of parsed as DocFolderDef[]) byKey.set(f.key, f);
        return Array.from(byKey.values());
      }
      return DEFAULT_DOC_FOLDERS;
    } catch {
      return DEFAULT_DOC_FOLDERS;
    }
  });

  React.useEffect(() => {
    try {
      localStorage.setItem(DOC_FOLDERS_CACHE_KEY, JSON.stringify(docFolders, null, 2));
    } catch {
      // ignore
    }
  }, [docFolders]);

  const handleAddDocFolder = React.useCallback(() => {
    const label = (prompt("Nom du porte-document :") || "").trim();
    if (!label) return;

    const base = (sanitizeFileNamePart(label) || "dossier").toLowerCase();
    let key = base;
    let i = 2;
    while (docFolders.some((f) => f.key === key)) {
      key = `${base}_${i++}`;
    }

    setDocFolders((prev) => [...prev, { key, label }]);
    setDocsRefreshNonce((n) => n + 1);
  }, [docFolders]);

  const [pdfViewer, setPdfViewer] = useState<{ url: string; name: string; relPath: string } | null>(null);
  const [exportYear, setExportYear] = useState<TrainingYear>("premiere");

  React.useEffect(() => {
    // Lib√®re l'URL blob quand on change de PDF / on ferme / on quitte la vue
    return () => {
      if (pdfViewer?.url) {
        try { URL.revokeObjectURL(pdfViewer.url); } catch {}
      }
    };
  }, [pdfViewer?.url]);

  React.useEffect(() => {
    // Si on change d'√©l√®ve / de classe / de vue, on ferme le viewer
    setPdfViewer(null);
  }, [selectedClassIdForSuiviDocs, selectedStudentForDocs]);



const refreshSuiviElevesDocs = React.useCallback(async () => {
  const classeId = selectedClassIdForSuiviDocs;
  const student = selectedStudentForDocs;
  if (!classeId || !student || !isTauriRuntime()) {
    setDocsFilesByFolder({});
    return;
  }

  const DOC_ROOT = "suivi_eleves_docs";
  const folders = docFolders.map((f) => f.key);

  const basePath = (folderKey: string) => {
    const classPart = sanitizeFileNamePart(classeId);
    const studentPart = sanitizeFileNamePart(student);
    const folderPart = sanitizeFileNamePart(folderKey);
    return `${DOC_ROOT}/${trainingYear}/${classPart}/${studentPart}/${folderPart}`;
  };

  const listFolder = async (folderKey: string) => {
    const dir = basePath(folderKey);
    try {
      const ok = await exists(dir, { baseDir: BaseDirectory.AppLocalData });
      if (!ok) return [];
      const entries = await readDir(dir, { baseDir: BaseDirectory.AppLocalData });
      return entries
        .filter((e: any) => e?.isFile && String(e?.name || "").toLowerCase().endsWith(".pdf"))
        .map((e: any) => ({
          name: String(e.name || ""),
          path: `${dir}/${String(e.name || "")}`,
        }))
        .sort((a, b) => a.name.localeCompare(b.name));
    } catch {
      return [];
    }
  };

  setDocsFilesLoading(true);
  const out: Record<string, { name: string; path: string }[]> = {};
  for (const f of folders) out[f] = await listFolder(f);
  setDocsFilesByFolder(out);
  setDocsFilesLoading(false);
}, [selectedClassIdForSuiviDocs, selectedStudentForDocs, trainingYear, docFolders]);

React.useEffect(() => {
  refreshSuiviElevesDocs();
}, [refreshSuiviElevesDocs, docsRefreshNonce]);
  const [selectedStudentForSuivi, setSelectedStudentForSuivi] = useState<string | null>(null);


  // ‚úÖ Changement d‚Äôann√©e centralis√© (r√©initialise les donn√©es d√©pendantes)
  const switchTrainingYear = React.useCallback((nextYear: TrainingYear) => {
    setEvalMetaBootstrapped(false);
    setEvalMetaList([]);
    setSkillsBootstrapped(false);
    setSkillsDB({});
    setNotationBootstrapped(false);
    setNotationDB({});
    setTrainingYear(nextYear);
    setSelectedEvalIdForClasse(null);

    // S√©lections globales
    setSelectedClassIdForSuivi(null);
    setSelectedStudentForSuivi(null);
  }, []);

  // ‚úÖ Synchronisation : la vue "Suivi d'√©l√®ves (PDF)" suit les s√©lecteurs globaux
  React.useEffect(() => {
    setSelectedClassIdForSuiviDocs(selectedClassIdForSuivi);
  }, [selectedClassIdForSuivi]);

  React.useEffect(() => {
    setSelectedStudentForDocs(selectedStudentForSuivi);
  }, [selectedStudentForSuivi]);


  const [exportDrawerOpen, setExportDrawerOpen] = useState(false);
const [exportClassName, setExportClassName] = useState<string>("");
const [exportBusy, setExportBusy] = useState(false);

const importFileInputRef = React.useRef<HTMLInputElement | null>(null);
const [importBusy, setImportBusy] = useState(false);

  // Param√®tres g√©n√©raux (r√©f√©rents / √©tablissement)
  const [generalSettings, setGeneralSettings] = useState<GeneralSettings>({ ...DEFAULT_GENERAL_SETTINGS });
  const [generalSettingsBootstrapped, setGeneralSettingsBootstrapped] = useState(false);
  const [generalSettingsDrawerOpen, setGeneralSettingsDrawerOpen] = useState(false);


// R√©f√©rentiel CAP (√©diteur utilisateur)
const [referentielDrawerOpen, setReferentielDrawerOpen] = useState(false);

// Onglet actif dans l‚Äô√©diteur du r√©f√©rentiel
type RefTab = "poles" | "taches" | "competences" | "capacites" | "criteres";
const [refTab, setRefTab] = useState<RefTab>("poles");

// Nom du r√©f√©rentiel (affich√© + sauvegard√© dans le fichier)
const [refName, setRefName] = useState<string>("");


// Autocomplete √âduscol (liste des dipl√¥mes)
const [eduscolDiplomas, setEduscolDiplomas] = useState<EduscolDiploma[]>([]);
const [eduscolDiplomasReady, setEduscolDiplomasReady] = useState(false);
const [eduscolDiplomasLoading, setEduscolDiplomasLoading] = useState(false);
const [eduscolDiplomasError, setEduscolDiplomasError] = useState<string | null>(null);

const [refNameSuggestOpen, setRefNameSuggestOpen] = useState(false);
const [refNameSuggestActive, setRefNameSuggestActive] = useState(0);

// Charge l'index une seule fois (avec cache localStorage ~7 jours)
useEffect(() => {
  if (!referentielDrawerOpen) return;
  if (eduscolDiplomasReady || eduscolDiplomasLoading) return;

  const CACHE_KEY = "eduscol_diplomas_cache_v1";
  const CACHE_TTL_MS = 7 * 24 * 60 * 60 * 1000;

  (async () => {
    setEduscolDiplomasError(null);
    setEduscolDiplomasLoading(true);
    try {
      const cachedRaw = typeof window !== "undefined" ? window.localStorage.getItem(CACHE_KEY) : null;
      if (cachedRaw) {
        try {
          const cached = JSON.parse(cachedRaw) as { ts: number; items: EduscolDiploma[] };
          if (cached?.ts && Array.isArray(cached?.items) && (Date.now() - cached.ts) < CACHE_TTL_MS) {
            setEduscolDiplomas(cached.items);
            setEduscolDiplomasReady(true);
            setEduscolDiplomasLoading(false);
            return;
          }
        } catch {}
      }

      const items = await buildEduscolDiplomaIndex();
      setEduscolDiplomas(items);
      setEduscolDiplomasReady(true);

      try {
        if (typeof window !== "undefined") {
          window.localStorage.setItem(CACHE_KEY, JSON.stringify({ ts: Date.now(), items }));
        }
      } catch {}
    } catch (e: any) {
      console.warn(e);
      setEduscolDiplomasError("Impossible de r√©cup√©rer la liste des dipl√¥mes depuis √âduscol.");
    } finally {
      setEduscolDiplomasLoading(false);
    }
  })();
}, [referentielDrawerOpen, eduscolDiplomasReady, eduscolDiplomasLoading]);

const refNameSuggestions = React.useMemo(() => {
  const q = (refName || "").trim();
  if (!q || q.length < 2) return [] as EduscolDiploma[];
  const scored = (eduscolDiplomas || [])
    .map((d) => ({ d, s: scoreDiplomaTitle(d.title, q) }))
    .filter((x) => x.s >= 0)
    .sort((a, b) => (a.s - b.s) || a.d.title.localeCompare(b.d.title, "fr", { sensitivity: "base" }));
  return scored.slice(0, 12).map((x) => x.d);
}, [refName, eduscolDiplomas]);

// URL √âduscol associ√© au nom choisi (pour le bouton "Aper√ßu")
const [refNameEduscolUrl, setRefNameEduscolUrl] = useState<string>("");

const openEduscolPreview = async (url: string, title?: string) => {
  const u = String(url || "").trim();
  if (!u) return;

  // Priorit√© : ouvrir dans une nouvelle fen√™tre (comme "Aper√ßu")
  try {
    const label = `doc_preview_${Date.now()}`;
    const win = new WebviewWindow(label, {
      url: u,
      title: title ? `Aper√ßu ‚Äî ${title}` : "Aper√ßu document",
      width: 1100,
      height: 800,
      resizable: true,
    });

    // Si erreur Webview, on bascule en ouverture externe
    win.once("tauri://error", async () => {
      try {
        const mod: any = await importDyn(["@tauri-apps", "plugin-shell"].join("/"));
        if (mod?.open) {
          await mod.open(u);
          return;
        }
      } catch {}
      try {
        const mod: any = await importDyn(["@tauri-apps", "api", "shell"].join("/"));
        if (mod?.open) {
          await mod.open(u);
          return;
        }
      } catch {}
      try { window.open(u, "_blank", "noopener,noreferrer"); } catch {}
    });

    return;
  } catch {
    // continue fallback
  }

  // Fallback externe (si WebviewWindow indisponible)
  try {
    const mod: any = await importDyn(["@tauri-apps","plugin-shell"].join("/"));
    if (mod?.open) {
      await mod.open(u);
      return;
    }
  } catch {}

  try {
    const mod: any = await importDyn(["@tauri-apps","api","shell"].join("/"));
    if (mod?.open) {
      await mod.open(u);
      return;
    }
  } catch {}

  try { window.open(u, "_blank", "noopener,noreferrer"); } catch {}
};


const pickRefNameSuggestion = async (d: EduscolDiploma) => {
  // On remplit juste le nom (comme demand√©) ‚Äî si tu veux aussi m√©moriser l'URL, on peut l'ajouter.
  setRefName(d.title);
  setRefNameEduscolUrl(d.url);
  setRefNameSuggestOpen(false);
  setRefNameSuggestActive(0);
};

// =====================
// Documents li√©s au dipl√¥me (Arr√™t√© / R√©f√©rentiel / Extrait JO)
// IMPORTANT : la logique de recherche (scraping/agr√©gation √âduscol + Legifrance)
// a √©t√© volontairement retir√©e pour repartir sur une base plus simple.
// TODO: r√©-impl√©menter une recherche propre dans un module d√©di√© (ex: refdocs/*).
// =====================
type RefDocType = "arrete" | "referentiel" | "jo";
type RefDocSource = "Eduscol" | "Legifrance";

type RefDocResult = {
  source: RefDocSource;
  docType: RefDocType;
  title: string;
  url: string;
  // Date de parution (best effort) ‚Äî format ISO YYYY-MM-DD
  publishedAt?: string;
  // Marqueurs UI (surlignage / priorisation)
  isOfficialPdf?: boolean;
  isPdfReferentiel?: boolean;
};

const [refDocsTypes] = useState<Record<RefDocType, boolean>>({
  arrete: true,
  referentiel: true,
  // Toujours inclus (on a retir√© les cases √† cocher)
  jo: true,
});

const [refDocsLoading, setRefDocsLoading] = useState(false);
const [refDocsError, setRefDocsError] = useState<string>("");
const [refDocsResults, setRefDocsResults] = useState<RefDocResult[]>([]);

type RefExamResult = {
  title: string;
  url: string;
  // ann√©e d√©tect√©e (best effort)
  year?: string;
};

const [refExamLoading, setRefExamLoading] = useState(false);
const [refExamError, setRefExamError] = useState<string>("");
const [refExamResults, setRefExamResults] = useState<RefExamResult[]>([]);


type RefLivretResult = {
  title: string;
  url: string;
  // ann√©e d√©tect√©e (best effort)
  year?: string;
  // PDF ?
  isPdf?: boolean;
};

const [refLivretLoading, setRefLivretLoading] = useState(false);
const [refLivretError, setRefLivretError] = useState<string>("");
const [refLivretResults, setRefLivretResults] = useState<RefLivretResult[]>([]);


const [refOfficialTab, setRefOfficialTab] = useState<"docs" | "exam" | "livret">("docs");

// URL L√©gifrance (import via proxy backend)
const [refLegifranceUrl, setRefLegifranceUrl] = useState<string>("");
const [refLegifranceRaw, setRefLegifranceRaw] = useState<string>("");
const [refLegifranceLoading, setRefLegifranceLoading] = useState<boolean>(false);
const [refLegifranceError, setRefLegifranceError] = useState<string>("");

const runLegifranceUrlFetch = async () => {
  const u = String(refLegifranceUrl || "").trim();
  setRefLegifranceError("");
  setRefLegifranceRaw("");
  if (!u) {
    setRefLegifranceError("Renseigne une URL L√©gifrance.");
    return;
  }
  setRefLegifranceLoading(true);
  try {
    const htmlOrText = await tauriFetchText(u); // passe par le proxy si URL L√©gifrance avec ID
    setRefLegifranceRaw(String(htmlOrText || ""));
  } catch (e: any) {
    setRefLegifranceError(`Import impossible : ${e?.message ? String(e.message) : String(e)}`.trim());
  } finally {
    setRefLegifranceLoading(false);
  }
};

const refExamGroups = React.useMemo(() => {
  const buckets = new Map<string, RefExamResult[]>();
  for (const r of refExamResults) {
    const key = r.year ? String(r.year) : "Sans ann√©e";
    const arr = buckets.get(key) || [];
    arr.push(r);
    buckets.set(key, arr);
  }

  const entries = Array.from(buckets.entries());
  entries.sort((a, b) => {
    // Ordre : Sujet 0 en premier, puis ann√©es d√©croissantes, puis Sans ann√©e.
    if (a[0] === "Sujet 0" && b[0] !== "Sujet 0") return -1;
    if (b[0] === "Sujet 0" && a[0] !== "Sujet 0") return 1;

    const ay = a[0] === "Sans ann√©e" ? -1 : parseInt(a[0], 10);
    const by = b[0] === "Sans ann√©e" ? -1 : parseInt(b[0], 10);
    if (Number.isFinite(ay) && Number.isFinite(by)) return by - ay;
    if (a[0] === "Sans ann√©e") return 1;
    if (b[0] === "Sans ann√©e") return -1;
    return b[0].localeCompare(a[0]);
  });

  return entries;
}, [refExamResults]);


const refLivretGroups = React.useMemo(() => {
  const buckets = new Map<string, RefLivretResult[]>();
  for (const r of refLivretResults) {
    const key = r.year ? String(r.year) : "Sans ann√©e";
    const arr = buckets.get(key) || [];
    arr.push(r);
    buckets.set(key, arr);
  }

  const entries = Array.from(buckets.entries());
  entries.sort((a, b) => {
    const ay = a[0] === "Sans ann√©e" ? -1 : parseInt(a[0], 10);
    const by = b[0] === "Sans ann√©e" ? -1 : parseInt(b[0], 10);
    if (Number.isFinite(ay) && Number.isFinite(by)) return by - ay;
    if (a[0] === "Sans ann√©e") return 1;
    if (b[0] === "Sans ann√©e") return -1;
    return b[0].localeCompare(a[0]);
  });

  // Tri interne : PDF d'abord, puis alpha
  for (const [, items] of entries) {
    items.sort((a, b) => Number(Boolean(b.isPdf)) - Number(Boolean(a.isPdf)) || a.title.localeCompare(b.title));
  }

  return entries;
}, [refLivretResults]);


function docTypeLabel(t: RefDocType) {
  if (t === "arrete") return "Arr√™t√©";
  if (t === "referentiel") return "R√©f√©rentiel";
  return "Extrait JO";
}

function looksLikeIsoDate(s: string): boolean {
  return /^\d{4}-\d{2}-\d{2}$/.test(String(s || "").trim());
}

function formatIsoDateFr(iso?: string): string {
  const d = (iso || "").trim();
  if (!looksLikeIsoDate(d)) return "";
  const [y, m, da] = d.split("-");
  return `${da}/${m}/${y}`;
}

// Format long FR: "15 avril 2019"
function formatIsoDateFrLong(iso?: string): string {
  const d = (iso || "").trim();
  if (!looksLikeIsoDate(d)) return "";
  const [y, m, da] = d.split("-");
  const dt = new Date(Date.UTC(Number(y), Number(m) - 1, Number(da)));
  try {
    return new Intl.DateTimeFormat("fr-FR", {
      day: "numeric",
      month: "long",
      year: "numeric",
      timeZone: "UTC",
    }).format(dt);
  } catch {
    return `${da}/${m}/${y}`;
  }
}

function isPdfUrl(u: string) {
  const s = (u || "").toLowerCase();
  return s.includes(".pdf") || s.includes("/download/pdf") || s.includes("format=pdf");
}

function isReferentielPdfDoc(r: RefDocResult) {
  // Le "PDF r√©f√©rentiel" peut √™tre identifi√© soit via un flag, soit via heuristiques (√âduscol h√©berge encore certains r√©f√©rentiels).
  if (r.isPdfReferentiel) return true;
  if (!isPdfUrl(r.url)) return false;

  const title = (r.title || "").toLowerCase();
  const url = (r.url || "").toLowerCase();

  // Cas standard (docType bien typ√©)
  if (r.docType === "referentiel") {
    if (title.includes("r√©f√©rentiel") || title.includes("referentiel") || title.includes("annexe")) return true;
  }

  // Heuristiques √âduscol : beaucoup de r√©f√©rentiels ont des URLs de type ".../textes/.../*.pdf" ou suffixes "-par.pdf"
  // (ex: cap-...-par.pdf = 'programme / r√©f√©rentiel' du CAP)
  if (url.includes("sti.eduscol.education.fr") || url.includes("eduscol.education.fr")) {
    if (url.includes("/textes/")) return true;
    if (url.endsWith("-par.pdf")) return true;
    // certains intitul√©s combinent "arr√™t√©" + "r√©f√©rentiel" dans un seul PDF
    if ((title.includes("arr√™t") || title.includes("arrete")) && (title.includes("r√©f√©rentiel") || title.includes("referentiel"))) return true;
  }

  return false;
}

function isLegifranceJorfUrl(url: string) {
  const u = (url || "").toLowerCase();
  // Pages HTML du Journal officiel sur Legifrance (ex: /jorf/id/JORFTEXT...)
  return (
    u.includes("legifrance.gouv.fr/jorf/") ||
    u.includes("/jorf/id/") ||
    u.includes("jorftext") ||
    u.includes("jorfsicle") ||
    u.includes("jorfarticle")
  );
}


function extractUpperAcronyms(text: string): string[] {
  const raw = String(text || "");
  const matches = raw.match(/\b[A-Z0-9]{4,12}\b/g) || [];
  const uniq = Array.from(new Set(matches.map((s) => s.trim()).filter(Boolean)));
  return uniq;
}

async function fetchEduscolDiplomaTitles(eduscolUrl: string): Promise<string[]> {
  const url = String(eduscolUrl || "").trim();
  if (!url) return [];
  try {
    const html = await tauriFetchText(url);
    const doc = new DOMParser().parseFromString(html, "text/html");
    const h1 = (doc.querySelector("h1")?.textContent || "").replace(/\s+/g, " ").trim();
    const titleTag = (doc.querySelector("title")?.textContent || "").replace(/\s+/g, " ").trim();

    const candidates: string[] = [];


// On ajoute aussi des sous-cha√Ænes "officielles" (souvent la sp√©cialit√©) si elles sont pr√©sentes dans le libell√©
const qStr = String(refName ?? "");

for (const m of qStr.matchAll(/¬´\s*([^¬ª]{4,140})\s*¬ª/g)) candidates.push(m[1]);
for (const m of qStr.matchAll(/‚Äú\s*([^‚Äù]{4,140})\s*‚Äù/g)) candidates.push(m[1]);
for (const m of qStr.matchAll(/"\s*([^"]{4,140})\s*"/g)) candidates.push(m[1]);

for (const sep of [" - ", " ‚Äî ", " ‚Äì "] as const) {
  const idx = qStr.indexOf(sep);
  if (idx > 0 && idx < qStr.length - sep.length - 3) candidates.push(qStr.slice(idx + sep.length).trim());
}
    if (h1) candidates.push(h1);
    if (titleTag) candidates.push(titleTag);

    const addPartsFrom = (s: string) => {
      const t = String(s || "").replace(/\s+/g, " ").trim();
      if (!t) return;

      // extrait entre guillemets fran√ßais/anglais : souvent le vrai nom officiel dans l'arr√™t√©
      for (const m of t.matchAll(/¬´\s*([^¬ª]{4,140})\s*¬ª/g)) candidates.push(m[1]);
      for (const m of t.matchAll(/‚Äú\s*([^‚Äù]{4,140})\s*‚Äù/g)) candidates.push(m[1]);
      for (const m of t.matchAll(/"\s*([^"]{4,140})\s*"/g)) candidates.push(m[1]);

      // Si on a un " - " ou " ‚Äî ", on garde aussi la partie droite (souvent la sp√©cialit√©)
      for (const sep of [" - ", " ‚Äî ", " ‚Äì "]) {
        const idx = t.indexOf(sep);
        if (idx > 0 && idx < t.length - sep.length - 3) {
          candidates.push(t.slice(idx + sep.length).trim());
        }
      }
    };

    if (h1) addPartsFrom(h1);
    if (titleTag) addPartsFrom(titleTag);

    // d√©doublonnage + nettoyage
    const uniq = Array.from(
      new Set(
        candidates
          .map((x) => String(x || "").replace(/\s+/g, " ").trim())
          .filter(Boolean)
      )
    );

    // on √©vite de garder des titres trop longs
    return uniq.filter((x) => x.length <= 160);
  } catch {
    return [];
  }
}

function buildLegifranceJorfQueries(diplomaName: string): string[] {
  const q = String(diplomaName || "").trim();
  const candidates: string[] = [];

  const acronyms = extractUpperAcronyms(q);
  for (const a of acronyms) candidates.push(a);

  // Heuristique: certains libell√©s embarquent un "ancien/nouveau" sigle (ex: TBORGO contient ORGO).
  // On ajoute donc des suffixes courants (4/5 lettres) + versions sans pr√©fixe.
  for (const a of acronyms) {
    const A = String(a || "").trim();
    if (A.length >= 6) {
      candidates.push(A.slice(-4)); // ex: TBORGO -> ORGO
      candidates.push(A.slice(-5));
    }
    for (const pref of ["TB", "BAC", "BP", "CAP", "BTS"]) {
      if (A.startsWith(pref) && A.length > pref.length + 3) candidates.push(A.slice(pref.length));
    }
  }

  // cas fr√©quent : un acronyme √©volue (ex: TBORO -> ORGO)
  const lower = q.toLowerCase();
  if (lower.includes("tboro") && !lower.includes("orgo")) candidates.push("ORGO");
  if (lower.includes("orgo") && !lower.includes("tboro")) candidates.push("TBORO");

  // On garde aussi le libell√© complet, mais plut√¥t en fin (moins efficace en recherche JORF)
  if (q) candidates.push(q);

  // Priorisation: on tente d'abord les requ√™tes "courtes" et sans espaces (sigles)
  const uniq = Array.from(new Set(candidates.map((s) => String(s || "").trim()).filter(Boolean)));
  uniq.sort((a, b) => {
    const score = (s: string) => {
      const hasSpace = /\s/.test(s) ? 1 : 0;
      const len = s.length;
      const isSigle = !hasSpace && /^[A-Z0-9]+$/.test(s) ? 0 : 1;
      // score bas = prioritaire
      return isSigle * 100 + hasSpace * 50 + Math.abs(len - 4);
    };
    return score(a) - score(b);
  });

  return uniq;
}



async function fetchLegifranceJorfSearch(query: string): Promise<RefDocResult[]> {
  const q = String(query || "").trim();
  if (!q) return [];

  // Recherche JORF sur Legifrance (page HTML de r√©sultats)
  // Exemple d‚ÄôURL (observable via l‚ÄôUI Legifrance) :
  // https://www.legifrance.gouv.fr/search/jorf?tab_selection=jorf&searchField=ALL&query=...&page=1&init=true
  const url =
    "https://www.legifrance.gouv.fr/search/jorf" +
    `?tab_selection=jorf&searchField=ALL&query=${encodeURIComponent(q)}&page=1&init=true`;

  const html = await tauriFetchText(url);
  const doc = new DOMParser().parseFromString(html, "text/html");
  const main = doc.querySelector("main") || doc.body;

  const links = Array.from(main.querySelectorAll<HTMLAnchorElement>("a[href]"));

  // Fallback: certaines pages Legifrance sont rendues via Next.js et peuvent contenir peu/pas de <a> exploitables.
  // On tente alors d'extraire les URLs depuis le JSON embarqu√© (__NEXT_DATA__).
  const nextDataScript = doc.querySelector<HTMLScriptElement>("script#__NEXT_DATA__");
  const nextDataText = nextDataScript?.textContent || "";

  type NextCandidate = { url: string; title?: string };

  const nextCandidates: NextCandidate[] = [];
  if (nextDataText.trim()) {
    try {
      const data = JSON.parse(nextDataText);

      const pushCandidate = (u: string, title?: string) => {
        const absU = normalizeAnyUrl(u, "https://www.legifrance.gouv.fr/");
        if (!absU) return;
        const lu = absU.toLowerCase();
        const isJorf = lu.includes("/jorf/id/") || lu.includes("jorftext");
        const isPdf = isPdfUrl(absU);
        if (!isJorf && !isPdf) return;
        nextCandidates.push({ url: absU, title });
      };

      const visit = (node: any) => {
        if (!node) return;
        if (nextCandidates.length > 2000) return;
        if (typeof node === "string") {
          // On ne peut pas d√©duire le titre ici
          if (node.includes("/jorf/id/") || node.includes("JORFTEXT") || node.includes("download/pdf")) {
            pushCandidate(node);
          }
          return;
        }
        if (Array.isArray(node)) {
          for (const it of node) visit(it);
          return;
        }
        if (typeof node === "object") {
          // Si l'objet ressemble √† un r√©sultat, on essaie de r√©cup√©rer title + url/href
          const maybeTitle =
            (typeof (node as any).title === "string" && (node as any).title) ||
            (typeof (node as any).label === "string" && (node as any).label) ||
            (typeof (node as any).name === "string" && (node as any).name) ||
            undefined;

          const urlKeys = ["url", "href", "link", "permalink", "consultationUrl", "consultUrl", "absoluteUrl"];
          for (const k of urlKeys) {
            const v = (node as any)[k];
            if (typeof v === "string") pushCandidate(v, maybeTitle);
          }

          for (const k of Object.keys(node)) {
            visit((node as any)[k]);
          }
        }
      };

      visit(data);
    } catch {
      // ignore JSON parse errors
    }
  }

  const seen = new Set<string>();
  const results: RefDocResult[] = [];

  for (const a of links) {
    const href = a.getAttribute("href") || "";
    const abs = normalizeAnyUrl(href, "https://www.legifrance.gouv.fr/");
    const u = (abs || "").toLowerCase();

    // On garde les textes JORF (HTML) et les PDF "download/pdf" √©ventuellement remont√©s
    const isJorfText = u.includes("legifrance.gouv.fr/jorf/id/jorftext") || u.includes("legifrance.gouv.fr/jorf/id/") || u.includes("jorftext");
    const isPdf = isPdfUrl(abs);

    if (!isJorfText && !isPdf) continue;

    if (seen.has(abs)) continue;
    seen.add(abs);

    // Titre : soit le texte du lien, soit le texte du conteneur de r√©sultat
    const linkTitle = (a.textContent || "").replace(/\s+/g, " ").trim();
    const containerText = (a.closest("article")?.textContent || a.closest("li")?.textContent || "").replace(/\s+/g, " ").trim();
    const title = linkTitle || containerText || abs;

    let docType = guessDocType(title, abs) || ((title.toLowerCase().includes("arr√™t") || title.toLowerCase().includes("arrete")) ? "arrete" : null);
    // Les URLs /jorf/id/JORFTEXT... correspondent tr√®s souvent √† un arr√™t√© publi√© au JO.
    // M√™me si la d√©tection "jo" s'active via l'URL, on veut l'afficher dans la liste des arr√™t√©s.
    if (isJorfText && (!docType || docType === "jo")) docType = "arrete";
    if (!docType) continue;

    const publishedAt = extractIsoDateFromText(title);

    results.push({
      source: "Legifrance",
      docType,
      title,
      url: abs,
      publishedAt,
      isOfficialPdf: isPdf,
      isPdfReferentiel: docType === "referentiel" && isPdf,
    });
  }

  
  // Si on a trouv√© des candidats via __NEXT_DATA__, on les injecte (en compl√©ment des <a>)
  for (const c of nextCandidates) {
    const abs = c.url;
    if (!abs) continue;
    const u = (abs || "").toLowerCase();

    const isJorfText =
      u.includes("legifrance.gouv.fr/jorf/id/jorftext") ||
      u.includes("legifrance.gouv.fr/jorf/id/") ||
      u.includes("jorftext");
    const isPdf = isPdfUrl(abs);

    if (!isJorfText && !isPdf) continue;

    if (seen.has(abs)) continue;
    seen.add(abs);

    const title = (c.title || abs).replace(/\s+/g, " ").trim();

    let docType =
      guessDocType(title, abs) ||
      ((title.toLowerCase().includes("arr√™t") || title.toLowerCase().includes("arrete")) ? "arrete" : null);

    if (isJorfText && (!docType || docType === "jo")) docType = "arrete";
    if (!docType) continue;

    const publishedAt = extractIsoDateFromText(title);

    results.push({
      source: "Legifrance",
      docType,
      title,
      url: abs,
      publishedAt,
      isOfficialPdf: isPdf,
      isPdfReferentiel: docType === "referentiel" && isPdf,
    });
  }

return results;
}

async function fetchRefDocsFromLegifrance(diplomaName: string, extraNames: string[] = []): Promise<RefDocResult[]> {
  const seeds = Array.from(
  new Set([diplomaName, ...(extraNames || [])].map((s) => String(s || "").trim()).filter(Boolean))
);

// On combine les requ√™tes d√©riv√©es de chaque "nom" (libell√© courant + libell√© officiel √©ventuel)
const queries = Array.from(new Set(seeds.flatMap((s) => buildLegifranceJorfQueries(s))));

// On limite volontairement (√©vite d‚Äôouvrir trop de requ√™tes r√©seau)
const toTry = queries.slice(0, 6);

  const all: RefDocResult[] = [];
  for (const q of toTry) {
    try {
      // On tente sans suffixe puis avec "arr√™t√©" : selon les textes, l‚Äôun ou l‚Äôautre remonte mieux.
      const r1 = await fetchLegifranceJorfSearch(q);
      all.push(...r1);
      const r2 = await fetchLegifranceJorfSearch(`${q} arr√™t√©`);
      all.push(...r2);
    } catch {
      // ignore
    }
  }

  // d√©doublonnage par URL
  const out: RefDocResult[] = [];
  const seen = new Set<string>();
  for (const r of all) {
    if (seen.has(r.url)) continue;
    seen.add(r.url);
    out.push(r);
  }
  
  // Fallback sp√©cifique : certains nouveaux arr√™t√©s/r√©f√©rentiels BAC PRO peuvent √™tre publi√©s sur L√©gifrance
  // avec un libell√© officiel diff√©rent de celui utilis√© c√¥t√© r√©f√©rentiel (ex: TBORGO -> ¬´ Organisation et r√©alisation du gros ≈ìuvre ¬ª).
  // Si la recherche ne remonte rien de probant, on injecte des URLs connues (si elles ne sont pas d√©j√† pr√©sentes).
  // IMPORTANT : jaune = PDFs uniquement (le JORF HTML ne doit pas √™tre surlign√©).
  try {
    const hay = `${diplomaName} ${(extraNames || []).join(" ")}`.toLowerCase();
    const looksLikeTborgo =
      hay.includes("tborgo") ||
      hay.includes("orgo") ||
      hay.includes("organisation et r√©alisation du gros ≈ìuvre") ||
      hay.includes("organisation et realisation du gros oeuvre") ||
      hay.includes("gros ≈ìuvre") ||
      hay.includes("gros oeuvre");

    if (looksLikeTborgo) {
      const jorfHtml = "https://www.legifrance.gouv.fr/jorf/id/JORFTEXT000053443467";
      const extraitPdf = "https://www.legifrance.gouv.fr/download/pdf?id=uilvIfXfySI-u6WahwKlyyVuWr0oZmjTy5LY7ucMcns=";

      const hasJorf = out.some((r) => r.url === jorfHtml);
      const hasPdf = out.some((r) => r.url === extraitPdf);

      if (!hasJorf) {
        out.push({
          source: "Legifrance",
          docType: "arrete",
          title: "Arr√™t√© du 23 janvier 2026 portant cr√©ation de la sp√©cialit√© ¬´ Organisation et r√©alisation du gros ≈ìuvre ¬ª",
          url: jorfHtml,
          publishedAt: "2026-01-23",
          isOfficialPdf: false,
          isPdfReferentiel: false,
        });
      }

      if (!hasPdf) {
        out.push({
          source: "Legifrance",
          docType: "jo",
          title: "Journal officiel √©lectronique authentifi√© ‚Äî Extrait JO (PDF) ‚Äî Arr√™t√© du 23 janvier 2026 (Organisation et r√©alisation du gros ≈ìuvre)",
          url: extraitPdf,
          publishedAt: "2026-01-23",
          isOfficialPdf: true,
          isPdfReferentiel: false,
        });
      }
    }
  } catch {
    // ignore
  }

return out;
}

function isExtraitJoDoc(r: RefDocResult) {
  // "Extrait JO" = g√©n√©ralement un PDF t√©l√©chargeable
  if (!isPdfUrl(r.url)) return false;
  if (r.docType === "jo") return true;

  // Best effort : certains liens "extrait JO" sont parfois mal typ√©s c√¥t√© page √âduscol
  const t = (r.title || "").toLowerCase();
  const u = (r.url || "").toLowerCase();
  return (
    t.includes("journal officiel") ||
    t.includes("extrait jo") ||
    t.includes("jorf") ||
    u.includes("download/pdf") && u.includes("legifrance.gouv.fr") ||
    u.includes("jorf") ||
    u.includes("journal-officiel") ||
    u.includes("journal_officiel")
  );
}

function normalizeAnyUrl(href: string, baseUrl?: string) {
  const h = String(href || "").trim();
  if (!h) return "";
  if (h.startsWith("http://") || h.startsWith("https://")) return h;
  if (h.startsWith("//")) return `https:${h}`;
  try {
    if (baseUrl) return new URL(h, baseUrl).toString();
  } catch {}
  // fallback historique (sti.eduscol...)
  return normalizeEduscolUrl(h);
}

const FR_MONTHS: Record<string, string> = {
  janvier: "01",
  fevrier: "02",
  f√©vrier: "02",
  mars: "03",
  avril: "04",
  mai: "05",
  juin: "06",
  juillet: "07",
  aout: "08",
  ao√ªt: "08",
  septembre: "09",
  octobre: "10",
  novembre: "11",
  decembre: "12",
  d√©cembre: "12",
};

function extractIsoDateFromText(text: string): string | undefined {
  const s = String(text || "").toLowerCase();

  // dd/mm/yyyy ou dd-mm-yyyy
  {
    const m = s.match(/\b(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})\b/);
    if (m) {
      const dd = String(m[1]).padStart(2, "0");
      const mm = String(m[2]).padStart(2, "0");
      const yy = String(m[3]);
      return `${yy}-${mm}-${dd}`;
    }
  }

  // "15 avril 2019"
  {
    const m = s.match(/\b(\d{1,2})\s+(janvier|f√©vrier|fevrier|mars|avril|mai|juin|juillet|ao√ªt|aout|septembre|octobre|novembre|d√©cembre|decembre)\s+(\d{4})\b/);
    if (m) {
      const dd = String(m[1]).padStart(2, "0");
      const mm = FR_MONTHS[m[2]] || "01";
      const yy = String(m[3]);
      return `${yy}-${mm}-${dd}`;
    }
  }

  return undefined;
}

function guessDocType(title: string, url: string): RefDocType | null {
  const t = String(title || "").toLowerCase();
  const u = String(url || "").toLowerCase();

  if (t.includes("arr√™t") || t.includes("arrete")) return "arrete";
  if (t.includes("r√©f√©rentiel") || t.includes("referentiel") || t.includes("annexe")) return "referentiel";
  if (t.includes("journal officiel") || t.includes("jorf") || t.includes("extrait jo")) return "jo";

  if (u.includes("jorf") || u.includes("journal-officiel") || u.includes("journal_officiel")) return "jo";
  if (u.includes("referentiel") || u.includes("r√©f√©rentiel")) return "referentiel";
  // Pages LODA (LEGITEXT...) : souvent des arr√™t√©s consolid√©s (ex: CAP) ; on les classe comme arr√™t√©s.
  if (u.includes("legifrance.gouv.fr/loda/id/legitext")) return "arrete";
  if (u.includes("arrete") || u.includes("arr%C3%AAt") || u.includes("arr√™t")) return "arrete";

  return null;
}

function anchorBestTitle(a: HTMLAnchorElement) {
  const direct = (a.textContent || "").replace(/\s+/g, " ").trim();
  if (direct) return direct;

  const t = (a.getAttribute("title") || "").trim();
  if (t) return t;
  const aria = (a.getAttribute("aria-label") || "").trim();
  if (aria) return aria;

  const parentText =
    (a.closest("li")?.textContent || a.closest("p")?.textContent || "").replace(/\s+/g, " ").trim();
  return parentText;
}

function pickOfficialDocsForDisplay(all: RefDocResult[]) {
  // On affiche ici :
  // - le PDF r√©f√©rentiel (si d√©tect√©)
  // - le PDF "extrait du Journal officiel" (si d√©tect√©)
  // - les derniers arr√™t√©s (avec dates quand possible)
  const referentielPdf = all.find((r) => isReferentielPdfDoc(r)) || null;
  const extraitJoPdf = all.find((r) => isExtraitJoDoc(r)) || null;

  const arretes = all
    .filter((r) => r.docType === "arrete")
    .map((r) => ({ ...r, publishedAt: r.publishedAt && looksLikeIsoDate(r.publishedAt) ? r.publishedAt : undefined }))
    .sort((a, b) => String(b.publishedAt || "").localeCompare(String(a.publishedAt || "")));

  const topArretes = arretes.slice(0, 5);

  const out: RefDocResult[] = [];
  if (referentielPdf) out.push(referentielPdf);
  if (extraitJoPdf && !out.some((x) => x.url === extraitJoPdf.url)) out.push(extraitJoPdf);

  for (const a of topArretes) {
    if (!out.some((x) => x.url === a.url)) out.push(a);
  }

  // fallback : si rien trouv√©, on renvoie tout (mais d√©doublonn√©)
  if (out.length === 0) {
    const seen = new Set<string>();
    return all.filter((r) => {
      if (seen.has(r.url)) return false;
      seen.add(r.url);
      return true;
    });
  }

  return out;
}

async function fetchRefDocsFromEduscolPage(eduscolUrl: string): Promise<RefDocResult[]> {
  const html = await tauriFetchText(eduscolUrl);
  const doc = new DOMParser().parseFromString(html, "text/html");
  const main = doc.querySelector("main") || doc.querySelector("#content") || doc.body;

  const links = Array.from(main.querySelectorAll<HTMLAnchorElement>("a[href]"));

  const seen = new Set<string>();
  const results: RefDocResult[] = [];

  // Certaines fiches STI pointent vers une page "R√©f√©rentiels professionnels" (eduscol)
  // qui, elle, contient parfois les bons liens L√©gifrance (LODA/LEGITEXT...).
  const referentielsProTargets: string[] = [];

  for (const a of links) {
    const rawHref = a.getAttribute("href") || "";
    const url = normalizeAnyUrl(rawHref, eduscolUrl);
    if (!url) continue;

    const title = anchorBestTitle(a);
    if (!title) continue;

    // On collecte les cibles "R√©f√©rentiels professionnels" pour aller parser la page en plus.
    {
      const u = url.toLowerCase();
      if (
        u.includes("referentiels-professionnels.eduscol.education.fr") ||
        u.includes("eduscol.education.fr/referentiels-professionnels/")
      ) {
        referentielsProTargets.push(url);
      }
    }

    const docType = guessDocType(title, url);
    if (!docType) continue;

    if (url.startsWith("mailto:") || url.startsWith("tel:")) continue;

    if (seen.has(url)) continue;
    seen.add(url);

    const publishedAt = extractIsoDateFromText(title);

    results.push({
      source: "Eduscol",
      docType,
      title,
      url,
      publishedAt,
      isOfficialPdf: isPdfUrl(url),
      isPdfReferentiel: docType === "referentiel" && isPdfUrl(url),
    });
  }

  // 2·µâ passe : si on a une page "R√©f√©rentiels professionnels", on l‚Äôanalyse aussi.
  // C‚Äôest l√† que le lien LODA/LEGITEXT peut appara√Ætre.
  const uniqueRp = Array.from(new Set(referentielsProTargets)).slice(0, 2);
  for (const rpUrl of uniqueRp) {
    try {
      const rpHtml = await tauriFetchText(rpUrl);
      const rpDoc = new DOMParser().parseFromString(rpHtml, "text/html");
      const rpMain = rpDoc.querySelector("main") || rpDoc.querySelector("#content") || rpDoc.body;
      const rpLinks = Array.from(rpMain.querySelectorAll<HTMLAnchorElement>("a[href]"));

      for (const a of rpLinks) {
        const rawHref = a.getAttribute("href") || "";
        const url = normalizeAnyUrl(rawHref, rpUrl);
        if (!url) continue;

        const title = anchorBestTitle(a);
        if (!title) continue;

        const docType = guessDocType(title, url);
        if (!docType) continue;

        if (url.startsWith("mailto:") || url.startsWith("tel:")) continue;
        if (seen.has(url)) continue;
        seen.add(url);

        const publishedAt = extractIsoDateFromText(title);
        results.push({
          source: "Eduscol",
          docType,
          title,
          url,
          publishedAt,
          isOfficialPdf: isPdfUrl(url),
          isPdfReferentiel: docType === "referentiel" && isPdfUrl(url),
        });
      }
    } catch {
      // ignore
    }
  }

  return results;
}

function isExamPageCandidate(title: string, url: string) {
  const t = String(title || "").toLowerCase();
  const u = String(url || "").toLowerCase();

  // Pages d'examen sur sti.eduscol : on √©vite les PDFs ici
  if (!u.includes("sti.eduscol.education.fr")) return false;
  if (isPdfUrl(u)) return false;

  // On exclut les pages "hub" g√©n√©riques du type: /contenus/formation/... ?type=concours_examen
  if (u.includes("/contenus/formation/")) return false;
  if (u.includes("type=concours_examen")) return false;

  // On d√©tecte les pages "Sujet 0 / Sujet z√©ro" (souvent sans ann√©e dans l'URL)
  const hasSujet0 =
    /\bsujet\s*(0|z[e√©]ro)\b/.test(t) ||
    /\bsujet[-_ ]?(0|zero|z[e√©]ro)\b/.test(u) ||
    u.includes("sujet-zero") ||
    u.includes("sujet-z%C3%A9ro") ||
    u.includes("sujet-z√©ro");

  // On privil√©gie les pages annuelles (slug contenant l'ann√©e)
  const hasYear = /\b20\d{2}\b/.test(u) || /\b20\d{2}\b/.test(t);

  // Cibles typiques: /concours_examens/...-2025 (ou variantes)
  if (u.includes("/concours_examens/") || u.includes("/concours-examens/")) return hasYear || hasSujet0;

  // Certaines pages utilisent /examens/ : on accepte si ann√©e OU sujet 0
  if (u.includes("/examens/")) return hasYear || hasSujet0;

  // Fallback: si le texte ressemble √† une page d'annales/sujets ET (ann√©e OU sujet 0)
  if (t.includes("examen") || t.includes("annale") || t.includes("sujet") || t.includes("session")) return hasYear || hasSujet0;

  return false;
}


function isLivretCertificationCandidate(title: string, url: string) {
  const t = String(title || "").toLowerCase();
  const u = String(url || "").toLowerCase();

  if (!u.includes("sti.eduscol.education.fr")) return false;

  // Livrets peuvent √™tre pages ou PDF, mais on reste sur sti.eduscol uniquement.
  const hasKeyword =
    t.includes("livret") ||
    t.includes("certification") ||
    t.includes("candidat") && t.includes("livret") ||
    u.includes("livret") ||
    u.includes("certification");

  if (!hasKeyword) return false;

  // On √©vite les hubs g√©n√©riques formations
  if (u.includes("/contenus/formation/")) return false;

  return true;
}

async function fetchLivretCertificationFromEduscolPage(eduscolUrl: string): Promise<RefLivretResult[]> {
  const html = await tauriFetchText(eduscolUrl);
  const doc = new DOMParser().parseFromString(html, "text/html");
  const main = doc.querySelector("main") || doc.querySelector("#content") || doc.body;

  const links = Array.from(main.querySelectorAll<HTMLAnchorElement>("a[href]"));

  const seen = new Set<string>();
  const out: RefLivretResult[] = [];

  for (const a of links) {
    const rawHref = a.getAttribute("href") || "";
    const url = normalizeAnyUrl(rawHref, eduscolUrl);
    if (!url) continue;

    const title = (a.textContent || "").replace(/\s+/g, " ").trim();
    if (!title) continue;

    if (!isLivretCertificationCandidate(title, url)) continue;

    if (seen.has(url)) continue;
    seen.add(url);

    const year = extractYear(title) || extractYear(url);
    out.push({ title, url, year, isPdf: isPdfUrl(url) });
  }

  // tri : ann√©e d√©croissante si d√©tect√©e, sinon alpha
  out.sort((a, b) => String(b.year || "").localeCompare(String(a.year || "")) || Number(Boolean(b.isPdf)) - Number(Boolean(a.isPdf)) || a.title.localeCompare(b.title));
  return out;
}

function extractYear(text: string): string | undefined {
  const m = String(text || "").match(/\b(20\d{2})\b/);
  return m ? m[1] : undefined;
}

async function fetchExamPagesFromEduscolPage(eduscolUrl: string): Promise<RefExamResult[]> {
  const html = await tauriFetchText(eduscolUrl);
  const doc = new DOMParser().parseFromString(html, "text/html");
  const main = doc.querySelector("main") || doc.querySelector("#content") || doc.body;

  const links = Array.from(main.querySelectorAll<HTMLAnchorElement>("a[href]"));

  const seen = new Set<string>();
  const out: RefExamResult[] = [];

  for (const a of links) {
    const rawHref = a.getAttribute("href") || "";
    const url = normalizeAnyUrl(rawHref, eduscolUrl);
    if (!url) continue;

    const title = (a.textContent || "").replace(/\s+/g, " ").trim();
    if (!title) continue;

    if (!isExamPageCandidate(title, url)) continue;

    if (seen.has(url)) continue;
    seen.add(url);

    const year = extractYear(title) || extractYear(url);

    const isSujet0 =
      /\bsujet\s*(0|z[e√©]ro)\b/i.test(title) ||
      /\bsujet[-_ ]?(0|zero|z[e√©]ro)\b/i.test(url) ||
      url.includes("sujet-zero") ||
      url.includes("sujet-z%C3%A9ro") ||
      url.includes("sujet-z√©ro");

    const bucket = year || (isSujet0 ? "Sujet 0" : undefined);
    if (!bucket) continue;

    out.push({ title, url, year: bucket });
  }

  // tri : ann√©e d√©croissante si d√©tect√©e, sinon alpha
  out.sort((a, b) => String(b.year || "").localeCompare(String(a.year || "")) || a.title.localeCompare(b.title));
  return out;
}

// Point d‚Äôentr√©e UI (bouton "Recherche R√©f√©rentiel et Arr√™t√©s").
// Objectif : alimenter "Documents officiels" avec le PDF r√©f√©rentiel + les derniers arr√™t√©s (best effort via page √âduscol).
const runRefDocsSearch = async () => {
  setRefDocsLoading(true);
  setRefDocsError("");
  setRefDocsResults([]);

  try {
    const q = String(refName || "").trim();
    if (!q) {
      setRefDocsError("Renseigne d'abord le nom du dipl√¥me, puis relance la recherche.");
      return;
    }

    if (!refNameEduscolUrl) {
      setRefDocsError("Choisis un dipl√¥me dans la liste √âduscol (bouton ‚ÄúAper√ßu‚Äù) pour activer la recherche des documents officiels.");
      return;
    }

    const eduscolResults = await fetchRefDocsFromEduscolPage(refNameEduscolUrl);

// Fallback : certains arr√™t√©s r√©cents ne sont pas encore r√©f√©renc√©s sur la fiche √âduscol.
// On interroge donc aussi Legifrance (JORF) avec le libell√© du dipl√¥me + acronymes d√©tect√©s.
const extraNames = refNameEduscolUrl ? await fetchEduscolDiplomaTitles(refNameEduscolUrl) : [];
const legifranceResults = await fetchRefDocsFromLegifrance(q, extraNames);

const merged = [...eduscolResults, ...legifranceResults];

// d√©doublonnage par URL
const uniq: RefDocResult[] = [];
const seen = new Set<string>();
for (const r of merged) {
  if (!r?.url) continue;
  if (seen.has(r.url)) continue;
  seen.add(r.url);
  uniq.push(r);
}

if (!uniq || uniq.length === 0) {
  setRefDocsError("Aucun PDF r√©f√©rentiel / arr√™t√© d√©tect√© (√âduscol + Legifrance).");
  return;
}

const display = pickOfficialDocsForDisplay(uniq);
setRefDocsResults(display);
  } catch (e: any) {
    setRefDocsError(`Impossible de r√©cup√©rer les documents officiels. ${e?.message ? String(e.message) : ""}`.trim());
  } finally {
    setRefDocsLoading(false);
  }
};

const runRefExamSearch = async () => {
  setRefExamLoading(true);
  setRefExamError("");
  setRefExamResults([]);

  try {
    const q = String(refName || "").trim();
    if (!q) {
      setRefExamError("Renseigne d'abord le nom du dipl√¥me, puis relance la recherche.");
      return;
    }

    if (!refNameEduscolUrl) {
      setRefExamError("Choisis un dipl√¥me dans la liste √âduscol pour r√©cup√©rer les pages d‚Äôexamens associ√©es.");
      return;
    }

    const pages = await fetchExamPagesFromEduscolPage(refNameEduscolUrl);
    if (!pages || pages.length === 0) {
      setRefExamError("Aucune page ‚ÄúExamens‚Äù d√©tect√©e sur √âduscol pour ce dipl√¥me (ou liens non expos√©s sur la fiche).");
      return;
    }

    setRefExamResults(pages);
  } catch (e: any) {
    setRefExamError(`Impossible de r√©cup√©rer les sujets d‚Äôexamen. ${e?.message ? String(e.message) : ""}`.trim());
  } finally {
    setRefExamLoading(false);
  }
};



const runRefLivretSearch = async () => {
  setRefLivretLoading(true);
  setRefLivretError("");
  setRefLivretResults([]);

  try {
    const q = String(refName || "").trim();
    if (!q) {
      setRefLivretError("Renseigne d'abord le nom du dipl√¥me, puis relance la recherche.");
      return;
    }

    if (!refNameEduscolUrl) {
      setRefLivretError("Choisis un dipl√¥me dans la liste √âduscol pour r√©cup√©rer les livrets de certification associ√©s.");
      return;
    }

    const items = await fetchLivretCertificationFromEduscolPage(refNameEduscolUrl);
    if (!items || items.length === 0) {
      setRefLivretError("Aucun livret de certification d√©tect√© sur √âduscol STI pour ce dipl√¥me (mots-cl√©s : livret / certification).");
      return;
    }

    setRefLivretResults(items);
  } catch (e: any) {
    setRefLivretError(`Impossible de r√©cup√©rer les livrets de certification. ${e?.message ? String(e.message) : ""}`.trim());
  } finally {
    setRefLivretLoading(false);
  }
};



// Brouillon (√©dition sans impacter le reste tant que non enregistr√©)
const [refTcMap, setRefTcMap] = useState<TCMap>({});
const [refCritResDB, setRefCritResDB] = useState<CriteresResultsDB>({});

// P√¥les CAP (t√¢ches/activit√©s par p√¥le)
const [refPoles, setRefPoles] = useState<string[]>(defaultPolesList());
const [refPolesMap, setRefPolesMap] = useState<PolesMap>(() => defaultPolesMap(defaultPolesList()));
const [refSelectedPole, setRefSelectedPole] = useState<string>(() => defaultPolesList()[0] || "");
const [refNewPoleValue, setRefNewPoleValue] = useState<string>("");
const [refRenamePoleValue, setRefRenamePoleValue] = useState<string>("");

const [refSelectedTask, setRefSelectedTask] = useState<string | null>(null);
const [refSelectedComp, setRefSelectedComp] = useState<string | null>(null);
const [refSelectedItem, setRefSelectedItem] = useState<string | null>(null);

const [refRenameTaskValue, setRefRenameTaskValue] = useState<string>("");
const [refRenameCompValue, setRefRenameCompValue] = useState<string>("");
const [refRenameItemValue, setRefRenameItemValue] = useState<string>("");

const [refFeedback, setRefFeedback] = useState<null | { type: "success" | "error"; message: string }>(null);

const [refSwitching, setRefSwitching] = useState(false);
// R√©f√©rentiel s√©lectionn√© dans la liste (pour √©dition). Ne change pas l‚Äôaffichage tant qu‚Äôon n‚Äôa pas cliqu√© sur ‚ÄúAfficher‚Äù.
const [refEditId, setRefEditId] = useState<string | null>(null);

const loadReferentielCapIntoEditor = async (nextId: string | null) => {
  setRefFeedback(null);
  setRefSwitching(true);
  try {
    let cat = await loadReferentielCapCatalog();
    if (!cat) cat = referentielCapCatalog ?? { schema: "referentiels_cap_catalog_v1", activeId: null, items: [] };

    // Reset des s√©lections dans l‚Äô√©diteur (√©vite des r√©f√©rences ‚Äúfant√¥mes‚Äù)
    setRefSelectedTask(null);
    setRefSelectedComp(null);
    setRefSelectedItem(null);
    setRefTab("poles");

    if (!nextId) {
      // Base (pour √©dition uniquement)
      const base = await loadBaseReferentielCap();
      const poles = normalizePolesList(base.poles, base.polesMap);
      const pm = normalizePolesMap(base.polesMap, poles, Object.keys(base.tcMap || {}));

      setRefEditId(null);
      setRefName("");
      setRefTcMap(JSON.parse(JSON.stringify(base.tcMap || {})));
      setRefCritResDB(JSON.parse(JSON.stringify(base.critResDB || {})));
      setRefPoles(poles);
      setRefPolesMap(JSON.parse(JSON.stringify(pm)));
      setRefSelectedPole(poles[0] || "");
      setRefFeedback({ type: "success", message: "R√©f√©rentiel de base charg√© dans l‚Äô√©diteur." });
      return;
    }

    const item = (cat.items || []).find((i) => i.id === nextId);
    if (!item) {
      setRefFeedback({ type: "error", message: "R√©f√©rentiel introuvable." });
      return;
    }

    const poles = normalizePolesList(item.poles, item.polesMap);
    const pm = normalizePolesMap(item.polesMap, poles, Object.keys(item.tcMap || {}));

    setRefEditId(nextId);
    setRefName(item.name || "");
    setRefTcMap(JSON.parse(JSON.stringify(item.tcMap || {})));
    setRefCritResDB(JSON.parse(JSON.stringify(item.critResDB || {})));
    setRefPoles(poles);
    setRefPolesMap(JSON.parse(JSON.stringify(pm)));
    setRefSelectedPole(poles[0] || "");

    setRefFeedback({ type: "success", message: "R√©f√©rentiel charg√© dans l‚Äô√©diteur." });
  } finally {
    setRefSwitching(false);
  }
};

const applyReferentielCapSelection = async (nextId: string | null) => {
  setRefFeedback(null);
  setRefSwitching(true);
  try {
    let cat = await loadReferentielCapCatalog();
    if (!cat) cat = referentielCapCatalog ?? { schema: "referentiels_cap_catalog_v1", activeId: null, items: [] };

    if (!nextId) {
      // Afficher la base
      const base = await loadBaseReferentielCap();
      const poles = normalizePolesList(base.poles, base.polesMap);
      const pm = normalizePolesMap(base.polesMap, poles, Object.keys(base.tcMap || {}));

      setTcMap(base.tcMap);
      setCritResDB(base.critResDB);
      setCapPoles(poles);
      setPolesMap(pm);
      setReferentielCapName("R√©f√©rentiel de base");

      const nextCat = { ...cat, activeId: null };
      setReferentielCapCatalog(nextCat);
      setReferentielCapActiveId(null);
      await saveReferentielCapCatalog(nextCat);

      await clearReferentielCapFromStore();

      setRefFeedback({ type: "success", message: "R√©f√©rentiel de base affich√©." });
      return;
    }

    const item = (cat.items || []).find((i) => i.id === nextId);
    if (!item) {
      setRefFeedback({ type: "error", message: "R√©f√©rentiel introuvable." });
      return;
    }

    const poles = normalizePolesList(item.poles, item.polesMap);
    const pm = normalizePolesMap(item.polesMap, poles, Object.keys(item.tcMap || {}));

    const bundle: ReferentielCapBundle = {
      schema: "referentiel_cap_v1",
      name: item.name || "",
      tcMap: item.tcMap,
      critResDB: item.critResDB,
      poles,
      polesMap: pm,
    };

    // Applique au logiciel
    setTcMap(bundle.tcMap);
    setCritResDB(bundle.critResDB);
    setCapPoles(bundle.poles);
    setPolesMap(bundle.polesMap);
    setReferentielCapName(bundle.name);

    // S√©curit√©: reset de s√©lections potentiellement invalides
    setSelectedTasks([]);
    setActiveTask(null);
    setSelectedCompetences([]);
    setSelectedCriteres([]);
    setSelectedSubCrit([]);
    setManageKey(null);

    const nextCat = { ...cat, activeId: nextId };
    setReferentielCapCatalog(nextCat);
    setReferentielCapActiveId(nextId);
    await saveReferentielCapCatalog(nextCat);

    // Maintient aussi le bundle "actif" (compat / cache)
    await saveReferentielCapToStore(bundle);

    setRefFeedback({ type: "success", message: "R√©f√©rentiel affich√©." });
  } finally {
    setRefSwitching(false);
  }
};

const deleteSelectedReferentielCap = async () => {
  const targetId = refEditId;
  if (!targetId) return;

  const targetName = (referentielCapCatalog.items || []).find((i) => i.id === targetId)?.name || "Sans nom";
  const ok = await confirm(`Supprimer le r√©f√©rentiel "${targetName}" ?`, { title: "Mon r√©f√©rentiel", kind: "warning" } as any);
  if (!ok) return;

  setRefFeedback(null);
  setRefSwitching(true);
  try {
    let cat = await loadReferentielCapCatalog();
    if (!cat) cat = referentielCapCatalog ?? { schema: "referentiels_cap_catalog_v1", activeId: null, items: [] };

    const wasActive = referentielCapActiveId === targetId;

    const nextCat: ReferentielCapCatalog = {
      ...cat,
      activeId: wasActive ? null : cat.activeId,
      items: (cat.items || []).filter((i) => i.id !== targetId),
    };

    setReferentielCapCatalog(nextCat);
    await saveReferentielCapCatalog(nextCat);

    // √âditeur : revient en base
    await loadReferentielCapIntoEditor(null);

    // Si on a supprim√© le r√©f√©rentiel affich√© : retour base c√¥t√© logiciel
    if (wasActive) {
      setReferentielCapActiveId(null);
      await clearReferentielCapFromStore();
      const base = await loadBaseReferentielCap();
      const poles = normalizePolesList(base.poles, base.polesMap);
      const pm = normalizePolesMap(base.polesMap, poles, Object.keys(base.tcMap || {}));

      setTcMap(base.tcMap);
      setCritResDB(base.critResDB);
      setCapPoles(poles);
      setPolesMap(pm);
      setReferentielCapName("R√©f√©rentiel de base");
      setRefFeedback({ type: "success", message: "R√©f√©rentiel supprim√©. R√©f√©rentiel de base affich√©." });
    } else {
      // Si ce n‚Äô√©tait pas l‚Äôaffich√©, on ne touche pas au logiciel
      setRefFeedback({ type: "success", message: "R√©f√©rentiel supprim√©." });
    }
  } finally {
    setRefSwitching(false);
  }
};


const refAllCompetences = React.useMemo(() => {
  const s = new Set<string>();
  Object.values(refTcMap || {}).forEach((arr) => (arr || []).forEach((c) => s.add(c)));
  Object.keys(refCritResDB || {}).forEach((c) => s.add(c));
  return Array.from(s).sort((a, b) => a.localeCompare(b, "fr", { sensitivity: "base" }));
}, [refTcMap, refCritResDB]);

// Quand on ouvre: on copie le r√©f√©rentiel courant dans le brouillon
React.useEffect(() => {
  if (!referentielDrawerOpen) return;

  setRefFeedback(null);
  setRefSelectedTask(null);
  setRefSelectedComp(null);
  setRefSelectedItem(null);
  setRefTab("poles");
  // Par d√©faut, on √©dite le r√©f√©rentiel actuellement affich√©
  setRefEditId(referentielCapActiveId);
  setRefName(referentielCapActiveId ? (referentielCapName || "") : "");

  (async () => {
    try {
      const cat = await loadReferentielCapCatalog();
      if (cat) {
        setReferentielCapCatalog(cat);
        setReferentielCapActiveId(cat.activeId);
        setRefEditId(cat.activeId);
      }
    } catch {}
  })();

  const poles = normalizePolesList(capPoles, polesMap);
  const pm = normalizePolesMap(polesMap, poles, Object.keys(tcMap || {}));

  setRefTcMap(JSON.parse(JSON.stringify(tcMap || {})));
  setRefCritResDB(JSON.parse(JSON.stringify(critResDB || {})));
  setRefPoles(poles);
  setRefPolesMap(JSON.parse(JSON.stringify(pm)));
  setRefSelectedPole(poles[0] || "");

  setRefRenamePoleValue(poles[0] || "");
  setRefNewPoleValue("");
  setRefRenameTaskValue("");
  setRefRenameCompValue("");
  setRefRenameItemValue("");
}, [referentielDrawerOpen]);

React.useEffect(() => {
  if (!refFeedback) return;
  const t = window.setTimeout(() => setRefFeedback(null), 2200);
  return () => window.clearTimeout(t);
}, [refFeedback]);

React.useEffect(() => {
  setRefRenamePoleValue(refSelectedPole || "");
}, [refSelectedPole]);

React.useEffect(() => {
  if (!refSelectedPole || !(refPoles || []).includes(refSelectedPole)) {
    setRefSelectedPole((refPoles && refPoles.length ? refPoles[0] : ""));
  }
}, [refPoles, refSelectedPole]);

React.useEffect(() => {
  setRefRenameTaskValue(refSelectedTask || "");
}, [refSelectedTask]);

React.useEffect(() => {
  setRefRenameCompValue(refSelectedComp || "");
}, [refSelectedComp]);

React.useEffect(() => {
  setRefRenameItemValue(refSelectedItem || "");
}, [refSelectedItem]);

  const [generalSettingsSaveFeedback, setGeneralSettingsSaveFeedback] = useState<null | { type: "success" | "error"; message: string }>(null);

  useEffect(() => {
    if (!generalSettingsSaveFeedback) return;
    const t = window.setTimeout(() => setGeneralSettingsSaveFeedback(null), 2200);
    return () => window.clearTimeout(t);
  }, [generalSettingsSaveFeedback]);


const normalizeImportedClassExport = React.useCallback((raw: any, fromName: string, toName: string) => {
  const safeFrom = String(fromName || "").trim();
  const safeTo = String(toName || "").trim();

  const pickFirstValue = (o: any) => {
    if (!o || typeof o !== "object") return undefined;
    const k = Object.keys(o)[0];
    return k ? (o as any)[k] : undefined;
  };

  const normalizeSkills = (skills: any) => {
    const block = (skills && typeof skills === "object")
      ? ((skills as any)[safeFrom] ?? (skills as any)[safeTo] ?? pickFirstValue(skills))
      : undefined;
    return block ? ({ [safeTo]: block } as any) : ({} as any);
  };

  const normalizeNotation = (notation: any) => {
    const out: any = {};
    if (!notation || typeof notation !== "object") return out;
    Object.entries(notation as any).forEach(([schoolYear, byClass]: any) => {
      const classPart = byClass?.[safeFrom] ?? byClass?.[safeTo] ?? pickFirstValue(byClass);
      if (!classPart) return;
      out[schoolYear] = { [safeTo]: classPart };
    });
    return out;
  };

  const normalizeAbsencesRetards = (ar: any): AbsencesRetardsStore => {
  const out: AbsencesRetardsStore = { records: {}, planning: {} };
  if (!ar || typeof ar !== "object") return out;

  const rec = ar.records && typeof ar.records === "object" ? ar.records : {};
  const plan = ar.planning && typeof ar.planning === "object" ? ar.planning : {};

  // records: schoolYear -> classId -> student -> dates
  Object.entries(rec as any).forEach(([schoolYear, byClass]: any) => {
    const classPart = byClass?.[safeFrom] ?? byClass?.[safeTo] ?? pickFirstValue(byClass);
    if (!classPart) return;
    out.records[schoolYear] = { [safeTo]: classPart };
  });

  // planning: schoolYear -> classId -> settings
  Object.entries(plan as any).forEach(([schoolYear, byClass]: any) => {
    const classPart = byClass?.[safeFrom] ?? byClass?.[safeTo] ?? pickFirstValue(byClass);
    if (!classPart) return;
    out.planning[schoolYear] = { [safeTo]: classPart };
  });

  return out;
};

  const normalizeExtraLocalStorage = (extra: any) => {
    const out: Record<string, string> = {};
    if (!extra || typeof extra !== "object") return out;
    Object.entries(extra as any).forEach(([k, v]) => {
      const kk = safeFrom && safeTo && safeFrom !== safeTo
        ? String(k).split(`_${safeFrom}_`).join(`_${safeTo}_`)
        : String(k);
      if (typeof v === "string") out[kk] = v;
    });
    return out;
  };

  const tp = raw?.trainingYears || {};
  const p = tp?.premiere || {};
  const d = tp?.deuxieme || {};

  const classGroup: ClassGroup = (() => {
    const g = raw?.classGroup;
    if (g && typeof g === "object") {
      return {
        id: String((g as any).id || "") || `${Date.now()}_${Math.random().toString(16).slice(2)}`,
        name: safeTo,
        students: String((g as any).students || ""),
      };
    }
    return {
      id: `${Date.now()}_${Math.random().toString(16).slice(2)}`,
      name: safeTo,
      students: "",
    };
  })();

  const mapEvalMeta = (list: any) => {
    const arr = Array.isArray(list) ? list : [];
    return arr.map((ev) => ({ ...ev, group: safeTo }));
  };

  return {
    schema: String(raw?.schema || ""),
    exportedAt: raw?.exportedAt,
    className: safeTo,
    classGroup,
    trainingYears: {
      premiere: {
        evalMeta: mapEvalMeta(p?.evalMeta),
        skills: normalizeSkills(p?.skills),
        notation: normalizeNotation(p?.notation),
        absencesRetards: normalizeAbsencesRetards(p?.absencesRetards),
      },
      deuxieme: {
        evalMeta: mapEvalMeta(d?.evalMeta),
        skills: normalizeSkills(d?.skills),
        notation: normalizeNotation(d?.notation),
        absencesRetards: normalizeAbsencesRetards(d?.absencesRetards),
      },
    },
    devoirFiles: (raw?.devoirFiles && typeof raw.devoirFiles === "object") ? raw.devoirFiles : {},
    extraLocalStorage: normalizeExtraLocalStorage(raw?.extraLocalStorage),
  };
}, []);

const handleImportClassDataFromText = React.useCallback(
  async (jsonText: string) => {
    const rawText = String(jsonText || "");
    if (!rawText.trim()) return;

    setImportBusy(true);
    try {
      let parsed: any;
      try {
        parsed = JSON.parse(rawText);
      } catch {
        alert("‚ùå Fichier invalide : impossible de lire le JSON.");
        return;
      }

      if (!parsed || typeof parsed !== "object" || parsed.schema !== "classe_export_v1") {
        alert("‚ùå Ce fichier ne correspond pas √† un export de classe (schema attendu : classe_export_v1). ");
        return;
      }

      const fromName = String(parsed.className || "").trim();
      if (!fromName) {
        alert("‚ùå Export invalide : nom de classe manquant.");
        return;
      }

      let toName = fromName;
      const wantRename = await confirm("Voulez-vous changer le nom de la classe lors de l‚Äôimport ?", {
        title: "Import",
        kind: "info",
      });
      if (wantRename) {
        const input = window.prompt("Nouveau nom de la classe :", fromName);
        if (input === null) return; // annulation
        const next = String(input || "").trim();
        if (!next) {
          alert("‚ùå Nom de classe invalide.");
          return;
        }
        toName = next;
      }

      const normalized = normalizeImportedClassExport(parsed, fromName, toName);

      const [groups, evalPrem, evalDeux, skillsPrem, skillsDeux, notationPrem, notationDeux] =
        await Promise.all([
          loadElevesFromStore(),
          loadEvalMetaFromStore("premiere"),
          loadEvalMetaFromStore("deuxieme"),
          loadSkillsFromStore("premiere"),
          loadSkillsFromStore("deuxieme"),
          loadNotationFromStore("premiere"),
          loadNotationFromStore("deuxieme"),
        ]);

      const classExists = (groups || []).some((g) => g.name === toName);

      const existingEvalPremCount = (evalPrem || []).filter((ev) => (ev.group || "") === toName).length;
      const existingEvalDeuxCount = (evalDeux || []).filter((ev) => (ev.group || "") === toName).length;
      const existingSkillsPrem = !!(skillsPrem as any)?.[toName];
      const existingSkillsDeux = !!(skillsDeux as any)?.[toName];
      const existingNotationPremYears = Object.entries((notationPrem || {}) as any)
        .filter(([, byClass]: any) => !!byClass?.[toName]).length;
      const existingNotationDeuxYears = Object.entries((notationDeux || {}) as any)
        .filter(([, byClass]: any) => !!byClass?.[toName]).length;

      // Collisions : devoirs et localStorage
      const devoirCollisions: string[] = [];
      if (isTauriRuntime()) {
        for (const fileName of Object.keys(normalized.devoirFiles || {})) {
          const safe = ensureJsonFileName(fileName);
          try {
            const p = `${devoirDirName("premiere")}/${safe}`;
            if (await exists(p, { baseDir: BaseDirectory.AppLocalData })) devoirCollisions.push(safe);
          } catch {
            // ignore
          }
        }
      }
      const localStorageCollisions: string[] = [];
      try {
        Object.keys(normalized.extraLocalStorage || {}).forEach((k) => {
          if (localStorage.getItem(k) != null) localStorageCollisions.push(k);
        });
      } catch {
        // ignore
      }

      const hasOverwriteRisk =
        classExists ||
        existingEvalPremCount > 0 ||
        existingEvalDeuxCount > 0 ||
        existingSkillsPrem ||
        existingSkillsDeux ||
        existingNotationPremYears > 0 ||
        existingNotationDeuxYears > 0 ||
        devoirCollisions.length > 0 ||
        localStorageCollisions.length > 0;

      if (hasOverwriteRisk) {
        const lines: string[] = [];
        if (classExists) lines.push(`‚Ä¢ Classe "${toName}" : existe d√©j√†`);
        if (existingEvalPremCount) lines.push(`‚Ä¢ 1√®re ann√©e : ${existingEvalPremCount} devoir(s) existant(s) seront remplac√©s`);
        if (existingEvalDeuxCount) lines.push(`‚Ä¢ 2√®me ann√©e : ${existingEvalDeuxCount} devoir(s) existant(s) seront remplac√©s`);
        if (existingSkillsPrem) lines.push(`‚Ä¢ Comp√©tences 1√®re ann√©e : donn√©es existantes seront √©cras√©es`);
        if (existingSkillsDeux) lines.push(`‚Ä¢ Comp√©tences 2√®me ann√©e : donn√©es existantes seront √©cras√©es`);
        if (existingNotationPremYears) lines.push(`‚Ä¢ Notation 1√®re ann√©e : ${existingNotationPremYears} ann√©e(s) scolaire(s) seront √©cras√©es`);
        if (existingNotationDeuxYears) lines.push(`‚Ä¢ Notation 2√®me ann√©e : ${existingNotationDeuxYears} ann√©e(s) scolaire(s) seront √©cras√©es`);
        if (devoirCollisions.length) lines.push(`‚Ä¢ Fichiers devoirs : ${devoirCollisions.length} fichier(s) existe(nt) d√©j√† et seront remplac√©s`);
        if (localStorageCollisions.length) lines.push(`‚Ä¢ Notes locales : ${localStorageCollisions.length} cl√©(s) localStorage seront remplac√©es`);

        const msg =
          `‚ö†Ô∏è Import : des donn√©es vont √™tre √©cras√©es.\n\n` +
          lines.join("\n") +
          `\n\nContinuer ?`;

        const ok = await confirm(msg, { title: "Import", kind: "warning" });
        if (!ok) return;
      }

      // --- Appliquer : classes ---
      const nextGroups: ClassGroup[] = (() => {
        const base = Array.isArray(groups) ? groups.slice() : [];
        const idx = base.findIndex((g) => g.name === toName);
        if (idx >= 0) {
          const keepId = base[idx]?.id;
          base[idx] = { ...normalized.classGroup, id: keepId || normalized.classGroup.id };
          return base;
        }
        return [...base, normalized.classGroup];
      })();

      // --- EvalMeta ---
      const nextEvalPrem = (evalPrem || []).filter((ev) => (ev.group || "") !== toName).concat(normalized.trainingYears.premiere.evalMeta || []);
      const nextEvalDeux = (evalDeux || []).filter((ev) => (ev.group || "") !== toName).concat(normalized.trainingYears.deuxieme.evalMeta || []);

      // --- Skills ---
      const nextSkillsPrem: any = { ...(skillsPrem || {}) };
      const nextSkillsDeux: any = { ...(skillsDeux || {}) };
      delete nextSkillsPrem[toName];
      delete nextSkillsDeux[toName];
      const premBlock = (normalized.trainingYears.premiere.skills as any)?.[toName];
      const deuxBlock = (normalized.trainingYears.deuxieme.skills as any)?.[toName];
      if (premBlock) nextSkillsPrem[toName] = premBlock;
      if (deuxBlock) nextSkillsDeux[toName] = deuxBlock;

      // --- Notation (remplacement complet des entr√©es de cette classe) ---
      const removeClassFromNotation = (db: any) => {
        const out: any = {};
        Object.entries(db || {}).forEach(([schoolYear, byClass]: any) => {
          const copy: any = { ...(byClass || {}) };
          delete copy[toName];
          if (Object.keys(copy).length) out[schoolYear] = copy;
        });
        return out;
      };
      const mergeNotationForClass = (db: any, imported: any) => {
        const out: any = { ...(db || {}) };
        Object.entries(imported || {}).forEach(([schoolYear, byClass]: any) => {
          const classPart = byClass?.[toName] ?? (() => {
            if (!byClass || typeof byClass !== "object") return undefined;
            const k = Object.keys(byClass)[0];
            return k ? byClass[k] : undefined;
          })();
          if (!classPart) return;
          out[schoolYear] = { ...(out[schoolYear] || {}), [toName]: classPart };
        });
        return out;
      };

      const nextNotationPrem = mergeNotationForClass(removeClassFromNotation(notationPrem), normalized.trainingYears.premiere.notation);
      const nextNotationDeux = mergeNotationForClass(removeClassFromNotation(notationDeux), normalized.trainingYears.deuxieme.notation);

      // --- Persister ---
      await Promise.all([
        saveElevesToStore(nextGroups),
        saveEvalMetaToStore(nextEvalPrem, "premiere"),
        saveEvalMetaToStore(nextEvalDeux, "deuxieme"),
        saveSkillsToStore(nextSkillsPrem as SkillsDB, "premiere"),
        saveSkillsToStore(nextSkillsDeux as SkillsDB, "deuxieme"),
        saveNotationToStore(nextNotationPrem as NotationDB, "premiere"),
        saveNotationToStore(nextNotationDeux as NotationDB, "deuxieme"),
      ]);

      // --- Devoir files (FS) ---
      if (isTauriRuntime()) {
        try {
          await mkdir(devoirDirName("premiere"), {
            baseDir: BaseDirectory.AppLocalData,
            recursive: true,
          } as any);
        } catch {}

        for (const [fileName, content] of Object.entries(normalized.devoirFiles || {})) {
          const safe = ensureJsonFileName(fileName);
          try {
            const p = `${devoirDirName("premiere")}/${safe}`;
            await writeTextFile(p, JSON.stringify(content, null, 2), {
              baseDir: BaseDirectory.AppLocalData,
            } as any);
          } catch (e) {
            console.warn("Import devoir failed:", safe, e);
          }
        }
      } else {
        const n = Object.keys(normalized.devoirFiles || {}).length;
        if (n) alert("‚ö†Ô∏è Import : les fichiers de devoir ne peuvent pas √™tre √©crits en mode Web (ignor√©s)." );
      }

      // --- Extra localStorage ---
      try {
        Object.entries(normalized.extraLocalStorage || {}).forEach(([k, v]) => {
          localStorage.setItem(k, String(v ?? ""));
        });
      } catch {}

      // --- Rafra√Æchir l'√©tat UI (au moins les donn√©es principales) ---
      setClassGroups(nextGroups);
      setEvalMetaListPremiere(nextEvalPrem);
      setEvalMetaListDeuxieme(nextEvalDeux);
      setSkillsDBPremiere(nextSkillsPrem as SkillsDB);
      setSkillsDBDeuxieme(nextSkillsDeux as SkillsDB);
      setNotationDBPremiere(nextNotationPrem as NotationDB);
      setNotationDBDeuxieme(nextNotationDeux as NotationDB);

      if (trainingYear === "premiere") {
        setEvalMetaList(nextEvalPrem);
        setSkillsDB(nextSkillsPrem as SkillsDB);
        setNotationDB(nextNotationPrem as NotationDB);
      } else {
        setEvalMetaList(nextEvalDeux);
        setSkillsDB(nextSkillsDeux as SkillsDB);
        setNotationDB(nextNotationDeux as NotationDB);
      }

      alert(`‚úÖ Import termin√© : ${toName}`);
    } catch (e) {
      console.error("Import error:", e);
      alert("‚ùå Import impossible.");
    } finally {
      setImportBusy(false);
    }
  },
  [normalizeImportedClassExport, trainingYear]
);

const handleImportClick = React.useCallback(async () => {
  if (importBusy) return;

    if (isTauriRuntime()) {
    try {
      const picked = await open({
        title: "Importer une classe",
        multiple: false,
        filters: [
          { name: "Export (ZIP)", extensions: ["zip"] },
          { name: "Export (JSON)", extensions: ["json"] },
        ],
      } as any);
      if (!picked) return;
      const path = Array.isArray(picked) ? picked[0] : picked;
      if (!path) return;

      const p = String(path);

      // ZIP : on extrait le JSON + on restaure les dossiers inclus (devoirs / PDFs)
      if (p.toLowerCase().endsWith(".zip")) {
        const bytes = await readFile(p);
        const ab =
          bytes instanceof Uint8Array
            ? bytes.buffer.slice(bytes.byteOffset, bytes.byteOffset + bytes.byteLength)
            : (bytes as any);

        const zip = await (JSZip as any).loadAsync(ab as any);

        // 1) Trouver le JSON principal (schema classe_export_v1)
        let mainJsonText = "";
        const jsonNames = Object.keys(zip.files || {}).filter(
          (n) => n.toLowerCase().endsWith(".json") && n.toLowerCase() !== "manifest.json"
        );

        for (const n of jsonNames) {
          try {
            const txt = await zip.file(n).async("string");
            const obj = JSON.parse(txt);
            if (obj && typeof obj === "object" && obj.schema === "classe_export_v1") {
              mainJsonText = txt;
              break;
            }
          } catch {
            // ignore
          }
        }

        if (!mainJsonText) {
          // fallback : si manifest.json contient d√©j√† schema, on tente fileName standard
          try {
            const mani = await zip.file("manifest.json")?.async("string");
            const maniObj = mani ? JSON.parse(mani) : null;
            if (maniObj?.className && maniObj?.trainingYear) {
              const guess = Object.keys(zip.files || {}).find(
                (n) =>
                  n.toLowerCase().endsWith(".json") &&
                  n.toLowerCase() !== "manifest.json"
              );
              if (guess) mainJsonText = await zip.file(guess).async("string");
            }
          } catch {}
        }

        if (!mainJsonText) {
          alert("‚ùå ZIP invalide : impossible de trouver l‚Äôexport JSON principal.");
          return;
        }

        // 2) Restaurer les fichiers du ZIP vers AppLocalData (hors JSON principal + manifest)
        const ensureParentDir = async (relPath: string) => {
          const parts = String(relPath || "").split("/").filter(Boolean);
          if (parts.length <= 1) return;
          parts.pop();
          const dir = parts.join("/");
          if (!dir) return;
          await mkdir(dir, { baseDir: BaseDirectory.AppLocalData, recursive: true } as any).catch(() => {});
        };

        const entries = Object.keys(zip.files || {});
        for (const name of entries) {
          const f = zip.files[name];
          if (!f || f.dir) continue;

          const lower = String(name).toLowerCase();
          if (lower === "manifest.json") continue;

          // On √©vite de r√©-√©crire le JSON principal : il sera import√© via handleImportClassDataFromText
          if (lower.endsWith(".json")) {
            // on restaure seulement les JSON de dossiers (ex: devoirs), pas le principal
            // Heuristique : ne pas restaurer un JSON √† la racine (souvent le principal)
            const isRootJson = !name.includes("/");
            if (isRootJson) continue;

            try {
              const txt = await zip.file(name).async("string");
              await ensureParentDir(name);
              await writeTextFile(name, txt, { baseDir: BaseDirectory.AppLocalData } as any);
            } catch (e) {
              console.warn("Restore JSON failed:", name, e);
            }
            continue;
          }

          // Binaires (PDF, etc.)
          try {
            const fileBytes = await zip.file(name).async("uint8array");
            await ensureParentDir(name);
            await writeFile(name, fileBytes as any, { baseDir: BaseDirectory.AppLocalData } as any);
          } catch (e) {
            console.warn("Restore file failed:", name, e);
          }
        }

        // 3) Importer le JSON principal (merge dans l'app)
        await handleImportClassDataFromText(mainJsonText);
        return;
      }

      // JSON simple
      const txt = await readTextFile(p);
      await handleImportClassDataFromText(txt);
    } catch (e) {
      console.error("Import open/read error:", e);
      alert("‚ùå Impossible d‚Äôouvrir ou lire le fichier (permissions / format).");
    }
    return;
  }

  // Mode Web/dev : input file
  importFileInputRef.current?.click();
}, [handleImportClassDataFromText, importBusy]);

const openExportDrawer = React.useCallback(() => {
  const groupIsClass = classGroups.some((c) => c.name === group);
  const fallback =
    exportClassName ||
    selectedClassIdForSuivi ||
    (groupIsClass ? group : "") ||
    classGroups[0]?.name ||
    "";
  setExportClassName(fallback);
  setExportDrawerOpen(true);
}, [classGroups, exportClassName, group, selectedClassIdForSuivi]);

const handleExportClassData = React.useCallback(
  async (classNameRaw?: string) => {
    const className = String(classNameRaw ?? exportClassName ?? "").trim();
    if (!className) {
      alert("S√©lectionnez une classe √† exporter.");
      return;
    }

    setExportBusy(true);
    try {
      const [allGroups, evalPrem, evalDeux, skillsPrem, skillsDeux, notationPrem, notationDeux] =
        await Promise.all([
          loadElevesFromStore(),
          loadEvalMetaFromStore("premiere"),
          loadEvalMetaFromStore("deuxieme"),
          loadSkillsFromStore("premiere"),
          loadSkillsFromStore("deuxieme"),
          loadNotationFromStore("premiere"),
          loadNotationFromStore("deuxieme"),
        ]);

      const classGroup = allGroups.find((g) => g.name === className) || null;

      const evalMetaPremiere = (evalPrem || []).filter((ev) => (ev.group || "") === className);
      const evalMetaDeuxieme = (evalDeux || []).filter((ev) => (ev.group || "") === className);

      const filterSkillsByClass = (db: SkillsDB): SkillsDB => {
        const block = (db as any)?.[className];
        return block ? ({ [className]: block } as SkillsDB) : ({} as SkillsDB);
      };

      const filterNotationByClass = (db: NotationDB): NotationDB => {
        const out: any = {};
        Object.entries(db || {}).forEach(([schoolYear, byClass]: any) => {
          const classPart = byClass?.[className];
          if (classPart) out[schoolYear] = { [className]: classPart };
        });
        return out as NotationDB;
      };

      // Inclut le contenu JSON des devoirs (si accessible via le FS Tauri)
      const devoirFiles: Record<string, any> = {};
      if (isTauriRuntime()) {
        const seen = new Set<string>();
        const metas = [...evalMetaPremiere, ...evalMetaDeuxieme];
        for (const ev of metas) {
          const safe = ensureJsonFileName(ev.fileName);
          if (seen.has(safe)) continue;
          seen.add(safe);
          try {
            const txt = await readTextFile(`${devoirDirName("premiere")}/${safe}`, {
              baseDir: BaseDirectory.AppLocalData,
            });
            if (txt && txt.trim()) devoirFiles[safe] = JSON.parse(txt);
          } catch {
            // fichier absent => ignore
          }
        }
      }

      // Notes annexes stock√©es en localStorage (ex : absences / indicateurs)
      const extraLocalStorage: Record<string, string> = {};
      try {
        for (let i = 0; i < localStorage.length; i++) {
          const k = localStorage.key(i);
          if (!k) continue;
          if (!k.includes(`_${className}_`)) continue;
          if (!k.startsWith("bilan_absences_") && !k.startsWith("bilan_absences_traffic_")) continue;
          const v = localStorage.getItem(k);
          if (v != null) extraLocalStorage[k] = v;
        }
      } catch {
        // ignore
      }

      const payload = {
        schema: "classe_export_v1",
        exportedAt: new Date().toISOString(),
        className,
        classGroup,
        trainingYears: {
          premiere: {
            evalMeta: evalMetaPremiere,
            skills: filterSkillsByClass(skillsPrem),
            notation: filterNotationByClass(notationPrem),
          },
          deuxieme: {
            evalMeta: evalMetaDeuxieme,
            skills: filterSkillsByClass(skillsDeux),
            notation: filterNotationByClass(notationDeux),
          },
        },
        devoirFiles,
        extraLocalStorage,
      };

      const fileName = `export_${sanitizeFileNamePart(className)}_${tsForFileName()}.json`;

      // --- Export Tauri : enregistrement √† l'emplacement choisi par l'utilisateur (Save dialog) ---
      if (isTauriRuntime()) {
        // ‚úÖ Export complet en ZIP (JSON + devoirs + PDFs de suivi, etc.)
        const zipPath = await save({
          title: "Exporter (ZIP)",
          defaultPath: `export_${sanitizeFileNamePart(className)}_${sanitizeFileNamePart(getCurrentSchoolYear())}_${exportYear}_${tsForFileName()}.zip`,
          filters: [{ name: "Export (ZIP)", extensions: ["zip"] }],
        } as any);

        // Annul√© par l'utilisateur
        if (!zipPath) return;

        const zip = new JSZip();

        // 0) Manifest (utile pour l'import ZIP)
        zip.file(
          "manifest.json",
          JSON.stringify(
            {
              schema: "classe_export_v1",
              exportedAt: new Date().toISOString(),
              schoolYear: getCurrentSchoolYear(),
              trainingYear: exportYear,
              className,
            },
            null,
            2
          )
        );

        // 1) JSON principal (m√™me contenu que l'export classique)
        zip.file(fileName, safeJsonStringify(payload, 2));

        // 2) Ajout r√©cursif d'un dossier AppLocalData dans le ZIP
        const addDirToZipFromAppLocalData = async (srcRel: string, zipBase: string) => {
          try {
            const ok = await exists(srcRel, { baseDir: BaseDirectory.AppLocalData } as any);
            if (!ok) return;

            const walk = async (relDir: string) => {
              const entries = await readDir(relDir, { baseDir: BaseDirectory.AppLocalData } as any);
              for (const entry of entries as any[]) {
                const name = String(entry?.name || "");
                if (!name) continue;

                const childRel = `${relDir}/${name}`;
                const isDir = !!entry?.isDir || Array.isArray(entry?.children);

                if (isDir) {
                  await walk(childRel);
                } else {
                  const bytes = await readFile(childRel, { baseDir: BaseDirectory.AppLocalData } as any);
                  const inside = childRel.startsWith(srcRel + "/")
                    ? childRel.slice(srcRel.length + 1)
                    : name;
                  zip.file(`${zipBase}/${inside}`, bytes as any);
                }
              }
            };

            await walk(srcRel);
          } catch (e) {
            console.warn("addDirToZipFromAppLocalData failed:", { srcRel, e });
          }
        };

        // 3) Devoirs (dossier ann√©e)
        try {
          await addDirToZipFromAppLocalData(devoirDirName(exportYear), devoirDirName(exportYear));
        } catch (e) {
          console.warn("Export devoirs (ZIP) √©chou√©:", e);
        }

        // 4) PDFs Suivi √©l√®ves (dossier de la classe pour l'ann√©e choisie)
        try {
          const DOC_ROOT = "suivi_eleves_docs";
          const schoolYearPart = sanitizeFileNamePart(getCurrentSchoolYear());
          const classPart = sanitizeFileNamePart(className);
          const srcDocsBase = `${DOC_ROOT}/${schoolYearPart}/${exportYear}/${classPart}`;

          // On garde le m√™me chemin dans le ZIP pour simplifier l'import
          await addDirToZipFromAppLocalData(srcDocsBase, srcDocsBase);
        } catch (e) {
          console.warn("Export PDFs suivi (ZIP) √©chou√©:", e);
        }

        // 5) G√©n√©rer + √©crire le ZIP
        const zipBytes = await zip.generateAsync({ type: "uint8array" } as any);
        await writeFile(String(zipPath), zipBytes as any);

        alert(`‚úÖ Export ZIP cr√©√© : ${zipPath}`);
        setExportDrawerOpen(false);
        return;
      }

      // --- Export Web (dev) : t√©l√©chargement direct ---
      try {
        const blob = new Blob([safeJsonStringify(payload, 2)], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = fileName;
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
        alert("‚úÖ Export t√©l√©charg√©.");
        setExportDrawerOpen(false);
      } catch {
        alert("‚ùå Impossible de g√©n√©rer l'export dans ce mode.");
      }
    } catch (e) {
      console.error("Export error:", e);
      alert("‚ùå Export impossible (v√©rifie les permissions Tauri).");
    } finally {
      setExportBusy(false);
    }
  },
  [classGroups, exportClassName, group, selectedClassIdForSuivi]
);
  // Suivi des comp√©tences : mode √©l√®ve / classe / √©volutions (2 ans)
  const [suiviMode, setSuiviMode] = useState<"eleve" | "classe" | "absences" | "notation" | "evolutions" | "bilan">("eleve");


// Absences / retards (planning annuel)
const [absencesSchoolYear, setAbsencesSchoolYear] = React.useState<string>(() => getCurrentSchoolYear());
const [absencesSelectedDateYmd, setAbsencesSelectedDateYmd] = React.useState<string>(() => toYmd(new Date()));
const [absencesSettingsOpen, setAbsencesSettingsOpen] = React.useState(false);
const [absencesAutoVacCache, setAbsencesAutoVacCache] = React.useState<Record<string, VacationRange[]>>({});
const [absencesAutoVacLoading, setAbsencesAutoVacLoading] = React.useState<Record<string, boolean>>({});
const [absencesAutoVacError, setAbsencesAutoVacError] = React.useState<Record<string, string | null>>({});

// Taille des colonnes jours (zoom)
const [absencesDayColPx, setAbsencesDayColPx] = React.useState<number>(16);
const [absencesTimelineView, setAbsencesTimelineView] = React.useState<"day" | "week">("week");
const [absencesRecapOpen, setAbsencesRecapOpen] = React.useState(false);
const [absencesRecapSemesterKey, setAbsencesRecapSemesterKey] = React.useState<"ALL" | "S1" | "S2">("ALL");


// Affichage : d√©marrer √† la semaine en cours (par d√©faut) ou tout afficher
const [absencesShowAllWeeks, setAbsencesShowAllWeeks] = React.useState<boolean>(true);
	const [absencesDisplayStartYmd, setAbsencesDisplayStartYmd] = React.useState<string>(() => {
  const td = new Date();
  const monday = addDays(td, -weekdayIndexMon0(td));
  return toYmd(monday);
});

// Navigation : saut de p√©riode (mois) quand on n'affiche pas tout
// Date du jour (YYYY-MM-DD) ‚Äî utilis√©e pour griser/barrer les semaines d√©j√† pass√©es
	const todayYmd = toYmd(new Date());

// Alertes : seuils AB / RT en % (sur jours de COURS effectifs, du d√©but √† aujourd'hui)
// - Vert : en-dessous du seuil Orange
// - Orange : >= seuil Orange
// - Rouge : >= seuil Rouge
type AbsencesThresholdsPct = {
  abOrangePct: number;
  abRedPct: number;
  rtOrangePct: number;
  rtRedPct: number;
};

const ABSENCES_ALERTS_CACHE_KEY_PCT_V1 = "absences_alert_thresholds_pct_v1"; // legacy
const ABSENCES_ALERTS_CACHE_KEY_PCT = "absences_alert_thresholds_pct_v2";

const clampPct = (n: number, fallback: number) => {
  const v = Number.isFinite(n) ? n : fallback;
  return Math.max(0, Math.min(100, v));
};

const readAbsencesThresholdsPct = (): AbsencesThresholdsPct => {
  const defaults = { abOrangePct: 6, abRedPct: 10, rtOrangePct: 9, rtRedPct: 15 };
  try {
    const rawV2 = localStorage.getItem(ABSENCES_ALERTS_CACHE_KEY_PCT);
    if (rawV2) {
      const obj = JSON.parse(rawV2) as any;
      const abOrangePct = clampPct(parseFloat(String(obj?.abOrangePct ?? obj?.abYellowPct ?? defaults.abOrangePct).replace(",", ".")), defaults.abOrangePct);
      const abRedPct = clampPct(parseFloat(String(obj?.abRedPct ?? defaults.abRedPct).replace(",", ".")), defaults.abRedPct);
      const rtOrangePct = clampPct(parseFloat(String(obj?.rtOrangePct ?? obj?.rtYellowPct ?? defaults.rtOrangePct).replace(",", ".")), defaults.rtOrangePct);
      const rtRedPct = clampPct(parseFloat(String(obj?.rtRedPct ?? defaults.rtRedPct).replace(",", ".")), defaults.rtRedPct);
      return {
        abOrangePct: Math.min(abOrangePct, abRedPct),
        abRedPct,
        rtOrangePct: Math.min(rtOrangePct, rtRedPct),
        rtRedPct,
      };
    }

    // v1 : uniquement des seuils "rouges" (abPct/rtPct). L'orange est d√©riv√© √† 60%.
    const rawV1 = localStorage.getItem(ABSENCES_ALERTS_CACHE_KEY_PCT_V1);
    if (rawV1) {
      const obj = JSON.parse(rawV1) as any;
      const abRedPct = clampPct(parseFloat(String(obj?.abPct ?? defaults.abRedPct).replace(",", ".")), defaults.abRedPct);
      const rtRedPct = clampPct(parseFloat(String(obj?.rtPct ?? defaults.rtRedPct).replace(",", ".")), defaults.rtRedPct);
      return {
        abRedPct,
        rtRedPct,
        abOrangePct: clampPct(abRedPct * 0.6, defaults.abOrangePct),
        rtOrangePct: clampPct(rtRedPct * 0.6, defaults.rtOrangePct),
      };
    }
  } catch {
    // ignore
  }
  return defaults;
};

const [absencesThresholdsPct, setAbsencesThresholdsPct] = React.useState<AbsencesThresholdsPct>(() => readAbsencesThresholdsPct());

// Alias (compat) : valeurs utilis√©es dans l'app
const absencesWarnAbsPct = absencesThresholdsPct.abOrangePct;
const absencesAlertAbsPct = absencesThresholdsPct.abRedPct;
const absencesWarnRtPct = absencesThresholdsPct.rtOrangePct;
const absencesAlertRtPct = absencesThresholdsPct.rtRedPct;

// Setters : on garantit Orange <= Rouge
const setAbsencesWarnAbsPct = React.useCallback((v: number) => {
  const next = clampPct(v, absencesWarnAbsPct);
  setAbsencesThresholdsPct((p) => ({ ...p, abOrangePct: Math.min(next, p.abRedPct) }));
}, [absencesWarnAbsPct]);

const setAbsencesAlertAbsPct = React.useCallback((v: number) => {
  const next = clampPct(v, absencesAlertAbsPct);
  setAbsencesThresholdsPct((p) => ({ ...p, abRedPct: next, abOrangePct: Math.min(p.abOrangePct, next) }));
}, [absencesAlertAbsPct]);

const setAbsencesWarnRtPct = React.useCallback((v: number) => {
  const next = clampPct(v, absencesWarnRtPct);
  setAbsencesThresholdsPct((p) => ({ ...p, rtOrangePct: Math.min(next, p.rtRedPct) }));
}, [absencesWarnRtPct]);

const setAbsencesAlertRtPct = React.useCallback((v: number) => {
  const next = clampPct(v, absencesAlertRtPct);
  setAbsencesThresholdsPct((p) => ({ ...p, rtRedPct: next, rtOrangePct: Math.min(p.rtOrangePct, next) }));
}, [absencesAlertRtPct]);

React.useEffect(() => {
  try {
    localStorage.setItem(ABSENCES_ALERTS_CACHE_KEY_PCT, JSON.stringify(absencesThresholdsPct));
  } catch {}
}, [absencesThresholdsPct]);



const ensureAbsencesPlanningSettings = React.useCallback((schoolYear: string, classId: string) => {
  setAbsencesStore((prev) => {
    if (prev.planning?.[schoolYear]?.[classId]) return prev;
    const next: AbsencesRetardsStore = { records: prev.records, planning: { ...(prev.planning || {}) } };
    const byYear = { ...(next.planning[schoolYear] || {}) };
    byYear[classId] = defaultPlanningSettings(schoolYear, "B");
    next.planning[schoolYear] = byYear;
    return next;
  });
}, []);

const absencesPlanningSettings = React.useMemo(() => {
  if (!selectedClassIdForSuivi) return defaultPlanningSettings(absencesSchoolYear, "B");
  return absencesStore.planning?.[absencesSchoolYear]?.[selectedClassIdForSuivi] || defaultPlanningSettings(absencesSchoolYear, "B");
}, [absencesStore.planning, absencesSchoolYear, selectedClassIdForSuivi]);

// Helpers (Absences) : trouver le 1er jour de cours √† partir d'une date + navigation (mois)
const absencesFindFirstCourseYmdOnOrAfter = React.useCallback(
  (targetYmd: string) => {
    const s = absencesPlanningSettings.startYmd;
    const e = absencesPlanningSettings.endYmd;
    let d = fromYmd(targetYmd) || fromYmd(s) || new Date();

    // clamp
    if (toYmd(d) < s) d = fromYmd(s) || d;
    if (toYmd(d) > e) d = fromYmd(e) || d;

    for (let i = 0; i < 500; i += 1) {
      const ymd = toYmd(d);
      if (ymd > e) break;

      if (ymd >= s) {
        const wdKey = weekdayKeyFromDate(d);
        if (absencesPlanningSettings.courseDays?.[wdKey]) return ymd;
      }
      d = addDays(d, 1);
    }
    return s;
  },
  [absencesPlanningSettings.startYmd, absencesPlanningSettings.endYmd, absencesPlanningSettings.courseDays]
);

const absencesJumpToCurrentWeek = React.useCallback(() => {
  const td = fromYmd(todayYmd) || new Date();
  const mondayYmd = toYmd(addDays(td, -weekdayIndexMon0(td)));
  setAbsencesShowAllWeeks(false);
  setAbsencesDisplayStartYmd(absencesFindFirstCourseYmdOnOrAfter(mondayYmd));
}, [todayYmd, absencesFindFirstCourseYmdOnOrAfter]);

const absencesJumpByMonths = React.useCallback(
  (deltaMonths: number) => {
    setAbsencesShowAllWeeks(false);
    setAbsencesDisplayStartYmd((prev) => {
      const base = fromYmd(prev) || fromYmd(absencesPlanningSettings.startYmd) || new Date();
      const target = new Date(base.getFullYear(), base.getMonth() + deltaMonths, 1);
      return absencesFindFirstCourseYmdOnOrAfter(toYmd(target));
    });
  },
  [absencesFindFirstCourseYmdOnOrAfter, absencesPlanningSettings.startYmd]
);


const absencesAutoVacKey = React.useMemo(() => {
  return `${absencesSchoolYear}_${absencesPlanningSettings.zone}`;
}, [absencesSchoolYear, absencesPlanningSettings.zone]);

const absencesAutoVacHasKey = React.useMemo(
  () => Object.prototype.hasOwnProperty.call(absencesAutoVacCache, absencesAutoVacKey),
  [absencesAutoVacCache, absencesAutoVacKey]
);
const absencesAutoVacationsForKey = absencesAutoVacHasKey ? absencesAutoVacCache[absencesAutoVacKey] : null;
const absencesAutoVacIsLoading = !!absencesAutoVacLoading[absencesAutoVacKey];
const absencesAutoVacErrorForKey = absencesAutoVacError[absencesAutoVacKey] || null;

// S'assure qu'un planning existe pour la classe (sinon on cr√©e un planning par d√©faut)
React.useEffect(() => {
  if (!isAbsencesView) return;
  if (!selectedClassIdForSuivi) return;
  ensureAbsencesPlanningSettings(absencesSchoolYear, selectedClassIdForSuivi);
});

// Maintenir une date s√©lectionn√©e valide dans la plage du planning
React.useEffect(() => {
  if (!isAbsencesView) return;
  const s = absencesPlanningSettings.startYmd;
  const e = absencesPlanningSettings.endYmd;
  if (absencesSelectedDateYmd < s || absencesSelectedDateYmd > e) {
    setAbsencesSelectedDateYmd(s);
  }
});


// Maintenir un d√©but d'affichage valide (si l'utilisateur a navigu√© hors de la p√©riode)
React.useEffect(() => {
  if (!isAbsencesView) return;
  if (absencesShowAllWeeks) return;
  const s = absencesPlanningSettings.startYmd;
  const e = absencesPlanningSettings.endYmd;
  if (absencesDisplayStartYmd < s || absencesDisplayStartYmd > e) {
    absencesJumpToCurrentWeek();
  }
});


// Chargement auto des vacances (ICS) selon la zone
React.useEffect(() => {
  if (!isAbsencesView) return;
  if (!selectedClassIdForSuivi) return;
  if (absencesPlanningSettings.vacationsMode !== "auto") return;
  if (absencesAutoVacHasKey) return;
  if (absencesAutoVacIsLoading) return;

  setAbsencesAutoVacError((prev) => ({ ...prev, [absencesAutoVacKey]: null }));
  setAbsencesAutoVacLoading((prev) => ({ ...prev, [absencesAutoVacKey]: true }));
  fetchVacationsForSchoolYearFromIcs(absencesPlanningSettings.zone, absencesSchoolYear)
    .then((ranges) => {
      setAbsencesAutoVacCache((prev) => ({ ...prev, [absencesAutoVacKey]: ranges }));
      setAbsencesAutoVacError((prev) => ({ ...prev, [absencesAutoVacKey]: null }));
    })
    .catch((e) => {
      console.warn("Vacances auto non charg√©es :", e);
      const msg = (e && typeof e === "object" && "message" in (e as any)) ? String((e as any).message) : String(e);
      setAbsencesAutoVacError((prev) => ({ ...prev, [absencesAutoVacKey]: msg }));
      setAbsencesAutoVacCache((prev) => ({ ...prev, [absencesAutoVacKey]: [] }));
    })
    .finally(() => {
      setAbsencesAutoVacLoading((prev) => ({ ...prev, [absencesAutoVacKey]: false }));
    });
}, [
  suiviMode,
  selectedClassIdForSuivi,
  absencesAutoVacKey,
  absencesAutoVacationsForKey,
  absencesAutoVacIsLoading,
  absencesPlanningSettings.zone,
  absencesPlanningSettings.vacationsMode,
  absencesSchoolYear,
]);


const updateAbsencesPlanning = React.useCallback(
  (schoolYear: string, classId: string, updater: (cur: PlanningSettings) => PlanningSettings) => {
    setAbsencesStore((prev) => {
      const current = prev.planning?.[schoolYear]?.[classId] || defaultPlanningSettings(schoolYear, "B");
      const nextSettings = updater(current);

      const nextPlanning: AbsencesRetardsStore["planning"] = { ...(prev.planning || {}) };
      const byYear = { ...(nextPlanning[schoolYear] || {}) };
      byYear[classId] = nextSettings;
      nextPlanning[schoolYear] = byYear;

      return { ...prev, planning: nextPlanning };
    });
  },
  []
);

const setAbsenceStatus = React.useCallback(
  (schoolYear: string, classId: string, studentName: string, ymd: string, status: AttendanceStatus | null) => {
    setAbsencesStore((prev) => {
      const nextRecords: AbsencesRetardsStore["records"] = { ...(prev.records || {}) };
      const byYear = { ...(nextRecords[schoolYear] || {}) };
      const byClass = { ...(byYear[classId] || {}) };
      const byStudent = { ...(byClass[studentName] || {}) };

      if (status) byStudent[ymd] = status;
      else delete byStudent[ymd];

      // nettoyage l√©ger
      if (Object.keys(byStudent).length === 0) delete byClass[studentName];
      else byClass[studentName] = byStudent;

      if (Object.keys(byClass).length === 0) delete byYear[classId];
      else byYear[classId] = byClass;

      if (Object.keys(byYear).length === 0) delete nextRecords[schoolYear];
      else nextRecords[schoolYear] = byYear;

      return { ...prev, records: nextRecords };
    });
  },
  []
);

const setAbsenceStatusForAllStudents = React.useCallback(
  (schoolYear: string, classId: string, students: string[], ymd: string, status: AttendanceStatus | null) => {
    setAbsencesStore((prev) => {
      const nextRecords: AbsencesRetardsStore["records"] = { ...(prev.records || {}) };
      const byYear = { ...(nextRecords[schoolYear] || {}) };
      const byClass = { ...(byYear[classId] || {}) };

      for (const studentName of students) {
        const byStudent = { ...(byClass[studentName] || {}) };
        if (status) byStudent[ymd] = status;
        else delete byStudent[ymd];

        if (Object.keys(byStudent).length === 0) delete byClass[studentName];
        else byClass[studentName] = byStudent;
      }

      if (Object.keys(byClass).length === 0) delete byYear[classId];
      else byYear[classId] = byClass;

      if (Object.keys(byYear).length === 0) delete nextRecords[schoolYear];
      else nextRecords[schoolYear] = byYear;

      return { ...prev, records: nextRecords };
    });
  },
  []
);


  // Bilan p√©riodique (onglet Suivi des comp√©tences)
  const [bilanSemester, setBilanSemester] = useState<SemesterKey>("S1");
  const [bilanAbsencesNote, setBilanAbsencesNote] = useState<string>("");
  const [bilanAbsencesTraffic, setBilanAbsencesTraffic] = useState<TrafficLightColor>("none");
  const [bilanAppreciationNote, setBilanAppreciationNote] = useState<string>("");

  // Ann√©e scolaire cible pour le Bilan : on prend la plus r√©cente pr√©sente dans la base de notation.
  // (Important pour consulter les donn√©es de 1√®re ann√©e quand on est d√©j√† sur l'ann√©e scolaire suivante.)
  const bilanSchoolYear = React.useMemo(
    () => pickLatestSchoolYearFromNotationDB(notationDB, getCurrentSchoolYear()),
    [notationDB, trainingYear]
  );

  // === BILAN : absences/retards auto (comptage + feu) ===
const bilanPlanningSettings = React.useMemo(() => {
  if (!selectedClassIdForSuivi) return defaultPlanningSettings(bilanSchoolYear, "B");
  return (
    absencesStore.planning?.[bilanSchoolYear]?.[selectedClassIdForSuivi] ||
    defaultPlanningSettings(bilanSchoolYear, "B")
  );
}, [absencesStore.planning, bilanSchoolYear, selectedClassIdForSuivi]);

const bilanAutoVacKey = React.useMemo(
  () => `${bilanSchoolYear}_${bilanPlanningSettings.zone}`,
  [bilanSchoolYear, bilanPlanningSettings.zone]
);
const bilanAutoVacHasKey = React.useMemo(
  () => Object.prototype.hasOwnProperty.call(absencesAutoVacCache, bilanAutoVacKey),
  [absencesAutoVacCache, bilanAutoVacKey]
);
const bilanAutoVacationsForKey = bilanAutoVacHasKey ? absencesAutoVacCache[bilanAutoVacKey] : null;
const bilanAutoVacIsLoading = !!absencesAutoVacLoading[bilanAutoVacKey];
const bilanAutoVacErrorForKey = absencesAutoVacError[bilanAutoVacKey] || null;

// (optionnel mais conseill√©) charger ICS si vacances auto
React.useEffect(() => {
  if (suiviMode !== "bilan") return;
  if (bilanPlanningSettings.vacationsMode !== "auto") return;
  if (bilanAutoVacHasKey || bilanAutoVacIsLoading) return;

  setAbsencesAutoVacLoading((p) => ({ ...p, [bilanAutoVacKey]: true }));
  setAbsencesAutoVacError((p) => ({ ...p, [bilanAutoVacKey]: null }));

  fetchVacationsForSchoolYearFromIcs(bilanPlanningSettings.zone, bilanSchoolYear)
    .then((ranges) => setAbsencesAutoVacCache((p) => ({ ...p, [bilanAutoVacKey]: ranges || [] })))
    .catch((e) => setAbsencesAutoVacError((p) => ({ ...p, [bilanAutoVacKey]: String(e?.message || e) })))
    .finally(() => setAbsencesAutoVacLoading((p) => ({ ...p, [bilanAutoVacKey]: false })));
}, [
  suiviMode,
  bilanPlanningSettings.vacationsMode,
  bilanPlanningSettings.zone,
  bilanSchoolYear,
  bilanAutoVacKey,
  bilanAutoVacHasKey,
  bilanAutoVacIsLoading,
]);

const bilanAbsencesAuto = React.useMemo(() => {
  if (!selectedClassIdForSuivi || !selectedStudentForSuivi) return null;

  const classId = selectedClassIdForSuivi;
  const studentName = selectedStudentForSuivi;

  const yearBucket =
    (absencesStore.records?.[bilanSchoolYear]?.[classId] || {}) as Record<string, Record<string, AttendanceStatus>>;
  const byDate = yearBucket?.[studentName] || {};

  const startYmd = bilanPlanningSettings.startYmd;
  const endYmd = bilanPlanningSettings.endYmd;

  const vacationRanges: VacationRange[] =
    bilanPlanningSettings.vacationsMode === "auto"
      ? (bilanAutoVacationsForKey || [])
      : (bilanPlanningSettings.vacationsManual || []).map((r) => ({
          startYmd: r.startYmd,
          endYmdExclusive: addDaysYmd(r.endYmd, 1),
          label: r.label || "Vacances",
        }));

  const stageRanges: VacationRange[] = (bilanPlanningSettings.stages || []).map((r) => ({
    startYmd: r.startYmd,
    endYmdExclusive: addDaysYmd(r.endYmd, 1),
    label: r.label || "Stage",
  }));

  const cutoffYmd = todayYmd < endYmd ? todayYmd : endYmd;

  const buildEffectiveCourseSet = (fromStr: string, toInclusiveStr: string) => {
    const set = new Set<string>();
    const s = fromYmd(fromStr);
    const e = fromYmd(toInclusiveStr);
    if (!s || !e) return set;
    for (let d = new Date(s.getTime()); d <= e; d = addDays(d, 1)) {
      const wdKey = weekdayKeyFromDate(d);
      if (!bilanPlanningSettings.courseDays?.[wdKey]) continue;
      const ymd = toYmd(d);
      if (findLabelInRanges(ymd, vacationRanges)) continue;
      if (findLabelInRanges(ymd, stageRanges)) continue;
      set.add(ymd);
    }
    return set;
  };

  // P√©riode du bilan: semestre choisi (S1/S2) ou ann√©e
  let periodLabel = "Ann√©e";
  let periodSet = buildEffectiveCourseSet(startYmd, cutoffYmd);

  if (bilanSemester === "S1" || bilanSemester === "S2") {
    periodLabel = bilanSemester;

    const parsedSY = parseSchoolYearString(bilanSchoolYear);
    const endYear = parsedSY?.endYear ?? new Date().getFullYear() + 1;

    const fallbackWinterStart = `${endYear}-02-01`;
    const winterVac = vacationRanges.find((r) => /Hiver/i.test(r.label || ""));
    const splitYmd = winterVac?.startYmd || fallbackWinterStart;

    const schoolEndExclusive = addDaysYmd(endYmd, 1);

    const sem =
      bilanSemester === "S1"
        ? { start: startYmd, endExclusive: splitYmd }
        : { start: splitYmd, endExclusive: schoolEndExclusive };

    const semEndInclusive = addDaysYmd(sem.endExclusive, -1);
    const toInclusive = cutoffYmd < semEndInclusive ? cutoffYmd : semEndInclusive;

    periodSet = toInclusive < sem.start ? new Set<string>() : buildEffectiveCourseSet(sem.start, toInclusive);
  }

  const denom = periodSet.size;

  let ab = 0;
  let rt = 0;
  for (const [ymd, status] of Object.entries(byDate)) {
    if (status !== "AB" && status !== "RT") continue;
    if (!periodSet.has(ymd)) continue;
    if (status === "AB") ab += 1;
    else rt += 1;
  }

  const abPct = denom > 0 ? (ab / denom) * 100 : 0;
  const rtPct = denom > 0 ? (rt / denom) * 100 : 0;

  const tooAb = absencesAlertAbsPct > 0 && abPct >= absencesAlertAbsPct;
  const tooRt = absencesAlertRtPct > 0 && rtPct >= absencesAlertRtPct;

  const midAb = absencesWarnAbsPct > 0 && abPct >= absencesWarnAbsPct;
  const midRt = absencesWarnRtPct > 0 && rtPct >= absencesWarnRtPct;

  const traffic: TrafficLightColor =
    denom === 0 ? "none" : tooAb || tooRt ? "red" : midAb || midRt ? "yellow" : "green";

  return { ab, rt, denom, abPct, rtPct, traffic, periodLabel };
}, [
  selectedClassIdForSuivi,
  selectedStudentForSuivi,
  absencesStore.records,
  bilanSchoolYear,
  bilanPlanningSettings,
  bilanAutoVacationsForKey,
  bilanSemester,
  todayYmd,
  absencesWarnAbsPct,
  absencesAlertAbsPct,
  absencesWarnRtPct,
  absencesAlertRtPct,
]);

const bilanAbsencesTrafficAuto: TrafficLightColor = bilanAbsencesAuto?.traffic ?? "none";

  const bilanAbsencesStorageKey = React.useMemo(() => {
    if (!selectedClassIdForSuivi || !selectedStudentForSuivi) return null;
    return `bilan_absences_${trainingYear}_${bilanSchoolYear}_${selectedClassIdForSuivi}_${selectedStudentForSuivi}_${bilanSemester}`;
  }, [trainingYear, bilanSchoolYear, selectedClassIdForSuivi, selectedStudentForSuivi, bilanSemester]);
  const bilanAbsencesTrafficStorageKey = React.useMemo(() => {
    if (!selectedClassIdForSuivi || !selectedStudentForSuivi) return null;
    return `bilan_absences_traffic_${trainingYear}_${bilanSchoolYear}_${selectedClassIdForSuivi}_${selectedStudentForSuivi}_${bilanSemester}`;
  }, [trainingYear, bilanSchoolYear, selectedClassIdForSuivi, selectedStudentForSuivi, bilanSemester]);

  const bilanAppreciationStorageKey = React.useMemo(() => {
    if (!selectedClassIdForSuivi || !selectedStudentForSuivi) return null;
    return `bilan_appreciation_${trainingYear}_${bilanSchoolYear}_${selectedClassIdForSuivi}_${selectedStudentForSuivi}_${bilanSemester}`;
  }, [trainingYear, bilanSchoolYear, selectedClassIdForSuivi, selectedStudentForSuivi, bilanSemester]);
  // Bootstrap param√®tres g√©n√©raux
  useEffect(() => {
    let cancelled = false;
    (async () => {
      const gs = await loadGeneralSettingsFromStore();
      if (cancelled) return;
      setGeneralSettings(gs);
      setGeneralSettingsBootstrapped(true);
    })();
    return () => { cancelled = true; };
  }, []);

  // Auto-compl√©ter la liste des classes (cl√©s) dans les param√®tres g√©n√©raux
  useEffect(() => {
    if (!generalSettingsBootstrapped) return;
    setGeneralSettings((prev) => {
      const next: GeneralSettings = {
        ...prev,
        classReferents: { ...(prev.classReferents || {}) },
      };
      classGroups.forEach((c) => {
        const k = String(c?.name || "").trim();
        if (!k) return;
        if (typeof next.classReferents[k] !== "string") next.classReferents[k] = "";
      });
      return next;
    });
  }, [classGroups, generalSettingsBootstrapped]);

  // Sauvegarde (debounce l√©ger)
  useEffect(() => {
    if (!generalSettingsBootstrapped) return;
    const t = window.setTimeout(() => {
      saveGeneralSettingsToStore(generalSettings).catch(() => {});
    }, 250);
    return () => window.clearTimeout(t);
  }, [generalSettings, generalSettingsBootstrapped]);



  useEffect(() => {
    try {
      if (typeof window === "undefined") return;
      if (!bilanAppreciationStorageKey) {
        setBilanAppreciationNote("");
        return;
      }
      const raw = localStorage.getItem(bilanAppreciationStorageKey);
      setBilanAppreciationNote(raw ?? "");
    } catch {
      setBilanAppreciationNote("");
    }
  }, [bilanAppreciationStorageKey]);

  useEffect(() => {
    try {
      if (typeof window === "undefined") return;
      if (!bilanAppreciationStorageKey) return;
      localStorage.setItem(bilanAppreciationStorageKey, bilanAppreciationNote ?? "");
    } catch {}
  }, [bilanAppreciationStorageKey, bilanAppreciationNote]);



  useEffect(() => {
    try {
      if (typeof window === "undefined") return;
      if (!bilanAbsencesStorageKey) {
        setBilanAbsencesNote("");
        return;
      }
      const raw = localStorage.getItem(bilanAbsencesStorageKey);
      setBilanAbsencesNote(raw ?? "");
    } catch {
      setBilanAbsencesNote("");
    }
  }, [bilanAbsencesStorageKey]);

  useEffect(() => {
    try {
      if (typeof window === "undefined") return;
      if (!bilanAbsencesStorageKey) return;
      localStorage.setItem(bilanAbsencesStorageKey, bilanAbsencesNote ?? "");
    } catch {}
  }, [bilanAbsencesStorageKey, bilanAbsencesNote]);
  useEffect(() => {
    try {
      if (typeof window === "undefined") return;
      if (!bilanAbsencesTrafficStorageKey) {
        setBilanAbsencesTraffic("none");
        return;
      }
      const raw = localStorage.getItem(bilanAbsencesTrafficStorageKey);
      const v = raw as TrafficLightColor | null;
      if (v === "red" || v === "yellow" || v === "green" || v === "none") setBilanAbsencesTraffic(v);
      else setBilanAbsencesTraffic("none");
    } catch {
      setBilanAbsencesTraffic("none");
    }
  }, [bilanAbsencesTrafficStorageKey]);

  useEffect(() => {
    try {
      if (typeof window === "undefined") return;
      if (!bilanAbsencesTrafficStorageKey) return;
      localStorage.setItem(bilanAbsencesTrafficStorageKey, bilanAbsencesTraffic ?? "none");
    } catch {}
  }, [bilanAbsencesTrafficStorageKey, bilanAbsencesTraffic]);


  // Vue "√âvolutions" : param√®tres (persist√©s en localStorage)
  const [evolutionSettingsOpen, setEvolutionSettingsOpen] = useState(false);
  const [evolutionCapLine, setEvolutionCapLine] = useState<number>(() => {
    try {
      const raw = typeof window !== "undefined" ? localStorage.getItem("evolution_settings") : null;
      const parsed = raw ? JSON.parse(raw) : null;
      const v = parsed?.capLine;
      if (typeof v === "number" && isFinite(v)) return Math.max(0, Math.min(20, v));
    } catch {}
    return 10;
  });
  const [evolutionGroupMode, setEvolutionGroupMode] = useState<"activite" | "ep">(() => {
    try {
      const raw = typeof window !== "undefined" ? localStorage.getItem("evolution_settings") : null;
      const parsed = raw ? JSON.parse(raw) : null;
      const v = parsed?.groupMode;
      if (v === "ep" || v === "activite") return v;
    } catch {}
    return "activite";
  });

  const [evolutionCardsPerRow, setEvolutionCardsPerRow] = useState<number>(() => {
    try {
      const raw = typeof window !== "undefined" ? localStorage.getItem("evolution_settings") : null;
      const parsed = raw ? JSON.parse(raw) : null;
      const v = parsed?.cardsPerRow;
      if (typeof v === "number" && isFinite(v)) return Math.max(1, Math.min(10, Math.round(v)));
    } catch {}
    return 3;
  });

const [evolutionShowDevoirs, setEvolutionShowDevoirs] = useState<boolean>(() => {
  try {
    const raw = typeof window !== "undefined" ? localStorage.getItem("evolution_settings") : null;
    const parsed = raw ? JSON.parse(raw) : null;
    const v = parsed?.showDevoirs;
    if (typeof v === "boolean") return v;
  } catch {}
  return true;
});

  useEffect(() => {
    try {
      if (typeof window === "undefined") return;
      localStorage.setItem(
        "evolution_settings",
        JSON.stringify({ capLine: evolutionCapLine, groupMode: evolutionGroupMode, cardsPerRow: evolutionCardsPerRow, showDevoirs: evolutionShowDevoirs })
      );
    } catch {}
  }, [evolutionCapLine, evolutionGroupMode, evolutionCardsPerRow, evolutionShowDevoirs]);
  const [classeSemesterForSuivi, setClasseSemesterForSuivi] = useState<SemesterKey>("S1");
  const [selectedEvalIdForClasse, setSelectedEvalIdForClasse] = useState<string | null>(null);
  const [showTasksVolet, setShowTasksVolet] = useState(false);
  const [activeView, setActiveView] = useState<"evaluation" | "suivi" | "suivi_eleves" | "notes" | "ccf">("evaluation");

const [suiviElevesMode, setSuiviElevesMode] = useState<"docs" | "absences">("docs");
const isDocsView = activeView === "suivi_eleves" && suiviElevesMode === "docs";
const isAbsencesView = activeView === "suivi_eleves" && suiviElevesMode === "absences";


// =======================
// CCF (livret) ‚Äî fiches d'√©valuation par √©l√®ve
// =======================
type CcfLevel = "NON" | "0" | "1" | "2" | "3";
type CcfEpKey = "EP1" | "EP2A1" | "EP2A2" | "EP3"; // "EP1" | "EP2A1" | "EP2A2" | "EP3"

type CcfEvalRow = {
  epKey: CcfEpKey;
  ref: string;
  epreuve: string;
  unite?: string;
  coef: number;
  mode?: string;
  duree?: string;
  // Styles (issus du fichier Excel "Evaluation")
  bgColor?: string;
  fontColor?: string;
};

const CCF_EVALUATION_FALLBACK: CcfEvalRow[] = [
  {
    epKey: "EP1",
    ref: "EP1",
    epreuve: "√âtude et pr√©paration d‚Äôune intervention",
    unite: "UP1",
    coef: 4,
    mode: "CCF",
    duree: "Environ 3h",
  },
  {
    epKey: "EP2A1",
    ref: "EP2 A1",
    epreuve: "R√©alisation et contr√¥le de travaux courants ‚Äî Situation 1 (en centre)",
    unite: "UP2",
    coef: 4,
    mode: "CCF",
    duree: "Environ 15h",
  },
  {
    epKey: "EP2A2",
    ref: "EP2 A2",
    epreuve: "R√©alisation et contr√¥le de travaux courants ‚Äî Situation 2 (en entreprise)",
    unite: "UP2",
    coef: 4,
    mode: "CCF",
    duree: "Environ 14h",
  },
  {
    epKey: "EP3",
    ref: "EP3",
    epreuve: "R√©alisation de travaux sp√©cifiques",
    unite: "UP3",
    coef: 2,
    mode: "CCF",
    duree: "Environ 3h",
  },
];
type CcfStudentSheet = {
  meta?: { date?: string; contexte?: string; evaluator?: string; comment?: string; noteProposee?: string };
  levels: Record<string, CcfLevel | undefined>; // itemCode -> level
};
// DB par √©l√®ve : toutes les EP ne sont pas forc√©ment renseign√©es d√®s le d√©part.
// On utilise donc un Partial pour √©viter les erreurs TypeScript lors des mises √† jour.
type CcfDb = Record<string, Partial<Record<CcfEpKey, CcfStudentSheet>>>; // studentName -> EP -> sheet

const CCF_DB_KEY = "ccf_db_v1";

const [ccfSelectedClassId, setCcfSelectedClassId] = useState<string | null>(null);
const [ccfSelectedStudentName, setCcfSelectedStudentName] = useState<string | null>(null);
const [ccfEpKey, setCcfEpKey] = useState<CcfEpKey>("EP1");
const [ccfDb, setCcfDb] = useState<CcfDb>(() => {
  try {
    const raw = localStorage.getItem(CCF_DB_KEY);
    return raw ? (JSON.parse(raw) as CcfDb) : {};
  } catch {
    return {};
  }
});


// Sous-onglets CCF + param√®tres globaux
type CcfCcfTab = CcfEpKey | "EVALUATION"; // EP1 | EP2A1 | EP2A2 | EP3 | EVALUATION
type CcfGlobalSettings = {
  date?: string;        // date d'√©valuation (par d√©faut)
  evaluator?: string;   // √©valuateur (par d√©faut)
  center?: string;      // centre / √©tablissement
  session?: string;     // session (optionnel)
};

const CCF_TAB_KEY = "ccf_tab_v1";
const CCF_SETTINGS_KEY = "ccf_settings_v1";
const CCF_REG_NOTES_KEY = "ccf_reg_notes_v1";
const CCF_EP_PARAMS_OPEN_KEY = "ccf_ep_params_open_v1";
const CCF_EXCEL_PATH_KEY = "ccf_excel_path_v1";

const [ccfTab, setCcfTab] = useState<CcfCcfTab>(() => {
  try {
    const saved = localStorage.getItem(CCF_TAB_KEY);
    if (saved === "EP1" || saved === "EP2A1" || saved === "EP2A2" || saved === "EP3" || saved === "EVALUATION") return saved as CcfCcfTab;
    // üß© Migration : anciens onglets (reglementation / fiches / recap) -> EP1
    return "EP1";
  } catch {
    return "EP1";
  }
});

// Source Excel (livret national) pour l'onglet CCF
const [ccfExcelPath, setCcfExcelPath] = useState<string | null>(() => {
  try {
    return localStorage.getItem(CCF_EXCEL_PATH_KEY);
  } catch {
    return null;
  }
});

// Templates CCF actifs : soit issus de l'Excel branch√©, soit fallback embarqu√©
const [ccfTemplates, setCcfTemplates] = useState<CcfTemplates>(() => CCF_TEMPLATES);
const [ccfEvaluationRows, setCcfEvaluationRows] = useState<CcfEvalRow[]>(() => CCF_EVALUATION_FALLBACK);


// Export JSON CCF (par classe)
const [ccfExportBusy, setCcfExportBusy] = useState(false);

const handleExportCcfJsonForSelectedClass = async () => {
  if (!ccfSelectedClassId) {
    alert("S√©lectionne d‚Äôabord une classe dans CCF.");
    return;
  }

  setCcfExportBusy(true);
  try {
    const students = getStudentsForClassCCF(ccfSelectedClassId);

    const ccfDbForClass: CcfDb = {};
    for (const st of students) {
      if (ccfDb[st]) ccfDbForClass[st] = ccfDb[st];
    }

    const payload = {
      schema: "ccf_export_v1",
      exportedAt: new Date().toISOString(),
      classId: ccfSelectedClassId,
      students,
      ccfSettings: ccfSettings || {},
      ccfExcelPath: ccfExcelPath || null,
      ccfEvaluationRows,
      ccfDb: ccfDbForClass,
    };

    const fileName = `CCF_${sanitizeFileNamePart(String(ccfSelectedClassId))}_${tsForFileName()}.json`;

    if (isTauriRuntime()) {
      const pickedPath = await save({
        title: "Enregistrer l‚Äôexport CCF",
        defaultPath: fileName,
        filters: [{ name: "CCF (JSON)", extensions: ["json"] }],
      });
      if (!pickedPath) return;

      const dest = ensureJsonFileName(String(pickedPath));
      await writeTextFile(dest, safeJsonStringify(payload, 2));
      alert(`‚úÖ Export CCF cr√©√© : ${dest}`);
      return;
    }

    // Mode Web/dev : t√©l√©chargement direct
    const blob = new Blob([safeJsonStringify(payload, 2)], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = fileName;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
    alert("‚úÖ Export CCF t√©l√©charg√©.");
  } catch (e) {
    console.error(e);
    alert("Erreur pendant l‚Äôexport CCF.");
  } finally {
    setCcfExportBusy(false);
  }
};

useEffect(() => {
  try {
    if (!ccfExcelPath) localStorage.removeItem(CCF_EXCEL_PATH_KEY);
    else localStorage.setItem(CCF_EXCEL_PATH_KEY, ccfExcelPath);
  } catch {
    // ignore
  }
}, [ccfExcelPath]);

function parseEpSheet(ws: ExcelJS.Worksheet, theme?: { colors: (string | null)[] }) {
  type TmpStyle = { bgColor?: string; fontColor?: string };
  type TmpItem = { code: string; label: string; criteria: string; realWeight: number } & TmpStyle;
  type TmpGroup = { code: string; title: string; items: TmpItem[] } & TmpStyle;

  const groups: any[] = [];
  let current: TmpGroup | null = null;

  const isGroup = (b: string) => /^C\d+(?:\.\d+)+\s*:\s*/.test(b);
  const isItem = (b: string) => /^C\d+(?:\.\d+)+\.\d+$/.test(b);

  const cellText = (cell: any): string => {
    try {
      const master = (cell as any)?.master ?? cell;
      const t = (master as any)?.text;
      if (t != null && String(t).trim() !== "") return String(t);
      const v = (master as any)?.value;
      if (v == null) return "";
      if (typeof v === "string" || typeof v === "number" || typeof v === "boolean") return String(v);
      if (typeof v === "object" && (v as any).result != null) return String((v as any).result);
      if (typeof v === "object" && Array.isArray((v as any).richText)) {
        return (v as any).richText.map((x: any) => x?.text ?? "").join("");
      }
      return String(v);
    } catch {
      return "";
    }
  };

  const cellNumber = (cell: any): number => {
    const master = (cell as any)?.master ?? cell;
    const v = (master as any)?.value;
    if (typeof v === "number" && isFinite(v)) return v;
    const raw = cellText(master).replace(/\s+/g, "").replace(",", ".");
    const n = Number(raw);
    return isFinite(n) ? n : 0;
  };

  const hex2rgb = (hex: string) => {
    const h = hex.replace(/^#/, "");
    const r = parseInt(h.slice(0, 2), 16);
    const g = parseInt(h.slice(2, 4), 16);
    const b = parseInt(h.slice(4, 6), 16);
    return { r, g, b };
  };
  const rgb2hex = ({ r, g, b }: { r: number; g: number; b: number }) =>
    "#" +
    [r, g, b]
      .map((n) => Math.max(0, Math.min(255, Math.round(n))).toString(16).padStart(2, "0"))
      .join("")
      .toUpperCase();

  // OOXML tint: <0 darken, >0 lighten
  const applyTint = (hex: string, tint?: number) => {
    if (typeof tint !== "number" || Number.isNaN(tint) || tint === 0) return hex;
    const { r, g, b } = hex2rgb(hex);
    const f = (c: number) => {
      if (tint < 0) return c * (1 + tint);
      return c + (255 - c) * tint;
    };
    return rgb2hex({ r: f(r), g: f(g), b: f(b) });
  };

  const argbToHex = (argb?: string): string | undefined => {
    if (!argb) return undefined;
    const s = String(argb).replace(/^#/, "").toUpperCase();
    if (s.length === 8) return `#${s.slice(2)}`;
    if (s.length === 6) return `#${s}`;
    return undefined;
  };

  const colorToHex = (color: any): string | undefined => {
    if (!color) return undefined;
    if (color.argb) return argbToHex(color.argb);
    if (typeof color.theme === "number" && theme?.colors) {
      const base = theme.colors[color.theme] || null;
      if (base) return applyTint(base, color.tint);
    }
    return undefined;
  };

  const extractStyle = (cell: any): TmpStyle => {
    try {
      const master = (cell as any)?.master ?? cell;
      const fill = (master as any)?.fill;
      const font = (master as any)?.font;

      const bg =
        colorToHex(fill?.fgColor) ||
        colorToHex(fill?.bgColor) ||
        undefined;

      const fg = colorToHex(font?.color) || undefined;

      const out: TmpStyle = {};
      if (bg) out.bgColor = bg;
      if (fg) out.fontColor = fg;
      return out;
    } catch {
      return {};
    }
  };

  const pickStyledCell = (row: ExcelJS.Row) => {
    // Dans ce livret, les couleurs sont souvent appliqu√©es sur C / F / ou sur une cellule fusionn√©e.
    const candidates = [2, 3, 6, 16].map((i) => row.getCell(i));
    for (const c of candidates) {
      const st = extractStyle(c);
      if (st.bgColor || st.fontColor) return { cell: c, st };
    }
    return { cell: row.getCell(2), st: extractStyle(row.getCell(2)) };
  };

  const flush = () => {
    if (!current || !current.items.length) return;
    const sum = current.items.reduce((s, it) => s + (it.realWeight || 0), 0);
    const groupPoints = (sum / 100) * 20;
    groups.push({
      code: current.code,
      title: current.title,
      bgColor: current.bgColor,
      fontColor: current.fontColor,
      groupPoints,
      items: current.items.map((it) => ({
        bgColor: it.bgColor,
        fontColor: it.fontColor,
        ...it,
        relative: sum ? (it.realWeight || 0) / sum : 0,
      })),
    });
  };

  ws.eachRow({ includeEmpty: true }, (row) => {
    const b = String(cellText(row.getCell(2)) ?? "").trim();
    const c = String(cellText(row.getCell(3)) ?? "").trim();
    const f = String(cellText(row.getCell(6)) ?? "").trim();
    const p = cellNumber(row.getCell(16));

    if (!b) return;

    if (isGroup(b)) {
      flush();
      const [codePart, ...rest] = b.split(":");
      const { st } = pickStyledCell(row);
      current = {
        code: (codePart ?? "").trim().replace(/\u00A0/g, " "),
        title: rest.join(":").trim(),
        items: [],
        ...st,
      };
      return;
    }

    if (current && isItem(b) && p > 0) {
      const { st } = pickStyledCell(row);
      current.items.push({
        code: b,
        label: c,
        criteria: f,
        realWeight: p,
        ...st,
      });
    }
  });

  flush();
  return groups;
}

async function importCcfTemplatesFromExcel(path: string) {
  const bytes = await readFile(path);

  const ab =
    bytes instanceof Uint8Array
      ? bytes.buffer.slice(bytes.byteOffset, bytes.byteOffset + bytes.byteLength)
      : (bytes as any);

  // --- Theme parsing (pour r√©soudre fgColor.theme + tint) ---
  const theme = { colors: Array(12).fill(null) as (string | null)[] };

  try {
    const zip = await (JSZip as any).loadAsync(ab as any);
    const themeFile =
      zip.file("xl/theme/theme1.xml") || zip.file("xl/theme/theme.xml");
    const xml = themeFile ? await themeFile.async("string") : "";

    // R√©cup√©ration du clrScheme: dk1, lt1, dk2, lt2, accent1-6, hlink, folHlink
    const pick = (tag: string) => {
      const m = xml.match(new RegExp(`<a:${tag}[^>]*>[\\s\\S]*?<a:srgbClr[^>]*val="([0-9A-Fa-f]{6})"`, "m"));
      return m ? `#${m[1].toUpperCase()}` : null;
    };

    // index selon OOXML: 0=lt1,1=dk1,2=lt2,3=dk2,4=accent1..9=accent6,10=hlink,11=folHlink
    theme.colors[0] = pick("lt1");
    theme.colors[1] = pick("dk1");
    theme.colors[2] = pick("lt2");
    theme.colors[3] = pick("dk2");
    theme.colors[4] = pick("accent1");
    theme.colors[5] = pick("accent2");
    theme.colors[6] = pick("accent3");
    theme.colors[7] = pick("accent4");
    theme.colors[8] = pick("accent5");
    theme.colors[9] = pick("accent6");
    theme.colors[10] = pick("hlink");
    theme.colors[11] = pick("folHlink");
  } catch {
    // si le th√®me est illisible, on reste en "sans th√®me"
  }

  const wb = new ExcelJS.Workbook();
  await wb.xlsx.load(ab as any);

  const norm = (s: string) => s.replace(/\s+/g, " ").trim().toLowerCase();
  const findSheet = (name: string) =>
    wb.worksheets.find((w) => norm(w.name) === norm(name));

  const get = (name: string) => {
    const ws = findSheet(name);
    if (!ws) throw new Error(`Feuille manquante dans l'Excel: ${name}`);
    return parseEpSheet(ws, theme);
  };

  return {
    EP1: get("EP1"),
    EP2A1: get("EP2 A1"),
    EP2A2: get("EP2 A2"),
    EP3: get("EP3"),
  } as unknown as CcfTemplates;
}



async function importCcfEvaluationFromExcel(path: string): Promise<CcfEvalRow[]> {
  try {
    const bytes = await readFile(path);

    const wb = new ExcelJS.Workbook();
    const ab =
      bytes instanceof Uint8Array
        ? bytes.buffer.slice(bytes.byteOffset, bytes.byteOffset + bytes.byteLength)
        : (bytes as any);

    // --- Theme parsing (pour r√©soudre fgColor.theme + tint) ---
    const theme = { colors: Array(12).fill(null) as (string | null)[] };

    try {
      const zip = await (JSZip as any).loadAsync(ab as any);
      const themeFile =
        zip.file("xl/theme/theme1.xml") || zip.file("xl/theme/theme.xml");
      const xml = themeFile ? await themeFile.async("string") : "";

      const pick = (tag: string) => {
        const m = xml.match(new RegExp(`<a:${tag}[^>]*>[\s\S]*?<a:srgbClr[^>]*val="([0-9A-Fa-f]{6})"`, "m"));
        return m ? `#${m[1].toUpperCase()}` : null;
      };

      // index OOXML: 0=lt1,1=dk1,2=lt2,3=dk2,4..9=accent1..6,10=hlink,11=folHlink
      theme.colors[0] = pick("lt1");
      theme.colors[1] = pick("dk1");
      theme.colors[2] = pick("lt2");
      theme.colors[3] = pick("dk2");
      theme.colors[4] = pick("accent1");
      theme.colors[5] = pick("accent2");
      theme.colors[6] = pick("accent3");
      theme.colors[7] = pick("accent4");
      theme.colors[8] = pick("accent5");
      theme.colors[9] = pick("accent6");
      theme.colors[10] = pick("hlink");
      theme.colors[11] = pick("folHlink");
    } catch {
      // th√®me illisible ‚Üí fallback sans th√®me
    }

    await wb.xlsx.load(ab as any);

    const norm = (s: string) => s.replace(/\s+/g, " ").trim().toLowerCase();
    const ws = wb.worksheets.find((w) => norm(w.name) === norm("Evaluation"));
    if (!ws) return CCF_EVALUATION_FALLBACK;

    const getText = (cell: any) => {
      const v = cell?.value as any;
      if (v == null) return "";
      if (typeof v === "object" && (v as any).richText) {
        return (v as any).richText.map((x: any) => x.text).join("");
      }
      return String(v);
    };


    // --- Style extraction (bg + font) ---
    const hex2rgb = (hex: string) => {
      const h = hex.replace("#", "");
      const r = parseInt(h.slice(0, 2), 16);
      const g = parseInt(h.slice(2, 4), 16);
      const b = parseInt(h.slice(4, 6), 16);
      return { r, g, b };
    };
    const rgb2hex = (rgb: { r: number; g: number; b: number }) => {
      const clamp = (n: number) => Math.max(0, Math.min(255, Math.round(n)));
      const to2 = (n: number) => clamp(n).toString(16).padStart(2, "0").toUpperCase();
      return `#${to2(rgb.r)}${to2(rgb.g)}${to2(rgb.b)}`;
    };
    const applyTint = (hex: string, tint?: number) => {
      if (typeof tint !== "number" || Number.isNaN(tint) || tint === 0) return hex;
      const { r, g, b } = hex2rgb(hex);
      const f = (c: number) => {
        if (tint < 0) return c * (1 + tint);
        return c + (255 - c) * tint;
      };
      return rgb2hex({ r: f(r), g: f(g), b: f(b) });
    };
    const argbToHex = (argb?: string): string | undefined => {
      if (!argb) return undefined;
      const s = String(argb).replace(/^#/, "").toUpperCase();
      if (s.length === 8) return `#${s.slice(2)}`;
      if (s.length === 6) return `#${s}`;
      return undefined;
    };
    const colorToHex = (color: any): string | undefined => {
      if (!color) return undefined;
      if (color.argb) return argbToHex(color.argb);
      if (typeof color.theme === "number" && theme?.colors) {
        const base = theme.colors[color.theme] || null;
        if (base) return applyTint(base, color.tint);
      }
      return undefined;
    };
    const extractStyle = (cell: any): { bgColor?: string; fontColor?: string } => {
      try {
        const master = (cell as any)?.master ?? cell;
        const fill = (master as any)?.fill;
        const font = (master as any)?.font;

        const bg = colorToHex(fill?.fgColor) || colorToHex(fill?.bgColor) || undefined;
        const fg = colorToHex(font?.color) || undefined;

        const out: { bgColor?: string; fontColor?: string } = {};
        if (bg) out.bgColor = bg;
        if (fg) out.fontColor = fg;
        return out;
      } catch {
        return {};
      }
    };
    const pickRowStyle = (row: any) => {
      const candidates = [4, 5, 7, 8, 9, 10, 11, 12].map((i) => row.getCell(i));
      for (const c of candidates) {
        const st = extractStyle(c);
        if (st.bgColor || st.fontColor) return st;
      }
      return {};
    };

    const rowsByRef: Record<string, any> = {};
    ws.eachRow({ includeEmpty: true }, (row) => {
      const ref = getText(row.getCell(4)).trim(); // D
      if (ref) rowsByRef[ref] = row;
    });

    const rowEP1 = rowsByRef["EP1"];
    const rowEP2A = rowsByRef["EP2 A"];

    let rowSit1: any = null;
    let rowSit2: any = null;
    ws.eachRow({ includeEmpty: true }, (row) => {
      const lib = getText(row.getCell(5)).trim(); // E
      if (/Situation\s*1/i.test(lib)) rowSit1 = row;
      if (/Situation\s*2/i.test(lib)) rowSit2 = row;
    });

    const unitEP2 = rowEP2A ? getText(rowEP2A.getCell(7)).trim() : "UP2";

    const mk = (
      epKey: CcfEpKey,
      ref: string,
      epreuve: string,
      unite: string | undefined,
      coef: number,
      mode: string | undefined,
      duree: string | undefined,
      st?: { bgColor?: string; fontColor?: string }
    ): CcfEvalRow => ({
      epKey,
      ref,
      epreuve,
      unite,
      coef,
      mode,
      duree,
      ...(st || {}),
    });

    const out: CcfEvalRow[] = [];

if (rowEP1) {
  out.push(
    mk(
      "EP1",
      "EP1",
      getText(rowEP1.getCell(5)).trim(),
      getText(rowEP1.getCell(7)).trim(),
      Number(getText(rowEP1.getCell(8)).trim() || 0),
      getText(rowEP1.getCell(9)).trim(),
      getText(rowEP1.getCell(10)).trim(),
      pickRowStyle(rowEP1) // ‚úÖ ici
    )
  );
}

if (rowSit1) {
  out.push(
    mk(
      "EP2A1",
      "EP2 A1",
      `R√©alisation et contr√¥le de travaux courants ‚Äî ${getText(rowSit1.getCell(5)).trim()}`,
      unitEP2 || "UP2",
      Number(getText(rowSit1.getCell(8)).trim() || 0),
      getText(rowSit1.getCell(9)).trim(),
      getText(rowSit1.getCell(10)).trim(),
      pickRowStyle(rowSit1) // ‚úÖ ici
    )
  );
}

if (rowSit2) {
  out.push(
    mk(
      "EP2A2",
      "EP2 A2",
      `R√©alisation et contr√¥le de travaux courants ‚Äî ${getText(rowSit2.getCell(5)).trim()}`,
      unitEP2 || "UP2",
      Number(getText(rowSit2.getCell(8)).trim() || 0),
      getText(rowSit2.getCell(9)).trim(),
      getText(rowSit2.getCell(10)).trim(),
      pickRowStyle(rowSit2) // ‚úÖ ici
    )
  );
}

const rowEP3 = rowsByRef["EP3"];
if (rowEP3) {
  out.push(
    mk(
      "EP3",
      "EP3",
      getText(rowEP3.getCell(5)).trim(),
      getText(rowEP3.getCell(7)).trim(),
      Number(getText(rowEP3.getCell(8)).trim() || 0),
      getText(rowEP3.getCell(9)).trim(),
      getText(rowEP3.getCell(10)).trim(),
      pickRowStyle(rowEP3) // ‚úÖ ici
    )
  );
}


    if (out.length !== 4 || out.some((r) => !r.coef)) return CCF_EVALUATION_FALLBACK;
    return out;
  } catch {
    return CCF_EVALUATION_FALLBACK;
  }
}

async function linkCcfExcel() {
  const p = await open({
    multiple: false,
    filters: [{ name: "Excel", extensions: ["xlsx", "xlsm", "xls"] }],
  });
  if (typeof p === "string") {
    setCcfExcelPath(p);
  }
}

function unlinkCcfExcel() {
  setCcfExcelPath(null);
  setCcfTemplates(CCF_TEMPLATES);
  setCcfEvaluationRows(CCF_EVALUATION_FALLBACK);
}

// Auto-refresh : si l'Excel change, l'onglet CCF se met √† jour
useEffect(() => {
  if (!ccfExcelPath) return;

  let stopped = false;
  let lastMtime = 0;

  const tick = async () => {
    try {
      const meta = await stat(ccfExcelPath);
      const mtime = meta?.mtime ? new Date(meta.mtime).getTime() : 0;
      if (mtime && mtime !== lastMtime) {
        lastMtime = mtime;
        const tpl = await importCcfTemplatesFromExcel(ccfExcelPath);
        const evr = await importCcfEvaluationFromExcel(ccfExcelPath);
        if (!stopped) {
          setCcfTemplates(tpl);
          setCcfEvaluationRows(evr);
        }
      }
    } catch {
      // Excel introuvable/d√©plac√© : on ne force pas le unlink pour √©viter les surprises
    }
  };

  tick();
  const id = setInterval(tick, 1500);

  return () => {
    stopped = true;
    clearInterval(id);
  };
}, [ccfExcelPath]);


// Sync : les onglets CCF pilotent directement l'√©preuve (EP1/EP2A1/EP2A2/EP3)
useEffect(() => {
  setCcfEpKey(ccfTab as CcfEpKey);
}, [ccfTab]);

const [ccfSettings, setCcfSettings] = useState<CcfGlobalSettings>(() => {
  try {
    const raw = localStorage.getItem(CCF_SETTINGS_KEY);
    return raw ? (JSON.parse(raw) as CcfGlobalSettings) : {};
  } catch {
    return {};
  }
});

const [ccfRegNotes, setCcfRegNotes] = useState<string>(() => {
  try {
    return localStorage.getItem(CCF_REG_NOTES_KEY) || "";
  } catch {
    return "";
  }
});

// Ouverture/fermeture du panneau "Param√®tres de l'√©preuve" dans Fiches d'√©valuations
const [ccfEpParamsOpen, setCcfEpParamsOpen] = useState<boolean>(() => {
  try {
    const raw = localStorage.getItem(CCF_EP_PARAMS_OPEN_KEY);
    if (raw === "0") return false;
    if (raw === "1") return true;
  } catch {}
  return true;
});

useEffect(() => {
  try {
    localStorage.setItem(CCF_TAB_KEY, ccfTab);
  } catch {}
}, [ccfTab]);

useEffect(() => {
  try {
    localStorage.setItem(CCF_SETTINGS_KEY, JSON.stringify(ccfSettings || {}));
  } catch {}
}, [ccfSettings]);

useEffect(() => {
  try {
    localStorage.setItem(CCF_REG_NOTES_KEY, ccfRegNotes || "");
  } catch {}
}, [ccfRegNotes]);

useEffect(() => {
  try {
    localStorage.setItem(CCF_EP_PARAMS_OPEN_KEY, ccfEpParamsOpen ? "1" : "0");
  } catch {}
}, [ccfEpParamsOpen]);
useEffect(() => {
  try {
    localStorage.setItem(CCF_DB_KEY, JSON.stringify(ccfDb));
  } catch {
    // ignore
  }
}, [ccfDb]);

function ccfFraction(level: CcfLevel | undefined): number | null {
  if (!level) return null;
  if (level === "NON") return null;
  if (level === "0") return 0;
  if (level === "1") return 1 / 3;
  if (level === "2") return 2 / 3;
  return 1;
}

function ccfLevelLabel(level: CcfLevel): string {
  // Affichage compact dans le tableau (NON, 0, 1, 2, 3).
  return level;
}

function ccfLevelButtonClass(level: CcfLevel, active: boolean): string {
  // Base styles keep consistent sizing; color indicates level.
  const base = "px-2 py-1 rounded-md border text-[11px] font-semibold min-w-[44px]";
  const palette =
    level === "NON"
      ? active
        ? "bg-neutral-800 text-white border-neutral-700 dark:bg-neutral-200/20 dark:text-neutral-50 dark:border-neutral-200/30"
        : "bg-white dark:bg-[var(--night-base)] text-neutral-800 dark:text-neutral-100 border-neutral-200 dark:border-sky-400/35 hover:bg-neutral-100/70 dark:hover:bg-neutral-200/10"
      : level === "0"
        ? active
          ? "bg-red-600 text-white border-red-700"
          : "bg-red-50 text-red-800 border-red-200 hover:bg-red-100"
        : level === "1"
          ? active
            ? "bg-orange-600 text-white border-orange-700"
            : "bg-orange-50 text-orange-800 border-orange-200 hover:bg-orange-100"
          : level === "2"
            ? active
              ? "bg-lime-600 text-white border-lime-700"
              : "bg-lime-50 text-lime-800 border-lime-200 hover:bg-lime-100"
            : active
              ? "bg-green-600 text-white border-green-700"
              : "bg-green-50 text-green-800 border-green-200 hover:bg-green-100";

  return classNames(base, palette);
}


function getStudentsForClassCCF(classId: string | null): string[] {
  if (!classId) return [];
  const classe = classGroups.find((c) => (c.id ?? c.name) === classId || c.name === classId);
  if (!classe) return [];
  return String(classe.students || "")
    .split(/\r?\n/)
    .map((s) => s.trim())
    .filter(Boolean);
}

function __normEpKey(ep: any): string {
  return String(ep || "").replace(/\s+/g, "");
}

function getCcfSheet(studentName: string, ep: any): CcfStudentSheet {
  const k = __normEpKey(ep) as CcfEpKey;
  return ccfDb?.[studentName]?.[k] ?? { meta: {}, levels: {} };
}

function setCcfSheet(studentName: string, ep: any, next: CcfStudentSheet) {
  const k = __normEpKey(ep) as CcfEpKey;
  setCcfDb((prev) => ({
    ...prev,
    [studentName]: {
      ...(prev[studentName] || {}),
      [k]: next,
    },
  }));
}

function computeCcfTotal(studentName: string, ep: any) {
  const k = __normEpKey(ep) as CcfEpKey;
  const tplRaw: any = (ccfTemplates?.[k] ?? (CCF_TEMPLATES as any)[k] ?? []);
  const tpl = Array.isArray(tplRaw) ? tplRaw : [];
  const sheet = getCcfSheet(studentName, k);

  let total = 0;
  const groupDetails = tpl.map((g: any) => {
    const itemsArr = Array.isArray(g?.items) ? g.items : [];
    const included = itemsArr
      .map((it: any) => {
        const frac = ccfFraction(sheet.levels?.[it.code] as CcfLevel | undefined);
        return { it, frac };
      })
      .filter((x: any) => x.frac !== null);

    const sumR = included.reduce((a: number, b: any) => a + (b.it.realWeight || 0), 0);
    const sumPoints = included.reduce((a: number, b: any) => a + (b.frac as number) * (b.it.realWeight || 0), 0);
    const groupScore = sumR > 0 ? (sumPoints / sumR) * (g.groupPoints || 0) : 0;

    total += groupScore;
    return { code: g.code, title: g.title, groupPoints: g.groupPoints || 0, groupScore };
  });

  return { total, groupDetails };
}


  const [helpOpen, setHelpOpen] = useState(() => {
    try {
      return localStorage.getItem("first_run_help_dismissed") !== "1";
    } catch {
      return true;
    }
  });
  const [notesMode, setNotesMode] = useState<"devoirs" | "tableau" | "notation">("tableau");
  // S√©lections propres √† la vue NOTE (notation comp√©tences)
  const [selectedNoteStudent, setSelectedNoteStudent] = useState<string | null>(null);
  const [selectedNoteEvalId, setSelectedNoteEvalId] = useState<string | null>(null);

  // Notation crit√©ri√©e : poids par exigence + niveau 1..4
  const [notationWeights, setNotationWeights] = useState<Record<string, number>>({});

  // Scores "g√©n√©raux" du devoir (pr√©visualisation dans DEVOIR)
  const [notationScores, setNotationScores] = useState<Record<string, number>>({});

  // Scores par √©l√®ve (onglet NOTE ‚Üí Notation comp√©tences)
  const [studentNotationScores, setStudentNotationScores] = useState<Record<string, number>>({});
  const getWeight = (key: string) => notationWeights[key] ?? 1;
  const [engagementLevel, setEngagementLevel] = useState<EngagementLevel | null>(null);

  // üîÅ Charger la notation d'un √©l√®ve pour un devoir
const loadCurrentStudentNotation = React.useCallback(() => {
  if (!selectedClassIdForSuivi) return;
  if (!selectedNoteEvalId) return;

  if (!selectedNoteStudent) {
    // pas d'√©l√®ve s√©lectionn√© ‚Üí on vide uniquement la grille √©l√®ve
    setStudentNotationScores({});
    setEngagementLevel(null);
    return;
  }

  const schoolYear = getCurrentSchoolYear();
  const className = selectedClassIdForSuivi;
  const studentName = selectedNoteStudent;

  const yearBucket = notationDB[schoolYear] || {};
  const classBucket = yearBucket[className] || {};
  const evalBucket = classBucket[selectedNoteEvalId] || {};
  const entry = (evalBucket as Record<string, NotationEntry>)[studentName];

  if (entry && entry.scoresByCriteria) {
    setStudentNotationScores(entry.scoresByCriteria);
    setEngagementLevel(entry.engagementLevel ?? "normal");
  } else {
    setStudentNotationScores({});
    setEngagementLevel("normal");
  }
}, [
  notationDB,
  selectedClassIdForSuivi,
  selectedNoteEvalId,
  selectedNoteStudent,
]);

useEffect(() => {
  if (activeView !== "notes") return;
  // D√®s qu'on est dans NOTE (tableau ou notation), on recharge l'√©l√®ve courant
  loadCurrentStudentNotation();
}, [
  activeView,
  notesMode,
  selectedClassIdForSuivi,
  selectedNoteEvalId,
  selectedNoteStudent,
  loadCurrentStudentNotation,
]);

const saveCurrentStudentNotation = React.useCallback(() => {
  if (!selectedClassIdForSuivi) {
    alert("Aucune classe s√©lectionn√©e.");
    return;
  }
  if (!selectedNoteEvalId) {
    alert("Aucun devoir s√©lectionn√©.");
    return;
  }
  if (!selectedNoteStudent) {
    alert("Aucun √©l√®ve s√©lectionn√©.");
    return;
  }

  // üîí Si l'√©l√®ve est marqu√© AB ou N.NOT, on bloque l'enregistrement
  try {
    const schoolYearCheck = getCurrentSchoolYear();
    const classNameCheck = selectedClassIdForSuivi;
    const studentNameCheck = selectedNoteStudent;

    const existing =
      (((notationDBRef.current || {})[schoolYearCheck] || {})[classNameCheck] || {})[
        selectedNoteEvalId
      ]?.[studentNameCheck] as NotationEntry | undefined;

    const st = existing?.status;
    if (st === "AB" || st === "N.NOT") {
      alert(st === "AB" ? "Cet √©l√®ve est marqu√© AB : notation fig√©e." : "Cet √©l√®ve est marqu√© N.NOT : notation fig√©e.");
      return;
    }
  } catch {}

  const evalMeta = evalMetaList.find((ev) => ev.id === selectedNoteEvalId);
  if (!evalMeta) {
    alert("Devoir introuvable.");
    return;
  }

  // 1) V√©rifier que tous les crit√®res sont not√©s
  const rows = buildPreviewRows();
  if (!rows || rows.length === 0) {
    alert(
      "Aucun crit√®re n'est d√©fini pour ce devoir.\n" +
        "V√©rifie l'onglet COMP√âTENCES / EXIGENCES."
    );
    return;
  }

  const allCritKeys = rows.flatMap((row) =>
    row.criteres.map((_c, idx) => {
      return `${row.task}||${row.comp}::${row.item}::crit#${idx}`;
    })
  );

const missingKeys = allCritKeys.filter((key) => {
  const s = studentNotationScores[key];
  return typeof s !== "number";
});

  if (missingKeys.length > 0) {
    alert(
      "Tous les crit√®res doivent √™tre not√©s avant d'enregistrer.\n" +
        "Certains crit√®res n'ont pas encore de niveau."
    );
    return;
  }

  // 2) Calcul de la note sur 20 avec engagement
  let totalWeighted = 0;
  let totalWeightForMark = 0;

allCritKeys.forEach((key) => {
    const score = studentNotationScores[key];
    // NR (=0) ou non not√© ‚Üí n‚Äôimpacte pas la note sur 20
    if (typeof score !== "number" || !isFinite(score) || score <= 0) return;
    const weight = notationWeights[key] ?? 1;
    totalWeighted += score * weight;
    totalWeightForMark += weight;
  });

  if (totalWeightForMark <= 0) {
    alert("Aucun poids saisi pour les crit√®res.");
    return;
  }

  const baseAvgOn4 = totalWeighted / totalWeightForMark;
  const baseOn20 = (baseAvgOn4 / 4) * 20;

  const factor =
    engagementLevel && ENGAGEMENT_FACTORS[engagementLevel]
      ? ENGAGEMENT_FACTORS[engagementLevel]
      : 1;

  const markOn20 = Math.max(0, Math.min(20, baseOn20 * factor));

  // 3) Sauvegarde dans notation_db
  const schoolYear = getCurrentSchoolYear();
  const className = selectedClassIdForSuivi;
  const studentName = selectedNoteStudent;

  const entry: NotationEntry = {
    markOn20,
    totalWeightForStudent: totalWeightForMark,
    semester: evalMeta.semester,
    evalId: evalMeta.id,
    evalName: evalMeta.name,
    className,
    studentName,
    savedAt: new Date().toISOString(),
    scoresByCriteria: { ...studentNotationScores },
    engagementLevel: engagementLevel ?? undefined,
    status: "OK",
  };

// ‚úÖ Calculer un "next" immuable + sauvegarde imm√©diate (√©vite les pertes si un chargement est en cours)
const nextNotationDB: NotationDB = (() => {
  const prev = notationDBRef.current || {};
  const next: NotationDB = { ...prev };
  const yearBucket = { ...(next[schoolYear] || {}) };
  const classBucket = { ...(yearBucket[className] || {}) };

  // ‚úÖ On conserve les notations pr√©c√©dentes : un m√™me devoir peut √™tre utilis√© plusieurs fois (sessions distinctes par evalId)
// Ensuite on √©crit la nouvelle entr√©e pour CE evalId
  const evalBucket = { ...(classBucket[evalMeta.id] || {}) };
  evalBucket[studentName] = entry;
  classBucket[evalMeta.id] = evalBucket;
  yearBucket[className] = classBucket;
  next[schoolYear] = yearBucket;
  return next;
})();

notationDirtyRef.current = true;
notationDBRef.current = nextNotationDB;
setNotationDB(nextNotationDB);
// Sauvegarde imm√©diate dans le fichier (et localStorage) de l'ann√©e courante
saveNotationToStore(nextNotationDB, trainingYear);

// üü¢ Pousser aussi les niveaux de comp√©tences vers skillsDB
const classIdForSkills = evalMeta.group || className;
const semesterForSkills = evalMeta.semester as SemesterKey;

if (classIdForSkills) {
  pushCurrentDevoirToSuivi(
    classIdForSkills,
    studentName,
    semesterForSkills,
    evalMeta.id,
    studentNotationScores          // üî• scores r√©els de l‚Äô√©l√®ve
  );
}

  alert(
    `Notation enregistr√©e pour ${studentName} ‚Äì ${evalMeta.name} : ${markOn20.toFixed(
      2
    )}/20`
  );
}, [
  selectedClassIdForSuivi,
  selectedNoteEvalId,
  selectedNoteStudent,
  evalMetaList,
  notationWeights,
  studentNotationScores,
  notationScores,
  engagementLevel,
  setNotationDB,
]);

// üü¶ Marquer un √©l√®ve ABSENT (AB) pour le devoir s√©lectionn√© (Notation comp√©tences)
const toggleCurrentStudentAbsent = React.useCallback(async () => {
  if (!selectedClassIdForSuivi) {
    alert("Aucune classe s√©lectionn√©e.");
    return;
  }
  if (!selectedNoteEvalId) {
    alert("Aucun devoir s√©lectionn√©.");
    return;
  }
  if (!selectedNoteStudent) {
    alert("Aucun √©l√®ve s√©lectionn√©.");
    return;
  }

  const evalMeta = evalMetaList.find((ev) => ev.id === selectedNoteEvalId);
  if (!evalMeta) {
    alert("Devoir introuvable.");
    return;
  }

  const schoolYear = getCurrentSchoolYear();
  const className = selectedClassIdForSuivi;
  const studentName = selectedNoteStudent;

  const current =
    (((notationDB[schoolYear] || {})[className] || {})[selectedNoteEvalId] || {})[
      studentName
    ] as NotationEntry | undefined;

  const isCurrentlyAbsent = current?.status === "AB";

  if (isCurrentlyAbsent) {
    const ok = isTauriRuntime()
      ? await confirm("Retirer le statut AB (absent) pour cet √©l√®ve sur ce devoir ?", {
          title: "Retirer AB",
          kind: "warning",
        })
      : window.confirm("Retirer le statut AB (absent) pour cet √©l√®ve sur ce devoir ?");

    if (!ok) return;
  }

  const next: NotationDB = { ...notationDB };
  next[schoolYear] = { ...(next[schoolYear] || {}) };
  next[schoolYear][className] = { ...(next[schoolYear][className] || {}) };
  next[schoolYear][className][selectedNoteEvalId] = {
    ...(next[schoolYear][className][selectedNoteEvalId] || {}),
  };

  if (!isCurrentlyAbsent) {
    // On force une entr√©e "AB" (affichage + gel)
    next[schoolYear][className][selectedNoteEvalId][studentName] = {
      markOn20: 0,
      totalWeightForStudent: 0,
      semester: evalMeta.semester,
      evalId: evalMeta.id,
      evalName: evalMeta.name,
      className,
      studentName,
      savedAt: new Date().toISOString(),
      scoresByCriteria: {},
      engagementLevel: undefined,
      status: "AB",
    };

    // On fige l'UI c√¥t√© √©l√®ve
    setStudentNotationScores({});
    setEngagementLevel(null);
  } else {
    // On retire le statut AB (on conserve l'entr√©e si elle existait, sinon on supprime)
    if (current) {
      next[schoolYear][className][selectedNoteEvalId][studentName] = {
        ...current,
        status: "OK",
        savedAt: new Date().toISOString(),
      };
    }
  }

  setNotationDB(next);
  await saveNotationToStore(next, trainingYear);
}, [
  notationDB,
  evalMetaList,
  selectedClassIdForSuivi,
  selectedNoteEvalId,
  selectedNoteStudent,
  trainingYear,
]);

// üü® Marquer un √©l√®ve NON NOT√â (N.NOT) pour le devoir s√©lectionn√© (Notation comp√©tences)
const toggleCurrentStudentNonNoted = React.useCallback(async () => {
  if (!selectedClassIdForSuivi) {
    alert("Aucune classe s√©lectionn√©e.");
    return;
  }
  if (!selectedNoteEvalId) {
    alert("Aucun devoir s√©lectionn√©.");
    return;
  }
  if (!selectedNoteStudent) {
    alert("Aucun √©l√®ve s√©lectionn√©.");
    return;
  }

  const evalMeta = evalMetaList.find((ev) => ev.id === selectedNoteEvalId);
  if (!evalMeta) {
    alert("Devoir introuvable.");
    return;
  }

  const schoolYear = getCurrentSchoolYear();
  const className = selectedClassIdForSuivi;
  const studentName = selectedNoteStudent;

  const prev = notationDB || {};
  const next: NotationDB = { ...prev };

  next[schoolYear] = { ...(next[schoolYear] || {}) };
  next[schoolYear][className] = { ...(next[schoolYear][className] || {}) };
  next[schoolYear][className][selectedNoteEvalId] = {
    ...(next[schoolYear][className][selectedNoteEvalId] || {}),
  };

  const current = (next[schoolYear][className][selectedNoteEvalId][studentName] ||
    undefined) as NotationEntry | undefined;

  const currentStatus = current?.status || "OK";

  if (currentStatus !== "N.NOT") {
    // On met N.NOT (et on √©crase AB si besoin)
    next[schoolYear][className][selectedNoteEvalId][studentName] = {
      markOn20: 0,
      totalWeightForStudent: 0,
      semester: evalMeta.semester,
      evalId: evalMeta.id,
      evalName: evalMeta.name,
      className,
      studentName,
      savedAt: new Date().toISOString(),
      scoresByCriteria: {},
      engagementLevel: undefined,
      status: "N.NOT",
    };

    // On fige l'UI c√¥t√© √©l√®ve
    setStudentNotationScores({});
    setEngagementLevel(null);
  } else {
    // On retire N.NOT
    if (current) {
      next[schoolYear][className][selectedNoteEvalId][studentName] = {
        ...current,
        status: "OK",
        savedAt: new Date().toISOString(),
      };
    }
  }

  setNotationDB(next);
  await saveNotationToStore(next, trainingYear);
}, [
  notationDB,
  evalMetaList,
  selectedClassIdForSuivi,
  selectedNoteEvalId,
  selectedNoteStudent,
  trainingYear,
]);


const suiviElevePdfRef = React.useRef<HTMLDivElement | null>(null);
const suiviClassePdfRef = React.useRef<HTMLDivElement | null>(null);
const suiviEvolutionsPdfRef = React.useRef<HTMLDivElement | null>(null);
const suiviBilanPdfRef = React.useRef<HTMLDivElement | null>(null);
const suiviAbsencesPdfRef = React.useRef<HTMLDivElement | null>(null);
const notesTablePdfRef = React.useRef<HTMLDivElement | null>(null);

const exportCurrentStudentNotationToPdf = (opts?: PreviewTargetOptions) => {
  if (!selectedClassIdForSuivi) {
    alert("Aucune classe s√©lectionn√©e.");
    return;
  }
  if (!selectedNoteEvalId) {
    alert("Aucun devoir s√©lectionn√©.");
    return;
  }

  const evalMeta = evalMetaList.find((ev) => ev.id === selectedNoteEvalId);
  if (!evalMeta) {
    alert("Devoir introuvable.");
    return;
  }

  const classe = classGroups.find((c) => c.name === selectedClassIdForSuivi);
  const students = (classe?.students || "")
    .split("\n")
    .map((s) => s.trim())
    .filter(Boolean);

  if (!students.length) {
    alert("Aucun √©l√®ve d√©fini pour cette classe.");
    return;
  }

  const schoolYear = getCurrentSchoolYear();
  const yearBucket = notationDB[schoolYear] || {};
  const classBucket = yearBucket[selectedClassIdForSuivi] || {};
  const evalBucket = (classBucket[evalMeta.id] || {}) as Record<
    string,
    NotationEntry
  >;

  const rows = buildPreviewRows();
  if (!rows || rows.length === 0) {
    alert(
      "Aucun crit√®re n'est d√©fini pour ce devoir.\n" +
        "V√©rifie l'onglet COMP√âTENCES / EXIGENCES."
    );
    return;
  }

  const escapeHtml = (raw: string | null | undefined): string => {
    if (!raw) return "";
    return String(raw)
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;");
  };

  // Crit√®res du devoir (identiques pour tous les √©l√®ves)
  const critLines = rows.flatMap((row) =>
    row.criteres.map((critereText, idx) => {
      const key = `${row.task}||${row.comp}::${row.item}::crit#${idx}`;
      return {
        key,
        task: row.task,
        comp: row.comp,
        item: row.item,
        critere: critereText,
        exigences: row.exigences as string[] | undefined,
      };
    })
  );

  if (critLines.length === 0) {
    alert("Aucun crit√®re s√©lectionn√©.");
    return;
  }

  // ‚öñÔ∏è Poids : m√™me logique que dans la vue NOTATION ‚Üí d√©faut = 1
  const getWeight = (key: string) => notationWeights[key] ?? 1;

  // Regroupement par t√¢che
  const groupedByTask = critLines.reduce<
    Record<string, (typeof critLines)[number][]>
  >((acc, r) => {
    const label = r.task || "Sans t√¢che";
    if (!acc[label]) acc[label] = [];
    acc[label].push(r);
    return acc;
  }, {});

  const totalWeight = critLines.reduce(
    (sum, r) => sum + getWeight(r.key),
    0
  );

  const renderScoreScale = (s: number | null) => {
    const levels = [0, 1, 2, 3, 4];
    const effective = s === null || Number.isNaN(s) ? 0 : s;

    const levelStyle = (level: number) => {
      switch (level) {
        case 0:
          return { bg: "var(--print-score-0-bg)", border: "var(--print-score-0-border)", color: "var(--print-score-0-text)" };
        case 1:
          return { bg: "var(--print-score-1-bg)", border: "var(--print-score-1-border)", color: "var(--print-score-1-text)" };
        case 2:
          return { bg: "var(--print-score-2-bg)", border: "var(--print-score-2-border)", color: "var(--print-score-2-text)" };
        case 3:
          return { bg: "var(--print-score-3-bg)", border: "var(--print-score-3-border)", color: "var(--print-score-3-text)" };
        case 4:
          return { bg: "var(--print-score-4-bg)", border: "var(--print-score-4-border)", color: "var(--print-score-4-text)" };
        default:
          return { bg: "var(--print-score-default-bg)", border: "var(--print-score-default-border)", color: "var(--print-score-default-text)" };
      }
    };

    const parts = levels.map((level) => {
      const isActive = effective === level;
      const label = level === 0 ? "NR" : String(level);
      const base = levelStyle(level);

      const bg = isActive ? base.bg : "var(--print-score-inactive-bg)";
      const border = base.border;
      const color = isActive ? base.color : "var(--print-score-inactive-text)";

      return `
        <span style="
          display:inline-flex;
          align-items:center;
          justify-content:center;
          min-width:20px;
          padding:2px 5px;
          border-radius:9999px;
          border:1px solid ${border};
          background:${bg};
          color:${color};
          font-size:10px;
          font-weight:${isActive ? "700" : "500"};
        ">
          ${label}
        </span>
      `;
    });

    return `
      <div style="display:flex;gap:4px;justify-content:center;">
        ${parts.join("")}
      </div>
    `;
  };

  const formatEngagementLabel = (
    level: EngagementLevel | null | undefined
  ) => {
    if (level === "volontaire") return "Tr√®s engag√©";
    if (level === "engage") return "Engag√©";
    if (level === "normal") return "Engagement normal";
    if (level === "attente") return "En attente";
    if (level === "absence") return "Absence d'int√©r√™t";
    return "Non renseign√©";
  };

const renderEngagementScale = (
  level: EngagementLevel | null | undefined
) => {
    const options = [
    {
      key: "absence",
      label: "Peu engag√©",
      activeBg: "var(--print-eng-absence-bg)",
      activeColor: "var(--print-eng-absence-text)",
      border: "var(--print-eng-absence-border)",
      inactiveText: "var(--print-eng-absence-inactive-text)",
    },
    {
      key: "attente",
      label: "En attente",
      activeBg: "var(--print-eng-attente-bg)",
      activeColor: "var(--print-eng-attente-text)",
      border: "var(--print-eng-attente-border)",
      inactiveText: "var(--print-eng-attente-inactive-text)",
    },
    {
      key: "normal",
      label: "Normal",
      activeBg: "var(--print-eng-normal-bg)",
      activeColor: "var(--print-eng-normal-text)",
      border: "var(--print-eng-normal-border)",
      inactiveText: "var(--print-eng-normal-inactive-text)",
    },
    {
      key: "engage",
      label: "Engag√©",
      activeBg: "var(--print-eng-engage-bg)",
      activeColor: "var(--print-eng-engage-text)",
      border: "var(--print-eng-engage-border)",
      inactiveText: "var(--print-eng-engage-inactive-text)",
    },
    {
      key: "volontaire",
      label: "Tr√®s engag√©",
      activeBg: "var(--print-eng-volontaire-bg)",
      activeColor: "var(--print-eng-volontaire-text)",
      border: "var(--print-eng-volontaire-border)",
      inactiveText: "var(--print-eng-volontaire-inactive-text)",
    },
  ] as const;

  const pills = options
    .map((opt) => {
      const isActive = level === opt.key;
      const bg = isActive ? opt.activeBg : "var(--print-eng-inactive-bg)";
      const border = isActive ? opt.border : "var(--print-border)";
      const color = isActive ? opt.activeColor : opt.inactiveText;
      const fontWeight = isActive ? "700" : "500";

      return `
        <span style="
          display:inline-flex;
          align-items:center;
          justify-content:center;
          padding:2px 8px;
          border-radius:9999px;
          border:1px solid ${border};
          background:${bg};
          color:${color};
          font-size:10px;
          font-weight:${fontWeight};
        ">
          ${opt.label}
        </span>
      `;
    })
    .join("");

  return `
    <div style="margin-top:4px;display:flex;flex-wrap:wrap;gap:4px;">
      ${pills}
    </div>
  `;
};
    // Photo du devoir
  const logoHtml = logoDataUrl
    ? `<img src="${logoDataUrl}" style="
          width:4.5cm;
          height:2.5cm;
          object-fit:contain;
          padding:4px;
        " />`
    : "";

  const today = new Date().toLocaleDateString("fr-FR");

  // üîß G√©n√®re les sections de t√¢ches pour un √©l√®ve donn√©
  const buildTaskSectionsHtmlForStudent = (
    scoresByCriteria: Record<string, number>
  ) => {
    const getScore = (key: string) => scoresByCriteria[key];

    return Object.entries(groupedByTask)
      .map(([taskLabel, items]) => {
        const taskWeight = items.reduce(
          (sum, r) => sum + getWeight(r.key),
          0
        );
        const taskPct =
          totalWeight > 0 ? (taskWeight / totalWeight) * 100 : 0;

        const tNum = taskNumber(taskLabel);
        const group = GROUPS.find(
          (g) => tNum >= g.range[0] && tNum <= g.range[1]
        );
        let accentColor = "var(--print-group-default)";
        if (group?.key === "G1") accentColor = "var(--print-group-g1)";
        else if (group?.key === "G2") accentColor = "var(--print-group-g2)";
        else if (group?.key === "G3") accentColor = "var(--print-group-g3)";

        type RowWithSpans = {
          row: (typeof items)[number];
          showCompCell: boolean;
          compRowSpan: number;
          showItemCell: boolean;
          itemRowSpan: number;
        };

        const rowsWithSpans: RowWithSpans[] = [];

        for (let i = 0; i < items.length; i++) {
          const current = items[i];

          // Fusion comp√©tence
          let showCompCell = true;
          let compRowSpan = 1;

          if (i > 0 && items[i - 1].comp === current.comp) {
            showCompCell = false;
            compRowSpan = 0;
          } else {
            for (let j = i + 1; j < items.length; j++) {
              if (items[j].comp === current.comp) {
                compRowSpan++;
              } else {
                break;
              }
            }
          }

          // Fusion "√™tre capable de"
          let showItemCell = true;
          let itemRowSpan = 1;

          if (
            i > 0 &&
            items[i - 1].comp === current.comp &&
            items[i - 1].item === current.item
          ) {
            showItemCell = false;
            itemRowSpan = 0;
          } else {
            for (let j = i + 1; j < items.length; j++) {
              if (
                items[j].comp === current.comp &&
                items[j].item === current.item
              ) {
                itemRowSpan++;
              } else {
                break;
              }
            }
          }

          rowsWithSpans.push({
            row: current,
            showCompCell,
            compRowSpan,
            showItemCell,
            itemRowSpan,
          });
        }

        const rowsHtml = rowsWithSpans
          .map(
            ({
              row,
              showCompCell,
              compRowSpan,
              showItemCell,
              itemRowSpan,
            }) => {
              const w = getWeight(row.key);
              const s = getScore(row.key);
              const sVal = typeof s === "number" ? s : null;

              const fam = parseCompetencyFamily(row.comp);
              let famLabel = "";
              if (fam === "C1") famLabel = "COMMUNIQUER";
              else if (fam === "C2") famLabel = "PR√âPARER";
              else if (fam === "C3") famLabel = "R√âALISER";
              else if (fam === "C4") famLabel = "CONTR√îLE";

              const exigencesHtml =
                row.exigences && row.exigences.length > 0
                  ? `<ul style="margin:0;padding-left:16px;">${row.exigences
                      .map((ex) => `<li>${escapeHtml(ex)}</li>`)
                      .join("")}</ul>`
                  : `<span style="color:var(--print-subtle);font-style:italic;font-size:11px;">Aucune exigence personnalis√©e</span>`;

              let compCellHtml = "";
              if (showCompCell) {
                compCellHtml = `
                  <td rowspan="${compRowSpan}" style="border:1px solid var(--print-border);padding:4px 6px;vertical-align:middle;">
                    <div style="display:flex;flex-direction:column;gap:2px;">
                      <div style="display:flex;align-items:center;flex-wrap:wrap;gap:4px;">
                        ${
                          famLabel
                            ? `<span style="
                                display:inline-flex;
                                align-items:center;
                                gap:4px;
                                border-radius:9999px;
                                padding:2px 6px;
                                font-size:10px;
                                font-weight:600;
                                background:var(--print-badge-bg);
                                color:var(--print-badge-text);
                              ">
                                <span style="width:6px;height:6px;border-radius:9999px;background:var(--print-badge-dot);"></span>
                                ${famLabel}
                              </span>`
                            : ""
                        }
                        <span style="font-size:11px;font-weight:600;">${escapeHtml(
                          row.comp
                        )}</span>
                      </div>
                    </div>
                  </td>
                `;
              }

              let itemCellHtml = "";
              if (showItemCell) {
                itemCellHtml = `
                  <td rowspan="${itemRowSpan}" style="border:1px solid var(--print-border);padding:4px 6px;vertical-align:middle;">
                    <div style="font-size:11px;color:var(--print-header-meta);">${escapeHtml(
                      row.item
                    )}</div>
                  </td>
                `;
              }

              return `
                <tr>
                  ${compCellHtml}
                  ${itemCellHtml}
                  <td style="border:1px solid var(--print-border);padding:4px 6px;vertical-align:middle;">
                    ${escapeHtml(row.critere)}
                  </td>
                  <td style="border:1px solid var(--print-border);padding:4px 6px;vertical-align:middle;">
                   ${exigencesHtml}
                  </td>
                  <td style="border:1px solid var(--print-border);padding:4px 6px;text-align:center;vertical-align:middle;">
                    ${Number.isFinite(w) ? w.toFixed(1) : ""}
<td style="border:1px solid var(--print-border);padding:4px 6px;text-align:center;vertical-align:middle;">
  ${renderScoreScale(sVal)}
</td>

                  </td>
                </tr>
              `;
            }
          )
          .join("");

        return `
          <section style="margin-top:18px;">
            <div style="
              border:1px solid var(--print-border);
              border-left:4px solid ${accentColor};
              border-radius:16px;
              background:var(--print-surface);
              padding:12px 14px;
            ">
              <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:8px;">
                <div style="display:flex;align-items:center;gap:6px;">
                  <span style="display:inline-block;width:10px;height:10px;border-radius:4px;background:var(--print-text);"></span>
                  <h2 style="margin:0;font-size:14px;font-weight:600;">${escapeHtml(
                    taskLabel
                  )}</h2>
                </div>
                <div style="font-size:11px;color:var(--print-header-meta);display:flex;align-items:center;gap:4px;">
                  <span>${items.length} crit√®re(s)</span>
                  <span style="font-size:10px;color:var(--print-subtle);">‚Ä¢</span>
                  <span>Total poids % : ${taskWeight.toFixed(1)}</span>
                  ${
                    totalWeight > 0
                      ? `<span style="font-size:10px;font-weight:600;color:var(--print-header-title);margin-left:4px;">
                          (${taskPct.toFixed(1)} % de la note finale)
                         </span>`
                      : ""
                  }
                </div>
              </div>
              <div style="overflow-x:auto;">
                <table style="width:100%;border-collapse:collapse;font-size:11px;">
                  <thead>
                    <tr style="background:var(--print-row-alt);">
                      <th style="border:1px solid var(--print-border);padding:4px 6px;text-align:left;width:20%;">Comp√©tence</th>
                      <th style="border:1px solid var(--print-border);padding:4px 6px;text-align:left;width:20%;">√ätre capable de‚Ä¶</th>
                      <th style="border:1px solid var(--print-border);padding:4px 6px;text-align:left;width:32%;">Crit√®re d'√©valuation</th>
                      <th style="border:1px solid var(--print-border);padding:4px 6px;text-align:left;width:14%;">Exigences</th>
                      <th style="border:1px solid var(--print-border);padding:4px 6px;text-align:center;width:7%;">Poids (%)</th>
                      <th style="border:1px solid var(--print-border);padding:4px 6px;text-align:center;width:7%;">Niveau</th>
                    </tr>
                  </thead>
                  <tbody>
                    ${rowsHtml}
                  </tbody>
                </table>
              </div>
            </div>
          </section>
        `;
      })
      .join("");
  };

  // üîÑ Une page par √©l√®ve
  const studentPagesHtml = students
    .map((studentName, index) => {
      const entry = evalBucket[studentName];

      if (!entry || !entry.scoresByCriteria) {
        return `
          <div class="page">
            <h1>Notation crit√©ri√©e ‚Äì ${escapeHtml(evalMeta.name)}</h1>
            <div class="meta">√âl√®ve : <strong>${escapeHtml(
              studentName
            )}</strong></div>
            <div class="meta">
              Classe : <strong>${escapeHtml(selectedClassIdForSuivi)}</strong>
              ¬∑ Semestre : <strong>${escapeHtml(evalMeta.semester)}</strong>
            </div>
            <div class="meta">Date d'√©dition : ${today}</div>
            <div style="margin-top:16px;font-size:12px;color:var(--print-header-meta);">
              Aucune notation enregistr√©e pour cet √©l√®ve sur ce devoir.
            </div>
          </div>
          ${
            index < students.length - 1
              ? '<div style="page-break-after:always;"></div>'
              : ""
          }
        `;
      }

      const scores = entry.scoresByCriteria || {};

      // Note /20 : on prend markOn20 s'il existe, sinon on recalcule
      let markOn20 = entry.markOn20;
      if (typeof markOn20 !== "number") {
        let totalWeightForMark = 0;
        let weightedAchieved = 0;
        critLines.forEach((r) => {
          const w = getWeight(r.key);
          const s = scores[r.key];
          if (typeof s !== "number") return;
          totalWeightForMark += w;
          weightedAchieved += w * (s / 4);
        });
        const baseMarkOn20 =
          totalWeightForMark > 0
            ? (weightedAchieved / totalWeightForMark) * 20
            : 0;
        const factor = computeEngagementFactor(entry.engagementLevel);
        markOn20 = Math.max(0, Math.min(20, baseMarkOn20 * factor));
      }

      const engagementLabel = formatEngagementLabel(entry.engagementLevel);
      const taskSectionsHtmlForStudent =
        buildTaskSectionsHtmlForStudent(scores);

      return `
        <div class="page">
          <div style="
            display:flex;
            justify-content:space-between;
            align-items:flex-start;
            gap:16px;
            margin-bottom:12px;
          ">
            <div>
              <h1>√âVALUATION - ${escapeHtml(evalMeta.name)}</h1>
              <div class="meta">
                √âl√®ve : <strong>${escapeHtml(studentName)}</strong>
              </div>
              <div class="meta">
                Classe : <strong>${escapeHtml(selectedClassIdForSuivi)}</strong>
                ¬∑ Semestre : <strong>${escapeHtml(evalMeta.semester)}</strong>
              </div>
  <div
    style="
      margin-top:8px;
      font-size:12px;
      color:var(--print-muted-text-strong);
      display:flex;
      align-items:center;
      gap:8px;
      flex-wrap:wrap;
    "
  >
    <span style="font-weight:600;">ENGAGEMENT&nbsp;:</span>
    ${renderEngagementScale(entry.engagementLevel)}
  </div>
</div>
            <div style="flex-shrink:0;display:flex;align-items:flex-start;gap:8px;">
              <div class="card">
                <div class="card-title">Note finale</div>
                <div class="card-value">${entry.status === "AB" ? "AB" : markOn20.toFixed(2) + " / 20"}</div>
              </div>
              ${logoHtml ? `<div>${logoHtml}</div>` : ""}
            </div>
          </div>

          ${taskSectionsHtmlForStudent}
        </div>
        ${
          index < students.length - 1
            ? '<div style="page-break-after:always;"></div>'
            : ""
        }
      `;
    })
    .join("");

  const html = `
<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>Notation ‚Äì ${escapeHtml(evalMeta.name)} ‚Äì ${escapeHtml(
    selectedClassIdForSuivi
  )}</title>
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: var(--print-bg);
    }
    .page {
      max-width: 1100px;
      margin: 16px auto;
      background: var(--print-surface);
      padding: 20px 24px;
      color: var(--print-text);
      font-size: 13px;
    }
    h1 {
      font-size: 20px;
      margin: 0 0 4px 0;
    }
    .meta {
      font-size: 12px;
      color: #4b5563;
      margin-bottom: 2px;
    }
    .card {
      border-radius: 10px;
      border: 1px solid var(--print-border);
      padding: 8px 10px;
      background: var(--print-row-alt);
    }
    .card-title {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--print-muted-text);
      margin-bottom: 2px;
    }
    .card-value {
      font-size: 18px;
      font-weight: 700;
    }
    @page {
      size: A4 landscape;
      margin: 10mm 12mm;
    }
  </style>
</head>
<body>
  ${studentPagesHtml}
</body>
</html>
`;

  pushPreview(html, opts);
};
const exportSuiviElevesToPdf = async () => {
  if (!selectedClassIdForSuivi) {
    alert("S√©lectionne une classe avant d'exporter.");
    return;
  }

  const classe = classGroups.find((c) => c.name === selectedClassIdForSuivi);
  if (!classe) return;

  const students = (classe.students || "")
    .split("\n")
    .map((s) => s.trim())
    .filter(Boolean);

  if (students.length === 0) {
    alert("Aucun √©l√®ve n'est renseign√© pour cette classe.");
    return;
  }

  // On force la Vue √©l√®ve pour √™tre s√ªr d'avoir le bon rendu
  const prevMode = suiviMode;
  const prevStudent = selectedStudentForSuivi;

  if (suiviMode !== "eleve") setSuiviMode("eleve");

  // R√©cup√®re les styles existants (Tailwind etc.)
  const styleTags = Array.from(
    document.querySelectorAll('link[rel="stylesheet"], style')
  )
    .map((n) => (n as HTMLElement).outerHTML)
    .join("\n");

  const esc = (s: string) =>
    s
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&#039;");

  const pages: string[] = [];

  // petite utilitaire pour attendre que React ait rendu
  const nextPaint = () =>
    new Promise<void>((resolve) => requestAnimationFrame(() => resolve()));

  for (const st of students) {
    setSelectedStudentForSuivi(st);

    // 2 frames : 1 pour le state, 1 pour le DOM/layout
    await nextPaint();
    await nextPaint();

    const wrap = suiviElevePdfRef.current;
    if (!wrap) continue;

    pages.push(`
      <div class="pdf-page">
        ${buildPrintHeaderHtml(esc, {
          viewTitle: "Synth√®se des comp√©tences",
          studentName: st,
          classId: selectedClassIdForSuivi,
          trainingYear,
          schoolYear: getCurrentSchoolYear(),
        })}
        ${wrap.outerHTML}
      </div>
    `);
}

  // restore
  if (prevMode !== suiviMode) setSuiviMode(prevMode);
  setSelectedStudentForSuivi(prevStudent ?? "");

  const html = `<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>${esc(`Synth√®se des comp√©tences ‚Äî ${selectedClassIdForSuivi}`)}</title>
  ${styleTags}
  <style>
    @page { size: A4 landscape; margin: 8mm; }
    body { margin: 0; -webkit-print-color-adjust: exact; print-color-adjust: exact; }
    .pdf-page { page-break-after: always; padding: 12px; }
    .pdf-page:last-child { page-break-after: auto; }

    .pdf-title {
      font-family: system-ui;
      font-size: 14px;
      font-weight: 700;
      margin: 0 0 10px 0;
    }

    /* √©viter les sticky / scroll en export */
    .sticky { position: static !important; }
    .overflow-x-auto { overflow: visible !important; }

    /* optionnel : masquer les √©l√©ments marqu√©s no-print si tu en as */
    .no-print { display: none !important; }
  </style>
</head>
<body>
  ${pages.join("\n")}
</body>
</html>`;

  setPreviewHtml(html);
  setPreviewOpen(true);
};
const exportSuiviClasseToPdf = (opts?: PreviewTargetOptions) => {
  const wrap = suiviClassePdfRef.current;
  if (!wrap) {
    alert("Bloc suivi classe introuvable (ref null). V√©rifie le ref sur le conteneur.");
    return;
  }

  const classId = selectedClassIdForSuivi;
  if (!classId) {
    alert("S√©lectionne une classe avant d'exporter.");
    return;
  }

  const styleTags = Array.from(
    document.querySelectorAll('link[rel="stylesheet"], style')
  )
    .map((n) => (n as HTMLElement).outerHTML)
    .join("\n");

  const esc = (s: string) =>
    s
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&#039;");

  const title = `Suivi de la classe ‚Äî ${classId} ‚Äî ${trainingYearLabel(trainingYear)}`;

  const html = `<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>${esc(title)}</title>
  ${styleTags}
  <style>
    @page { size: A4 landscape; margin: 8mm; }
    body { margin: 0; -webkit-print-color-adjust: exact; print-color-adjust: exact; }

    .sticky { position: static !important; }
    .overflow-x-auto { overflow: visible !important; }
    .no-print { display: none !important; }

    #page { width: calc(297mm - 16mm); margin: 0; }
    #pdfRoot { transform-origin: top left; transform: scale(var(--pdfScale, 1)); width: max-content; }

    .absences-print-root table { border-collapse: collapse; }
    .absences-print-root th, .absences-print-root td { padding: 2px 3px !important; }
  </style>
</head>
<body>
  <div style="padding:12px">
${buildPrintHeaderHtml(esc, {
viewTitle: "Suivi de la classe",
classId,
trainingYear,
schoolYear: getCurrentSchoolYear(),
})}

    <div id="page">
      <div id="pdfRoot">
        ${wrap.innerHTML}
      </div>
    </div>
  </div>

  <script>
    function fitToA4Width() {
      const page = document.getElementById('page');
      const root = document.getElementById('pdfRoot');
      const table = root ? root.querySelector('table') : null;
      if (!page || !root || !table) return;

      root.style.setProperty('--pdfScale', 1);

      const available = page.getBoundingClientRect().width;
      const needed = table.scrollWidth || table.getBoundingClientRect().width;
      if (!available || !needed) return;

      const scale = Math.min(1, available / needed);
      root.style.setProperty('--pdfScale', scale.toFixed(4));
    }

    window.addEventListener('load', fitToA4Width);
    window.addEventListener('beforeprint', fitToA4Width);
  </script>
</body>
</html>`;

  pushPreview(html, opts);
};

const openSuiviEleveToPreview = (opts?: PreviewTargetOptions) => {
  const wrap = suiviElevePdfRef.current;
  if (!wrap) {
    alert("Bloc suivi √©l√®ve introuvable (ref null).");
    return;
  }

  if (!selectedClassIdForSuivi || !selectedStudentForSuivi) {
    alert("S√©lectionne une classe et un √©l√®ve avant d'imprimer.");
    return;
  }

  const styleTags = Array.from(
    document.querySelectorAll('link[rel="stylesheet"], style')
  )
    .map((n) => (n as HTMLElement).outerHTML)
    .join("\n");

  const esc = (s: string) =>
    (s || "")
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&#039;");

  const title = `Synth√®se des comp√©tences ‚Äî Suivi de ${selectedStudentForSuivi} ‚Äî ${selectedClassIdForSuivi} ‚Äî ${trainingYearLabel(trainingYear)}`;

  const html = `<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>${esc(title)}</title>
  ${styleTags}
  <style>
    @page { size: A4 landscape; margin: 10mm; }
    body { margin: 0; -webkit-print-color-adjust: exact; print-color-adjust: exact; }
    .sticky { position: static !important; }
    .overflow-x-auto { overflow: visible !important; }
    .no-print { display: none !important; }
  </style>
</head>
<body>
  <div style="padding:12px">
${buildPrintHeaderHtml(esc, {
viewTitle: "Synth√®se des comp√©tences",
studentName: selectedStudentForSuivi,
classId: selectedClassIdForSuivi,
trainingYear,
schoolYear: getCurrentSchoolYear(),
})}
    ${wrap.outerHTML}
  </div>
</body>
</html>`;

  pushPreview(html, opts);
};

// Impression ‚Äì helpers communs pour les vues Suivi
const PRINT_BASE_CSS = `
  body { margin: 0; -webkit-print-color-adjust: exact; print-color-adjust: exact; }
  .sticky { position: static !important; }
  /* En impression, on "d√©roule" les conteneurs scrollables, mais on √©vite d'ouvrir les conteneurs en overflow-hidden
     (sinon certains graphiques d√©bordent et recouvrent les blocs adjacents). */
  .overflow-x-auto, .overflow-y-auto, .overflow-auto { overflow: visible !important; }
  .no-print { display: none !important; }
  .print-only { display: block !important; }
  .hidden.print-only { display: block !important; }
  button { display: none !important; }

  /* Impression BILAN : pas d'en-t√™te "app" + pas de padding, pour coller au PDF */
  body.print-bilan .print-header { display: none !important; }
  body.print-bilan .print-root { padding: 0 !important; }

  /* ==============================
     Livret p√©riodique (style PDF)
     ============================== */
  .bilan-livret { font-family: Arial, Helvetica, sans-serif !important; color: var(--livret-ink) !important; }
  .bilan-livret * { box-sizing: border-box; }

  /* Marges internes (haut/bas/c√¥t√©s) pour un rendu plus a√©r√©, comme le PDF de r√©f√©rence */
  .bilan-livret .lp-page {
    width: 400mm;
    height: 277mm;
    margin: 0 auto;
    padding: 12mm 12mm 12mm 12mm;
  }
  .bilan-livret .lp-grid { display: grid; grid-template-columns: 1fr 1fr; column-gap: 10mm; height: 100%; }
  .bilan-livret .lp-col { min-width: 0; }

  /* Titre / en-t√™te (page 1 droite) */
  .bilan-livret .lp-rightTitle { text-align: center; font-size: 12px; font-weight: 700; }
  .bilan-livret .lp-sem { text-align: center; font-size: 12px; margin-top: 6px; letter-spacing: .6px; font-weight: 700; }
  .bilan-livret .lp-nameBox { border: 1px solid var(--livret-ink); margin-top: 6px; padding: 4px 0; text-align: center; font-size: 18px; font-weight: 700; }
  .bilan-livret .lp-centerInfo { text-align: center; font-size: 10px; margin-top: 10px; line-height: 1.35; }
  .bilan-livret .lp-etabRow { text-align: center; }
  .bilan-livret .lp-etabLabel { font-weight: 400; text-transform: none; }
  .bilan-livret .lp-etabName { font-weight: 700; text-transform: uppercase; }
  .bilan-livret .lp-etabLine { text-transform: none; }

  /* Synth√®se (cadre "graph") */
  .bilan-livret .lp-chartFrame { margin-top: 16px; border: 1px solid var(--livret-frame-border); padding: 6px; border-radius: 0; }

  /*
    Histogramme (livret) : on s√©pare la zone de trac√© (bandes + barres) et la zone des libell√©s,
    pour √©viter les √©carts de hauteur entre la page √©cran et l'aper√ßu / impression.
  */
  .bilan-livret .lp-chart { position: relative; height: 70mm; overflow: hidden; }
  .bilan-livret .lp-plot { position: absolute; left: 4mm; right: 4mm; top: 4mm; bottom: 10mm; overflow: hidden; }

  .bilan-livret .lp-band { position: absolute; left: 0; right: 0; }
  .bilan-livret .lp-band.top { top: 0; height: 50%; background: var(--livret-band-top); }
  .bilan-livret .lp-band.mid { top: 50%; height: 25%; background: var(--livret-band-mid); }
  .bilan-livret .lp-band.bot { top: 75%; height: 25%; background: var(--livret-band-bot); }
  .bilan-livret .lp-midLine { position: absolute; left: 0; right: 0; top: 50%; border-top: 1px solid var(--livret-midline); }

  .bilan-livret .lp-bars { position: relative; z-index: 2; height: 100%; display: flex; align-items: flex-end; justify-content: space-between; gap: 0; }
  .bilan-livret .lp-barWrap { flex: 1; min-width: 0; height: 100%; display: flex; flex-direction: column; justify-content: flex-end; align-items: center; }
  .bilan-livret .lp-bar { width: 3mm; background: var(--livret-green); }
  .bilan-livret .lp-bar.gray { background: var(--print-muted-text); }
  .bilan-livret .lp-barPair { display: flex; align-items: flex-end; justify-content: center; gap: 1mm; height: 100%; }

  .bilan-livret .lp-labels { position: absolute; left: 4mm; right: 4mm; bottom: 0; height: 10mm; display: flex; align-items: flex-start; justify-content: space-between; }
  .bilan-livret .lp-labelWrap { flex: 1; min-width: 0; display: flex; justify-content: center; }
  .bilan-livret .lp-xlbl { font-size: 7px; line-height: 1; transform: rotate(-40deg); transform-origin: top left; white-space: nowrap; opacity: .85; }

  /* Int√©r√™t pour la pratique professionnelle */
  .bilan-livret .lp-motivTitle { margin-top: 8px; font-size: 11px; font-weight: 700; }
  /* Hauteur ma√Ætris√©e pour rester proche du gabarit PDF (sans √©tirer la colonne droite) */
  .bilan-livret .lp-motivBox {
    border: 2px solid var(--livret-ink);
    padding: 4px 6px;
    text-align: center;
    font-size: 14px;
    font-weight: 800;
    letter-spacing: .4px;
    background: var(--livret-paper);
    min-height: 12mm;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  .bilan-livret .lp-motivBox.good { border-color: var(--livret-motiv-good); }
  .bilan-livret .lp-motivBox.mid { border-color: var(--livret-motiv-mid); }
  .bilan-livret .lp-motivBox.bad { border-color: var(--livret-motiv-bad); }

  /* Absences (bo√Æte + feu tricolore) */
  .bilan-livret .lp-absBox {
    margin-top: 16px;
    border: 1px solid var(--livret-ink);
    display: grid;
    grid-template-columns: 28px 1fr;
    /* √©vite que le 3√®me point soit rogn√© quand le texte est vide */
    min-height: 16mm;
    align-items: stretch;
  }
  .bilan-livret .lp-traffic {
    border-right: 1px solid var(--livret-ink);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 3px;
    padding: 2mm 0;
    background: var(--livret-traffic-bg);
  }
  .bilan-livret .lp-trafficDot { width: 10px; height: 10px; border-radius: 50%; border: 1px solid var(--livret-ink); background: var(--livret-traffic-dot); }
  .bilan-livret .lp-trafficDot.green { background: var(--livret-traffic-green); }
  .bilan-livret .lp-trafficDot.yellow { background: var(--livret-paper)f00; }
  .bilan-livret .lp-trafficDot.red { background: var(--livret-traffic-red); }
  .bilan-livret .lp-absText { padding: 3mm 3mm; font-size: 10px; display: flex; align-items: center; }

  /* Appr√©ciation */
  .bilan-livret .lp-appTitle { margin-top: 12px; font-size: 11px; font-weight: 700; }
  .bilan-livret .lp-appBox {
    border: 1px solid var(--livret-ink);
    padding: 3mm;
    /* hauteur mini proche du PDF de r√©f√©rence, m√™me si le texte est vide */
    min-height: 28mm;
    font-size: 10px;
    line-height: 1.25;
    white-space: pre-wrap;
  }

  /* Signatures */
  .bilan-livret .lp-signTable { margin-top: 12px; width: 100%; border-collapse: collapse; font-size: 10px; }
  .bilan-livret .lp-signTable th,
  .bilan-livret .lp-signTable td { border: 1px solid var(--livret-ink); padding: 8px; }
  .bilan-livret .lp-signTable th { font-weight: 700; background: var(--livret-paper); }
  /* Zone signature plus haute, sans d√©pendre du DPI */
  .bilan-livret .lp-signBlank { height: 25mm; }

  /* Titres gris (page 2) */
  .bilan-livret .lp-grayTitle { background: var(--livret-graytitle-bg); border: 1px solid var(--livret-ink); padding: 4px 6px; font-weight: 700; font-size: 11px; text-transform: uppercase; }
  .bilan-livret .lp-note { font-size: 10px; margin: 6px 0 6px 0; font-weight: 700; }

  /* Liste t√¢ches */
  .bilan-livret .lp-taskRow { display: grid; grid-template-columns: 42px 1fr 14px; column-gap: 6px; font-size: 14px; padding: 2px 0; line-height: 1.3; }
  .bilan-livret .lp-taskCode { font-weight: 700; }
  .bilan-livret .lp-taskMark { text-align: right; font-weight: 700; }

  /* Comp√©tences (style "liste" + cases X color√©es) */
  .bilan-livret .lp-compBlock { margin-top: 10px; }
  .bilan-livret .lp-compHead { display: grid; grid-template-columns: 1fr 14px; column-gap: 6px; align-items: center; border-bottom: 1px solid var(--livret-ink); padding: 2px 0; font-size: 14px; font-weight: 700; line-height: 1.5; }
  .bilan-livret .lp-compItem { display: grid; grid-template-columns: 1fr 14px; column-gap: 6px; align-items: start; font-size: 12px; padding: 2px 0; line-height: 1.5; }
  .bilan-livret .lp-status { width: 12px; height: 12px; display: inline-flex; align-items: center; justify-content: center; font-size: 14px; font-weight: 900; line-height: 1; color: var(--livret-ink); }
  .bilan-livret .lp-status.NA { background: var(--livret-traffic-red); }
  .bilan-livret .lp-status.EA { background: var(--livret-paper)f00; }
  .bilan-livret .lp-status.A { background: var(--livret-traffic-green); }
  .bilan-livret .lp-status.NE { background: var(--livret-status-ne); }
  .bilan-livret .lp-legendLine { margin: 8px 0 6px 0; font-size: 10px; }
  .bilan-livret .lp-legendLine .lp-legItem { margin-right: 18px; white-space: nowrap; }
  .bilan-livret .lp-legendLine .lp-legItem .lp-status { margin-right: 4px; }

  /* Bilan p√©riodique : √©viter les "lignes vides" entre la synth√®se (histogramme) et le relev√© des comp√©tences */
  /* Bilan p√©riodique (livret) : on masque la mise en page √©cran dans l'aper√ßu / impression */
  .bilan-screen-layout { display: none !important; }

  /* Livret : pagination ma√Ætris√©e */
  .bilan-livret .livret-page { break-after: page !important; page-break-after: always !important; }
  .bilan-livret .livret-page:last-child { break-after: auto !important; page-break-after: auto !important; }


  .bilan-print-root > :not([hidden]) ~ :not([hidden]) { margin-top: 0 !important; }
  .bilan-page-1 { margin-bottom: 0 !important; padding-bottom: 0 !important; }
  /* √âvite un double saut de page (break-after + break-before) qui peut cr√©er un blanc entre les deux sections */
  .bilan-page-2 {
    margin-top: 0 !important;
    padding-top: 0 !important;
    break-before: auto !important;
    page-break-before: auto !important;
  }

  /* Recharts : √©vite les superpositions (tooltips/labels) dans l'aper√ßu / impression */
  .recharts-tooltip-wrapper { display: none !important; }
  .bilan-print-root .bilan-chart-wrap { overflow: hidden !important; }

  /* Bilan des comp√©tences : compacter en impression pour √©viter une 3√®me page */
  @media print {
    .bilan-page-2 { margin-top: 0 !important; padding-top: 0 !important; }
    .bilan-page-2 .bilan-group { box-shadow: none !important; border-width: 1px !important; }
    .bilan-page-2 .bilan-group-header { padding: 4px 6px !important; }
    .bilan-page-2 .bilan-group-grid {
      padding: 4px 6px !important;
      gap: 4px !important;
      grid-template-columns: repeat(3, minmax(0, 1fr)) !important;
    }

    .bilan-page-2 .bilan-competence-card { box-shadow: none !important; border-width: 1px !important; }
    .bilan-page-2 .bilan-competence-head { padding: 3px 4px !important; }
    .bilan-page-2 .bilan-competence-items { padding: 3px 4px !important; }
    .bilan-page-2 .bilan-competence-card { font-size: 9px !important; line-height: 1.2 !important; }
    .bilan-page-2 .bilan-competence-item { padding: 1px 3px !important; font-size: 8px !important; line-height: 1.15 !important; }
  }
`;

const collectPrintStyleTags = () =>
  Array.from(document.querySelectorAll('link[rel="stylesheet"], style'))
    .map((n) => (n as HTMLElement).outerHTML)
    .join("\n");

const escapeHtmlForPrint = (s: string) =>
  (s || "")
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#039;");

const serializeDomForPrint = (el: HTMLElement) => {
  // outerHTML suffit dans la plupart des cas ; le clone √©vite quelques surprises (hidden, etc.)
  const clone = el.cloneNode(true) as HTMLElement;
  clone.querySelectorAll("[hidden]").forEach((n) =>
    (n as HTMLElement).removeAttribute("hidden")
  );

  // Important : cloneNode ne refl√®te pas toujours les valeurs *courantes* des champs
  // (notamment textarea / select). On recopie explicitement les valeurs depuis le DOM original.
  const origFields = Array.from(el.querySelectorAll("input, textarea, select"));
  const cloneFields = Array.from(clone.querySelectorAll("input, textarea, select"));
  const n = Math.min(origFields.length, cloneFields.length);

  for (let i = 0; i < n; i++) {
    const o = origFields[i] as HTMLElement;
    const c = cloneFields[i] as HTMLElement;
    if (o.tagName !== c.tagName) continue;

    if (o.tagName === "TEXTAREA") {
      const ov = (o as HTMLTextAreaElement).value;
      (c as HTMLTextAreaElement).value = ov;
      // l'HTML imprim√© d√©pend du contenu entre les balises
      (c as HTMLTextAreaElement).textContent = ov;
    } else if (o.tagName === "INPUT") {
      const oi = o as HTMLInputElement;
      const ci = c as HTMLInputElement;
      if (oi.type === "checkbox" || oi.type === "radio") {
        ci.checked = oi.checked;
        if (oi.checked) ci.setAttribute("checked", "");
        else ci.removeAttribute("checked");
      } else {
        ci.value = oi.value;
        ci.setAttribute("value", oi.value);
      }
    } else if (o.tagName === "SELECT") {
      const os = o as HTMLSelectElement;
      const cs = c as HTMLSelectElement;
      cs.value = os.value;
      Array.from(cs.options).forEach((opt) => {
        const isSel = opt.value === os.value;
        opt.selected = isSel;
        if (isSel) opt.setAttribute("selected", "");
        else opt.removeAttribute("selected");
      });
    }
  }
  return clone.outerHTML;
};

const pushRefToPreview = (params: {
  wrap: HTMLElement;
  title: string;
  page: "A4 portrait" | "A4 landscape" | "A3 landscape";
  header: PrintHeaderMeta;
  opts?: PreviewTargetOptions;
  bodyClass?: string;
  extraCss?: string;
}) => {
  const styleTags = collectPrintStyleTags();
  const bodyClassAttr = params.bodyClass ? ` class="${params.bodyClass}"` : "";
  const html = `<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>${escapeHtmlForPrint(params.title)}</title>
  ${styleTags}
  <style>
    @page { size: ${params.page}; margin: 10mm 10mm; }
    ${PRINT_BASE_CSS}
    ${params.extraCss || ""}
  </style>
</head>
<body${bodyClassAttr}>
  <div class="print-root" style="padding:12px">
${buildPrintHeaderHtml(escapeHtmlForPrint, params.header)}
    ${serializeDomForPrint(params.wrap)}
  </div>
</body>
</html>`;

  pushPreview(html, params.opts);
};

const openSuiviEvolutionsToPreview = (opts?: PreviewTargetOptions) => {
  const wrap = suiviEvolutionsPdfRef.current;
  if (!wrap) {
    alert("Bloc suivi √©volutions introuvable (ref null).");
    return;
  }

  if (!selectedClassIdForSuivi || !selectedStudentForSuivi) {
    alert("S√©lectionne une classe et un √©l√®ve avant d'imprimer.");
    return;
  }

  pushRefToPreview({
    wrap,
    title: `√âvolutions ‚Äî Suivi de ${selectedStudentForSuivi} ‚Äî ${selectedClassIdForSuivi} ‚Äî ${trainingYearLabel(trainingYear)}`,
    page: "A4 landscape",
    header: {
      viewTitle: "√âvolutions",
      studentName: selectedStudentForSuivi,
      classId: selectedClassIdForSuivi,
      trainingYear,
      schoolYear: getCurrentSchoolYear(),
    },
    bodyClass: "bg-white text-neutral-900 print-bilan",
    opts,
  });
};

const openSuiviBilanToPreview = (opts?: PreviewTargetOptions) => {
  const wrap = suiviBilanPdfRef.current;
  if (!wrap) {
    alert("Aucun contenu Bilan √† imprimer.");
    return;
  }

  if (!selectedClassIdForSuivi || !selectedStudentForSuivi) {
    alert("S√©lectionne une classe et un √©l√®ve avant d'imprimer.");
    return;
  }

  pushRefToPreview({
    wrap,
    title: `Bilan ‚Äî Suivi de ${selectedStudentForSuivi} ‚Äî ${selectedClassIdForSuivi} ‚Äî ${trainingYearLabel(trainingYear)} ‚Äî ${bilanSemester}`,
    page: "A3 landscape",
    header: {
      viewTitle: `Bilan (${bilanSemester})`,
      studentName: selectedStudentForSuivi,
      classId: selectedClassIdForSuivi,
      trainingYear,
      schoolYear: getCurrentSchoolYear(),
    },
    bodyClass: "bg-white text-neutral-900 print-bilan",
    opts,
  });
};

const sanitizeAbsencesClassName = (s: string) =>
  String(s ?? "")
    .replace(/\s*[‚Äî‚Äì-]\s*CAP\s*2025\s*-\s*2027\s*/gi, "")
    .trim();

const openSuiviAbsencesToPreview = (opts?: PreviewTargetOptions) => {
  const wrap = suiviAbsencesPdfRef.current;
  if (!wrap) {
    alert("Aucun contenu Absences / retards √† imprimer.");
    return;
  }

  const classId = selectedClassIdForSuivi;
  if (!classId) {
    alert("S√©lectionne une classe avant d'imprimer.");
    return;
  }

  const styleTags = collectPrintStyleTags();
  const classLabel = sanitizeAbsencesClassName(classId);
  const title = `Absences / retards${classLabel ? ` ‚Äî ${classLabel}` : ""} ‚Äî ${absencesSchoolYear} ‚Äî ${trainingYearLabel(trainingYear)}`;

  const recapHtml = (() => {
    try {
      const classe = classGroups.find((c) => c.name === classId);
      const students = (classe?.students || "")
        .split("\n")
        .map((s) => s.trim())
        .filter(Boolean);

      const yearBucket =
        (absencesStore.records?.[absencesSchoolYear]?.[classId] || {}) as Record<
          string,
          Record<string, AttendanceStatus>
        >;

      const startYmd = absencesPlanningSettings.startYmd;
      const endYmd = absencesPlanningSettings.endYmd;

      const vacationRanges: VacationRange[] =
        absencesPlanningSettings.vacationsMode === "auto"
          ? absencesAutoVacationsForKey || []
          : (absencesPlanningSettings.vacationsManual || []).map((r) => ({
              startYmd: r.startYmd,
              endYmdExclusive: addDaysYmd(r.endYmd, 1),
              label: r.label || "Vacances",
            }));

      const stageRanges: VacationRange[] = (absencesPlanningSettings.stages || []).map((r) => ({
        startYmd: r.startYmd,
        endYmdExclusive: addDaysYmd(r.endYmd, 1),
        label: r.label || "PFMP",
      }));

      const cutoffYmd = todayYmd < endYmd ? todayYmd : endYmd;

      const buildCourseYmdSet = (from: string, to: string) => {
        const set = new Set<string>();
        const s = fromYmd(from);
        const e = fromYmd(to);
        if (!s || !e) return set;
        for (let d = new Date(s.getTime()); d <= e; d = addDays(d, 1)) {
          const wdKey = weekdayKeyFromDate(d);
          if (!absencesPlanningSettings.courseDays?.[wdKey]) continue;
          const ymd = toYmd(d);
          if (findLabelInRanges(ymd, vacationRanges)) continue;
          if (findLabelInRanges(ymd, stageRanges)) continue;
          set.add(ymd);
        }
        return set;
      };

      const effectiveCourseYmdSet = buildCourseYmdSet(startYmd, cutoffYmd);

      type SemesterKey = "S1" | "S2";
      type SemesterInfo = { key: SemesterKey; startYmd: string; endYmdExclusive: string };

      const yearEndExclusive = addDaysYmd(endYmd, 1);
      const winterVac = vacationRanges.find((r) => /vacances.*hiver/i.test(r.label || ""));
      const summerVac = vacationRanges.find((r) => /vacances.*(ete|√©t√©)/i.test(r.label || ""));

      const syParsed = parseSchoolYearString(absencesSchoolYear);
      const fallbackWinterStart = syParsed ? `${syParsed.endYear}-02-01` : `${new Date().getFullYear()}-02-01`;

      const clampYmd = (ymdIn: string, minYmd: string, maxYmd: string) => {
        if (ymdIn < minYmd) return minYmd;
        if (ymdIn > maxYmd) return maxYmd;
        return ymdIn;
      };

      const s1StartYmd = startYmd;
      const s1EndExclYmd = clampYmd(winterVac?.startYmd || fallbackWinterStart, startYmd, yearEndExclusive);
      const s2StartYmd = clampYmd(winterVac?.endYmdExclusive || s1EndExclYmd, startYmd, yearEndExclusive);
      const s2EndExclYmd = clampYmd(summerVac?.startYmd || yearEndExclusive, startYmd, yearEndExclusive);

      const semestersBase: SemesterInfo[] = [
        { key: "S1", startYmd: s1StartYmd, endYmdExclusive: s1EndExclYmd },
        { key: "S2", startYmd: s2StartYmd, endYmdExclusive: s2EndExclYmd },
      ];

      const semesters: SemesterInfo[] = semestersBase.map((s) => {
        let st = clampYmd(s.startYmd, startYmd, yearEndExclusive);
        let en = clampYmd(s.endYmdExclusive, startYmd, yearEndExclusive);
        if (en <= st) en = addDaysYmd(st, 1);
        return { ...s, startYmd: st, endYmdExclusive: en };
      });

      const semS1 = semesters.find((s) => s.key === "S1") || semesters[0];
      const semS2 = semesters.find((s) => s.key === "S2") || semesters[1] || semesters[0];

      const courseDaysBySemesterSoFar: Record<SemesterKey, number> = { S1: 0, S2: 0 };
      for (const ymd of effectiveCourseYmdSet) {
        if (ymd >= semS1.startYmd && ymd < semS1.endYmdExclusive) courseDaysBySemesterSoFar.S1 += 1;
        else if (ymd >= semS2.startYmd && ymd < semS2.endYmdExclusive) courseDaysBySemesterSoFar.S2 += 1;
      }

      const studentSemesterCounts: Record<string, Record<SemesterKey, { ab: number; rt: number }>> = {};
      for (const st of students) {
        const byDate = yearBucket?.[st] || {};
        const semMap: Record<SemesterKey, { ab: number; rt: number }> = {
          S1: { ab: 0, rt: 0 },
          S2: { ab: 0, rt: 0 },
        };

        for (const [ymd, status] of Object.entries(byDate)) {
          if (status !== "AB" && status !== "RT") continue;
          if (ymd < startYmd || ymd > cutoffYmd) continue;
          if (!effectiveCourseYmdSet.has(ymd)) continue;

          const sem: SemesterKey =
            ymd >= semS2.startYmd && ymd < semS2.endYmdExclusive ? "S2" : "S1";

          if (status === "AB") semMap[sem].ab += 1;
          else semMap[sem].rt += 1;
        }

        studentSemesterCounts[st] = semMap;
      }

      const rows = students
        .slice()
        .sort((a, b) => a.localeCompare(b))
        .map((st) => {
          const c = studentSemesterCounts[st] || { S1: { ab: 0, rt: 0 }, S2: { ab: 0, rt: 0 } };
          const totAb = c.S1.ab + c.S2.ab;
          const totRt = c.S1.rt + c.S2.rt;
          return { st, c, totAb, totRt };
        });

      const totals = rows.reduce(
        (acc, r) => {
          acc.S1.ab += r.c.S1.ab;
          acc.S1.rt += r.c.S1.rt;
          acc.S2.ab += r.c.S2.ab;
          acc.S2.rt += r.c.S2.rt;
          acc.T.ab += r.totAb;
          acc.T.rt += r.totRt;
          return acc;
        },
        { S1: { ab: 0, rt: 0 }, S2: { ab: 0, rt: 0 }, T: { ab: 0, rt: 0 } }
      );

      const semRange = (sem: SemesterInfo) => {
        const endIncl = addDaysYmd(sem.endYmdExclusive, -1);
        return `${formatYmdFr(sem.startYmd)} ‚Üí ${formatYmdFr(endIncl)}`;
      };

      const metaLine = `S1 (${semRange(semS1)}) ‚Ä¢ S2 (${semRange(semS2)}) ‚Ä¢ Jours de cours effectifs (jusqu'√† ${formatYmdFr(cutoffYmd)}) : S1=${courseDaysBySemesterSoFar.S1}, S2=${courseDaysBySemesterSoFar.S2}`;

      if (rows.length === 0) {
        return `<div class="absences-recap-print"><h2>R√©capitulatif absences/retards</h2><div class="meta">${escapeHtmlForPrint(metaLine)}</div><div>Aucun √©l√®ve.</div></div>`;
      }

      const tr = rows
        .map((r) => {
          return `<tr>
<td class="st">${escapeHtmlForPrint(r.st)}</td>
<td class="n">${r.c.S1.ab}</td>
<td class="n">${r.c.S1.rt}</td>
<td class="n">${r.c.S2.ab}</td>
<td class="n">${r.c.S2.rt}</td>
<td class="n">${r.totAb}</td>
<td class="n">${r.totRt}</td>
</tr>`;
        })
        .join("");

      const tfoot = `<tr>
<td class="st">Total classe</td>
<td class="n">${totals.S1.ab}</td>
<td class="n">${totals.S1.rt}</td>
<td class="n">${totals.S2.ab}</td>
<td class="n">${totals.S2.rt}</td>
<td class="n">${totals.T.ab}</td>
<td class="n">${totals.T.rt}</td>
</tr>`;

      return `<div class="absences-recap-print">
  <h2>R√©capitulatif absences/retards</h2>
  <div class="meta">${escapeHtmlForPrint(metaLine)}</div>
  <table class="recap-table">
    <colgroup>
      <col style="width:52%" />
      <col style="width:8%" /><col style="width:8%" />
      <col style="width:8%" /><col style="width:8%" />
      <col style="width:8%" /><col style="width:8%" />
    </colgroup>
    <thead>
      <tr>
        <th class="left">√âl√®ve</th>
        <th colspan="2">S1</th>
        <th colspan="2">S2</th>
        <th colspan="2">Total</th>
      </tr>
      <tr>
        <th class="left"></th>
        <th>AB</th><th>RT</th>
        <th>AB</th><th>RT</th>
        <th>AB</th><th>RT</th>
      </tr>
    </thead>
    <tbody>${tr}</tbody>
    <tfoot>${tfoot}</tfoot>
  </table>
</div>`;
    } catch (e) {
      return `<div class="absences-recap-print"><h2>R√©capitulatif absences/retards</h2><div>Impossible de g√©n√©rer le r√©capitulatif.</div></div>`;
    }
  })();

  const printedMainDom = (() => {
    const dom = serializeDomForPrint(wrap);
    return dom;
  })();



  const html = `<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>${escapeHtmlForPrint(title)}</title>
  ${styleTags}
  <style>
    @page { size: A3 landscape; margin: 8mm 8mm 8mm 4mm; }
    ${PRINT_BASE_CSS}

    /* On garde le texte des boutons dans le tableau (en-t√™tes jours/semaine) */
    .absences-print-root table button { display: contents !important; }

    /* Nettoyage UI */
    .absences-controls, .absences-sidepanel { display: none !important; }
    .absences-grid { grid-template-columns: 1fr !important; }

    #page { width: calc(420mm - 16mm); margin: 0; overflow: visible; }
    #recapRoot { margin-top: 6mm; }
    #pdfRoot { transform-origin: top left; transform: scale(var(--pdfScale, 1)); width: max-content; }

    /*
      Important: en impression Chromium, transform: scale() ne r√©duit pas toujours la hauteur "layout" utilis√©e
      pour la pagination, ce qui peut envoyer le r√©cap en page 2. On utilise zoom en mode print (layout-aware).
    */
    @media print {
      /* Supprime le padding inline pour maximiser la hauteur disponible */
      .print-root { padding: 0 !important; }
      #pdfRoot { zoom: var(--pdfScale, 1) !important; transform: none !important; }
    }
    .absences-print-root table { border-collapse: collapse; }
    /* Table (absences/retards) : lisibilit√© en impression */
    .absences-print-root table { font-size: 13px !important; }
    /* Noms √©l√®ves plus grands en print */
    .absences-print-root .student-name { font-size: 15px !important; }
    .absences-print-root td.sticky.left-0 { font-size: 15px !important; }
    /* Les libell√©s AB/RT & p√©riodes utilisaient text-[10px] en UI */
    .absences-print-root .text-\\[10px\\] { font-size: 13px !important; }
    .absences-print-root .text-\\[11px\\] { font-size: 14px !important; }
    .absences-print-root th, .absences-print-root td { padding: 2px 3px !important; }
    /* Les cellules ont souvent un height inline => on force une hauteur plus confortable */
    .absences-print-root th[style], .absences-print-root td[style] { height: 20px !important; }


    /* Colonne √©l√®ves : toujours sur 1 ligne + ellipsis (impression) */
    .absences-print-root td.sticky.left-0 { white-space: nowrap !important; }
    .absences-print-root .student-name-row { min-width: 0 !important; }
    .absences-print-root .student-name {
      display: block;
      min-width: 0 !important;
      overflow: hidden !important;
      text-overflow: ellipsis !important;
      white-space: nowrap !important;
    }

/* Emp√™che le clipping horizontal (containers scroll/hidden) */
.absences-print-root .overflow-x-auto { overflow: visible !important; }
.absences-print-root .overflow-hidden { overflow: visible !important; }

/* Largeur auto de la colonne √âl√®ve (pour gagner de la place) */
.absences-print-root { --nameColW: 140px; }
.absences-print-root colgroup col:first-child { width: var(--nameColW) !important; }
.absences-print-root th.sticky.left-0,
.absences-print-root td.sticky.left-0 {
  width: var(--nameColW) !important;
  min-width: var(--nameColW) !important;
  max-width: var(--nameColW) !important;
}
.absences-print-root th.sticky.left-0,
.absences-print-root td.sticky.left-0 {
  padding-left: 4px !important;
  padding-right: 4px !important;
}

    /* R√©capitulatif (impression) : toujours S1 + S2 (m√™me si S2 pas commenc√©) ‚Äî sur la m√™me page */
    .absences-recap-print { break-inside: avoid; page-break-inside: avoid; max-width: 260mm; margin: 0; }
    .absences-recap-print h2 { font-size: 15px; font-weight: 800; margin: 0 0 3px 0; }
    .absences-recap-print .meta { font-size: 11px; color: var(--print-muted-2); margin: 0 0 4px 0; }
    .absences-recap-print table { width: 100%; border-collapse: collapse; font-size: 10px; table-layout: fixed; }
    .absences-recap-print th, .absences-recap-print td { border: 1px solid var(--print-border); padding: 2px 4px; height: 18px; }
    .absences-recap-print th { background: var(--print-table-head-bg); }
    .absences-recap-print td.n { text-align: center; font-variant-numeric: tabular-nums; }
    .absences-recap-print td.st, .absences-recap-print th.left { text-align: left; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .absences-recap-print tfoot td { font-weight: 700; }

  </style>
</head>
<body class="bg-white text-neutral-900">
  <div class="print-root" style="padding:8px">
${buildPrintHeaderHtml(escapeHtmlForPrint, {
viewTitle: "Absences / retards",
classId: classLabel,
trainingYear,
schoolYear: absencesSchoolYear,
})}

    <div id="page">
      <div id="pdfRoot">
        ${printedMainDom}
      </div>
      <div id="recapRoot">
        ${recapHtml}
      </div>
    </div>
  </div>

<script>
  function computeStudentNameColWidth() {
    const root = document.querySelector('.absences-print-root');
    if (!root) return;

    const nameEls = Array.from(root.querySelectorAll('.student-name'));
    if (!nameEls.length) return;

    const sample = nameEls[0];
    const cs = window.getComputedStyle(sample);
    const font = cs.font || (cs.fontWeight + " " + cs.fontSize + " " + cs.fontFamily);

    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    if (!ctx) return;
    ctx.font = font;

    let max = 0;
    for (const el of nameEls) {
      const t = (el.textContent || '').trim();
      if (!t) continue;
      const w = ctx.measureText(t).width;
      if (w > max) max = w;
    }
    if (!max) return;

    // padding du TD + marge (indicateurs / ic√¥nes) + clamp pour gagner de la place
    const desired = Math.min(160, Math.max(110, Math.ceil(max + 18)));
    root.style.setProperty('--nameColW', desired + 'px');
  }

  function fitToA3Width() {
    const page = document.getElementById('page');
    const root = document.getElementById('pdfRoot');
    if (!page || !root) return;

    root.style.setProperty('--pdfScale', 1);

    const pageRect = page.getBoundingClientRect();
    const baseW = page.dataset.baseW ? Number(page.dataset.baseW) : pageRect.width;
    const baseH = page.dataset.baseH ? Number(page.dataset.baseH) : pageRect.height;
    if (!page.dataset.baseW) page.dataset.baseW = String(baseW);
    if (!page.dataset.baseH) page.dataset.baseH = String(baseH);

    const availableW = baseW;

    const neededW = root.scrollWidth || root.getBoundingClientRect().width;
    if (!availableW || !neededW) return;

    const scaleRaw = Math.min(1, availableW / neededW);
    // Petite marge de s√©curit√© pour √©viter qu'1px de d√©bordement d√©clenche une 2√®me page
    const scaleSafe = Math.max(0.1, Math.min(1, scaleRaw * 0.99));
    root.style.setProperty('--pdfScale', scaleSafe.toFixed(4));
  }

  function layoutAndFit() {
    computeStudentNameColWidth();
    fitToA3Width();
  }

  window.addEventListener('load', () => {
    layoutAndFit();
    // Recalcule apr√®s rendu des polices/mesures (√©vite pagination surprise)
    setTimeout(layoutAndFit, 50);
  });
  window.addEventListener('beforeprint', () => {
    layoutAndFit();
    setTimeout(layoutAndFit, 50);
  });
</script>
</body>
</html>`;

  pushPreview(html, opts);
};


const exportNotesTableToPdf = (opts?: PreviewTargetOptions) => {
  try {
    if (!selectedClassIdForSuivi) return;

    const classe = classGroups.find((c) => c.name === selectedClassIdForSuivi);
    if (!classe) return;

    const students = (classe.students || "")
      .split("\n")
      .map((s) => s.trim())
      .filter(Boolean);

    const evalsForClass = evalMetaList.filter(
      (ev) =>
        ev.group === classe.name &&
        ev.semester !== "Ne pas utiliser de semestre"
    );

    const schoolYear = getCurrentSchoolYear();
    const notationsForYear = notationDB[schoolYear]?.[classe.name] || {};

    if (students.length === 0) {
      alert("Aucun √©l√®ve n'est renseign√© pour cette classe.");
      return;
    }
    if (evalsForClass.length === 0) {
      alert("Aucun devoir n'est encore associ√© √† cette classe.");
      return;
    }

    const evalsS1 = evalsForClass.filter((ev) => ev.semester === "S1");
    const evalsS2 = evalsForClass.filter((ev) => ev.semester === "S2");

    const title = `Tableau des notes ‚Äî ${classe.name} ‚Äî ${schoolYear} ‚Äî ${trainingYearLabel(trainingYear)}`;

    const buildTableHtml = (label: string, evals: EvalMeta[]) => {
      if (evals.length === 0) {
        return `<div class="section"><h2>${escapeHtml(label)}</h2><div class="empty">Aucun devoir pour ce semestre.</div></div>`;
      }

      const head = evals
        .map(
          (ev) => `
            <th>
              <div class="h-name">${escapeHtml(ev.name)}</div>
            </th>
          `
        )
        .join("");

      const rows = students
        .map((st) => {
          const cells = evals
            .map((ev) => {
              const evalBucket = (notationsForYear as any)[ev.id] || {};
              const entry = evalBucket[st] as NotationEntry | undefined;
              const mark = entry?.markOn20;
              const status = entry?.status;

              const display =
                status === "AB"
                            ? "AB"
                            : status === "N.NOT"
                              ? "N.NOT"
                              : typeof mark === "number"
                                ? mark.toFixed(2).replace(".", ",")
                                : "‚Äî";

              return `<td>${escapeHtml(display)}</td>`;
            })
            .join("");

          return `
            <tr>
              <td class="student">${escapeHtml(st)}</td>
              ${cells}
            </tr>
          `;
        })
        .join("");

      return `
        <div class="section">
          <h2>${escapeHtml(label)}</h2>
          <table>
            <thead>
              <tr>
                <th class="left">√âl√®ve</th>
                ${head}
              </tr>
            </thead>
            <tbody>
              ${rows}
            </tbody>
          </table>
        </div>
      `;
    };

    const html = `<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>${escapeHtml(title)}</title>
  <style>
    @page { size: A4 landscape; margin: 10mm; }
    body { font-family: Arial, sans-serif; color: var(--print-text); }
    h1 { font-size: 16px; margin: 0 0 6px; }
    .meta { font-size: 11px; color: var(--print-muted-2); margin-bottom: 10px; }
    h2 { font-size: 13px; margin: 14px 0 6px; }
    .section { margin-top: 10px; }
    .empty { font-size: 11px; color: var(--print-muted-2); padding: 8px 0; }

    table { width: 100%; border-collapse: collapse; font-size: 10px; }
    th, td { border: 1px solid var(--print-border-strong); padding: 4px 6px; }
    th { background: var(--print-table-head-bg); text-align: center; vertical-align: bottom; }
    td { text-align: center; }
    th.left, td.student { text-align: left; }
    td.student { font-weight: 600; white-space: nowrap; }
    .h-name { font-weight: 700; font-size: 10px; }
  </style>
</head>
<body>
${buildPrintHeaderHtml(escapeHtml, {
viewTitle: "Tableau des notes",
classId: classe.name,
trainingYear,
schoolYear,
})}

  ${buildTableHtml("Semestre 1", evalsS1)}
  ${buildTableHtml("Semestre 2", evalsS2)}
</body>
</html>`;

    pushPreview(html, opts);
  } catch (e) {
    console.error("Export PDF tableau notes error:", e);
    alert("Impossible d'exporter le tableau des notes en PDF.");
  }
};

  // Vue classe : pour chaque devoir, on garde les t√¢ches et les comp√©tences √©valu√©es
  const [tasksByEvalId, setTasksByEvalId] = useState<Record<string, string[]>>({});
  const [compsByEvalId, setCompsByEvalId] = useState<Record<string, string[]>>({});
  // Pour NOTE : crit√®res + poids par devoir
  const [criteresByEvalId, setCriteresByEvalId] = useState<Record<string, string[]>>({});
  const [weightsByEvalId, setWeightsByEvalId] = useState<
  Record<string, Record<string, number>>
>({});

  // Base des devoirs : liste de tous les fichiers enregistr√©s
  const [devoirDBOpen, setDevoirDBOpen] = useState(false);
  const [savedDevoirs, setSavedDevoirs] = useState<SavedDevoirMeta[]>([]);
  const [savedDevoirsTrash, setSavedDevoirsTrash] = useState<SavedDevoirMeta[]>([]);
  const [devoirDBTab, setDevoirDBTab] = useState<"devoirs" | "corbeille">("devoirs");


// Rafra√Æchir la base des devoirs si on change d'ann√©e pendant que la fen√™tre est ouverte
useEffect(() => {
  if (!devoirDBOpen) return;
  if (!isTauriRuntime()) return;
  refreshDevoirDatabaseLists().catch(() => {});
}, [devoirDBOpen, trainingYear]);

// Charge t√¢ches + comp√©tences + crit√®res + poids pour toutes les √©valuations de la classe s√©lectionn√©e
useEffect(() => {
  if (!isTauriRuntime()) return;
  if (!selectedClassIdForSuivi) {
    setTasksByEvalId({});
    setCompsByEvalId({});
    setCriteresByEvalId({});
    setWeightsByEvalId({});
    return;
  }

  (async () => {
    try {
      const evalsForClass = evalMetaList.filter(
        (ev) => ev.group === selectedClassIdForSuivi
      );

      const mapTasks: Record<string, string[]> = {};
      const mapComps: Record<string, string[]> = {};
      const mapCriteres: Record<string, string[]> = {};
      const mapWeights: Record<string, Record<string, number>> = {};

      for (const ev of evalsForClass) {
        try {
          const safeName = ev.fileName.endsWith(".json")
            ? ev.fileName
            : `${ev.fileName}.json`;

          const txt = await readTextFile(`${DEVOIR_DIR}/${safeName}`, {
            baseDir: BaseDirectory.AppLocalData,
          });

          const data = JSON.parse(txt);

          const tasks = Array.isArray(data.selectedTasks)
            ? (data.selectedTasks as string[])
            : [];

          const comps = Array.isArray(data.selectedCompetences)
            ? (data.selectedCompetences as string[])
            : [];

          const criteres = Array.isArray(data.selectedCriteres)
            ? (data.selectedCriteres as string[])
            : [];

          const weights = (data.notationWeights || {}) as Record<string, number>;

          mapTasks[ev.id] = tasks;
          mapComps[ev.id] = comps;
          mapCriteres[ev.id] = criteres;
          mapWeights[ev.id] = weights;
        } catch (e) {
          console.warn("Erreur lecture devoir pour vue classe / NOTE", e);
        }
      }

      setTasksByEvalId(mapTasks);
      setCompsByEvalId(mapComps);
      setCriteresByEvalId(mapCriteres);
      setWeightsByEvalId(mapWeights);
    } catch (e) {
      console.warn(
        "Erreur chargement t√¢ches/comp√©tences/crit√®res/poids des √©valuations",
        e
      );
    }
  })();
}, [evalMetaList, selectedClassIdForSuivi, trainingYear]);

useEffect(() => {
  if (!selectedNoteEvalId) return;

  const meta = evalMetaList.find((ev) => ev.id === selectedNoteEvalId);
  if (!meta) return;

  (async () => {
    try {
      // Charge le devoir complet comme dans la vue DEVOIR
      await loadSavedDevoir(meta.fileName);

      // Optionnel : recaler groupe + semestre
      if (meta.group) {
        setGroup(meta.group);
      }
      if (meta.semester === "S1" || meta.semester === "S2") {
        setEvaluationSemester(meta.semester);
      }
    } catch (e) {
      console.error("Erreur lors du chargement du devoir depuis NOTE :", e);
    }
  })();
}, [selectedNoteEvalId, evalMetaList]);

  // --- Effets init ---
// Remplace l'effet qui charge les exigences perso par :
React.useEffect(() => {
  (async () => {
    try {
      // 0) tenter le cache
      let seed: Record<string, string[]> | null = null;
      try {
        const cache = localStorage.getItem('exigences_db_cache');
        if (cache) seed = JSON.parse(cache);
      } catch {}

      // 1) Tauri: AppData
      if (!seed && isTauriRuntime() && await getTauriFs()) {
        const disk = await loadExigencesFromTauri();
        if (disk && Object.keys(disk).length > 0) seed = disk;
      }

      // 2) r√©seau ‚Üí repli JSON statique
      if (!seed) {
        try {
          seed = await __fetchExigencesSeed(); // ‚Üê essaie /api puis /data/exigences_db.json
        } catch {
          seed = {};
        }
      }

      const data = seed ?? {};
      setPersistedExigencesDB(data);
      setExigencesIndex(buildExigencesIndex(data));
      try { localStorage.setItem('exigences_db_cache', JSON.stringify(data)); } catch {}

      // S√®me aussi dans AppData si Tauri
      if (isTauriRuntime() && await getTauriFs()) {
        try { await saveExigencesToTauri(data); } catch (e) {
          console.warn('Seed AppData failed', e);
        }
      }
    } catch (e) {
      console.warn('Impossible de charger les exigences perso', e);
    }
  })();
}, []);

  // Charge le r√©f√©rentiel CAP : soit "Base" (fichiers /data), soit un r√©f√©rentiel sauvegard√© dans le catalogue
React.useEffect(() => {
  (async () => {
    const applySaved = async (item: ReferentielCapCatalogItem) => {
      const poles = normalizePolesList(item.poles, item.polesMap);
      const pm = normalizePolesMap(item.polesMap, poles, Object.keys(item.tcMap || {}));

      setTcMap(item.tcMap);
      setCritResDB(item.critResDB);
      setCapPoles(poles);
      setPolesMap(pm);
      setReferentielCapName(item.name || "");
      await saveReferentielCapToStore({ schema: "referentiel_cap_v1", name: item.name || "", tcMap: item.tcMap, critResDB: item.critResDB, poles, polesMap: pm });
    };

    const applyBase = async () => {
      const base = await loadBaseReferentielCap();
      const poles = normalizePolesList(base.poles, base.polesMap);
      const pm = normalizePolesMap(base.polesMap, poles, Object.keys(base.tcMap || {}));

      setTcMap(base.tcMap);
      setCritResDB(base.critResDB);
      setCapPoles(poles);
      setPolesMap(pm);
      setReferentielCapName("R√©f√©rentiel de base");
      await clearReferentielCapFromStore();
    };

    // 1) Catalogue (nouveau)
    let catalog = await loadReferentielCapCatalog();

    // 2) Migration depuis l'ancien fichier bundle unique (si le catalogue n'existe pas)
    if (!catalog) {
      const legacy = await loadReferentielCapFromStore();
      if (legacy) {
        const id = __makeId();
        const poles = normalizePolesList((legacy as any).poles, (legacy as any).polesMap);
        const pm = normalizePolesMap((legacy as any).polesMap, poles, Object.keys(legacy.tcMap || {}));
        catalog = {
          schema: "referentiels_cap_catalog_v1",
          activeId: id,
          items: [
            {
              id,
              name: legacy.name || "Mon r√©f√©rentiel",
              updatedAt: new Date().toISOString(),
              tcMap: legacy.tcMap,
              critResDB: legacy.critResDB,
              poles,
              polesMap: pm,
            },
          ],
        };
        await saveReferentielCapCatalog(catalog);
      }
    }

    if (catalog) {
      setReferentielCapCatalog(catalog);
      setReferentielCapActiveId(catalog.activeId);

      if (catalog.activeId) {
        const item = catalog.items.find((i) => i.id === catalog.activeId);
        if (item) {
          await applySaved(item);
          return;
        }

        // activeId invalide => repasse en base
        const fixed = { ...catalog, activeId: null };
        setReferentielCapCatalog(fixed);
        setReferentielCapActiveId(null);
        await saveReferentielCapCatalog(fixed);
        await applyBase();
        return;
      }

      await applyBase();
      return;
    }

    // 3) Fallback ultime
    await applyBase();
  })();
}, []);


// S'assure qu'une t√¢che active est d√©finie apr√®s chargement de tcMap
  React.useEffect(() => {
    const ks = Object.keys(tcMap);
    // On nettoie seulement ce qui n'existe plus, sans rien pr√©s√©lectionner
    setSelectedTasks(prev => prev.filter(t => ks.includes(t)));
    setActiveTask(prev => (prev && ks.includes(prev)) ? prev : null);
  }, [tcMap]);

  // Nettoyage √©ventuel du scroll-lock (s√©curit√©)
  useEffect(() => {
    document.documentElement.classList.remove('overflow-hidden');
    // @ts-ignore
    document.documentElement.dataset.scrollLockCount = "0";
  }, []);

  // Persiste le th√®me
  useEffect(() => {
    const root = document.documentElement;
    if (theme === 'dark') root.classList.add('dark'); else root.classList.remove('dark');
    localStorage.setItem('theme', theme);
  }, [theme]);

  // --- Autosave ---
React.useEffect(() => {
  if (!customExigences) return;

  if (autosaveTimer.current != null) window.clearTimeout(autosaveTimer.current);
  autosaveTimer.current = window.setTimeout(async () => {
    const merged: Record<string, string[]> = {};
    const add = (key: string, arr: string[]) => {
      merged[key] = Array.from(new Set([...(merged[key] || []), ...arr]));
    };
    if (persistedExigencesDB) {
      for (const [k, v] of Object.entries(persistedExigencesDB)) add(k, Array.isArray(v) ? v : []);
    }
    if (customExigences) {
      for (const [rawKey, v] of Object.entries(customExigences)) {
        const normKey = normalizeKeyFromCritKey(rawKey);
        add(normKey, Array.isArray(v) ? v : []);
      }
    }

    try {
      if (isTauriRuntime() && await getTauriFs()) {
        await saveExigencesToTauri(merged);
        setPersistedExigencesDB(merged);
          setExigencesIndex(buildExigencesIndex(merged));
      } else {
        await fetch('/api/exigences', {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(merged),
        });
        setPersistedExigencesDB(merged);
          setExigencesIndex(buildExigencesIndex(merged));
      }
    } catch (e) {
      console.warn('Autosave √©chou√©', e);
    }
  }, 800);

  return () => { if (autosaveTimer.current != null) window.clearTimeout(autosaveTimer.current); };
}, [customExigences]);

  // Chargement au d√©marrage
React.useEffect(() => {
  (async () => {
    try {
      const groups = await loadElevesFromStore();
      if (Array.isArray(groups)) {
        setClassGroups(groups);
      }
    } catch (e) {
      console.warn("Erreur chargement eleves.json :", e);
    } finally {
      // ‚úÖ On indique que le chargement initial (m√™me vide) est termin√©
      setElevesBootstrapped(true);
    }
  })();
}, []);

// Sauvegarde automatique d√®s que classGroups change (apr√®s bootstrap)
React.useEffect(() => {
  if (!elevesBootstrapped) return; // ‚õî ne rien sauvegarder avant la fin du chargement initial
  saveElevesToStore(classGroups).catch((e) =>
    console.warn("Erreur sauvegarde eleves.json :", e)
  );
}, [classGroups, elevesBootstrapped]);

    // Voir ou se sauvegarde le fichier classe / √©l√©ves
  React.useEffect(() => {
  (async () => {
    const dir = await appLocalDataDir();
    console.log("Dossier AppLocalData :", dir);
  })();
}, []);

    // Charge la base des √©valuations (selon l'ann√©e) au d√©marrage + √† chaque changement d'ann√©e
  React.useEffect(() => {
    setEvalMetaBootstrapped(false);

    (async () => {
      try {
        const list = await loadEvalMetaFromStore(trainingYear);
        if (Array.isArray(list)) {
          setEvalMetaList(list);
        } else {
          setEvalMetaList([]);
        }
      } catch (e) {
        console.warn("Impossible de charger evaluations_db :", e);
        setEvalMetaList([]);
      } finally {
        setEvalMetaBootstrapped(true);
      }
    })();
  }, [trainingYear]);

  // Sauvegarde la base des √©valuations d√®s qu'elle change (dans le fichier de l'ann√©e courante)
  React.useEffect(() => {
  if (!evalMetaBootstrapped) return;
  const y = trainingYearRef.current;
  saveEvalMetaToStore(evalMetaList, y).catch((e) =>
    console.warn("Erreur sauvegarde evaluations_db :", e)
  );
}, [evalMetaList, evalMetaBootstrapped]);

// Chargement du suivi comp√©tences (selon l'ann√©e) au d√©marrage + √† chaque changement d'ann√©e
React.useEffect(() => {
  setSkillsBootstrapped(false);

  (async () => {
    try {
      const db = await loadSkillsFromStore(trainingYear);
      setSkillsDB(db && typeof db === "object" ? db : {});
    } catch (e) {
      console.warn("Erreur chargement skills_db :", e);
      setSkillsDB({});
    } finally {
      setSkillsBootstrapped(true);
    }
  })();
}, [trainingYear]);

// Sauvegarde du suivi comp√©tences (fichier + localStorage) ‚Äî selon l'ann√©e courante
React.useEffect(() => {
  if (!skillsBootstrapped) return;
  const y = trainingYearRef.current;
  saveSkillsToStore(skillsDB, y).catch((e) =>
    console.warn("Erreur sauvegarde skills_db :", e)
  );
}, [skillsBootstrapped, skillsDB]);



// Charger les donn√©es de 1√®re ann√©e en lecture seule quand on est en 2√®me ann√©e
React.useEffect(() => {
  let mounted = true;
  setPremiereBootstrapped(false);

  if (trainingYear !== "deuxieme") {
    setSkillsDBPremiere({});
    setEvalMetaListPremiere([]);
    setNotationDBPremiere({});
    setPremiereBootstrapped(true);
    return () => {
      mounted = false;
    };
  }

  (async () => {
    try {
      const [sdb, eml, ndb] = await Promise.all([
        loadSkillsFromStore("premiere"),
        loadEvalMetaFromStore("premiere"),
        loadNotationFromStore("premiere"),
        loadAbsencesRetardsFromStore("premiere"),
      ]);

      if (!mounted) return;

      setSkillsDBPremiere(sdb && typeof sdb === "object" ? sdb : {});
      setEvalMetaListPremiere(Array.isArray(eml) ? eml : []);
      setNotationDBPremiere(ndb && typeof ndb === "object" ? ndb : {});
    } catch (e) {
      console.warn("Erreur chargement donn√©es 1√®re ann√©e (lecture seule) :", e);
      if (!mounted) return;
      setSkillsDBPremiere({});
      setEvalMetaListPremiere([]);
      setNotationDBPremiere({});
    } finally {
      if (mounted) setPremiereBootstrapped(true);
    }
  })();

  return () => {
    mounted = false;
  };
}, [trainingYear]);


// Charger les donn√©es de 2√®me ann√©e en lecture seule quand on est en 1√®re ann√©e
// (utile pour afficher l'√©volution sur 2 ans dans la vue "√âvolutions")
React.useEffect(() => {
  let mounted = true;
  setDeuxiemeBootstrapped(false);

  if (trainingYear !== "premiere") {
    setSkillsDBDeuxieme({});
    setEvalMetaListDeuxieme([]);
    setNotationDBDeuxieme({});
    setDeuxiemeBootstrapped(true);
    return () => {
      mounted = false;
    };
  }

  (async () => {
    try {
      const [sdb, eml, ndb] = await Promise.all([
        loadSkillsFromStore("deuxieme"),
        loadEvalMetaFromStore("deuxieme"),
        loadNotationFromStore("deuxieme"),
        loadAbsencesRetardsFromStore("deuxieme"),
      ]);

      if (!mounted) return;
      setSkillsDBDeuxieme(sdb && typeof sdb === "object" ? sdb : {});
      setEvalMetaListDeuxieme(Array.isArray(eml) ? eml : []);
      setNotationDBDeuxieme(ndb && typeof ndb === "object" ? ndb : {});
    } catch (e) {
      console.warn("Erreur chargement donn√©es 2√®me ann√©e (lecture seule) :", e);
      if (!mounted) return;
      setSkillsDBDeuxieme({});
      setEvalMetaListDeuxieme([]);
      setNotationDBDeuxieme({});
    } finally {
      if (mounted) setDeuxiemeBootstrapped(true);
    }
  })();

  return () => {
    mounted = false;
  };
}, [trainingYear]);



  // Classe s√©lectionn√©e par d√©faut pour le suivi (par *nom* de classe)
  useEffect(() => {
  if (!selectedClassIdForSuivi && classGroups.length > 0) {
    setSelectedClassIdForSuivi(classGroups[0].name);
  }
}, [classGroups, selectedClassIdForSuivi]);

  // √âl√®ve s√©lectionn√© par d√©faut quand la classe change
  useEffect(() => {
    if (!selectedClassIdForSuivi) {
      setSelectedStudentForSuivi(null);
      return;
    }
    const classe = classGroups.find((c) => c.name === selectedClassIdForSuivi);
    if (!classe) {
      setSelectedStudentForSuivi(null);
      return;
    }
    const students = (classe.students || "")
      .split("\n")
      .map((s) => s.trim())
      .filter(Boolean);

    if (!students.length) {
      setSelectedStudentForSuivi(null);
      return;
    }
    if (!selectedStudentForSuivi || !students.includes(selectedStudentForSuivi)) {
      setSelectedStudentForSuivi(students[0]);
    }
  }, [selectedClassIdForSuivi, classGroups, selectedStudentForSuivi]);

// Quand on passe en mode "notation" dans le suivi,
// on charge automatiquement un devoir pour la classe s√©lectionn√©e
useEffect(() => {
  if (suiviMode !== "notation") return;
  if (!selectedClassIdForSuivi) return;

  const classe = classGroups.find((c) => c.name === selectedClassIdForSuivi);
  if (!classe) return;

  // Tous les devoirs S1/S2 de cette classe
  const evalsForClass = evalMetaList.filter(
    (ev) =>
      ev.group === classe.name &&
      ev.semester !== "Ne pas utiliser de semestre"
  );
  if (!evalsForClass.length) return;

  // On essaie de reprendre le devoir d√©j√† s√©lectionn√©,
  // sinon on prend le 1er de la liste
  let targetEval =
    (selectedEvalIdForClasse
      ? evalsForClass.find((ev) => ev.id === selectedEvalIdForClasse)
      : null) ?? evalsForClass[0];

  // Si aucun id s√©lectionn√©, on m√©morise celui du devoir choisi
  if (!selectedEvalIdForClasse || selectedEvalIdForClasse !== targetEval.id) {
    setSelectedEvalIdForClasse(targetEval.id);
  }

  // On charge le devoir complet (comme dans handleOpenClasseDevoir)
  (async () => {
    try {
      await loadSavedDevoir(targetEval.fileName);
      if (targetEval.group) {
        setGroup(targetEval.group);
      }
      if (targetEval.semester) {
        setEvaluationSemester(targetEval.semester as SemesterKey);
      }
    } catch (err) {
      console.error(
        "Erreur lors du chargement auto du devoir pour la notation √©l√®ves :",
        err
      );
    }
  })();
}, [
  suiviMode,
  selectedClassIdForSuivi,
  selectedEvalIdForClasse,
  evalMetaList,
  classGroups,
]);

// Affecter un niveau 1‚Äì4 √† un √©l√®ve / semestre / comp√©tence (sans toggle)
// üîπ Petit helper pour avoir une mise √† jour immuable et propre du skillsDB
function ensureStudentCompEntry(
  db: SkillsDB,
  classId: string,
  studentName: string,
  compLabel: string
): { next: SkillsDB; compRec: Record<SemesterKey, Level1to4> } {
  const next: SkillsDB = { ...db };

  // Classe
  const classRec = next[classId] ? { ...next[classId] } : {};
  next[classId] = classRec;

  // √âl√®ve
  const studentRec = classRec[studentName]
    ? { ...classRec[studentName] }
    : {};
  classRec[studentName] = studentRec;

  // Comp√©tence / crit√®re (cl√© = compLabel ou critKey)
  const compRec = studentRec[compLabel]
    ? { ...(studentRec[compLabel] as any) }
    : ({} as Record<SemesterKey, Level1to4>);
  studentRec[compLabel] = compRec as any;

  return { next, compRec };
}

const setStudentLevel = (
  classId: string,
  studentName: string,
  semester: SemesterKey,
  compLabel: string,
  level: Level1to4
) => {
  setSkillsDB((prev) => {
    const { next, compRec } = ensureStudentCompEntry(
      prev,
      classId,
      studentName,
      compLabel
    );

    // On enregistre syst√©matiquement le niveau pour ce semestre
    compRec[semester] = level;

    return next;
  });
};

// üîπ Push automatique depuis la notation de devoir (inchang√© dans le comportement)
const pushCurrentDevoirToSuivi = (
  classId: string,
  studentName: string,
  semester: SemesterKey,
  evalId: string,
  scoresByCriteria: Record<string, number>
) => {
  const levelsByComp = computeLevelsFromCurrentDevoir(scoresByCriteria);

  Object.entries(levelsByComp).forEach(([compLabel, lvl]) => {
    // ‚úÖ cl√© stable = evalId||comp√©tence (√©vite les collisions quand le m√™me devoir est r√©utilis√© ou entre 1√®re/2√®me ann√©e)
    const keyWithEval = `${evalId}||${compLabel}`;
    setStudentLevel(classId, studentName, semester, keyWithEval, lvl as Level1to4);
  });
};



const loadSavedDevoir = async (fileName: string) => {
  try {
    if (!isTauriRuntime()) {
      alert("Chargement disponible uniquement dans la version Tauri.");
      return;
    }

    const safeName = fileName.endsWith(".json") ? fileName : `${fileName}.json`;
    const txt = await readTextFile(`${DEVOIR_DIR}/${safeName}`, {baseDir: BaseDirectory.AppLocalData,});
    const data = JSON.parse(txt);

    // üîπ ID & semestre (si tu utilises ces √©tats)
    if (data.evaluationId) {
      setEvaluationId(data.evaluationId);
    }
    if (data.evaluationSemester) {
      setEvaluationSemester(data.evaluationSemester as SemesterKey);
    }

    // üîπ En-t√™te
    setTitle(data.title || "");
    setProject(data.project || "");
    setLogoDataUrl((data as any).logoDataUrl || null);
    setProfessionalSituation(data.professionalSituation || "");
    setEvaluator(data.evaluator || "");
    setGroup(data.group || "GROUPE");
    setEvaluationCategory((data.evaluationCategory || data.typeEvaluation) as EvaluationCategory || "D√©couverte professionnel");
    setObjectives(data.objectives || "");
    setEvaluationType(data.evaluationType || "criterie");

    // üîπ T√¢ches
    const loadedTasks = data.selectedTasks || [];
    setSelectedTasks(loadedTasks);
    if (loadedTasks.length > 0) {
      setActiveTask(loadedTasks[0]);
    } else {
      setActiveTask(null);
    }

    // üîπ Comp√©tences / crit√®res / sous-crit√®res
    setSelectedCompetences(data.selectedCompetences || []);
    setSelectedCriteres(data.selectedCriteres || []);
    setSelectedSubCrit(data.selectedSubCrit || []);

    // üîπ Exigences
    setCustomExigences(data.customExigences || {});
    setPersistedExigencesDB(data.persistedExigencesDB || {});
    setSelectedExigence(data.selectedExigence || {});

    // üîπ Notation
    setNotationWeights(data.notationWeights || {});
    setNotationScores(data.notationScores || {});

  } catch (err) {
    console.error("Erreur chargement devoir depuis la base :", err);
    alert("Impossible d‚Äôouvrir ce devoir.");
  }
};

const handleOpenDevoirDatabase = async () => {
  if (!isTauriRuntime()) {
    alert("La base des devoirs est disponible uniquement dans l'application Tauri.");
    return;
  }

  setDevoirDBOpen(true);
  await refreshDevoirDatabaseLists();
};

const ensureJsonName = (name: string) =>
  name.toLowerCase().endsWith(".json") ? name : `${name}.json`;

// Les "instances" (anciennes copies g√©n√©r√©es) ne doivent pas appara√Ætre dans la base des devoirs.
// Elles restent toutefois lisibles si elles sont r√©f√©renc√©es par une √©valuation d√©j√† cr√©√©e.
const isDevoirInstanceFile = (name: string) =>
  /(__copie_|__copy_|(?:^|[ _-])copie(?:[ _-]|\.|$)|\(copie\))/i.test(String(name || ""));

const listDevoirsFromFolder = async (folder: string): Promise<SavedDevoirMeta[]> => {
  let entries: any[] = [];
  try {
    entries = await readDir(folder, { baseDir: BaseDirectory.AppLocalData });
  } catch (e) {
    // dossier absent => liste vide
    return [];
  }

  const files: any[] = [];
  const flatten = (arr: any[]) => {
    arr.forEach((e: any) => {
      if (Array.isArray(e.children) && e.children.length) flatten(e.children);
      else files.push(e);
    });
  };
  flatten(entries);

  const items: SavedDevoirMeta[] = [];

  for (const f of files) {
    const name = String((f as any).name || "");
    if (!name.toLowerCase().endsWith(".json")) continue;

    // ‚úÖ Base des devoirs = uniquement des devoirs "uniques".
    // Les anciennes copies/instances (__copie_) ne doivent pas polluer la liste.
    if (folder === DEVOIR_DIR && isDevoirInstanceFile(name)) continue;

    // ‚úÖ Base des devoirs : afficher uniquement les devoirs "uniques" (pas les copies/instances).
    if (folder === DEVOIR_DIR && isDevoirInstanceFile(name)) continue;

    const path = `${folder}/${name}`;
    let txt = "";
    try {
      txt = await readTextFile(path, { baseDir: BaseDirectory.AppLocalData });
    } catch {
      continue;
    }

    let title = name;
    let group: string | undefined;
    let evaluationType: string | undefined;

    try {
      const data = JSON.parse(txt);
      if (data && typeof data === "object") {
        if (typeof data.title === "string" && data.title.trim()) title = data.title;
        if (typeof data.group === "string" && data.group.trim()) group = data.group;
        if (typeof data.evaluationType === "string" && data.evaluationType.trim())
          evaluationType = data.evaluationType;
      }
    } catch {}

    items.push({ fileName: name, title, group, evaluationType });
  }

  items.sort((a, b) => a.title.localeCompare(b.title));
  return items;
};

const refreshDevoirDatabaseLists = async () => {
  const normal = await listDevoirsFromFolder(DEVOIR_DIR);
  const trash = await listDevoirsFromFolder(DEVOIR_TRASH_DIR);
  setSavedDevoirs(normal);
  setSavedDevoirsTrash(trash);
};

// Helper : d√©tecte l'usage d'un fichier devoir dans Vue classe (ann√©e courante + autre ann√©e)
const getDevoirUsedClasses = async (fileName: string) => {
  const safe = ensureJsonName(fileName);

  const currentYear = trainingYearRef.current;
  const otherYear: TrainingYear = currentYear === "premiere" ? "deuxieme" : "premiere";

  const metasCurrent = evalMetaList.filter((ev) => ensureJsonName(ev.fileName) === safe);
  let metasOther: EvalMeta[] = [];
  try {
    metasOther = (await loadEvalMetaFromStore(otherYear)).filter(
      (ev) => ensureJsonName(ev.fileName) === safe
    );
  } catch {
    metasOther = [];
  }

  const metas = [...metasCurrent, ...metasOther];
  const classes = Array.from(new Set(metas.map((m) => m.group).filter(Boolean))) as string[];
  return { count: metas.length, classes };
};

const purgeDevoirFromEvalMetaYear = async (year: TrainingYear, safeFileName: string) => {
  try {
    const list = await loadEvalMetaFromStore(year);
    const filtered = list.filter((ev) => ensureJsonName(ev.fileName) !== safeFileName);
    if (filtered.length !== list.length) {
      await saveEvalMetaToStore(filtered, year);
    }
  } catch {
    // ignore
  }
};

const moveDevoirToTrash = async (dv: SavedDevoirMeta) => {
  if (!isTauriRuntime()) return;

  // ‚úÖ Alerte si utilis√© dans Vue classe
  const { classes } = await getDevoirUsedClasses(dv.fileName);

  const msg =
    classes.length > 0
      ? `‚ö†Ô∏è Ce devoir est utilis√© dans "Vue classe" pour :\n- ${classes.join(
          "\n- "
        )}\n\nLe mettre √† la corbeille le retirera automatiquement de ces classes. Continuer ?`
      : `Mettre "${dv.title}" dans la corbeille ?`;

  const ok = await confirm(msg, { title: "Corbeille", kind: "warning" });
  if (!ok) return;


  const srcName = ensureJsonName(dv.fileName);
  const srcPath = `${DEVOIR_DIR}/${srcName}`;

  try {
    // s'assurer que la corbeille existe
    try {
      await mkdir(DEVOIR_TRASH_DIR, {
        baseDir: BaseDirectory.AppLocalData,
        recursive: true,
      } as any);
    } catch {}

    // √©viter d‚Äô√©craser si un fichier du m√™me nom existe d√©j√†
    let dstName = srcName;
    let dstPath = `${DEVOIR_TRASH_DIR}/${dstName}`;
    if (await exists(dstPath, { baseDir: BaseDirectory.AppLocalData })) {
      dstName = `${Date.now()}__${srcName}`;
      dstPath = `${DEVOIR_TRASH_DIR}/${dstName}`;
    }

    // ‚úÖ MOVE (au lieu de copier+supprimer)
    try {
      await rename(srcPath, dstPath, { baseDir: BaseDirectory.AppLocalData } as any);
    } catch (renameErr) {
      // fallback copie+remove + rollback si remove √©choue
      const txt = await readTextFile(srcPath, { baseDir: BaseDirectory.AppLocalData });
      await writeTextFile(dstPath, txt, { baseDir: BaseDirectory.AppLocalData });

      try {
        await remove(srcPath, { baseDir: BaseDirectory.AppLocalData });
      } catch (rmErr) {
        try { await remove(dstPath, { baseDir: BaseDirectory.AppLocalData }); } catch {}
        throw rmErr;
      }
    }

    // Nettoyage des r√©f√©rences c√¥t√© evalMetaList
    setEvalMetaList((prev) => prev.filter((ev) => ensureJsonName(ev.fileName) !== srcName));

    // ‚úÖ Idem dans l'autre ann√©e (si jamais le m√™me fichier √©tait r√©f√©renc√©)
    const currentYear = trainingYearRef.current;
    const otherYear: TrainingYear = currentYear === "premiere" ? "deuxieme" : "premiere";
    await purgeDevoirFromEvalMetaYear(otherYear, srcName);

    await refreshDevoirDatabaseLists();
  } catch (e) {
    console.error("Erreur d√©placement corbeille :", { srcPath, file: dv.fileName, e });
    alert(
      "Impossible de mettre ce devoir √† la corbeille.\n" +
      String((e as any)?.message ?? e)
    );
  }
};


const restoreDevoirFromTrash = async (dv: SavedDevoirMeta) => {
  if (!isTauriRuntime()) return;

  try {
    const name = ensureJsonName(dv.fileName);
    const srcPath = `${DEVOIR_TRASH_DIR}/${name}`;
    const dstPath = `${DEVOIR_DIR}/${name}`;

    const txt = await readTextFile(srcPath, { baseDir: BaseDirectory.AppLocalData });

    // si un devoir du m√™me nom existe d√©j√†, on √©vite l‚Äô√©crasement
    let finalDst = dstPath;
    if (await exists(dstPath, { baseDir: BaseDirectory.AppLocalData })) {
      const newName = `${Date.now()}__${name}`;
      finalDst = `${DEVOIR_DIR}/${newName}`;
    }

    await writeTextFile(finalDst, txt, { baseDir: BaseDirectory.AppLocalData });
    await remove(srcPath, { baseDir: BaseDirectory.AppLocalData });

    await refreshDevoirDatabaseLists();
  } catch (e) {
    console.error("Erreur restauration :", e);
    alert("Impossible de restaurer ce devoir.");
  }
};
const deleteDevoirPermanently = async (dv: SavedDevoirMeta) => {
  if (!isTauriRuntime()) return;

  // ‚úÖ Alerte si utilis√© dans Vue classe
  const { classes } = await getDevoirUsedClasses(dv.fileName);

  const msg =
    classes.length > 0
      ? `‚ö†Ô∏è Ce devoir est encore r√©f√©renc√© dans "Vue classe" pour :\n- ${classes.join(
          "\n- "
        )}\n\nLe supprimer d√©finitivement le retirera aussi de ces classes. Continuer ?`
      : `Supprimer d√©finitivement "${dv.title}" ? (irr√©versible)`;

  const ok = await confirm(msg, {
    title: "Suppression d√©finitive",
    kind: "warning",
  });
  if (!ok) return;

  try {
    const name = ensureJsonName(dv.fileName);

    await remove(`${DEVOIR_TRASH_DIR}/${name}`, {
      baseDir: BaseDirectory.AppLocalData,
    });

    // ‚úÖ S√©curit√© : retirer aussi les r√©f√©rences √©ventuelles dans les 2 ann√©es
    await purgeDevoirFromEvalMetaYear("premiere", name);
    await purgeDevoirFromEvalMetaYear("deuxieme", name);

    // ‚úÖ update UI imm√©diat
    setSavedDevoirsTrash((prev) =>
      prev.filter((x) => ensureJsonName(x.fileName) !== name)
    );

    // ‚úÖ re-scan (au cas o√π)
    await refreshDevoirDatabaseLists();
  } catch (e) {
    console.error("Erreur suppression d√©finitive :", e);
    alert("Impossible de supprimer d√©finitivement ce devoir.");
  }
};

const makeUniqueEvalId = () => `${Date.now()}-${Math.random().toString(16).slice(2)}`;

const handleSelectDevoirFromDatabase = async (dv: SavedDevoirMeta) => {
  try {
    if (!isTauriRuntime()) {
      alert("La base des devoirs est disponible uniquement dans l'application Tauri.");
      return;
    }

    const inSuiviClasse =
      activeView === "suivi" && suiviMode === "classe" && !!selectedClassIdForSuivi;

    const safeSrcName = ensureJsonName(dv.fileName);
    const srcPath = `${DEVOIR_DIR}/${safeSrcName}`;

    const srcTxt = await readTextFile(srcPath, { baseDir: BaseDirectory.AppLocalData });
    const srcData: any = JSON.parse(srcTxt || "{}");

    // üîé ID "template" (dans le fichier devoir). On le conserve pour l'√©dition du devoir,
    // mais en Vue classe on cr√©e une *instance* (id unique) dans le JSON des √©valuations.
    const srcEvalId: string | null =
      typeof srcData?.evaluationId === "string" && srcData.evaluationId.trim()
        ? srcData.evaluationId.trim()
        : null;

    // ‚úÖ En Vue classe : chaque ajout = une nouvelle entr√©e (nouvel id) dans evaluations_db_*.json
    // ‚úÖ Dans la base des devoirs : on reste sur 1 fichier unique (aucune copie cr√©√©e)
    const idToUse = inSuiviClasse ? makeUniqueEvalId() : (srcEvalId || makeUniqueEvalId());

    // Si on ouvre le devoir (√©dition), on garantit qu'il a un evaluationId.
    if (!inSuiviClasse && !srcEvalId) {
      const patched = { ...srcData, evaluationId: idToUse };
      await writeTextFile(srcPath, JSON.stringify(patched, null, 2), {
        baseDir: BaseDirectory.AppLocalData,
      });
    }

    // ‚úÖ On charge toujours le fichier devoir unique
    await loadSavedDevoir(safeSrcName);

    if (inSuiviClasse) {
      const classId = selectedClassIdForSuivi as string;
      const sem = classeSemesterForSuivi;

      setEvalMetaList((prev) => {
        if (prev.some((ev) => ev.id === idToUse)) return prev;

        const now = new Date().toISOString();
        const nameToUse =
          (typeof srcData?.title === "string" && srcData.title.trim()
            ? srcData.title.trim()
            : dv.title) || safeSrcName.replace(/\.json$/i, "");

        return [
          ...prev,
          {
            id: idToUse,
            name: nameToUse,
            fileName: safeSrcName,
            group: classId,
            semester: sem,
            createdAt: now,
          },
        ];
      });
    }

    setDevoirDBOpen(false);
  } catch (e) {
    console.error("Erreur s√©lection devoir depuis base :", e);
    alert("Impossible d'ajouter ce devoir depuis la base.");
  }
};


  // Donn√©es pour l'histogramme d'un √©l√®ve


  type EvolutionBar = { label: string; fullLabel?: string; value: number | null };

  const MiniEvolutionChart = ({
    bars,
    splitIndex,
    capLine,
    showDevoirs = true,
  }: {
    bars: EvolutionBar[];
    splitIndex: number;
    capLine: number;
    showDevoirs?: boolean;
  }) => {
    const W = 440;
    const H = showDevoirs ? 190 : 150; 
    // marge droite r√©duite : pas de l√©gende "D√©couverte / Fondamentaux / Professionnalisation"
    const M = {  
  top: 4,
  right: 18,
  bottom: showDevoirs ? 24 : 4, // ‚úÖ r√©duit la ‚Äúzone vide‚Äù en bas
  left: 32,
    };
    const plotW = W - M.left - M.right;
    const plotH = H - M.top - M.bottom;
    const maxY = 20;
    const capY = Math.max(0, Math.min(maxY, typeof capLine === "number" && isFinite(capLine) ? capLine : 10));

    const miniChartPalette = {
      zoneDisc: "var(--mini-zone-decouverte)",
      zoneFund: "var(--mini-zone-apprentissage)",
      zonePro: "var(--mini-zone-acquisition)",
      zoneOpacity: "var(--mini-zone-opacity)",
      gridStroke: "var(--mini-grid-stroke)",
      gridOpacity: "var(--mini-grid-opacity)",
      tickFill: "var(--mini-tick-fill)",
      xLabelFill: "var(--mini-xlabel-fill)",
      capStroke: "var(--mini-cap-stroke)",
      sepStroke: "var(--mini-sep-stroke)",
      barFill: "var(--mini-bar-fill)",
    } as const;

const n = Math.max(1, bars.length);
    const step = plotW / n;
    const barW = Math.max(2, step * 0.65);
    const gap = step - barW;

    const yFor = (v: number) => M.top + ((maxY - v) / maxY) * plotH;
    const xFor = (i: number) => M.left + i * step + gap / 2;

    const labelEvery = Math.max(1, Math.ceil(bars.length / 12));

    const displayLabel = (s: string) => {
      const t = String(s || "");
      return t.length > 18 ? t.slice(0, 18) + "‚Ä¶" : t;
    };

    const band = (from: number, to: number, fill: string, opacity: number | string = 1) => {
      const y1 = yFor(to);
      const y2 = yFor(from);
      return (
        <rect
          x={M.left}
          y={y1}
          width={plotW}
          height={Math.max(0, y2 - y1)}
          fill={fill}
          fillOpacity={opacity}
        />
      );
    };

    // Zones fixes (0‚Üí20) + seuil CAP param√©trable
    const discoveryMax = 5;
    const discTo = Math.min(discoveryMax, maxY);
    const capTop = Math.max(0, Math.min(maxY, capY));
    const fundFrom = discTo;
    const fundTo = Math.max(fundFrom, capTop);
    const proFrom = fundTo;
    const proTo = maxY;

    const ZONES = [
      { key: "disc", label: "D√©couverte", from: 0, to: discTo, fill: miniChartPalette.zoneDisc },
      { key: "fund", label: "Apprentissages des fondamentaux", from: fundFrom, to: fundTo, fill: miniChartPalette.zoneFund },
      { key: "pro", label: "Professionnalisation", from: proFrom, to: proTo, fill: miniChartPalette.zonePro },
    ].filter((z) => z.to > z.from + 1e-6);

    const tickValues = Array.from(
      new Set([0, discTo, capTop, 10, 15, 20].map((v) => Math.round(v * 10) / 10))
    ).sort((a, b) => a - b);

    // IMPORTANT :
    // Quand on augmente le nombre de cartes par ligne, chaque carte devient plus √©troite.
    // Avec un SVG en largeur 100% + hauteur fixe, le viewport change de ratio.
    // Le SVG conserve le ratio du viewBox (preserveAspectRatio par d√©faut) ‚Üí effet "letterbox"
    // (blanc en haut/bas) per√ßu comme des marges qui augmentent.
    // Solution : verrouiller le ratio du conteneur sur le ratio du viewBox.
    const aspectRatio = `${W} / ${H}`;

    return (
      <div className="w-full" style={{ aspectRatio }}>
        <svg
          viewBox={`0 0 ${W} ${H}`}
          className="w-full h-full"
          preserveAspectRatio="xMidYMid meet"
        >
        {/* bandes de niveaux (0-20) */}
        {ZONES.map((z) => band(z.from, z.to, z.fill, miniChartPalette.zoneOpacity))}

        {/* grilles */}
        {tickValues.map((v) => (
          <g key={v}>
            <line
              x1={M.left}
              x2={M.left + plotW}
              y1={yFor(v)}
              y2={yFor(v)}
              stroke={miniChartPalette.gridStroke}
              strokeWidth={0.8}
              opacity={miniChartPalette.gridOpacity}
            />
            <text
              x={M.left - 6}
              y={yFor(v) + 3}
              textAnchor="end"
              fontSize={9}
              fill={miniChartPalette.tickFill}
            >
              {v}
            </text>
          </g>
        ))}

        {/* ligne CAP */}
        <line
          x1={M.left}
          x2={M.left + plotW}
          y1={yFor(capY)}
          y2={yFor(capY)}
          stroke={miniChartPalette.capStroke}
          strokeWidth={2.2}
        />
        <text
          x={M.left + plotW - 4}
          y={yFor(capY) - 4}
          textAnchor="end"
          fontSize={10.5}
          fontWeight={800}
          fill={miniChartPalette.capStroke}
        >
          CAP
        </text>

        {/* s√©paration ann√©e 1 / ann√©e 2 */}
        {splitIndex > 0 && splitIndex < bars.length && (
          <line
            x1={M.left + splitIndex * step}
            x2={M.left + splitIndex * step}
            y1={M.top}
            y2={M.top + plotH}
            stroke={miniChartPalette.sepStroke}
            strokeWidth={1}
            strokeDasharray="4 4"
            opacity={0.5}
          />
        )}

        {/* barres */}
        {bars.map((b, i) => {
          if (b.value == null) return null;
          const v = Math.max(0, Math.min(maxY, b.value));
          const x = xFor(i);
          const y = yFor(v);
          const h = yFor(0) - y;
          return (
            <g key={i}>
              <title>{(b.fullLabel ?? b.label)} ‚Äî {v.toFixed(1)} / 20</title>
              <rect
                x={x}
                y={y}
                width={barW}
                height={Math.max(0, h)}
                fill={miniChartPalette.barFill}
              />
            </g>
          );
        })}

        {/* labels X */}
        {showDevoirs && bars.map((b, i) => {
          if (i % labelEvery !== 0) return null;
          const x = xFor(i) + barW / 2;
          const y = M.top + plotH + 18;
          return (
            <text
              key={i}
              x={x}
              y={y}
              fontSize={8.5}
              fill={miniChartPalette.xLabelFill}
              textAnchor="end"
              transform={`rotate(-55 ${x} ${y})`}
            >
              <title>{b.fullLabel ?? b.label}</title>
              {displayLabel(b.label)}
            </text>
          );
        })}
        </svg>
      </div>
    );
  };

const handleRemoveEvalFromClasseSemester = (evalId: string) => {
  const ev = evalMetaList.find((x) => x.id === evalId);

  const ok = window.confirm(
    "Supprimer ce devoir et effacer toutes les notes + niveaux de synth√®se associ√©s ? (irr√©versible)"
  );
  if (!ok) return;

  // 1) Retirer la colonne (meta)
  setEvalMetaList((prev) => prev.filter((x) => x.id !== evalId));

  // 2) D√©s√©lectionner si besoin
  if (selectedNoteEvalId === evalId) setSelectedNoteEvalId(null);
  if (selectedEvalIdForClasse === evalId) setSelectedEvalIdForClasse(null);

  // 3) Purger NOTATION_DB (ann√©e scolaire courante, classe concern√©e)
  try {
    const schoolYear = getCurrentSchoolYear();
    const classId = ev?.group;

    setNotationDB((prev) => {
      const next: NotationDB = { ...prev };
      const yearBucket: any = { ...(next[schoolYear] || {}) };

      if (classId && yearBucket[classId]) {
        const classBucket: any = { ...(yearBucket[classId] || {}) };
        if (classBucket[evalId]) delete classBucket[evalId];
        yearBucket[classId] = classBucket;
      } else {
        // fallback: si pas de classe, on supprime partout (rare)
        Object.keys(yearBucket).forEach((cls) => {
          const classBucket: any = { ...(yearBucket[cls] || {}) };
          if (classBucket[evalId]) delete classBucket[evalId];
          yearBucket[cls] = classBucket;
        });
      }

      next[schoolYear] = yearBucket;
      return next;
    });
  } catch (e) {
    console.warn("Purge notationDB √©chou√©e:", e);
  }

  // 4) Purger SKILLS_DB (cl√© = evalId||comp ; legacy = evalName||comp)
  try {
    const classId = ev?.group;
    const legacyName = (ev?.name || "").trim();
    if (!classId) return;

    setSkillsDB((prev) => {
      const classRec: any = (prev as any)[classId];
      if (!classRec) return prev;

      const next: SkillsDB = { ...prev };
      const nextClassRec: any = { ...classRec };
      (next as any)[classId] = nextClassRec;

      Object.entries(classRec).forEach(([studentName, studentRecordAny]) => {
        const studentRecord = (studentRecordAny || {}) as Record<string, any>;
        let changed = false;
        const nextStudent: any = { ...studentRecord };

        Object.keys(studentRecord).forEach((k) => {
          if (k.startsWith(`${evalId}||`)) {
            delete nextStudent[k];
            changed = true;
            return;
          }
          if (legacyName && k.startsWith(`${legacyName}||`)) {
            delete nextStudent[k];
            changed = true;
            return;
          }
        });

        if (changed) nextClassRec[studentName] = nextStudent;
      });

      return next;
    });
  } catch (e) {
    console.warn("Purge skillsDB √©chou√©e:", e);
  }
};

  // --- Helpers UI ---
  const isTaskExpanded = (task: string) => expandedTasks[task] ?? true;
  const toggleTaskExpanded = (task: string) => setExpandedTasks(prev => ({ ...prev, [task]: !(prev[task] ?? true) }));
  const isCompExpanded = (compKey: string) => expandedCompetences[compKey] ?? false;
  const toggleCompExpanded = (compKey: string) => setExpandedCompetences(prev => ({ ...prev, [compKey]: !(prev[compKey] ?? false) }));

  const toggleSubCrit = (key: string, comp: string, item: string) => {
    const [taskLabel] = key.split("||");
    const compScopedKey = taskLabel + "||" + comp;

    setSelectedSubCrit(prevSub => {
      const on = prevSub.includes(key);
      const nextSub = on ? prevSub.filter(k => k !== key) : [...prevSub, key];

      if (on) {
        const stillUnderComp = nextSub.some(k => k.startsWith(taskLabel + "||" + comp + "::"));
        if (!stillUnderComp) setSelectedCompetences(prevComps => prevComps.filter(c => c !== compScopedKey));

        setSelectedCriteres(prevCrit => {
          const critKey = comp + "::" + item;
          const remainsForItem = nextSub.some(k => k.startsWith(taskLabel + "||" + comp + "::" + item + "::"));
          return remainsForItem ? prevCrit : prevCrit.filter(k => k !== critKey);
        });
      } else {
        setSelectedCriteres(prevCrit => {
          const critKey = comp + "::" + item;
          return prevCrit.includes(critKey) ? prevCrit : [...prevCrit, critKey];
        });
        setSelectedCompetences(prevComps => prevComps.includes(compScopedKey) ? prevComps : [...prevComps, compScopedKey]);
      }
      return nextSub;
    });
  };

  const toggleExigenceSelection = (critKey: string, ex: string) => {
    setSelectedExigence(prev => {
      const current = prev[critKey] ?? getEffectiveExigences(critKey);
      const next = current.includes(ex) ? current.filter(e => e !== ex) : [...current, ex];
      return { ...prev, [critKey]: next };
    });
  };

  const removeFromCell = (critKey: string, ex: string) => {
    setSelectedExigence(prev => {
      const current = prev[critKey] ?? getEffectiveExigences(critKey);
const next = { ...prev };
next[critKey] = current.filter(e => e !== ex);
return next;
    });
  };

  const getDBExigences = (critKey: string): string[] => {
    const { comp, item } = parseScopedCritKey(critKey);
    if (!critResDB) return [];
    const compEntry = critResDB[comp];
    const itemEntry = compEntry?.[item];
    return itemEntry?.exigences ?? [];
  };

  const getEffectiveExigences = (critKey: string): string[] => {
    const base = getDBExigences(critKey) || [];
    const custom = customExigences[critKey] || [];
    const set = new Set<string>([...base, ...custom]);
    return Array.from(set);
  };

  const openManage = (critKey: string) => {
    setCustomExigences(prev => {
      if (prev[critKey]) return prev;
      const base = getDBExigences(critKey);
      const { comp, item } = parseScopedCritKey(critKey);
      const persisted = getPersistedExigencesFor(comp, item) ?? [];
      return { ...prev, [critKey]: Array.from(new Set([...base, ...persisted])) };
    });
    setManageKey(critKey);
    setDrawerInput("");
  };

  const addDrawerExigence = () => {
    if (!manageKey) return;
    const v = drawerInput.trim();
    if (!v) return;
    setCustomExigences(prev => {
      const base = prev[manageKey!] ?? [];
      const arr = [...base];
      if (!arr.includes(v)) arr.push(v);
      return { ...prev, [manageKey!]: arr };
    });
    setSelectedExigence(prev => {
      const current = prev[manageKey!] ?? [];
      return current.includes(v) ? prev : { ...prev, [manageKey!]: [...current, v] };
    });
    setDrawerInput("");
  };

  const removeDrawerExigence = (idx: number) => {
    if (!manageKey) return;
    setCustomExigences(prev => {
      const arr = [...(prev[manageKey!] ?? getDBExigences(manageKey!))];
      if (idx < 0 || idx >= arr.length) return prev;
      const ex = arr[idx];
      arr.splice(idx, 1);
      const next = { ...prev, [manageKey!]: arr };

      // remove from selectedExigence so UI selection updates immediately
      setSelectedExigence(prevSel => {
        const cur = prevSel[manageKey!] ?? [];
        return { ...prevSel, [manageKey!]: cur.filter(e => e !== ex) };
      });

      // Also remove from persistedExigencesDB if present in the persisted "library"
      try {
        const { task, comp, item } = parseScopedCritKey(manageKey!);
        const code = __extractCode(comp) || comp;
        const codeKey = __norm(code);
        const itemKey = __norm(__cleanItem(item));
        const pair = codeKey + '::' + itemKey;
        const rawKey = rawKeyByPairRef.current[pair] || `${code} II ${__cleanItem(item)} :`;
        const currentPersist = Array.isArray((persistedExigencesDB as any)?.[rawKey]) ? (persistedExigencesDB as any)[rawKey] as string[] : [];
        if (currentPersist.includes(ex)) {
          const nextPersist = { ...(persistedExigencesDB || {}) };
          const filtered = currentPersist.filter(v => v !== ex);
          if (filtered.length > 0) nextPersist[rawKey] = filtered;
          else delete nextPersist[rawKey];
          setPersistedExigencesDB(nextPersist);
          setExigencesIndex(buildExigencesIndex(nextPersist));
          try { localStorage.setItem('exigences_db_cache', JSON.stringify(nextPersist)); } catch {}
          (async () => {
            try {
              if (isTauriRuntime() && await getTauriFs()) {
                await saveExigencesToTauri(nextPersist);
              }
            } catch (e) {
              console.warn('saveExigencesToTauri failed', e);
            }
          })();
        }
      } catch (e) {
        // ignore errors here to avoid crashing manage UI
        console.warn('Failed to remove from persistedExigencesDB', e);
      }

      return next;
    });
  };

  const onLogoUpload = async (f: File) => {
    const reader = new FileReader();
    reader.onload = () => setLogoDataUrl(String(reader.result));
    reader.readAsDataURL(f);
  };

  // Petit helper pour s√©curiser le HTML
  const escapeHtml = (unsafe: string) =>
    (unsafe || "")
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&#039;");

  // Construit les lignes du tableau d'exigences perso (comme l'√©tape 3)
  const buildPreviewRows = () => {
    if (!critResDB) return [];

    const rows: {
      task: string;
      comp: string;
      item: string;
      criteres: string[];
      exigences: string[];
    }[] = [];

    sortByTaskNumber(selectedTasks).forEach((task) => {
      const comps = (tcMap[task] || []) as string[];

      comps.forEach((comp) => {
        const compEntry = (critResDB as any)[comp] || {};
        const itemKeys = Object.keys(compEntry);

        itemKeys.forEach((item) => {
          // On garde seulement les items o√π au moins un sous-crit√®re est s√©lectionn√©
          const prefix = `${task}||${comp}::${item}::`;
          const subList: string[] =
            (critResDB &&
              (critResDB as any)[comp] &&
              (critResDB as any)[comp][item]?.resultats) ||
            [];

          const selectedIdx = selectedSubCrit
            .filter((k) => k.startsWith(prefix) && !/::E\d+$/.test(k))
            .map((k) => {
              const m = k.match(/::(\d+)$/);
              return m ? Number(m[1]) : null;
            })
            .filter((n): n is number => n !== null);

          if (selectedIdx.length === 0) return;

          const critKey = `${task}||${comp}::${item}`;
          const normKey = normalizeKeyFromCritKey(critKey);

          const options = Array.from(
            new Set([
              ...getEffectiveExigences(critKey),
              ...(persistedExigencesDB?.[normKey] ?? []),
              ...(getPersistedExigencesFor(comp, item) ?? []),
              ...(customExigences?.[critKey] ?? []),
            ] as string[])
          );

          const baseSelected =
            selectedExigence[critKey] ?? getEffectiveExigences(critKey);
          const chosenAll = Array.from(new Set(baseSelected));
          const chosenCustom = chosenAll.filter((ex) => options.includes(ex));

          rows.push({
            task,
            comp,
            item,
            criteres: selectedIdx.map((i) => subList[i]),
            exigences: chosenCustom,
          });
        });
      });
    });

    return rows;
  };
// Calcule un niveau 0‚Äì3 par comp√©tence √† partir du devoir en cours
function computeLevelsFromCurrentDevoir(
  scoresByCriteria: Record<string, number>
): Record<string, Level1to4> {
  const rows = buildPreviewRows();
  if (!rows || rows.length === 0) {
    return {};
  }

  let evalLabel = "";
  if (selectedNoteEvalId) {
    const meta = evalMetaList.find((ev) => ev.id === selectedNoteEvalId);
    if (meta?.name) {
      evalLabel = meta.name.trim();
    }
  }

  type Agg = { weighted: number; totalWeight: number };
  const agg: Record<string, Agg> = {};

  rows.forEach((row) => {
    row.criteres.forEach((_critereText: string, idx: number) => {
      const key = `${row.task}||${row.comp}::${row.item}::crit#${idx}`;
      const score = scoresByCriteria[key];
      const weight = notationWeights[key] ?? 1;

      if (typeof score !== "number") return;

      const baseCompLabel = row.comp;
      const compLabel = baseCompLabel;

      if (!agg[compLabel]) {
        agg[compLabel] = { weighted: 0, totalWeight: 0 };
      }

      agg[compLabel].weighted += score * weight;
      agg[compLabel].totalWeight += weight;
    });
  });

  const result: Record<string, Level1to4> = {};
  for (const [compLabel, { weighted, totalWeight }] of Object.entries(agg)) {
    if (totalWeight === 0) continue;

    const avg = weighted / totalWeight;
    let lvl: Level1to4;
    if (avg < 1.5) lvl = 1;
    else if (avg < 2.5) lvl = 2;
    else if (avg < 3.5) lvl = 3;
    else lvl = 4;

    result[compLabel] = lvl;
  }

  return result;
}


// üîÅ Rendu r√©utilisable de la NOTATION crit√©ri√©e

const renderNotationCriteree = (options?: { lockWeights?: boolean }) => {
  const lockWeights = options?.lockWeights ?? false;
  const rows = buildPreviewRows();

  if (!rows || rows.length === 0) {
    return (
      <div className="text-sm text-neutral-600 dark:text-neutral-300">
        S√©lectionnez d&apos;abord des crit√®res dans les onglets{" "}
        <strong>COMP√âTENCES</strong> et <strong>EXIGENCES</strong>.
      </div>
    );
  }

  // Chaque crit√®re de chaque item devient une ¬´ ligne de notation ¬ª
  const critLines = rows.flatMap((row) =>
    row.criteres.map((critereText, idx) => {
      const key = `${row.task}||${row.comp}::${row.item}::crit#${idx}`;
      return {
        key,
        task: row.task,
        comp: row.comp,
        item: row.item,
        critere: critereText,
        exigences: row.exigences,
      };
    })
  );

  if (critLines.length === 0) {
    return (
      <div className="text-sm text-neutral-600 dark:text-neutral-300">
        Aucun crit√®re s√©lectionn√©. Utilisez d&apos;abord l&apos;onglet <strong>COMP√âTENCES</strong>.
      </div>
    );
  }

    // üîÄ Choix de la source des scores :
  // - DEVOIR (lockWeights = false) ‚Üí notationScores (bar√®me / pr√©visualisation)
  // - NOTE   (lockWeights = true)  ‚Üí studentNotationScores (par √©l√®ve)
  const scoreMap = lockWeights ? studentNotationScores : notationScores;
  const getScoreForView = (key: string) => scoreMap[key];
  const setScoreForView = lockWeights
    ? setStudentNotationScores
    : setNotationScores;

   // üîπ Poids total (tous crit√®res confondus)
const totalWeight = critLines.reduce(
  (sum, r) => sum + getWeight(r.key),
  0
);
// üîπ Calcul de la note de base (sur 20) √† partir des poids + scores
let totalWeightForMark = 0;
let weightedAchieved = 0;

critLines.forEach((r) => {
  const w = notationWeights[r.key] ?? 1;
  const s = getScoreForView(r.key); // 0,1,2,3,4 (0 = NR)

  if (typeof s !== "number") return; // pas encore not√©

  totalWeightForMark += w;
  weightedAchieved += w * (s / 4);
});

const baseMarkOn20 =
  totalWeightForMark > 0 ? (weightedAchieved / totalWeightForMark) * 20 : 0;

  // üîπ Bonus / malus d'engagement uniquement dans la vue "notation par devoir"
  // (lockWeights = true c√¥t√© onglet NOTE)
  const factor = lockWeights ? computeEngagementFactor(engagementLevel) : 1;

  // on borne entre 0 et 20 pour √©viter les valeurs aberrantes
  const finalMark = Math.max(0, Math.min(20, baseMarkOn20 * factor));

  // üü¶ Statut AB (absent) : affichage + gel de la notation pour cet √©l√®ve
  const schoolYearForAbsence = getCurrentSchoolYear();
  const classNameForAbsence = selectedClassIdForSuivi;
  const evalIdForAbsence = selectedNoteEvalId;
  const studentNameForAbsence = selectedNoteStudent;
  const currentNotationEntryForAbsence: NotationEntry | undefined =
    lockWeights && classNameForAbsence && evalIdForAbsence && studentNameForAbsence
      ? ((((notationDB[schoolYearForAbsence] || {})[classNameForAbsence] || {})[
          evalIdForAbsence
        ] || {})[studentNameForAbsence] as NotationEntry | undefined)
      : undefined;
  const isAbsentForThisEval = currentNotationEntryForAbsence?.status === "AB";
  const isNonNotedForThisEval = currentNotationEntryForAbsence?.status === "N.NOT";
  const isFrozenForThisEval = isAbsentForThisEval || isNonNotedForThisEval;

  // üîπ Regroupement par t√¢che (affichage proche de l‚Äôonglet DEVOIR)
  const groupedByTask = critLines.reduce<
    Record<string, (typeof critLines)[number][]>
  >((acc, r) => {
    const label = r.task || "Sans t√¢che";
    if (!acc[label]) acc[label] = [];
    acc[label].push(r);
    return acc;
  }, {});

  return (
    <div className="space-y-4">


{/* Bandeau explicatif + engagement + note + bouton */}
<div className="flex flex-wrap items-start justify-between gap-3">
  {/* Colonne gauche : Notation crit√©ri√©e + texte + engagement (en dessous) */}
  <div className="flex flex-col gap-2 max-w-4xl">
    <div className="border border-sky-200 dark:border-sky-400/40 rounded-2xl px-4 py-3 bg-white dark:bg-[var(--night-surface)] keep-light shadow-sm text-xs text-neutral-700 dark:text-neutral-300 space-y-1">
      <h2 className="text-base font-semibold text-neutral-900 dark:text-neutral-300">Notation crit√©ri√©e</h2>

      {lockWeights ? (
        // üîí Mode NOTE : on saisit les niveaux, les poids sont fig√©s
        <p className="text-xs text-neutral-500 max-w-4xl">
          Dans cette vue, saisir uniquement le{" "}
          <strong>niveau de ma√Ætrise</strong> pour chaque crit√®re (NR, 1, 2, 3, 4).
          Les <strong>poids</strong> sont d√©finis dans l&apos;onglet{" "}
          <strong>DEVOIR</strong>. La <strong>note finale</strong> est
          calcul√©e √† partir des niveaux renseign√©s, des pond√©rations et de
          l&apos;√©ventuel <strong>ajustement d&apos;engagement de l&apos;√©l√®ve</strong>.
          <br />
          <span className="font-semibold uppercase">
            Niveau de ma√Ætrise :
          </span>{" "}
          NR = 0 = Non R√©alis√©, 1 = Non acquis, 2 = En cours d&apos;acquisition,
          3 = Ma√Ætrise satisfaisante, 4 = Tr√®s bonne ma√Ætrise.
        </p>
      ) : (
        // üõ†Ô∏è Mode DEVOIR : on construit le bar√®me et les poids
        <p className="text-xs text-neutral-500 max-w-4xl">
          Dans cet onglet, tu construis le <strong>bar√®me</strong> du devoir.
          Pour chaque <strong>crit√®re d&apos;√©valuation</strong>, saisis un{" "}
          <strong>poids en %</strong> (10, 20, 40‚Ä¶) qui refl√®te son importance
          dans le devoir. Plus le <strong>poids</strong> est √©lev√©, plus il
          compte dans la <strong>note finale</strong>. Le total des poids peut
          d√©passer <strong>100&nbsp;%</strong> : ils sont utilis√©s comme{" "}
          <strong>coefficients relatifs</strong> et automatiquement pris en
          compte pour calculer la note sur 20.
          <br />
          <span className="font-semibold uppercase">
            Niveau de ma√Ætrise
          </span>{" "}
          (NR = 0 = Non R√©alis√©, 1 = Non acquis, 2 = En cours d&apos;acquisition,
          3 = Ma√Ætrise satisfaisante, 4 = Tr√®s bonne ma√Ætrise).
        </p>
      )}
    </div>

{/* Engagement de l'√©l√®ve en LIGNE (compact) avec contours color√©s */}
{lockWeights && selectedNoteStudent && (
  <div className="border border-neutral-200 dark:border-sky-400/35 rounded-2xl px-4 py-3 bg-yellow-50 dark:bg-[var(--night-panel)] keep-light shadow-sm text-xs text-neutral-700 dark:text-neutral-300 max-w-4xl space-y-1">
  <div className="flex flex-wrap items-center gap-2 text-[12px]">
    <h2 className="text-base font-semibold text-neutral-900 dark:text-neutral-300">ENGAGEMENT DE L&apos;√âL√àVE :</h2>

    {(() => {
      const OPTIONS: Array<{ id: EngagementLevel; label: string }> = [
        { id: "absence", label: "Peu engag√©" },
        { id: "attente", label: "En attente" },
        { id: "normal", label: "Normal" },
        { id: "engage", label: "Engag√©" },
        { id: "volontaire", label: "Tr√®s engag√©" },
      ];

      const COLORS: Record<EngagementLevel, { bg: string; bgSoft: string; text: string }> = {
        absence: {
          bg: "var(--eng-absence)",
          bgSoft: "var(--eng-absence-soft)",
          text: "var(--eng-text)"
        },
        attente: {
          bg: "var(--eng-attente)",
          bgSoft: "var(--eng-attente-soft)",
          text: "var(--eng-text)"
        },
        normal: {
          bg: "var(--eng-normal)",
          bgSoft: "var(--eng-normal-soft)",
          text: "var(--eng-text)"
        },
        engage: {
          bg: "var(--eng-engage)",
          bgSoft: "var(--eng-engage-soft)",
          text: "var(--eng-text)"
        },
        volontaire: {
          bg: "var(--eng-volontaire)",
          bgSoft: "var(--eng-volontaire-soft)",
          text: "var(--eng-text)"
        },
      };

      return OPTIONS.map((opt) => {
        const isActive = engagementLevel === opt.id;
        const c = COLORS[opt.id];

        return (
          <button
            key={opt.id}
            type="button"
            disabled={lockWeights && isFrozenForThisEval}
            onClick={() => {
              if (lockWeights && isFrozenForThisEval) return;
              setEngagementLevel(opt.id);
            }}
            style={{ "--pill-bg": isActive ? c.bg : c.bgSoft, "--pill-border": c.bg, "--pill-text": c.text } as React.CSSProperties}
            className={classNames(
              "eng-pill inline-flex items-center gap-1 px-2 py-1 rounded-full border text-[10px] transition",
              "disabled:opacity-50 disabled:cursor-not-allowed",
              isActive ? "font-semibold" : "hover:brightness-95",
              isActive &&
                "ring-2 ring-offset-1 ring-neutral-900/30 dark:ring-neutral-100/60 ring-offset-white dark:ring-offset-[var(--night-ring-offset)] shadow-sm"
            )}
          >
            <span
              className="eng-pill__dot w-2 h-2 rounded-full border flex items-center justify-center"
              aria-hidden="true"
            >
              {isActive && (
                <span
                  className="eng-pill__dotInner w-1.5 h-1.5 rounded-full"
                />
              )}
            </span>

            <span>{opt.label}</span>
          </button>
        );
      });
    })()}

  </div>
  </div>
)}

  </div>
  {/* Encadr√© STATUT entre engagement et note */}
  {lockWeights && selectedNoteStudent && (
    <div className="border border-dark-800 dark:border-sky-400/40 rounded-2xl px-3 py-3 bg-white dark:bg-[var(--night-surface)] keep-light shadow-sm text-xs text-neutral-700 dark:text-neutral-300 self-start">
      <div className="text-[11px] font-semibold text-neutral-700 dark:text-neutral-300 mb-2">STATUT :</div>
      <div className="flex items-center gap-2">
        <Button
          size="sm"
          variant="outline"
          className={classNames("pill-toggle pill-toggle--absent", isAbsentForThisEval && "is-active")}
          onClick={toggleCurrentStudentAbsent}
        >
          {isAbsentForThisEval ? "Annuler AB" : "AB"}
        </Button>

        <Button
          size="sm"
          variant="outline"
          className={classNames("pill-toggle pill-toggle--nnot", isNonNotedForThisEval && "is-active")}
          onClick={toggleCurrentStudentNonNoted}
        >
          {isNonNotedForThisEval ? "Annuler N.NOT" : "N.NOT"}
        </Button>
      </div>
    </div>
  )}


  {/* Colonne droite : note finale + bouton Enregistrer EN DESSOUS */}
  <div className="border border-sky-200 dark:border-sky-400/40 rounded-2xl px-3 py-2 bg-white dark:bg-[var(--night-surface)] keep-light shadow-sm text-right text-sm min-w-[230px]">
    <div className="text-xs text-neutral-500">Pond√©ration totale</div>
    <div className="font-semibold">{totalWeight.toFixed(1)} %</div>
    <div className="text-xs text-neutral-500 mt-1">
      Note finale (sur 20)
    </div>
<div className="text-lg font-bold">
  {isAbsentForThisEval ? "AB" : isNonNotedForThisEval ? "N.NOT" : `${finalMark.toFixed(2)} / 20`}
</div>

{isFrozenForThisEval && (
  <div className="text-xs text-neutral-500 mt-1">
    {isAbsentForThisEval ? "√âl√®ve absent : notation fig√©e" : "√âl√®ve non not√© : notation fig√©e"}
  </div>
)}

{lockWeights && selectedNoteStudent && (
  <div className="mt-3 flex justify-end gap-2">
    <Button size="sm" onClick={saveCurrentStudentNotation} disabled={isFrozenForThisEval}>
      Enregistrer la notation de {selectedNoteStudent}
    </Button>
  </div>
)}

  </div>
</div>


      {/* Un bloc par T√ÇCHE */}
      <div className="space-y-5">
        {Object.entries(groupedByTask).map(([taskLabel, items]) => {
          const taskWeight = items.reduce(
            (sum, r) => sum + (getWeight(r.key) || 0),
            0
          );
          const taskPct =
            totalWeight > 0 ? (taskWeight / totalWeight) * 100 : 0;

          // üîπ Trouver le groupe (G1, G2, G3) en fonction du num√©ro de t√¢che
          const tNum = taskNumber(taskLabel);
          const group = GROUPS.find(
            (g) => tNum >= g.range[0] && tNum <= g.range[1]
          );
          const groupStyles = group ? GROUP_STYLES[group.key] : undefined;

          type RowWithSpans = {
            row: (typeof items)[number];
            showCompCell: boolean;
            compRowSpan: number;
            showItemCell: boolean;
            itemRowSpan: number;
          };

          const rowsWithSpans: RowWithSpans[] = [];

          for (let i = 0; i < items.length; i++) {
            const current = items[i];

            // ----- Fusion COMP√âTENCE -----
            let showCompCell = true;
            let compRowSpan = 1;

            if (i > 0 && items[i - 1].comp === current.comp) {
              // m√™me comp√©tence que la ligne pr√©c√©dente ‚Üí pas de cellule
              showCompCell = false;
              compRowSpan = 0;
            } else {
              // on compte combien de lignes cons√©cutives partagent la m√™me comp√©tence
              for (let j = i + 1; j < items.length; j++) {
                if (items[j].comp === current.comp) {
                  compRowSpan++;
                } else {
                  break;
                }
              }
            }

            // ----- Fusion √äTRE CAPABLE DE (comp + item identiques) -----
            let showItemCell = true;
            let itemRowSpan = 1;

            if (
              i > 0 &&
              items[i - 1].comp === current.comp &&
              items[i - 1].item === current.item
            ) {
              // m√™me comp + m√™me item que la ligne pr√©c√©dente ‚Üí pas de cellule
              showItemCell = false;
              itemRowSpan = 0;
            } else {
              // on compte combien de lignes cons√©cutives ont le m√™me couple (comp, item)
              for (let j = i + 1; j < items.length; j++) {
                if (
                  items[j].comp === current.comp &&
                  items[j].item === current.item
                ) {
                  itemRowSpan++;
                } else {
                  break;
                }
              }
            }

            rowsWithSpans.push({
              row: current,
              showCompCell,
              compRowSpan,
              showItemCell,
              itemRowSpan,
            });
          }

          return (
            <section key={taskLabel}>
              {/* üîπ Encadr√© color√© suivant le groupe G1/G2/G3 */}
              <div
                className={classNames(
                  "border rounded-2xl bg-white dark:bg-[var(--night-panel)] shadow-sm px-4 py-3 space-y-3",
                  groupStyles?.accentBorder || "border-neutral-200 dark:border-sky-400/35"
                )}
              >
                {/* En-t√™te de la t√¢che */}
                <div className="flex items-center justify-between">
                  <div className="flex items-center gap-2">
                    <span className="inline-block w-3 h-3 rounded-[4px] bg-neutral-900 dark:bg-neutral-100" />
                    <h3 className="text-sm sm:text-base font-semibold text-neutral-900 dark:text-neutral-300">
                      {taskLabel}
                    </h3>
                  </div>

                  <div className="text-[11px] sm:text-xs text-neutral-500 text-right flex items-center gap-1">
                    <span>{items.length} crit√®re(s)</span>
                    <span className="text-[10px] text-neutral-400">‚Ä¢</span>
                    <span>Total poids % : {taskWeight.toFixed(1)}</span>
                    {totalWeight > 0 && (
                      <span className="ml-1 text-[10px] font-semibold text-neutral-900 dark:text-neutral-300">
                        ({taskPct.toFixed(1)} % de la note finale)
                      </span>
                    )}
                  </div>
                </div>

                {/* Tableau de notation pour cette t√¢che */}
                <div className="overflow-x-auto">
                  <table className="w-full text-xs border-collapse">
                    <thead>
                      <tr className="bg-neutral-50 dark:bg-[var(--night-panel)]">
                        <th className="border px-2 py-1 text-left w-[20%]">
                          Comp√©tence
                        </th>
                        <th className="border px-2 py-1 text-left w-[20%]">
                          √ätre capable de‚Ä¶
                        </th>
                        <th className="border px-2 py-1 text-left w-[32%]">
                          Crit√®re d&apos;√©valuation
                        </th>
                        <th className="border px-2 py-1 text-left w-[10%]">
                          Exigence
                        </th>
                        <th className="border px-2 py-1 text-center w-[7%] dark:bg-[var(--night-base)] dark:text-neutral-300">Poids (%)</th>
                        <th className="border px-2 py-1 text-center w-[6%]">
                          Niveau
                        </th>
                      </tr>
                    </thead>

                    <tbody>
                      {rowsWithSpans.map(
                        ({
                          row: r,
                          showCompCell,
                          compRowSpan,
                          showItemCell,
                          itemRowSpan,
                        }) => {
                          const w = getWeight(r.key) || 0;
                          const s = getScoreForView(r.key);

                          const fam = parseCompetencyFamily(r.comp);
                          const famKey =
                            fam === "C1" ||
                            fam === "C2" ||
                            fam === "C3" ||
                            fam === "C4"
                              ? fam
                              : null;
                          const famStyle = famKey
                            ? FAMILY_STYLES[famKey]
                            : null;
                          const famLabel =
                            famKey === "C1"
                              ? "COMMUNIQUER"
                              : famKey === "C2"
                              ? "PR√âPARER"
                              : famKey === "C3"
                              ? "R√âALISER"
                              : famKey === "C4"
                              ? "CONTR√îLE"
                              : "";

                          const isNR = s === 0;

                          return (
                            <tr key={r.key}>
                              {/* COL 1 ‚Äî Comp√©tence (fusionn√©e) */}
                              {showCompCell && (
                                <td
                                  className="border px-2 py-1 align-middle"
                                  rowSpan={compRowSpan}
                                >
                                  <div className="flex flex-col gap-0.5">
                                    <div className="flex items-center gap-1 flex-wrap">
                                      {famStyle && (
                                        <span
                                          className={classNames(
                                            "inline-flex items-center gap-1 rounded-full px-1.5 py-0.5 text-[10px] font-semibold",
                                            famStyle.chipBg,
                                            famStyle.chipText
                                          )}
                                        >
                                          <span
                                            className={classNames(
                                              "w-2 h-2 rounded-full",
                                              famStyle.bullet
                                            )}
                                          />
                                          {famLabel}
                                        </span>
                                      )}
                                      <span className="text-[11px] font-semibold">
                                        {r.comp}
                                      </span>
                                    </div>
                                  </div>
                                </td>
                              )}

                              {/* COL 2 ‚Äî √ätre capable de‚Ä¶ (fusionn√©e si m√™me comp+item) */}
                              {showItemCell && (
                                <td
                                  className="border px-2 py-1 align-middle"
                                  rowSpan={itemRowSpan}
                                >
                                  <div className="text-[11px] text-neutral-500 dark:text-neutral-300">
                                    {r.item}
                                  </div>
                                </td>
                              )}

                              {/* COL 3 ‚Äî Crit√®re d'√©valuation */}
                              <td className="border px-2 py-1 align-middle">
                                {r.critere}
                              </td>

                              {/* COL 4 ‚Äî Exigences */}
                              <td className="border px-2 py-1 align-middle">
                                {r.exigences && r.exigences.length > 0 ? (
                                  <ul className="list-disc pl-4 space-y-0.5">
                                    {r.exigences.map((ex, i) => (
                                      <li key={i}>{ex}</li>
                                    ))}
                                  </ul>
                                ) : (
                                  <span className="text-[11px] text-neutral-400 italic">
                                    Aucune exigence personnalis√©e
                                  </span>
                                )}
                              </td>

                              {/* COL 5 ‚Äî Poids (%) */}
                              <td className="border px-2 py-1 text-center align-middle dark:bg-[var(--night-base)]">
                                {lockWeights ? (
                                  <span className="inline-block min-w-[3rem] text-xs">
                                    {Number.isFinite(w) ? w : 0}
                                  </span>
                                ) : (
                                  <Input
                                    type="number"
                                    min={0}
                                    step={1}
                                    className="h-7 w-16 mx-auto text-center text-xs !bg-white dark:!bg-[var(--night-deep)] !text-neutral-900 dark:!text-neutral-50 !border-neutral-300 dark:!border-neutral-700/60 placeholder:text-neutral-500 dark:placeholder:text-neutral-500"
                                    value={Number.isFinite(w) ? w : ""}
                                    onChange={(e) => {
                                      const v = parseFloat(
                                        e.target.value.replace(",", ".")
                                      );
                                      setNotationWeights((prev) => ({
                                        ...prev,
                                        [r.key]: isNaN(v)
                                          ? 0
                                          : Math.max(0, v),
                                      }));
                                    }}
                                  />
                                )}
                              </td>

                              {/* COL 6 ‚Äî Niveau NR + 1..4 */}
                              <td className="border px-2 py-1 text-center align-middle">
                                <div className="inline-flex items-center gap-1">
                                  {/* NR */}
                                  <button
                                    type="button"
                                    onClick={() =>
                                      setScoreForView((prev) => {
                                        const current = prev[r.key] ?? null;
                                        const next = { ...prev };

                                        if (current === 0) {
                                          delete next[r.key];
                                          return next;
                                        }

                                        next[r.key] = 0;
                                        return next;
                                      })
                                    }
                                    className="p-0 rounded-full"
                                  >
                                    <span
                                      className={classNames(
                                        "h-7 px-2 inline-flex items-center justify-center rounded-full border text-[10px] transition",
                                        isNR
                                          ? "bg-neutral-900 border-neutral-900 text-white font-semibold ring-2 ring-offset-1 ring-neutral-900/30 dark:bg-neutral-100 dark:border-neutral-100 dark:text-neutral-300 dark:ring-neutral-100/60 ring-offset-white dark:ring-offset-[var(--night-ring-offset)]"
                                          : "bg-white dark:bg-[var(--night-surface)] text-neutral-700 dark:text-neutral-300 border-neutral-300 dark:border-sky-400/35 hover:bg-amber-100/70 dark:hover:bg-[var(--night-hover)]"
                                      )}
                                    >
                                      NR
                                    </span>
                                  </button>

                                  {/* 1 √† 4 */}
                                  {[1, 2, 3, 4].map((val) => {
                                    const isActive = s === val;

                                    // Couleurs fixes (ne d√©pendent pas de Tailwind ‚Üí pas de purge, OK en dark mode)
                                    const LEVEL_COLORS: Record<1 | 2 | 3 | 4, { bg: string; text: string }> = {
                                      1: { bg: "var(--code-red-bg)", text: "var(--code-red-text)" },
                                      2: { bg: "var(--code-orange-bg)", text: "var(--code-orange-text)" },
                                      3: { bg: "var(--code-yellow-bg)", text: "var(--code-yellow-text)" },
                                      4: { bg: "var(--code-green-bg)", text: "var(--code-green-text)" },
                                    };
                                    const c = LEVEL_COLORS[val as 1 | 2 | 3 | 4];

                                    return (
                                      <button
                                        key={val}
                                        type="button"
                                        onClick={() =>
                                          setScoreForView((prev) => {
                                            const current = prev[r.key] ?? null;
                                            const next = { ...prev };

                                            if (current === val) {
                                              delete next[r.key];
                                              return next;
                                            }

                                            next[r.key] = val;
                                            return next;
                                          })
                                        }
                                        className="p-0 rounded-full"
                                      >
                                        <span
                                          style={{ "--score-bg": c.bg, "--score-border": c.bg, "--score-text": c.text } as React.CSSProperties}
                                          className={classNames(
                                            "score-bubble h-7 w-7 inline-flex items-center justify-center rounded-full border text-xs transition",
                                            isActive ? "opacity-100" : "opacity-35 hover:opacity-60",
                                            isActive &&
                                              "font-semibold ring-2 ring-offset-1 ring-neutral-900/30 dark:ring-neutral-100/60 ring-offset-white dark:ring-offset-[var(--night-ring-offset)] shadow-sm"
                                          )}
                                        >
                                          {val}
                                        </span>
                                      </button>
                                    );
                                  })}</div>
                              </td>
                            </tr>
                          );
                        }
                      )}
                    </tbody>
                  </table>
                </div>
              </div>
            </section>
          );
        })}
      </div>

    </div>
  );
};

// Ouvre un devoir depuis la vue "classe" : charge le devoir et affiche l'aper√ßu
const handleOpenClasseDevoir = async (ev: EvalMeta) => {
  try {
    if (!isTauriRuntime()) {
      alert(
        "L'aper√ßu du devoir n'est disponible que dans la version install√©e (Tauri)."
      );
      return;
    }

    // On m√©morise l'ID du devoir s√©lectionn√© pour la vue classe (utile plus tard)
    setSelectedEvalIdForClasse(ev.id);

    // Charger le devoir complet √† partir de son fichier
    await loadSavedDevoir(ev.fileName);

    // (Optionnel) remettre le groupe / semestre dans les champs de l'√©valuation
    if (ev.group) {
      setGroup(ev.group);
    }
    if (ev.semester) {
      setEvaluationSemester(ev.semester as SemesterKey);
    }

  } catch (err) {
    console.error(
      "Erreur lors de l'ouverture du devoir depuis la vue classe :",
      err
    );
    alert("Impossible d'ouvrir l'aper√ßu de ce devoir.");
  }
};
  const openPreviewWindow = (overrideEvaluationType?: string, overrideCategory?: string, opts?: PreviewTargetOptions) => {
  if (typeof window === "undefined") return;

  const rows = buildPreviewRows();

  // üîπ Calcul des rowSpan pour la colonne "T√ÇCHES"
  const taskRowSpans: number[] = [];
  for (let i = 0; i < rows.length; i++) {
    if (i > 0 && rows[i].task === rows[i - 1].task) {
      // m√™me t√¢che que la ligne pr√©c√©dente ‚Üí on ne r√©-affiche pas la cellule
      taskRowSpans[i] = 0;
    } else {
      // nouvelle t√¢che ‚Üí on compte combien de lignes cons√©cutives partagent la m√™me t√¢che
      let span = 1;
      while (i + span < rows.length && rows[i + span].task === rows[i].task) {
        span++;
      }
      taskRowSpans[i] = span;
    }
  }
  // üîπ Calcul des rowSpan pour la colonne "COMP√âTENCE"
  // (fusionne seulement si T√ÇCHE ET COMP√âTENCE sont identiques)
  const compRowSpans: number[] = [];
  for (let i = 0; i < rows.length; i++) {
    if (
      i > 0 &&
      rows[i].task === rows[i - 1].task &&
      rows[i].comp === rows[i - 1].comp
    ) {
      // m√™me t√¢che + m√™me comp√©tence que la ligne pr√©c√©dente ‚Üí on ne r√©-affiche pas la cellule
      compRowSpans[i] = 0;
    } else {
      let span = 1;
      while (
        i + span < rows.length &&
        rows[i + span].task === rows[i].task &&
        rows[i + span].comp === rows[i].comp
      ) {
        span++;
      }
      compRowSpans[i] = span;
    }
  }

  const logoHtml = logoDataUrl
    ? `<img src="${logoDataUrl}" style="max-width:120px;max-height:120px;object-fit:contain;" />`
    : "";

  // Chaque ligne de "Objectifs" = une puce
  const objectifsLines = (objectives || "")
    .split("\n")
    .map((l) => l.trim())
    .filter((l) => l.length > 0);

  const objectifsHtml = objectifsLines.length
    ? `<ul class="objectifs-list">
        ${objectifsLines.map((line) => `<li>${escapeHtml(line)}</li>`).join("")}
       </ul>`
    : "";

  // Situation professionnelle
  const situationHtml = professionalSituation
    ? `<p>${escapeHtml(professionalSituation)}</p>`
    : "<p><span style='color:var(--print-empty);font-style:italic;'>Non renseign√©e</span></p>";

  const evalType = overrideEvaluationType ?? evaluationType;

  const evalCategory = overrideCategory ?? evaluationCategory;

  const isAuto = evalType === "Auto-√©valuation";
  const isCodeColor = evalType === "code-couleur";
  const isCriterie = evalType === "criterie";

  // üîπ Construction du tableau (Aper√ßu / Impression)
  // - Auto-√©valuation & Code-couleur : on garde le tableau "par ligne" (rows)
  // - Crit√©ri√© : on imprime une ligne PAR CRIT√àRE, avec Poids + bulles NR/1/2/3/4 (comme dans l'app)
  let tableHtml = "";

  if (isCriterie) {
    const critLines = rows.flatMap((r) =>
      (r.criteres || []).map((crit, idx) => ({
        key: `${r.task}||${r.comp}::${r.item}::crit#${idx}`,
        task: r.task,
        comp: r.comp,
        item: r.item,
        critere: crit,
        exigences: r.exigences || [],
      }))
    );

    const taskSpans: number[] = [];
    const compSpans: number[] = [];
    const itemSpans: number[] = [];

    for (let i = 0; i < critLines.length; i++) {
      // T√ÇCHE
      if (i > 0 && critLines[i].task === critLines[i - 1].task) {
        taskSpans[i] = 0;
      } else {
        let span = 1;
        while (i + span < critLines.length && critLines[i + span].task === critLines[i].task) span++;
        taskSpans[i] = span;
      }

      // COMP√âTENCE (fusion uniquement si T√ÇCHE + COMP√âTENCE identiques)
      if (
        i > 0 &&
        critLines[i].task === critLines[i - 1].task &&
        critLines[i].comp === critLines[i - 1].comp
      ) {
        compSpans[i] = 0;
      } else {
        let span = 1;
        while (
          i + span < critLines.length &&
          critLines[i + span].task === critLines[i].task &&
          critLines[i + span].comp === critLines[i].comp
        ) {
          span++;
        }
        compSpans[i] = span;
      }

      // √äTRE CAPABLE DE (fusion si T√ÇCHE + COMP + ITEM identiques)
      if (
        i > 0 &&
        critLines[i].task === critLines[i - 1].task &&
        critLines[i].comp === critLines[i - 1].comp &&
        critLines[i].item === critLines[i - 1].item
      ) {
        itemSpans[i] = 0;
      } else {
        let span = 1;
        while (
          i + span < critLines.length &&
          critLines[i + span].task === critLines[i].task &&
          critLines[i + span].comp === critLines[i].comp &&
          critLines[i + span].item === critLines[i].item
        ) {
          span++;
        }
        itemSpans[i] = span;
      }
    }

    const bubble = (
      label: string,
      border: string,
      bg: string,
      fg: string
    ) => `
      <span style="
        display:inline-flex;
        align-items:center;
        justify-content:center;
        width:22px;
        height:22px;
        border-radius:9999px;
        border:2px solid ${border};
        background:${bg};
        color:${fg};
        font-size:10px;
        font-weight:800;
        line-height:1;
        box-sizing:border-box;
      ">${label}</span>
    `;

    const scaleHtml = `
      <div style="display:flex;gap:6px;justify-content:center;flex-wrap:wrap;">
        ${bubble("NR", "var(--print-muted-text)", "transparent", "var(--text)")}
        ${bubble("1", "var(--code-red-bg)", "transparent", "var(--code-red-bg)")}
        ${bubble("2", "var(--code-orange-bg)", "transparent", "var(--code-orange-bg)")}
        ${bubble("3", "var(--code-yellow-bg)", "transparent", "var(--code-yellow-bg)")}
        ${bubble("4", "var(--code-green-bg)", "transparent", "var(--code-green-bg)")}
      </div>
    `;


    let body = "";
    critLines.forEach((r, idx) => {
      body += "<tr>";

      // T√ÇCHES fusionn√©e
      if (taskSpans[idx] > 0) {
        body += `<td rowspan="${taskSpans[idx]}">${escapeHtml(r.task)}</td>`;
      }

      // COMP√âTENCE fusionn√©e
      if (compSpans[idx] > 0) {
        body += `<td rowspan="${compSpans[idx]}">${escapeHtml(r.comp)}</td>`;
      }

      // √äTRE CAPABLE DE fusionn√©e
      if (itemSpans[idx] > 0) {
        body += `<td rowspan="${itemSpans[idx]}">${escapeHtml(r.item)}</td>`;
      }

      // CRIT√àRE
      body += `<td>${escapeHtml(r.critere)}</td>`;

      // EXIGENCES
      body += "<td>";
      if (r.exigences && r.exigences.length) {
        body += r.exigences.map((e: string) => escapeHtml(e)).join("<br />");
      } else {
        body += "<span style='color:var(--print-empty);font-style:italic;'>Aucune s√©lection</span>";
      }
      body += "</td>";

      // POIDS
      const w = notationWeights[r.key] ?? 1;
      body += `<td style="text-align:center;">${Number.isFinite(w) ? w : ""}</td>`;

      // NIVEAU (bulles)
      body += `<td>${scaleHtml}</td>`;

      body += "</tr>";
    });

    tableHtml =
      critLines.length === 0
        ? `<p style="font-style:italic;color:var(--print-muted-2);font-size:11px;">Aucun crit√®re s√©lectionn√©.</p>`
        : `
<table>
  <thead>
    <tr>
      <th>T√ÇCHES</th>
      <th>COMP√âTENCE</th>
      <th>√äTRE CAPABLE DE</th>
      <th>CRIT√àRES D'√âVALUATION</th>
      <th>EXIGENCES</th>
      <th style="width:12mm;">POIDS (%)</th>
      <th style="width:44mm;">NIVEAU</th>
    </tr>
  </thead>
  <tbody>
    ${body}
  </tbody>
</table>`;
  } else {
    // üîπ Construction du <tbody> √† la main (plus simple que rows.map dans le template)
    let tableBodyHtml = "";

    rows.forEach((r, idx) => {
      const taskSpan = taskRowSpans[idx] || 0;
      const compSpan = compRowSpans[idx] || 0;

      tableBodyHtml += "<tr>";

      // Colonne T√ÇCHES fusionn√©e
      if (taskSpan > 0) {
        tableBodyHtml += `<td rowspan="${taskSpan}">${escapeHtml(r.task)}</td>`;
      }

      // Colonne COMP√âTENCE fusionn√©e
      if (compSpan > 0) {
        tableBodyHtml += `<td rowspan="${compSpan}">${escapeHtml(r.comp)}</td>`;
      }

      // Colonne √äTRE CAPABLE DE
      tableBodyHtml += `<td>${escapeHtml(r.item)}</td>`;

      // Colonne CRIT√àRES D'√âVALUATION
      tableBodyHtml += `<td>${(r.criteres || []).map((c) => escapeHtml(c)).join("<br />")}</td>`;

      // Colonne EXIGENCES
      tableBodyHtml += "<td>";
      if (r.exigences && r.exigences.length) {
        tableBodyHtml += r.exigences.map((e) => escapeHtml(e)).join("<br />");
      } else {
        tableBodyHtml += "<span style='color:var(--print-empty);font-style:italic;'>Aucune s√©lection</span>";
      }
      tableBodyHtml += "</td>";

      // Colonnes auto-√©valuation (smileys)
      if (isAuto) {
        tableBodyHtml += `<td class="auto-col"></td>`;
        tableBodyHtml += `<td class="auto-col"></td>`;
        tableBodyHtml += `<td class="auto-col"></td>`;
      }

      // Colonnes code couleur
      if (isCodeColor) {
        tableBodyHtml += `<td class="code-col"></td>`;
        tableBodyHtml += `<td class="code-col"></td>`;
        tableBodyHtml += `<td class="code-col"></td>`;
        tableBodyHtml += `<td class="code-col"></td>`;
      }

      tableBodyHtml += "</tr>";
    });

    tableHtml =
      rows.length === 0
        ? `<p style="font-style:italic;color:var(--print-muted-2);font-size:11px;">Aucune exigence personnalis√©e s√©lectionn√©e.</p>`
        : `
<table>
  <thead>
    <tr>
      <th>T√ÇCHES</th>
      <th>COMP√âTENCE</th>
      <th>√äTRE CAPABLE DE</th>
      <th>CRIT√àRES D'√âVALUATION</th>
      <th>EXIGENCES</th>
      ${
        isAuto
          ? `
      <th class="auto-col">üòï</th>
      <th class="auto-col">üòê</th>
      <th class="auto-col">üòä</th>
      `
          : ""
      }
      ${
        isCodeColor
          ? `
      <th class="code-col code-red">‚óè</th>
      <th class="code-col code-orange">‚óè</th>
      <th class="code-col code-yellow">‚óè</th>
      <th class="code-col code-green">‚óè</th>
      `
          : ""
      }
    </tr>
  </thead>
  <tbody>
    ${tableBodyHtml}
  </tbody>
</table>`;
  }

  const previewIsDark = theme === "dark";
  const previewOuterBg = getCssVar("--eval-preview-outer-bg", previewIsDark ? "#0b1220" : "#f3f4f6");
  const previewPageBg = getCssVar("--eval-preview-page-bg", previewIsDark ? "#0f1b2d" : "#ffffff");
  const previewText = getCssVar("--eval-preview-text", previewIsDark ? "#f8fafc" : "#111827");
  const previewMuted = getCssVar("--eval-preview-muted", previewIsDark ? "rgba(248,250,252,.72)" : "#4b5563");
  const previewBorder = getCssVar("--eval-preview-border", previewIsDark ? "rgba(148,163,184,.50)" : "#d1d5db");
  const previewTheadBg = getCssVar("--eval-preview-thead-bg", previewIsDark ? "#162238" : "#f3f4f6");
  const previewTheadText = getCssVar("--eval-preview-thead-text", previewIsDark ? "#e2e8f0" : "#111827");
  const previewEmpty = getCssVar("--eval-preview-empty", "#888");
  const previewMuted2 = getCssVar("--eval-preview-muted2", "#666");

  const html = `
<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>${escapeHtml(title || "√âvaluation")}</title>
  <style>
    :root {
      --outer-bg: ${previewOuterBg};
      --page-bg: ${previewPageBg};
      --text: ${previewText};
      --muted: ${previewMuted};
      --border: ${previewBorder};
      --thead-bg: ${previewTheadBg};
      --thead-text: ${previewTheadText};

      /* Variables partag√©es (utilis√©es dans le HTML g√©n√©r√©) */
      --print-empty: ${previewEmpty};
      --print-muted-2: ${previewMuted2};
    }

    * {
      box-sizing: border-box;
    }

    html, body {
      height: 100%;
    }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: var(--outer-bg); /* bleu autour */
      display: flex;
      justify-content: center;
      align-items: flex-start;
      padding: 16px;
      color: var(--text);
    }

    /* üìÑ Feuille A4 paysage √† l'√©cran (ratio 297 x 210) */
    .page {
      background: var(--page-bg);
      padding: 10mm 12mm;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    @media screen {
      .page {
        width: min(1120px, 100%);
        aspect-ratio: 297 / 210;
        height: auto;
      }
    }

    .header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      padding-bottom: 6px;
      border-bottom: 2px solid var(--text);
      margin-bottom: 6px;
    }

    .header-left h1 {
      font-size: 16px;
      margin: 0 0 4px 0;
    }

    .meta {
      font-size: 11px;
      color: var(--muted);
      line-height: 1.3;
    }

    .meta-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      column-gap: 18px;
      row-gap: 2px;
      max-width: 620px;
    }
    .meta-wide {
      grid-column: 1 / -1;
    }

    .logo {
      text-align: right;
      min-width: 120px;
    }

    .logo img {
      max-width: 110px;
      max-height: 110px;
      object-fit: contain;
    }

    .content {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 6px;
      overflow: hidden;
      font-size: 11px;
    }

    .section {
      margin: 0;
    }

    .section h2 {
      font-size: 12px;
      margin: 0 0 3px 0;
      text-transform: uppercase;
      letter-spacing: .04em;
    }

    .section p {
      margin: 0;
    }

    /* üîπ Ligne du haut : Objectifs + Situation pro */
    .top-row {
      display: flex;
      gap: 8mm;
      align-items: flex-start;
    }

    .section-objectifs {
      flex: 1.2;
    }

    .section-situation {
      flex: 1;
      padding-left: 4mm; /* l√©ger d√©calage vers la gauche */
    }

    .section-situation h2,
    .section-situation p {
      text-align: left; /* alignement √† gauche */
    }

    .section-table {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    .table-wrapper {
      flex: 1;
      min-height: 0;
      overflow: auto;
      border: none;         /* pas de bordure autour du bloc */
      border-radius: 0px;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 10px;
    }

    .objectifs-list {
      margin: 0;
      padding-left: 6mm; /* effet tabulation devant chaque objectif */
    }

    .objectifs-list li {
      margin: 0 0 0.5mm 0;  /* moins d'espace entre objectifs */
      font-size: 11px;
      line-height: 1.2;
    }

    th, td {
      border: 1px solid var(--border);
      padding: 3px 4px;
      vertical-align: middle;
    }

    thead th {
      background: var(--thead-bg);
      color: var(--thead-text);
      text-align: center;
      font-weight: 600;
      text-transform: uppercase;
    }

    .auto-col {
      width: 10mm;
      text-align: center;
      font-size: 12px;
    }

    .code-col {
      width: 8mm;
      text-align: center;
      font-size: 12px;
    }
      
    .crit-col {
      width: 8mm;
      text-align: center;
      font-size: 11px;
    }
    .code-red { color: var(--code-red-fg); }
    .code-orange { color: var(--code-orange-fg); }
    .code-yellow { color: var(--code-yellow-fg); }
    .code-green { color: var(--code-green-fg); }

    @page {
      size: A4 landscape;
      margin: 10mm 12mm;
    }

    @media print {
      :root {
        --outer-bg: var(--print-surface);
        --page-bg: var(--print-surface);
        --text: var(--print-text);
        --muted: var(--print-subtle-strong);
        --border: var(--print-muted-text);
        --thead-bg: #f3f4f6;
        --thead-text: var(--print-text);
      }

      body {
        background: var(--print-surface);
        padding: 0;
        display: block;
      }

      .page {
        box-shadow: none;
        width: auto;
        height: auto;
        margin: 0;
        padding: 0;
      }

      .table-wrapper {
        overflow: visible;
        border: 1px solid var(--border);
      }
    }
  </style>
</head>
<body>
  <div class="page">
    <div class="header">
      <div class="header-left">
        <h1>${escapeHtml(title || "√âvaluation CAP Ma√ßonnerie")}</h1>
        <div class="meta-grid">
          <div class="meta">Projet : ${escapeHtml(project || "")}</div>
          <div class="meta">Classe : ${escapeHtml(group || "")}</div>
          <div class="meta">√âvaluateur : ${escapeHtml(evaluator || "")}</div>
          <div class="meta">Ann√©e : ${escapeHtml(trainingYearLabel(trainingYear))}</div>
          <div class="meta meta-wide">Niveau : ${escapeHtml(evalCategory || "")}</div>
        </div>
      </div>
      <div class="logo">
        ${logoHtml}
      </div>
    </div>

    <div class="content">
      <div class="top-row">
        <div class="section section-objectifs">
          <h2>Objectifs de l'√©valuation</h2>
          ${objectifsHtml || "<p><span style='color:var(--print-empty);font-style:italic;'>Non renseign√©s</span></p>"}
        </div>
        <div class="section section-situation">
          <h2>Situation professionnelle</h2>
          ${situationHtml}
        </div>
      </div>

      <div class="section section-table">
        <h2>Tableau des exigences personnalis√©es</h2>
        <div class="table-wrapper">
          ${tableHtml}
        </div>
      </div>
    </div>
  </div>
</body>
</html>
`;

  pushPreview(html, opts);
};


  const handlePrintClick = () => {
    try {
      // üìù DEVOIR / √âVALUATION
      if (activeView === "evaluation") {
        setPrintEvaluationType(evaluationType);
        openPreviewWindow(evaluationType, evaluationCategory, { mode: "modal", autoPrint: true, target: "printWindow" });
        return;
      }

      // üìä SUIVI
      if (activeView === "suivi") {
        if (suiviMode === "eleve") {
          openSuiviEleveToPreview({ mode: "modal", autoPrint: true, target: "printWindow" });
          return;
        }
        if (suiviMode === "classe") {
          exportSuiviClasseToPdf({ mode: "modal", autoPrint: true, target: "printWindow" });
          return;
        }
        if (suiviMode === "absences") {
          openSuiviAbsencesToPreview({ mode: "modal", autoPrint: true, target: "printWindow" });
          return;
        }
        if (suiviMode === "notation") {
          exportCurrentStudentNotationToPdf({ mode: "modal", autoPrint: true, target: "printWindow" });
          return;
        }
        if (suiviMode === "evolutions") {
          openSuiviEvolutionsToPreview({ mode: "modal", autoPrint: true, target: "printWindow" });
          return;
        }
        if (suiviMode === "bilan") {
          openSuiviBilanToPreview({ mode: "modal", autoPrint: true, target: "printWindow" });
          return;
        }
        // Fallback : si une sous-vue non pr√©vue existe
        alert('Impression indisponible pour cette sous-vue de "Suivi".');
        return;
      }

      // ‚úÖ NOTES
      if (activeView === "notes") {
        if (notesMode === "tableau") {
          exportNotesTableToPdf({ mode: "modal", autoPrint: true, target: "printWindow" });
          return;
        }
        // notesMode === "notation"
        exportCurrentStudentNotationToPdf({ mode: "modal", autoPrint: true, target: "printWindow" });
        return;
      }

      // Fallback
      setPrintEvaluationType(evaluationType);
      openPreviewWindow(evaluationType, evaluationCategory, { mode: "modal", autoPrint: true, target: "printWindow" });
    } catch (e) {
      console.error("handlePrintClick failed:", e);
    }
  };

async function handleCheckUpdate() {
  if (updateBusy) return;
  setUpdateBusy(true);

  try {
    const update = await check();

    if (!update?.available) {
      await confirm("Aucune mise √† jour disponible.", {
        title: "Mise √† jour",
        kind: "info",
      });
      return;
    }

    const ok = await confirm(
      `Mise √† jour disponible (${update.version}).\n\nT√©l√©charger et installer maintenant ?`,
      { title: "Mise √† jour", kind: "info" }
    );

    if (!ok) return;

    // T√©l√©charge + installe, puis relance l‚Äôapp
    await update.downloadAndInstall();
    await relaunch();
  } catch (e) {
    console.error(e);
    await confirm(`Erreur mise √† jour : ${String(e)}`, {
      title: "Mise √† jour",
      kind: "error",
    });
  } finally {
    setUpdateBusy(false);
  }
}

// Volet T√ÇCHES global : total S1 + S2
function TasksVoletTotal({
  selectedClassId,
}: {
  selectedClassId: string | null;
}) {
  if (!selectedClassId) return null;

  // Tous les devoirs S1 + S2 de la classe
  const evalsForClasse = evalMetaList.filter(
    (ev) => ev.group === selectedClassId
  );

  // Toutes les t√¢ches tri√©es (T1, T2, ...)
  const allTasks = sortByTaskNumber(Object.keys(tcMap));

  // Compter S1 + S2
  const countByTask: Record<string, number> = {};

  evalsForClasse.forEach((ev) => {
    (tasksByEvalId[ev.id] || []).forEach((taskLabel) => {
      countByTask[taskLabel] = (countByTask[taskLabel] || 0) + 1;
    });
  });

  const taskUsageList = allTasks.map((label) => ({
    label,
    count: countByTask[label] || 0,
  }));

  return (
    <div className="border rounded-lg bg-white dark:bg-[var(--night-panel)] w-full overflow-hidden shadow-sm">
      <div className="bg-neutral-900 text-white text-xs font-semibold text-center py-1">
        T√¢ches ‚Äì TOTAL (S1 + S2)
      </div>
      <div className="max-h-[720px] overflow-auto">
        <table className="w-full border-collapse text-[11px] text-neutral-900 dark:text-neutral-300">
          <thead>
            <tr>
              {/* Colonne Famille (en-t√™te, vertical) */}
              <th className="border border-neutral-300 dark:border-sky-400/35 bg-neutral-100 dark:bg-[var(--night-panel)] px-1 py-1 text-center align-middle w-10">
                <span className="app-verticalHeader">
                </span>
              </th>
              <th className="border border-neutral-300 dark:border-sky-400/35 bg-neutral-100 dark:bg-[var(--night-panel)] px-2 py-1 text-middle">
                T√¢ches
              </th>
              <th className="border border-neutral-300 dark:border-sky-400/35 bg-neutral-100 dark:bg-[var(--night-panel)] px-2 py-1 text-center w-10">
                Nb
              </th>
            </tr>
          </thead>
          <tbody>
            {taskUsageList.map((t, index) => {
              // üîπ Groupe de la t√¢che
              const tNum = taskNumber(t.label);
              const group = GROUPS.find(
                (g) => tNum >= g.range[0] && tNum <= g.range[1]
              );

              // Fond des cellules selon la famille
              const cellBgClass =
                group?.key === "G1"
                  ? "bg-sky-50 dark:bg-sky-950/35"
                  : group?.key === "G2"
                  ? "bg-amber-50 dark:bg-amber-950/35"
                  : group?.key === "G3"
                  ? "bg-violet-50 dark:bg-violet-950/35"
                  : "bg-white dark:bg-[var(--night-panel)]";

              // Libell√© famille pour la colonne gauche
              const famLabel =
                group?.key === "G1"
                  ? "COMMUNIQUER ¬∑ PR√âPARATION"
                  : group?.key === "G2"
                  ? "R√âALISER & CONTR√îLE\nD'OUVRAGE COURANT"
                  : group?.key === "G3"
                  ? "R√âALISATION DE\nTRAVAUX SP√âCIFIQUES"
                  : "";

              // üîπ D√©terminer si c'est la premi√®re ligne de ce groupe
              const prevTask = index > 0 ? taskUsageList[index - 1] : null;
              const prevNum = prevTask ? taskNumber(prevTask.label) : null;
              const prevGroup =
                prevNum !== null
                  ? GROUPS.find(
                      (g) => prevNum >= g.range[0] && prevNum <= g.range[1]
                    )
                  : null;

              const isFirstOfGroup =
                group && group.key !== prevGroup?.key ? true : false;

              // üîπ Calculer le rowSpan pour la cellule Famille
              let rowSpan = 0;
              if (isFirstOfGroup && group) {
                for (let i = index; i < taskUsageList.length; i++) {
                  const num = taskNumber(taskUsageList[i].label);
                  const g = GROUPS.find(
                    (gg) => num >= gg.range[0] && num <= gg.range[1]
                  );
                  if (!g || g.key !== group.key) break;
                  rowSpan++;
                }
              }

              return (
                <tr key={t.label}>
                  {/* Colonne Famille : cellule fusionn√©e, texte vertical */}
                  {isFirstOfGroup && group && rowSpan > 0 && (
                    <td
                      rowSpan={rowSpan}
                      className={classNames(
                        "border border-neutral-300 dark:border-sky-400/35 px-1 py-1 w-10 text-center align-middle",
                        cellBgClass
                      )}
                    >
                      <span
                      className="text-[8px] leading-tight app-verticalHeader"
                      >
                        {famLabel}
                      </span>
                    </td>
                  )}

                  {/* Colonne T√¢che */}
                  <td
                    className={classNames(
                      "border border-neutral-300 dark:border-sky-400/35 px-2 py-1",
                      cellBgClass
                    )}
                  >
                    {t.label}
                  </td>

                  {/* Colonne Nb */}
                  <td
                    className={classNames(
                      "border border-neutral-300 dark:border-sky-400/35 px-2 py-1 text-center font-semibold",
                      cellBgClass
                    )}
                  >
                    {t.count > 0 ? t.count : ""}
                  </td>
                </tr>
              );
            })}
          </tbody>
        </table>
      </div>
    </div>
  );
}



// Tableau "type Excel" : comp√©tences en lignes, devoirs en colonnes pour 1 semestre
function DoubleSemesterMatrix({
  allCompetences,
  evalMetaList,
  selectedClassId,
  compsByEvalId,
  onAddDevoirS1,
  onAddDevoirS2,
  onRemoveDevoir,
}: {
  allCompetences: string[];
  evalMetaList: EvalMeta[];
  selectedClassId: string | null;
  compsByEvalId: Record<string, string[]>;
  onAddDevoirS1: () => void;
  onAddDevoirS2: () => void;
  onRemoveDevoir: (ev: EvalMeta) => void;
  onOpenDevoir: (ev: EvalMeta) => void;
}) {
  if (!selectedClassId) return null;

  const MAX_DEVOIRS_PER_SEMESTRE = 20;

  const evalsS1 = evalMetaList
    .filter((ev) => ev.group === selectedClassId && ev.semester === "S1")
    .slice(0, MAX_DEVOIRS_PER_SEMESTRE);

  const evalsS2 = evalMetaList
    .filter((ev) => ev.group === selectedClassId && ev.semester === "S2")
    .slice(0, MAX_DEVOIRS_PER_SEMESTRE);

return (
  <div className="border rounded-lg overflow-hidden shadow-sm bg-white dark:bg-[var(--night-panel)]">
    <div className="overflow-x-auto">
      <table className="min-w-full border-collapse text-xs text-neutral-900 dark:text-neutral-300">
        <thead>
          {/* Ligne 1 : bandeaux S1 / S2 */}
          <tr>
            {/* Nouvelle colonne Famille (en-t√™te, fusionn√©e sur 2 lignes) */}
<th
  rowSpan={2}
  className="border border-neutral-300 dark:border-sky-400/35 bg-white dark:bg-[var(--night-panel)] sticky left-0 z-30 w-10 px-1 py-2 text-[11px] font-semibold text-neutral-700 dark:text-neutral-300 text-center align-middle"
>
  <span className="app-verticalHeader">
  </span>
</th>


            {/* Colonne Comp√©tence : titre g√©n√©ral */}
            <th className="border border-neutral-300 dark:border-sky-400/35 bg-white dark:bg-[var(--night-surface)] sticky left-0 z-20 w-80 px-3 py-2 text-middle align-middle">
              <div className="text-[11px] text-neutral-400">
                Vue d&apos;ensemble par semestre
              </div>
            </th>

            {/* Bandeau S1 */}
            <th
              colSpan={MAX_DEVOIRS_PER_SEMESTRE + 1}
              className="border border-neutral-300 dark:border-sky-400/35 bg-amber-100 dark:bg-amber-950/45 text-neutral-900 dark:text-neutral-300 text-[11px] font-semibold text-center"
            >
              <div className="flex flex-col items-center py-1">
                <span>SEMESTRE 1</span>
                <span className="text-[10px] font-normal opacity-80">
                  Devoirs &amp; comp√©tences √©valu√©es
                </span>
              </div>
            </th>

            {/* Colonne vide de s√©paration */}
            <th className="w-4 bg-white dark:bg-[var(--night-panel)]" />

            {/* Bandeau S2 */}
            <th
              colSpan={MAX_DEVOIRS_PER_SEMESTRE + 1}
              className="border border-neutral-300 dark:border-sky-400/35 bg-lime-100 dark:bg-lime-950/45 text-neutral-900 dark:text-neutral-300 text-[11px] font-semibold text-center"
            >
              <div className="flex flex-col items-center py-1">
                <span>SEMESTRE 2</span>
                <span className="text-[10px] font-normal opacity-80">
                  Devoirs &amp; comp√©tences √©valu√©es
                </span>
              </div>
            </th>
          </tr>

          {/* Ligne 2 : en-t√™tes d√©taill√©s */}
          <tr>
            {/* En-t√™te Comp√©tence */}
            <th
              className="sticky left-0 z-20 border border-neutral-300 dark:border-sky-400/35 bg-white dark:bg-[var(--night-surface)] px-3 py-2 text-middle w-80 align-middle text-[14px] font-semibold text-neutral-700 dark:text-neutral-300"
            >
              COMP√âTENCES
            </th>

            {/* Colonnes S1 */}
            {Array.from({ length: MAX_DEVOIRS_PER_SEMESTRE }).map((_, idx) => {
              const ev = evalsS1[idx];
              return (
                <th
                  key={`S1-${idx}`}
                  className="border border-neutral-300 dark:border-sky-400/35 text-center px-0.5 py-1 align-top bg-white dark:bg-[var(--night-surface)] w-[22px]"
                >
                  {ev ? (
                    <div className="flex flex-col items-center gap-1">
                      <div
                        className="text-[10px] font-medium leading-tight text-neutral-700 dark:text-neutral-300 app-verticalHeader"
                        title={ev.name}
                      >
                        {ev.name}
                      </div>

<button
  type="button"
  onClick={() => onRemoveDevoir(ev)}
  className="mini-circle-btn mini-circle-btn--danger"
  title="Supprimer ce devoir"
>
  ‚úï
</button>

                    </div>
                  ) : (
<button
  type="button"
  onClick={onAddDevoirS1}
  className="mini-circle-btn mini-circle-btn--add is-amber"
  title="Ajouter un devoir en S1"
>
  <Plus className="w-3 h-3" />
</button>

                  )}
                </th>
              );
            })}

            {/* Nb S1 (GRIS) */}
            <th className="border border-neutral-300 dark:border-sky-400/35 bg-neutral-100 dark:bg-[var(--night-panel)] text-center w-16 text-[11px] font-semibold text-neutral-800 dark:text-neutral-300">
              Nb S1
            </th>

            {/* Colonne vide de s√©paration */}
            <th className="w-4 bg-white dark:bg-[var(--night-panel)]" />

            {/* Colonnes S2 */}
            {Array.from({ length: MAX_DEVOIRS_PER_SEMESTRE }).map((_, idx) => {
              const ev = evalsS2[idx];
              return (
                <th
                  key={`S2-${idx}`}
                  className="border border-neutral-300 dark:border-sky-400/35 text-center px-0.5 py-1 align-top bg-white dark:bg-[var(--night-panel)] w-[22px]"
                >
                  {ev ? (
                    <div className="flex flex-col items-center gap-1">
                      <div
                        className="text-[10px] font-medium leading-tight text-neutral-700 dark:text-neutral-300 app-verticalHeader"
                        title={ev.name}
                      >
                        {ev.name}
                      </div>

<button
  type="button"
  onClick={() => onRemoveDevoir(ev)}
  className="mini-circle-btn mini-circle-btn--danger"
  title="Supprimer ce devoir"
>
  ‚úï
</button>

                    </div>
                  ) : (
<button
  type="button"
  onClick={onAddDevoirS2}
  className="mini-circle-btn mini-circle-btn--add is-lime"
  title="Ajouter un devoir en S2"
>
  <Plus className="w-3 h-3" />
</button>

                  )}
                </th>
              );
            })}

            {/* Nb S2 (GRIS) */}
            <th className="border border-neutral-300 dark:border-sky-400/35 bg-neutral-100 dark:bg-[var(--night-panel)] text-center w-16 text-[11px] font-semibold text-neutral-800 dark:text-neutral-300">
              Nb S2
            </th>
          </tr>
        </thead>

        <tbody>
          {allCompetences.map((compLabel, rowIndex) => {
            const countS1 = evalsS1.filter((ev) =>
              (compsByEvalId[ev.id] || []).some((e) =>
                e.includes(`||${compLabel}`)
              )
            ).length;

            const countS2 = evalsS2.filter((ev) =>
              (compsByEvalId[ev.id] || []).some((e) =>
                e.includes(`||${compLabel}`)
              )
            ).length;

            const fam = parseCompetencyFamily(compLabel); // "C1" | "C2" | "C3" | "C4" | "OTHER"
            const prevFam =
              rowIndex > 0
                ? parseCompetencyFamily(allCompetences[rowIndex - 1])
                : undefined;
            const nextFam =
              rowIndex < allCompetences.length - 1
                ? parseCompetencyFamily(allCompetences[rowIndex + 1])
                : undefined;

            const hasFam =
              fam === "C1" || fam === "C2" || fam === "C3" || fam === "C4";

            const isFamFirst = hasFam && fam !== prevFam;
            const isFamLast = hasFam && fam !== nextFam;

            const famTopColor =
              fam === "C1"
                ? "border-t-sky-400"
                : fam === "C2"
                ? "border-t-amber-400"
                : fam === "C3"
                ? "border-t-lime-400"
                : fam === "C4"
                ? "border-t-fuchsia-400"
                : "";
            const famBottomColor =
              fam === "C1"
                ? "border-b-sky-400"
                : fam === "C2"
                ? "border-b-amber-400"
                : fam === "C3"
                ? "border-b-lime-400"
                : fam === "C4"
                ? "border-b-fuchsia-400"
                : "";
            const famLeftColor =
              fam === "C1"
                ? "border-l-sky-400"
                : fam === "C2"
                ? "border-l-amber-400"
                : fam === "C3"
                ? "border-l-lime-400"
                : fam === "C4"
                ? "border-l-fuchsia-400"
                : "";
            const famRightColor =
              fam === "C1"
                ? "border-r-sky-400"
                : fam === "C2"
                ? "border-r-amber-400"
                : fam === "C3"
                ? "border-r-lime-400"
                : fam === "C4"
                ? "border-r-fuchsia-400"
                : "";

            const famBg =
              fam === "C1"
                ? "bg-sky-50 dark:bg-sky-950/35"
                : fam === "C2"
                ? "bg-amber-50 dark:bg-amber-950/35"
                : fam === "C3"
                ? "bg-lime-50 dark:bg-lime-950/35"
                : fam === "C4"
                ? "bg-fuchsia-50 dark:bg-fuchsia-950/35"
                : "bg-white dark:bg-[var(--night-panel)]";

            const topThicknessClass =
              hasFam && isFamFirst ? "border-t-2" : hasFam ? "border-t" : "";
            const bottomThicknessClass =
              hasFam && isFamLast ? "border-b-2" : hasFam ? "border-b" : "";

            const topColorClass = hasFam && isFamFirst ? famTopColor : "";
            const bottomColorClass = hasFam && isFamLast ? famBottomColor : "";

            // RowSpan pour la colonne Famille
            let famRowSpan = 0;
            if (hasFam && isFamFirst) {
              let span = 1;
              for (let i = rowIndex + 1; i < allCompetences.length; i++) {
                if (
                  parseCompetencyFamily(allCompetences[i]) !== fam
                ) {
                  break;
                }
                span++;
              }
              famRowSpan = span;
            }

            const famLabel =
              fam === "C1"
                ? "COM."
                : fam === "C2"
                ? "PR√âPARER"
                : fam === "C3"
                ? "R√âALISER"
                : fam === "C4"
                ? "CONT."
                : "";

            return (
              <tr
                key={compLabel}
                className="odd:bg-white even:bg-neutral-50 hover:bg-amber-100/70/80 dark:odd:bg-[var(--night-panel)] dark:even:bg-[var(--night-panel)] dark:hover:bg-[var(--night-hover)] transition-colors"
              >
                {/* Colonne Famille : cellule fusionn√©e (rowSpan) */}
                {hasFam && isFamFirst && famRowSpan > 0 && (
  <td
    rowSpan={famRowSpan}
    className={classNames(
      "border border-neutral-300 dark:border-sky-400/35 sticky left-0 z-20 w-10 px-1 py-1 text-[11px] text-neutral-900 dark:text-neutral-300 text-center align-middle",
      famBg,
      "align-middle",
      "border-l-2",
      famLeftColor,
      topThicknessClass,
      topColorClass,
      bottomThicknessClass,
      bottomColorClass
    )}
  >
    <div className="flex items-center justify-center h-full">
      <span
        className="font-semibold app-verticalHeader"
      >
        {famLabel}
      </span>
    </div>
  </td>
)}


                {/* Colonne comp√©tence */}
                <td
                  className={classNames(
                    "sticky left-0 z-10 px-2 py-[2px] text-[11px] leading-[1.05] align-middle border border-neutral-300 dark:border-sky-400/35 min-w-[280px] w-[280px]",
                    hasFam ? famBg : "bg-white dark:bg-[var(--night-panel)]",
                    topThicknessClass,
                    topColorClass,
                    bottomThicknessClass,
                    bottomColorClass
                  )}
                >
{(() => {
  const code = compactCode(compLabel);
  const label = compLabel.replace(/^C\s*\d+\.\d+\s*[:.]\s*/, "").trim();

  return (
    <div className="grid grid-cols-[auto,1fr] gap-x-2 items-start">
      <span className="text-[11px] font-semibold text-neutral-900 dark:text-neutral-300 whitespace-nowrap">
        {code}
      </span>

      <span
        className="text-[11px] text-neutral-800 dark:text-neutral-300 break-words"
        style={{
          display: "-webkit-box",
          WebkitBoxOrient: "vertical",
          WebkitLineClamp: 2, // max 2 lignes si trop long
          overflow: "hidden",
        }}
        title={label}
      >
        {label}
      </span>
    </div>
  );
})()}

                </td>

                {/* croix S1 */}
                {Array.from({ length: MAX_DEVOIRS_PER_SEMESTRE }).map(
                  (_, idx) => {
                    const ev = evalsS1[idx];
                    const uses =
                      ev &&
                      (compsByEvalId[ev.id] || []).some((e) =>
                        e.includes(`||${compLabel}`)
                      );
                    return (
                      <td
                        key={`S1-${compLabel}-${idx}`}
                        className={classNames(
                          "border border-neutral-300 dark:border-sky-400/35 text-center align-middle",
                          hasFam ? famBg : "bg-white dark:bg-[var(--night-panel)]",
                          topThicknessClass,
                          topColorClass,
                          bottomThicknessClass,
                          bottomColorClass
                        )}
                      >
                        {uses ? "√ó" : ""}
                      </td>
                    );
                  }
                )}

                {/* Nb S1 (GRIS, mais bordures haut/bas color√©es si d√©but/fin de famille) */}
                <td
                  className={classNames(
                    "border border-neutral-300 dark:border-sky-400/35 text-center font-semibold bg-neutral-100 dark:bg-[var(--night-panel)] text-[11px] text-neutral-800 dark:text-neutral-300",
                    topThicknessClass,
                    topColorClass,
                    bottomThicknessClass,
                    bottomColorClass
                  )}
                >
                  {countS1 || ""}
                </td>

                {/* Colonne vide de s√©paration */}
                <td className="w-4 bg-white dark:bg-[var(--night-panel)]" />

                {/* croix S2 */}
                {Array.from({ length: MAX_DEVOIRS_PER_SEMESTRE }).map(
                  (_, idx) => {
                    const ev = evalsS2[idx];
                    const uses =
                      ev &&
                      (compsByEvalId[ev.id] || []).some((e) =>
                        e.includes(`||${compLabel}`)
                      );
                    return (
                      <td
                        key={`S2-${compLabel}-${idx}`}
                        className={classNames(
                          "border border-neutral-300 dark:border-sky-400/35 text-center align-middle",
                          hasFam ? famBg : "bg-white dark:bg-[var(--night-panel)]",
                          topThicknessClass,
                          topColorClass,
                          bottomThicknessClass,
                          bottomColorClass
                        )}
                      >
                        {uses ? "√ó" : ""}
                      </td>
                    );
                  }
                )}

                {/* Nb S2 (GRIS, bordure droite color√©e pour fermer le bloc) */}
                <td
                  className={classNames(
                    "border border-neutral-300 dark:border-sky-400/35 text-center font-semibold bg-neutral-100 dark:bg-[var(--night-panel)] text-[11px] text-neutral-800 dark:text-neutral-300",
                    hasFam && "border-r-2",
                    hasFam && famRightColor,
                    topThicknessClass,
                    topColorClass,
                    bottomThicknessClass,
                    bottomColorClass
                  )}
                >
                  {countS2 || ""}
                </td>
              </tr>
            );
          })}
        </tbody>
      </table>
    </div>
  </div>
);



}

function SemesterMatrix({
  semester,
  allCompetences,
  evalMetaList,
  selectedClassId,
  compsByEvalId,
  onAddDevoir,
  onRemoveDevoir,
  onOpenDevoir,      
  hideCompetences = false,   
}: {
  semester: SemesterKey;
  allCompetences: string[];
  evalMetaList: EvalMeta[];
  selectedClassId: string | null;
  compsByEvalId: Record<string, string[]>;
  onAddDevoir: () => void;
  onRemoveDevoir: (ev: EvalMeta) => void;
  onOpenDevoir: (ev: EvalMeta) => void;   
  hideCompetences?: boolean; // 
}) {
  if (!selectedClassId) return null;

  const MAX_DEVOIRS_PER_SEMESTRE = 20;

  // Devoirs de la classe pour ce semestre
  const evalsForSem = evalMetaList
    .filter((ev) => ev.group === selectedClassId && ev.semester === semester)
    .slice(0, MAX_DEVOIRS_PER_SEMESTRE);

  const headerColor = semester === "S1" ? "bg-amber-400" : "bg-lime-500";

  return (
    <div className="border rounded-lg overflow-hidden shadow-sm flex-1 min-w-[480px] bg-white dark:bg-[var(--night-panel)]">
      {/* Bandeau SEMESTRE */}
      <div className={`${headerColor} text-white font-semibold text-center py-2`}>
        {semester === "S1" ? "SEMESTRE 1" : "SEMESTRE 2"}
      </div>

      <div className="overflow-x-auto">
        <table className="min-w-full border-collapse text-xs text-neutral-900 dark:text-neutral-300">
          <thead>
            <tr>
              {/* Colonne comp√©tences */}
              {!hideCompetences && (
  <th
    className="border border-neutral-300 dark:border-sky-400/35 bg-neutral-100 dark:bg-[var(--night-panel)] px-2 py-2 text-left align-bottom w-64 sticky left-0 z-20 bg-white dark:bg-[var(--night-panel)]"
  >
    Comp√©tences
  </th>
)}
              {/* Colonnes devoirs (max 20) */}
              {Array.from({ length: MAX_DEVOIRS_PER_SEMESTRE }).map((_, idx) => {
                const ev = evalsForSem[idx];

                return (
                  <th
                    key={idx}
                    className="border border-neutral-300 dark:border-sky-400/35 text-center px-0.5 py-1 align-top bg-white dark:bg-[var(--night-panel)] w-[22px]"
                  >
                    {ev ? (
                      <div className="flex flex-col items-center gap-1">
                        {/* Nom du devoir en vertical */}
                        <button
  type="button"
  onClick={() => onOpenDevoir(ev)}
  className="text-[10px] font-medium leading-tight underline decoration-dotted hover:text-neutral-900 dark:text-neutral-300 app-verticalHeader"
  title="Ouvrir l'aper√ßu et la notation de ce devoir"
>
  {ev.name}
</button>


                        {/* Bouton pour retirer ce devoir de la classe / semestre */}
                        <button
                          type="button"
                          onClick={() => onRemoveDevoir(ev)}
                          className="mt-1 w-5 h-5 flex items-center justify-center rounded-full border border-neutral-400 hover:bg-amber-100/70 dark:bg-[var(--night-surface)]"
                          title="Retirer ce devoir de cette classe / semestre"
                        >
                          <X className="w-3 h-3" />
                        </button>
                      </div>
                    ) : (
                      // Slot vide ‚Üí bouton +
                      <button
                        type="button"
                        onClick={onAddDevoir}
                        className="w-6 h-6 flex items-center justify-center rounded-full border border-dashed border-neutral-400 hover:bg-amber-100/70 dark:bg-[var(--night-surface)]"
                        title="Ajouter un devoir pour ce semestre"
                      >
                        <Plus className="w-3 h-3" />
                      </button>
                    )}
                  </th>
                );
              })}

              {/* Colonne "Nb" = nombre de devoirs utilisant la comp√©tence */}
              <th className="border border-neutral-300 dark:border-sky-400/35 bg-neutral-100 dark:bg-[var(--night-panel)] px-2 py-2 text-center align-bottom w-16 text-[11px]">
                Nb
              </th>
            </tr>
          </thead>

          <tbody>
            {allCompetences.map((compLabel) => {
              // üî¢ Compter le nombre de devoirs du semestre qui utilisent cette comp√©tence
              const countForComp = evalsForSem.reduce((acc, ev) => {
                if (!ev) return acc;
                const compsForEv = compsByEvalId[ev.id] || [];
                const usesComp = compsForEv.some((entry) => {
                  const parts = entry.split("||");
                  // format : t√¢che||comp√©tence||...
                  return parts[1] === compLabel;
                });
                return acc + (usesComp ? 1 : 0);
              }, 0);

              return (
                <tr key={compLabel}>
                  {/* Libell√© comp√©tence */}
                  {!hideCompetences && (
  <td
    className="border border-neutral-300 dark:border-sky-400/35 px-2 py-1 text-[11px] bg-white dark:bg-[var(--night-surface)] sticky left-0 z-10"
  >
    <span className="font-semibold">{compactCode(compLabel)}</span>{" "}
    <span className="text-[10px] text-neutral-600 dark:text-neutral-300">
      {compLabel.replace(/^C\s*\d+\.\d+\s*[:.]\s*/, "")}
    </span>
  </td>
)}
                  {/* cellules X / vides pour chaque devoir */}
                  {Array.from({ length: MAX_DEVOIRS_PER_SEMESTRE }).map((_, idx) => {
                    const ev = evalsForSem[idx];

                    if (!ev) {
                      return (
                        <td
                          key={idx}
                          className="border border-neutral-300 dark:border-sky-400/35 text-center align-middle"
                        />
                      );
                    }

                    const compsForEv = compsByEvalId[ev.id] || [];
                    const usesComp = compsForEv.some((entry) => {
                      const parts = entry.split("||");
                      return parts[1] === compLabel;
                    });

                    return (
                      <td
                        key={idx}
                        className="border border-neutral-300 dark:border-sky-400/35 text-center align-middle"
                      >
                        {usesComp ? (
                          <span className="font-bold text-lg leading-none">
                            √ó
                          </span>
                        ) : null}
                      </td>
                    );
                  })}

                  {/* Nb de devoirs qui utilisent cette comp√©tence */}
                  <td className="border border-neutral-300 dark:border-sky-400/35 text-center align-middle text-[11px] font-semibold bg-neutral-50 dark:bg-[var(--night-panel)]">
                    {countForComp > 0 ? countForComp : ""}
                  </td>
                </tr>
              );
            })}
          </tbody>
        </table>
      </div>
    </div>
  );
}


  return (
    <div
      className="w-full h-screen overflow-hidden px-2 sm:px-2 lg:px-0 night-root app-page"
    >
      <FirstRunHelp open={helpOpen} onOpenChange={setHelpOpen} />
{previewOpen && previewHtml && (
  <div
    className="fixed inset-0 z-[9999] bg-black/60 px-4 pb-4 pt-[72px]"
    role="dialog"
    aria-modal="true"
    onMouseDown={(e) => {
      if (e.target === e.currentTarget) {
        closePreviewModal();
      }
    }}
  >
    <div className="keep-light app-surface w-[calc(100vw-32px)] h-[calc(100vh-72px-32px)] max-w-none max-h-none rounded-2xl shadow-xl flex flex-col overflow-hidden">
      <div className="flex items-center justify-between px-4 py-2 border-b app-border app-surface sticky top-0 z-10">
        <span className="font-semibold text-sm">Aper√ßu</span>
        <div className="flex items-center gap-2">
          {/* S√©lecteur propre √† l'Aper√ßu (ind√©pendant de la fen√™tre Impression) */}
          <div className="flex items-center gap-2 mr-2">
            <span className="text-xs app-muted-text">Type d‚Äôaper√ßu</span>
            <select
              className="h-8 w-[220px] text-xs border rounded-md px-2 app-input"
              value={previewEvaluationType || ""}
              onChange={(e) => {
                const v = e.target.value;
                setPreviewEvaluationType(v);
                openPreviewWindow(v, evaluationCategory, { target: "preview" });
              }}
            >
              <option value="" disabled>
                S√©lectionner un type
              </option>
              <option value="Auto-√©valuation">Auto-√©valuation</option>
              <option value="code-couleur">Code couleur</option>
              <option value="criterie">Crit√©ri√©</option>
            </select>
          </div>

          <Button
            variant="ghost"
            className="h-8 w-8 p-0 text-xl leading-none"
            aria-label="Fermer l'aper√ßu"
            onClick={() => {
              closePreviewModal();
            }}
          >
            √ó
          </Button>
        </div>
      </div>

	      <div className="flex-1 overflow-auto bg-neutral-50 dark:bg-[var(--night-panel)]">
        <iframe
          ref={previewIframeRef}
          title="Aper√ßu d'impression"
          srcDoc={previewHtml || ""}
          className="w-full h-full border-0"
        />
      </div>
    </div>
  </div>
)}



      
      {printOpen && printHtml && (
        <div
          // D√©calage vers le bas pour √©viter la confusion avec la barre du haut (CAP-...)
          // + fond plus opaque / blur pour ne pas voir la barre derri√®re.
          className="fixed inset-0 z-[10000] bg-black/80 backdrop-blur-sm px-4 pb-4 pt-[128px]"
          role="dialog"
          aria-modal="true"
          onMouseDown={(e) => {
            if (e.target === e.currentTarget) {
              closePrintModal();
            }
          }}
        >
          <div className="keep-light bg-white dark:bg-[var(--night-panel)] text-neutral-900 dark:text-neutral-300 w-[calc(100vw-32px)] h-[calc(100vh-128px-32px)] max-w-none max-h-none rounded-2xl shadow-xl flex flex-col overflow-hidden">
            <div className="sticky top-0 z-10">
              <div className="flex items-center justify-between px-4 py-2 bg-white dark:bg-[var(--night-panel)] text-neutral-900 dark:text-neutral-300 border-b border-neutral-200 dark:border-sky-400/35">
                <span className="font-semibold text-sm">Impression</span>
                <div className="flex items-center gap-2">
                  <Button
                    variant="outline"
                    className="h-8 px-3 text-xs bg-white hover:bg-amber-100/70 dark:bg-[var(--night-surface)] text-neutral-900 dark:text-neutral-300 border-neutral-300 dark:border-sky-400/35 hover:bg-amber-100/70 dark:bg-[var(--night-surface)]"
                    onClick={() => {
                      startPrintJob(printHtml);
                    }}
                  >
                    Imprimer
                  </Button>

                  <Button
                    variant="ghost"
                    className="h-8 px-3 text-xs text-neutral-900 dark:text-neutral-300 hover:bg-amber-100/70 dark:bg-[var(--night-surface)]"
                    aria-label="Fermer la fen√™tre d'impression"
                    onClick={() => {
                      closePrintModal();
                    }}
                  >
                    ‚úï Fermer
                  </Button>
                </div>
              </div>

              {activeView === "evaluation" && (
                <div className="flex items-center gap-2 px-4 py-2 border-b border-neutral-200 dark:border-sky-400/35 bg-white dark:bg-[var(--night-panel)]">
                  <span className="text-xs text-neutral-600 dark:text-neutral-300">Type</span>
                  <select
                    className="h-8 w-[220px] text-xs border rounded-md px-2 app-input"
                    value={printEvaluationType || ""}
                    onChange={(e) => {
                      const v = e.target.value;
                      setPrintEvaluationType(v);
                      openPreviewWindow(v, evaluationCategory, { target: "printWindow" });
                    }}
                  >
                    <option value="" disabled>
                      S√©lectionner un type d'impression
                    </option>
                    <option value="Auto-√©valuation">Auto-√©valuation</option>
                    <option value="code-couleur">Code couleur</option>
                    <option value="criterie">Crit√©ri√©</option>
                  </select>
                </div>
              )}
            </div>

            <div className="flex-1 overflow-auto bg-neutral-50 dark:bg-[var(--night-panel)]">
              <iframe
                ref={printIframeRef}
                title="Impression"
                srcDoc={printHtml || ""}
                className="w-full h-full border-0"
              />
            </div>
          </div>
        </div>
      )}

{printJobHtml && (
  <iframe
    ref={printJobIframeRef}
    title="Print Job"
    srcDoc={printJobHtml || ""}
    className="fixed right-0 bottom-0 w-[1px] h-[1px] opacity-0 pointer-events-none"
  />
)}

<div className="sticky top-0 z-30 bg-white/80 dark:bg-[var(--night-panel)]/95 backdrop-blur border-b border-neutral-900 dark:border-[var(--night-border-strong)] dark:text-white night-banner">
        <div className="h-1 w-full topbar-rainbow" />
<div className="topbar-row w-full px-2 py-2 flex items-center">
{/* Actions */}
<input
  ref={importFileInputRef}
  type="file"
  accept="application/json,.json"
  className="hidden"
  onChange={async (e) => {
    try {
      const f = e.target.files?.[0];
      if (!f) return;
      const txt = await f.text();
      await handleImportClassDataFromText(txt);
    } finally {
      // permettre de r√©-importer le m√™me fichier
      e.currentTarget.value = "";
    }
  }}
/>

<DropdownMenu>
  <DropdownMenuTrigger asChild>
    <Button
      title="Actions"
      aria-label="Actions"
      className={classNames("topbar-btn", referentielDrawerOpen && "is-open")}
    >
      <span className="topbar-emoji" aria-hidden="true">üß∞</span>
      <span className="topbar-label sm:hidden">ACTIONS</span>
      <span className="topbar-label hidden sm:inline">ACTIONS</span>
    </Button>
  </DropdownMenuTrigger>

  <DropdownMenuContent
    align="start"
    className="w-64 bg-white dark:bg-[var(--night-panel)] border border-neutral-200 dark:border-sky-400/35 text-neutral-900 dark:text-neutral-300"
  >
    <DropdownMenuLabel className="text-xs text-neutral-700 dark:text-neutral-300">
      Actions
    </DropdownMenuLabel>

    <DropdownMenuSeparator className="bg-neutral-200 dark:bg-neutral-700/60" />

<DropdownMenuItem
  disabled={updateBusy}
  className="cursor-pointer dark:hover:bg-[var(--night-hover)]"
  onSelect={() => handleCheckUpdate()}
>
  <div className="flex items-center gap-2">
    <span className="text-base leading-none" aria-hidden="true">‚¨ÜÔ∏è</span>
    <span className="text-sm">{updateBusy ? "V√©rification‚Ä¶" : "V√©rifier mise √† jour"}</span>
  </div>
</DropdownMenuItem>

    <DropdownMenuSeparator className="bg-neutral-200 dark:bg-neutral-700/60" />

    <DropdownMenuItem
      disabled={importBusy}
      className="cursor-pointer dark:hover:bg-[var(--night-hover)]"
      onSelect={() => handleImportClick()}
    >
      <div className="flex items-center gap-2">
        <Upload className="w-4 h-4" aria-hidden="true" />
        <span className="text-sm">{importBusy ? "Importer‚Ä¶" : "Importer une classe"}</span>
      </div>
    </DropdownMenuItem>

    <DropdownMenuItem className="cursor-pointer dark:hover:bg-[var(--night-hover)]" onSelect={() => openExportDrawer()}>
      <div className="flex items-center gap-2">
        <Download className="w-4 h-4" aria-hidden="true" />
        <span className="text-sm">Exporter une classe</span>
      </div>
    </DropdownMenuItem>

    <DropdownMenuSeparator className="bg-neutral-200 dark:bg-neutral-700/60" />

    <DropdownMenuItem className="cursor-pointer dark:hover:bg-[var(--night-hover)]" onSelect={() => handlePrintClick()}>
      <div className="flex items-center gap-2">
        <span className="text-base leading-none" aria-hidden="true">üñ®Ô∏è</span>
        <span className="text-sm">Imprimer</span>
      </div>
    </DropdownMenuItem>

    <DropdownMenuSeparator className="bg-neutral-200 dark:bg-neutral-700/60" />

    <DropdownMenuItem className="cursor-pointer dark:hover:bg-[var(--night-hover)]" onSelect={() => setClassDrawerOpen(true)}>
      <div className="flex items-center gap-2">
        <span className="text-base leading-none" aria-hidden="true">üìö</span>
        <span className="text-sm">Classes</span>
      </div>
    </DropdownMenuItem>

    <DropdownMenuItem className="cursor-pointer dark:hover:bg-[var(--night-hover)]" onSelect={() => handleOpenDevoirDatabase()}>
      <div className="flex items-center gap-2">
        <span className="text-base leading-none" aria-hidden="true">üìÅ</span>
        <span className="text-sm">devoirs</span>
      </div>
    </DropdownMenuItem>

    <DropdownMenuItem className="cursor-pointer dark:hover:bg-[var(--night-hover)]" onSelect={() => setGeneralSettingsDrawerOpen(true)}>
      <div className="flex items-center gap-2">
        <Settings2 className="w-4 h-4" aria-hidden="true" />
        <span className="text-sm">Param√®tre g√©n√©ral</span>
      </div>
    </DropdownMenuItem>

<DropdownMenuItem className="cursor-pointer dark:hover:bg-[var(--night-hover)]" onSelect={() => { setReferentielDrawerOpen(true); }}>
  <div className="flex items-center gap-2">
    <span className="text-base leading-none" aria-hidden="true">üìò</span>
    <span className="text-sm">Mon r√©f√©rentiel (CAP)</span>
  </div>
</DropdownMenuItem>

  </DropdownMenuContent>
</DropdownMenu>

<div className="topbar-subgroup">
    {/* Cr√©er un devoir */}
    <Button
      type="button"
      title="Cr√©er un devoir"
      aria-label="Cr√©er un devoir"
      className={classNames("topbar-btn", activeView === "evaluation" && "is-active")}
      onClick={() => setActiveView("evaluation")}
    >
      <span className="topbar-emoji" aria-hidden="true">üìù</span>
      <span className="topbar-label sm:hidden">CR√âER</span>
      <span className="topbar-label hidden sm:inline">CR√âER UN DEVOIR</span>
    </Button>

    {/* Notation */}
    <Button
      type="button"
      title="Notation"
      aria-label="Notation"
      className={classNames("topbar-btn", activeView === "notes" && "is-active")}
      onClick={() => setActiveView("notes")}
    >
      <span className="topbar-emoji" aria-hidden="true">üßÆ</span>
      <span className="topbar-label sm:hidden">NOTES</span>
      <span className="topbar-label hidden sm:inline">NOTATION</span>
    </Button>

    {/* Suivi des comp√©tences */}
    <Button
      type="button"
      title="Suivi des comp√©tences"
      aria-label="Suivi des comp√©tences"
      className={classNames("topbar-btn", activeView === "suivi" && "is-active")}
      onClick={() => setActiveView("suivi")}
    >
      <span className="topbar-emoji" aria-hidden="true">üìä</span>
      <span className="topbar-label sm:hidden">SUIVI</span>
      <span className="topbar-label hidden sm:inline">SUIVI DES COMP√âTENCES</span>
    </Button>

    
{/* Suivi d'√©l√®ves */}
<Button
  type="button"
  title="Suivi d'√©l√®ves"
  aria-label="Suivi d'√©l√®ves"
  className={classNames("topbar-btn", activeView === "suivi_eleves" && "is-active")}
  onClick={() => { setActiveView("suivi_eleves"); setSuiviElevesMode("docs"); }}
>
  <span className="topbar-emoji" aria-hidden="true">üóÇÔ∏è</span>
  <span className="topbar-label sm:hidden">√âL√àVES</span>
  <span className="topbar-label hidden sm:inline">SUIVI D&apos;√âL√àVES</span>
</Button>


    {/* CCF */}
    <Button
      type="button"
      title="CCF"
      aria-label="CCF"
      className={classNames("topbar-btn", activeView === "ccf" && "is-active")}
      onClick={() => setActiveView("ccf")}
    >
      <span className="topbar-emoji" aria-hidden="true">üßæ</span>
      <span className="topbar-label sm:hidden">CCF</span>
      <span className="topbar-label hidden sm:inline">CCF</span>
    </Button>

  </div>

{/* Drawer Classe / √âl√®ves */}
<Drawer
  open={classDrawerOpen}
  onClose={() => setClassDrawerOpen(false)}
  side="right"
  className="w-[360px] sm:w-[420px]"
>
  <div className="px-4 py-3 border-b border-neutral-200 dark:border-sky-400/35 font-semibold bg-white dark:bg-[var(--night-panel)] text-neutral-900 dark:text-neutral-300">
    Classe / √©l√®ves
  </div>

  <div className="p-3 space-y-4 bg-neutral-50 dark:bg-[var(--night-base)]">
    <div className="flex items-center justify-between gap-2">
      <div>
        <p className="text-xs text-neutral-600 dark:text-neutral-300">
          Ajoutez une ou plusieurs classes et saisissez les noms des √©l√®ves (un par ligne).
        </p>
      </div>
      <Button
        type="button"
        className="btn-primary btn-sm"
        onClick={() => {
          setClassGroups((prev) => [
            ...prev,
            {
              id: `${Date.now()}-${Math.random().toString(16).slice(2)}`,
              name: `Classe ${prev.length + 1}`,
              students: "",
            },
          ]);
        }}
      >
        + Ajouter une classe
      </Button>
    </div>

    {classGroups.length === 0 ? (
      <p className="text-xs text-neutral-500 dark:text-neutral-300">
        Aucune classe pour l‚Äôinstant. Cliquez sur <strong>Ajouter une classe</strong> pour commencer.
      </p>
    ) : (
            <div className="space-y-3">
        {classGroups.map((classe, idx) => {
          const s = CLASS_BUBBLE_STYLES[idx % CLASS_BUBBLE_STYLES.length];
          const studentCount = (classe.students || "")
            .split("\n")
            .map((x) => x.trim())
            .filter(Boolean).length;

          return (
            <div
              key={classe.id}
              className="border border-neutral-200 dark:border-sky-400/35 rounded-xl bg-white dark:bg-[var(--night-surface)] keep-light p-3 space-y-2 shadow-sm"
            >
              {/* ‚úÖ Bulle color√©e (identit√© de la classe) */}
              <div className="flex items-center justify-between gap-2">
                <span
                  className={classNames(
                    "inline-flex items-center gap-2 rounded-full border px-2 py-1 text-[11px] font-semibold",
                    s.bubble
                  )}
                >
                  <span className={classNames("w-2 h-2 rounded-full", s.dot)} aria-hidden="true" />
                  {classe.name || `Classe ${idx + 1}`}
                </span>

                <span className="text-[11px] text-neutral-500 dark:text-neutral-300">
                  {studentCount} √©l√®ve{studentCount > 1 ? "s" : ""}
                </span>
              </div>

              <div className="flex items-center justify-between gap-2">
                <div className="flex-1 space-y-1">
                  <Label className="text-xs text-neutral-900 dark:text-neutral-300">Intitul√© de la classe</Label>
                  <Input
                    value={classe.name}
                    onChange={(e) =>
                      setClassGroups((prev) =>
                        prev.map((c) =>
                          c.id === classe.id ? { ...c, name: e.target.value } : c
                        )
                      )
                    }
                    className="h-8 text-xs !bg-white dark:!bg-[var(--night-panel)] !text-neutral-900 dark:!text-neutral-50 !border-neutral-300 dark:!border-neutral-700/60"
                    placeholder="Ex : CAP1, CAP2 Groupe A..."
                  />
                </div>
                <Button
                  type="button"
                  variant="ghost"
                  className="h-8 px-2 text-xs btn-ghost-danger"
                  onClick={() =>
                    setClassGroups((prev) => prev.filter((c) => c.id !== classe.id))
                  }
                >
                  Supprimer
                </Button>
              </div>

              <div className="space-y-1">
                <Label className="text-xs text-neutral-900 dark:text-neutral-300">Noms des √©l√®ves</Label>
                <Textarea
                  rows={6}
                  className="text-xs !bg-white dark:!bg-[var(--night-panel)] !text-neutral-900 dark:!text-neutral-50 !border-neutral-300 dark:!border-neutral-700/60"
                  placeholder="Un √©l√®ve par ligne"
                  value={classe.students}
                  onChange={(e) =>
                    setClassGroups((prev) =>
                      prev.map((c) =>
                        c.id === classe.id
                          ? { ...c, students: e.target.value }
                          : c
                      )
                    )
                  }
                />
              </div>
            </div>
          );
        })}
      </div>
    )}
  </div>
</Drawer>

{/* Drawer Export */}
<Drawer
  open={exportDrawerOpen}
  onClose={() => setExportDrawerOpen(false)}
  side="right"
  className="w-[360px] sm:w-[420px]"
>
  <div className="px-4 py-3 border-b border-neutral-200 dark:border-sky-400/35 font-semibold bg-white dark:bg-[var(--night-panel)] text-neutral-900 dark:text-neutral-300">
    Exporter une classe
  </div>

  <div className="p-3 space-y-4 bg-neutral-50 dark:bg-[var(--night-base)]">
    <p className="text-xs text-neutral-600 dark:text-neutral-300">
      Exporte dans un fichier toutes les donn√©es li√©es √† une classe (devoirs sur 2 ans, notation, suivi des comp√©tences‚Ä¶).
    </p>

    <div className="space-y-2">
<label className="text-neutral-900 dark:!text-neutral-50">Classe √† exporter</label>

<select
  className="w-full rounded-md border border-neutral-200 bg-white px-3 py-2 text-sm text-neutral-900
             dark:border-sky-400/35 dark:bg-[var(--night-panel)] dark:text-neutral-300"
  value={exportClassName}
  onChange={(e) => setExportClassName(e.target.value)}
>
  <option value="" disabled>
    Choisir la classe
  </option>
  {classGroups.map((c) => (
    <option key={c.name} value={c.name}>
      {c.name}
    </option>
  ))}
</select>

    </div>

    <div className="flex items-center gap-2">
      <Button
        type="button"
        disabled={!exportClassName || exportBusy}
        className="btn-primary"
        onClick={() => handleExportClassData(exportClassName)}
      >
        {exportBusy ? "Export en cours‚Ä¶" : "Enregistrer sous‚Ä¶"}
      </Button>

      <Button
        type="button"
        variant="ghost"
        className="h-9 px-3 text-xs"
        onClick={() => setExportDrawerOpen(false)}
      >
        Fermer
      </Button>
    </div>

    <div className="text-[11px] text-neutral-500 dark:text-neutral-300">
      Le fichier export√© peut √™tre d√©plac√© sur un autre ordinateur pour sauvegarde ou transfert.
    </div>
  </div>
</Drawer>

{/* Drawer Param√®tre g√©n√©ral */}
<Drawer
  open={generalSettingsDrawerOpen}
  onClose={() => setGeneralSettingsDrawerOpen(false)}
  side="right"
  className="w-[360px] sm:w-[520px]"
>
  <div className="px-4 py-3 border-b border-neutral-200 dark:border-sky-400/35 font-semibold bg-white dark:bg-[var(--night-panel)] text-neutral-900 dark:text-neutral-300">
    Param√®tre g√©n√©ral
  </div>

  <div className="p-3 space-y-4 bg-neutral-50 dark:bg-[var(--night-base)]">
    <p className="text-xs text-neutral-600 dark:text-neutral-300">
      Ces informations sont utilis√©es dans les impressions (livret p√©riodique). Elles sont sauvegard√©es dans <span className="font-mono">AppLocalData/{GENERAL_SETTINGS_FILE}</span>.
    </p>

    <div className="space-y-2">
      <Label className="text-neutral-900 dark:!text-neutral-50">Nom de l&apos;√©tablissement</Label>
      <Input
        value={generalSettings.establishmentName}
        onChange={(e) => setGeneralSettings((p) => ({ ...p, establishmentName: e.target.value }))}
        placeholder="Ex: GRETA / CFA / Lyc√©e ..."
        className="bg-white text-neutral-900 border-neutral-200 dark:!bg-[var(--night-panel)] dark:!text-neutral-50 dark:border-sky-400/35"
      />
    </div>

    <div className="space-y-2">
      <Label className="text-neutral-900 dark:!text-neutral-50">Localisation (optionnel)</Label>
      <Input
        value={generalSettings.establishmentLocation}
        onChange={(e) => setGeneralSettings((p) => ({ ...p, establishmentLocation: e.target.value }))}
        placeholder="Ex: Ville / Adresse courte"
        className="bg-white text-neutral-900 border-neutral-200 dark:!bg-[var(--night-panel)] dark:!text-neutral-50 dark:border-sky-400/35"
      />
    </div>

    <div className="space-y-2">
      <Label className="text-neutral-900 dark:!text-neutral-50">R√©f√©rent(s) par d√©faut (optionnel)</Label>
      <Input
        value={generalSettings.defaultReferents}
        onChange={(e) => setGeneralSettings((p) => ({ ...p, defaultReferents: e.target.value }))}
        placeholder="Ex: Nom Pr√©nom / Nom2 Pr√©nom2"
        className="bg-white text-neutral-900 border-neutral-200 dark:!bg-[var(--night-panel)] dark:!text-neutral-50 dark:border-sky-400/35"
      />
      <p className="text-[11px] text-neutral-500 dark:text-neutral-300">
        Utilis√© si une classe n&apos;a pas de r√©f√©rent renseign√© ci-dessous.
      </p>
    </div>

    <div className="pt-2 border-t border-neutral-200 dark:border-sky-400/35">
      <div className="text-sm font-semibold text-neutral-900 dark:text-neutral-300 mb-2">R√©f√©rent(s) par classe</div>
      <div className="space-y-2">
        {classGroups.length === 0 ? (
          <div className="text-xs text-neutral-600 dark:text-neutral-300">Aucune classe.</div>
        ) : (
          classGroups.map((c) => {
            const k = String(c.name || "").trim();
            const v = (generalSettings.classReferents && typeof generalSettings.classReferents[k] === "string")
              ? generalSettings.classReferents[k]
              : "";
            return (
              <div key={c.id} className="grid grid-cols-1 sm:grid-cols-[170px_1fr] gap-2 items-center">
                <div className="text-xs font-medium text-neutral-800 dark:text-neutral-300">
                  {c.name}
                </div>
                <Input
                  value={v}
                  onChange={(e) =>
                    setGeneralSettings((p) => ({
                      ...p,
                      classReferents: { ...(p.classReferents || {}), [k]: e.target.value },
                    }))
                  }
                  placeholder="R√©f√©rent(s) de la classe"
                  className="bg-white text-neutral-900 border-neutral-200 dark:!bg-[var(--night-panel)] dark:!text-neutral-50 dark:border-sky-400/35"
                />
              </div>
            );
          })
        )}
      </div>
    </div>

    <div className="pt-2 border-t border-neutral-200 dark:border-sky-400/35">
      <div className="text-sm font-semibold text-neutral-900 dark:text-neutral-300 mb-2">
        Seuils ‚Äî Feux Absences / Retards
      </div>
      <div className="text-[11px] text-neutral-500 dark:text-neutral-300">
        Utilis√©s pour le feu (vert/orange/rouge) dans le suivi et le bilan p√©riodique. Seuils exprim√©s en % des jours de cours effectifs.
      </div>
      <div className="grid grid-cols-1 sm:grid-cols-2 gap-3 mt-2">
        <div className="space-y-2 rounded-lg border border-neutral-200 dark:border-sky-400/35 bg-white dark:bg-[var(--night-surface)] p-3">
          <div className="text-xs font-semibold text-neutral-900 dark:text-neutral-300">Absences</div>
          <div className="grid grid-cols-2 gap-2">
            <div className="space-y-1">
              <Label className="text-xs">Orange (%)</Label>
              <Input
                type="number"
                min={0}
                max={100}
                step={0.5}
                value={String(absencesWarnAbsPct)}
                onChange={(e) => {
                  const raw = (e.target.value || "0").replace(",", ".");
                  const n = parseFloat(raw);
                  if (!Number.isFinite(n)) return;
                  setAbsencesWarnAbsPct(n);
                }}
                className="h-9 text-xs bg-white dark:bg-[var(--night-panel)]"
              />
            </div>
            <div className="space-y-1">
              <Label className="text-xs">Rouge (%)</Label>
              <Input
                type="number"
                min={0}
                max={100}
                step={0.5}
                value={String(absencesAlertAbsPct)}
                onChange={(e) => {
                  const raw = (e.target.value || "0").replace(",", ".");
                  const n = parseFloat(raw);
                  if (!Number.isFinite(n)) return;
                  setAbsencesAlertAbsPct(n);
                }}
                className="h-9 text-xs bg-white dark:bg-[var(--night-panel)]"
              />
            </div>
          </div>
        </div>

        <div className="space-y-2 rounded-lg border border-neutral-200 dark:border-sky-400/35 bg-white dark:bg-[var(--night-surface)] p-3">
          <div className="text-xs font-semibold text-neutral-900 dark:text-neutral-300">Retards</div>
          <div className="grid grid-cols-2 gap-2">
            <div className="space-y-1">
              <Label className="text-xs">Orange (%)</Label>
              <Input
                type="number"
                min={0}
                max={100}
                step={0.5}
                value={String(absencesWarnRtPct)}
                onChange={(e) => {
                  const raw = (e.target.value || "0").replace(",", ".");
                  const n = parseFloat(raw);
                  if (!Number.isFinite(n)) return;
                  setAbsencesWarnRtPct(n);
                }}
                className="h-9 text-xs bg-white dark:bg-[var(--night-panel)]"
              />
            </div>
            <div className="space-y-1">
              <Label className="text-xs">Rouge (%)</Label>
              <Input
                type="number"
                min={0}
                max={100}
                step={0.5}
                value={String(absencesAlertRtPct)}
                onChange={(e) => {
                  const raw = (e.target.value || "0").replace(",", ".");
                  const n = parseFloat(raw);
                  if (!Number.isFinite(n)) return;
                  setAbsencesAlertRtPct(n);
                }}
                className="h-9 text-xs bg-white dark:bg-[var(--night-panel)]"
              />
            </div>
          </div>
        </div>
      </div>
      <div className="text-[11px] text-neutral-500 dark:text-neutral-300 mt-1">
        Vert = &lt; Orange ‚Ä¢ Orange = ‚â• Orange ‚Ä¢ Rouge = ‚â• Rouge ‚Ä¢ Sauvegarde automatique.
      </div>
    </div>

    <div className="flex items-center gap-2 pt-2">
      <Button
        type="button"
        className="btn-primary"
        onClick={async () => {
          try {
            await saveGeneralSettingsToStore(generalSettings);
            setGeneralSettingsSaveFeedback({ type: "success", message: "Param√®tres enregistr√©s." });
          } catch {
            setGeneralSettingsSaveFeedback({ type: "error", message: "√âchec de l‚Äôenregistrement." });
          }
        }}
      >
        Enregistrer mon r√©f√©rentiel
      </Button>

      <Button
        type="button"
        variant="ghost"
        className="h-9 px-3 text-xs"
        onClick={() => setGeneralSettingsDrawerOpen(false)}
      >
        Fermer
      </Button>

      <Button
        type="button"
        variant="ghost"
        className="h-9 px-3 text-xs ml-auto btn-ghost-danger"
        onClick={async () => {
          const ok = await confirm("R√©initialiser les param√®tres g√©n√©raux ?", { title: "Param√®tre g√©n√©ral", kind: "warning" } as any);
          if (!ok) return;
          setGeneralSettings({ ...DEFAULT_GENERAL_SETTINGS });
          await saveGeneralSettingsToStore({ ...DEFAULT_GENERAL_SETTINGS });
          setGeneralSettingsSaveFeedback({ type: "success", message: "Param√®tres r√©initialis√©s." });
        }}
      >
        R√©initialiser
      </Button>
    </div>

    {generalSettingsSaveFeedback ? (
      <div
        className={classNames(
          "mt-2 rounded-md px-3 py-2 text-xs border",
          generalSettingsSaveFeedback.type === "success"
            ? "bg-emerald-50 text-emerald-700 border-emerald-200 dark:bg-emerald-950/30 dark:text-emerald-200 dark:border-emerald-800/60"
            : "bg-red-50 text-red-700 border-red-200 dark:bg-red-950/30 dark:text-red-200 dark:border-red-800/60"
        )}
        role="status"
      >
        {generalSettingsSaveFeedback.message}
      </div>
    ) : null}

  </div>


</Drawer>


<div className="flex-1" />

          <div className="flex items-center gap-1">
            <button
              type="button"
              onClick={() => setTheme(theme === 'dark' ? 'light' : 'dark')}
              className="icon-btn"
              title={theme === 'dark' ? 'Passer en th√®me clair' : 'Passer en th√®me sombre'}
              aria-label={theme === 'dark' ? 'Passer en th√®me clair' : 'Passer en th√®me sombre'}
            >
              {theme === 'dark' ? <Sun className="w-4 h-4" /> : <Moon className="w-4 h-4" />}
            </button>

            <button
              type="button"
              onClick={() => setHelpOpen(true)}
              className="icon-btn"
              title="Aide"
              aria-label="Aide"
            >
              <span className="text-sm font-bold leading-none">?</span>
            </button>
          </div>

        </div>
      </div>

      <div className="w-full px-4 py-1">
        <div className="flex items-center gap-4">
          <div className="flex-1">
          </div>
        </div>
      </div>


<Drawer
  open={referentielDrawerOpen}
  onClose={() => setReferentielDrawerOpen(false)}
  side="right"
  className="w-full"
>
  <div className="w-full px-3 sm:px-6 lg:px-8 py-4">
    <div className="max-w-[1400px] mx-auto">
      <div className="rounded-2xl border border-neutral-200 dark:border-sky-400/35 overflow-hidden bg-white dark:bg-[var(--night-base)]">
  <div className="px-4 py-3 border-b border-neutral-200 dark:border-sky-400/35 font-semibold bg-white dark:bg-[var(--night-panel)] text-neutral-900 dark:text-neutral-300 flex items-center justify-between">
    <span>Mon r√©f√©rentiel (CAP)</span>
    <div className="flex items-center gap-2">
      <span className="text-xs font-normal text-neutral-600 dark:text-neutral-300">Choisir un r√©f√©rentiel :</span>
      <select
        className="h-8 max-w-[420px] rounded-md border border-neutral-200 bg-white px-2 text-xs text-neutral-900 dark:border-sky-400/35 dark:bg-[var(--night-panel)] dark:text-neutral-200"
        value={refEditId ?? "__base__"}
        onChange={async (e) => {
          const v = e.target.value;
          if (v === "__base__") await loadReferentielCapIntoEditor(null);
          else await loadReferentielCapIntoEditor(v);
        }}
        disabled={refSwitching}
      >
        <option value="__base__">Base (r√©f√©rentiel par d√©faut)</option>
        {(referentielCapCatalog.items || [])
          .slice()
          .sort((a, b) => (a.name || "Sans nom").localeCompare(b.name || "Sans nom", "fr", { sensitivity: "base" }))
          .map((it) => (
            <option key={it.id} value={it.id}>
              {it.name || "Sans nom"}
            </option>
          ))}
      </select>

      <Button
        type="button"
        variant="ghost"
        className="h-8 px-2 text-xs"
        onClick={async () => {
          // ‚ÄúEnregistrer l‚Äôaffichage‚Äù : applique le r√©f√©rentiel s√©lectionn√© (sans toucher aux modifications non enregistr√©es)
          await applyReferentielCapSelection(refEditId);
        }}
        disabled={refSwitching}
        title="Enregistrer le choix du r√©f√©rentiel affich√©"
      >
        Enregistrer l‚Äôaffichage
      </Button>

      {refEditId ? (
        <Button
          type="button"
          variant="ghost"
          className="h-8 px-2 text-xs btn-ghost-danger"
          onClick={deleteSelectedReferentielCap}
          disabled={refSwitching}
        >
          Supprimer
        </Button>
      ) : null}
    </div>
    <div className="flex items-center gap-2">
      <Button
        type="button"
        className="btn-primary"
        onClick={async () => {
          try {
            const tc = normalizeTcMap(refTcMap);
            const db = normalizeCritResDB(refCritResDB);
            const poles = normalizePolesList(refPoles, refPolesMap);
            const pm = normalizePolesMap(refPolesMap, poles, Object.keys(tc));

            const name = (refName || "").trim() || "Mon r√©f√©rentiel";
            const now = new Date().toISOString();

            // Catalogue √† jour (priorit√© disque/cache)
            let cat = await loadReferentielCapCatalog();
            if (!cat) cat = referentielCapCatalog ?? { schema: "referentiels_cap_catalog_v1", activeId: null, items: [] };

            let targetId = refEditId;

            // Si on est sur "Base" dans l‚Äô√©diteur : on cr√©e un nouveau r√©f√©rentiel (sans changer l‚Äôaffichage)
            if (!targetId) {
              targetId = __makeId();
              cat = {
                ...cat,
                items: [
                  { id: targetId, name, updatedAt: now, tcMap: tc, critResDB: db, poles, polesMap: pm },
                  ...(cat.items || []),
                ],
              };
              setRefEditId(targetId);
            } else {
              const exists = (cat.items || []).some((i) => i.id === targetId);
              if (!exists) {
                cat = {
                  ...cat,
                  items: [
                    { id: targetId, name, updatedAt: now, tcMap: tc, critResDB: db, poles, polesMap: pm },
                    ...(cat.items || []),
                  ],
                };
              } else {
                cat = {
                  ...cat,
                  items: (cat.items || []).map((i) =>
                    i.id === targetId ? { ...i, name, updatedAt: now, tcMap: tc, critResDB: db, poles, polesMap: pm } : i
                  ),
                };
              }
            }

            setReferentielCapCatalog(cat);
            await saveReferentielCapCatalog(cat);

            // Si on vient de modifier le r√©f√©rentiel actuellement affich√©, on l‚Äôapplique aussi au logiciel
            if (targetId && referentielCapActiveId === targetId) {
              setTcMap(tc);
              setCritResDB(db);
              setCapPoles(poles);
              setPolesMap(pm);
              setReferentielCapName(name);
              await saveReferentielCapToStore({ schema: "referentiel_cap_v1", name, tcMap: tc, critResDB: db, poles, polesMap: pm });
            }

            // Met √† jour le nom dans l‚Äô√©diteur
            setRefName(name);

            if (!refEditId) {
              setRefFeedback({ type: "success", message: "R√©f√©rentiel enregistr√© (nouveau). Clique sur ‚ÄúEnregistrer l‚Äôaffichage‚Äù pour l‚Äôutiliser." });
            } else {
              setRefFeedback({ type: "success", message: "R√©f√©rentiel enregistr√©." });
            }
          } catch (e) {
            console.warn(e);
            setRefFeedback({ type: "error", message: "Erreur : impossible d'enregistrer. V√©rifie la structure du r√©f√©rentiel." });
          }
        }}      >
        Enregistrer mon r√©f√©rentiel
      </Button>

      <Button
        type="button"
        variant="ghost"
        className="h-9 px-3 text-xs"
        onClick={() => setReferentielDrawerOpen(false)}
      >
        Fermer
      </Button>
    </div>
  </div>

  <div className="p-3 space-y-3 bg-neutral-50 dark:bg-[var(--night-base)]">
    {refFeedback && (
      <div
        className={classNames(
          "text-xs rounded-lg border px-3 py-2",
          refFeedback.type === "success"
            ? "border-emerald-200 bg-emerald-50 text-emerald-800 dark:border-emerald-500/30 dark:bg-emerald-500/10 dark:text-emerald-200"
            : "border-red-200 bg-red-50 text-red-800 dark:border-red-500/30 dark:bg-red-500/10 dark:text-red-200"
        )}
      >
        {refFeedback.message}
      </div>
    )}
<div className="rounded-xl border border-neutral-200 dark:border-sky-400/35 bg-white dark:bg-[var(--night-surface)] p-3 space-y-2">
      <div className="text-xs font-semibold text-neutral-900 dark:text-neutral-200">Nom du r√©f√©rentiel</div>

      <div className="relative">
        <Input
          value={refName}
          onChange={(e) => {
            const v = e.target.value;
            setRefName(v);
            // Si l'utilisateur tape exactement un dipl√¥me connu, on active le bouton "Aper√ßu".
            const exact = (eduscolDiplomas || []).find((d) => normKey(d.title) === normKey(v));
            setRefNameEduscolUrl(exact?.url || "");
            setRefNameSuggestOpen(true);
            setRefNameSuggestActive(0);
          }}
          onFocus={() => setRefNameSuggestOpen(true)}
          onBlur={() => {
            // Laisse le temps au clic sur une suggestion
            window.setTimeout(() => setRefNameSuggestOpen(false), 150);
          }}
          onKeyDown={(e) => {
            if (!refNameSuggestOpen) return;
            if (!refNameSuggestions.length) return;

            if (e.key === "ArrowDown") {
              e.preventDefault();
              setRefNameSuggestActive((i) => Math.min(i + 1, refNameSuggestions.length - 1));
            } else if (e.key === "ArrowUp") {
              e.preventDefault();
              setRefNameSuggestActive((i) => Math.max(i - 1, 0));
            } else if (e.key === "Enter") {
              e.preventDefault();
              const d = refNameSuggestions[refNameSuggestActive];
              if (d) pickRefNameSuggestion(d);
            } else if (e.key === "Escape") {
              setRefNameSuggestOpen(false);
            }
          }}
          placeholder="Tape un dipl√¥me (ex : mac ‚Üí CAP M...)"
          className="h-9 text-xs bg-white dark:bg-[var(--night-panel)] pr-56"
        />

        <div className="absolute right-2 top-1/2 -translate-y-1/2 flex items-center gap-1.5">
          <Button
            type="button"
            variant="ghost"
            className="h-7 px-2 text-[11px]"
            disabled={!refNameEduscolUrl}
            onMouseDown={(ev) => ev.preventDefault()}
            onClick={() => openEduscolPreview(refNameEduscolUrl)}
            title={refNameEduscolUrl ? "Ouvrir l'aper√ßu √âduscol" : "Choisis un dipl√¥me dans la liste pour activer l'aper√ßu"}
          >
            Aper√ßu
          </Button>
          <Button
            type="button"
            variant="ghost"
            className="h-7 px-2 text-[11px]"
            disabled={refDocsLoading || !refName}
            onMouseDown={(ev) => ev.preventDefault()}
            onClick={() => {
              void runRefDocsSearch();
              void runRefExamSearch();
              void runRefLivretSearch();
              // Confort : am√®ne l'utilisateur √† la section des r√©sultats
              window.setTimeout(() => {
                try {
                  document.getElementById("refdocs-section")?.scrollIntoView({ behavior: "smooth", block: "start" });
                } catch {}
              }, 0);
            }}
            title={refName ? "Rechercher les documents officiels" : "Renseigne d'abord le nom du dipl√¥me"}
          >
            {refDocsLoading ? "Recherche‚Ä¶" : "Recherche R√©f√©rentiel et Arr√™t√©s"}
          </Button>
          <div className="text-neutral-400">
            {eduscolDiplomasLoading ? (
              <span className="text-[11px]">‚Ä¶</span>
            ) : (
              <Search className="h-4 w-4" />
            )}
          </div>
        </div>

        {refNameSuggestOpen && (refName || "").trim().length >= 2 && (
          <div className="absolute z-50 mt-1 w-full rounded-xl border border-neutral-200 dark:border-sky-400/35 bg-white dark:bg-[var(--night-surface)] shadow-sm overflow-hidden">
            {eduscolDiplomasError ? (
              <div className="px-3 py-2 text-[11px] text-red-700 dark:text-red-300">
                {eduscolDiplomasError}
              </div>
            ) : refNameSuggestions.length === 0 ? (
              <div className="px-3 py-2 text-[11px] text-neutral-500 dark:text-neutral-300">
                {eduscolDiplomasLoading ? "Chargement de la liste des dipl√¥mes‚Ä¶" : "Aucune proposition (essaie 3-4 lettres)."}
              </div>
            ) : (
              <div className="max-h-64 overflow-auto">
                {refNameSuggestions.map((d, idx) => (
                  <button
                    key={d.url}
                    type="button"
                    className={classNames(
                      "w-full text-left px-3 py-2 text-xs hover:bg-neutral-50 dark:hover:bg-[var(--night-hover)]",
                      idx === refNameSuggestActive && "bg-neutral-50 dark:bg-[var(--night-hover)]"
                    )}
                    onMouseDown={(ev) => ev.preventDefault()}
                    onClick={() => pickRefNameSuggestion(d)}
                    title={d.url}
                  >
                    <div className="flex items-center justify-between gap-3">
                      <div className="font-medium text-neutral-900 dark:text-neutral-100">{d.title}</div>
                      <div className="shrink-0 text-[10px] text-neutral-500 dark:text-neutral-300">{d.category}</div>
                    </div>
                  </button>
                ))}
              </div>
            )}
          </div>
        )}
      </div>

      <div className="text-[11px] text-neutral-500 dark:text-neutral-300">
        Recherche bas√©e sur la liste des dipl√¥mes (Formations) d‚Äô√âduscol STI.
      </div>
    </div>
      <div id="refdocs-section" className="mt-2 rounded-xl border border-neutral-200 dark:border-sky-400/35 bg-neutral-50 dark:bg-[var(--night-panel)] p-3 space-y-2">
        <Tabs value={refOfficialTab} onValueChange={(v) => setRefOfficialTab(v as any)}>
          <div className="flex items-center justify-between gap-2">
            <TabsList className="inline-flex !flex !flex-row !flex-nowrap gap-1 rounded-full border border-neutral-200 dark:border-sky-400/35 bg-white/60 dark:bg-[var(--night-surface)] p-1">
              <TabsTrigger
                value="docs"
                className="inline-flex items-center rounded-full transition !bg-transparent !text-neutral-700 dark:!text-neutral-300 hover:!bg-amber-100/70 dark:hover:!bg-[var(--night-hover)] data-[state=active]:!bg-neutral-900 data-[state=active]:!text-white"
              >
                Documents officiels
              </TabsTrigger>
              <TabsTrigger
                value="exam"
                className="inline-flex items-center rounded-full transition !bg-transparent !text-neutral-700 dark:!text-neutral-300 hover:!bg-amber-100/70 dark:hover:!bg-[var(--night-hover)] data-[state=active]:!bg-neutral-900 data-[state=active]:!text-white"
              >
                Sujet d‚Äôexamen
              </TabsTrigger>
            
              <TabsTrigger
                value="livret"
                className="inline-flex items-center rounded-full transition !bg-transparent !text-neutral-700 dark:!text-neutral-300 hover:!bg-amber-100/70 dark:hover:!bg-[var(--night-hover)] data-[state=active]:!bg-neutral-900 data-[state=active]:!text-white"
              >
                Livret de certification
              </TabsTrigger>
</TabsList>
          </div>

          <TabsContent value="docs" className="mt-2 space-y-2">
            {refDocsError && (
              <div className="text-[11px] text-red-700 dark:text-red-300">{refDocsError}</div>
            )}

            {refDocsResults.length > 0 && (() => {
              const latestExtraitJoPdf = [...refDocsResults]
                .filter((x) => isExtraitJoDoc(x))
                .sort((a, b) => String(b.publishedAt || "").localeCompare(String(a.publishedAt || "")))[0];
              const latestExtraitJoPdfUrl = latestExtraitJoPdf?.url;

              return (
              <div className="overflow-x-auto rounded-xl border border-neutral-200 dark:border-sky-400/35 bg-white dark:bg-[var(--night-surface)]">
                <table className="w-full text-xs">
                  <thead className="bg-neutral-50 dark:bg-[var(--night-hover)]">
                    <tr className="text-left">
                      <th className="px-3 py-2 font-semibold">Type</th>
                      <th className="px-3 py-2 font-semibold">Source</th>
                      <th className="px-3 py-2 font-semibold whitespace-nowrap">Parution</th>
                      <th className="px-3 py-2 font-semibold">Titre</th>
                      <th className="px-3 py-2 font-semibold text-right">Ouvrir</th>
                    </tr>
                  </thead>
                  <tbody>
                    {refDocsResults.map((r) => {
                      const isLatestExtraitJoPdf = Boolean(latestExtraitJoPdfUrl && isExtraitJoDoc(r) && r.url === latestExtraitJoPdfUrl);
                      const shouldHighlightYellow = (isReferentielPdfDoc(r) || isExtraitJoDoc(r)) && !isLatestExtraitJoPdf;
                      const shouldHighlightRed = isLatestExtraitJoPdf;

                      return (
                      <tr
                        key={r.url}
                        className={classNames(
                          "border-t border-neutral-200 dark:border-sky-400/20",
                          shouldHighlightYellow && "bg-yellow-200/70 dark:bg-yellow-500/20",
                          shouldHighlightRed && "bg-red-200/70 dark:bg-red-500/20"
                        )}
                      >
                        <td className="px-3 py-2 whitespace-nowrap">{docTypeLabel(r.docType)}</td>
                        <td className="px-3 py-2 whitespace-nowrap">{r.source}</td>
                        <td className="px-3 py-2 whitespace-nowrap text-[11px] text-neutral-600 dark:text-neutral-300">
                          {r.publishedAt
                            ? (r.docType === "arrete" ? formatIsoDateFrLong(r.publishedAt) : formatIsoDateFr(r.publishedAt))
                            : "‚Äî"}
                        </td>
                        <td className="px-3 py-2">
                          <div className="flex items-center gap-2">
                            <div className="line-clamp-2">{r.title}</div>
                            {isReferentielPdfDoc(r) && (
                              <span className="rounded-full bg-yellow-300 px-2 py-0.5 text-[10px] font-semibold text-neutral-900 dark:bg-yellow-600/60 dark:text-white">
                                PDF r√©f√©rentiel
                              </span>
                            )}
                            {isExtraitJoDoc(r) && !isReferentielPdfDoc(r) && (
                              <span className={classNames(
                                "rounded-full px-2 py-0.5 text-[10px] font-semibold",
                                isLatestExtraitJoPdf
                                  ? "bg-red-300 text-neutral-900 dark:bg-red-600/60 dark:text-white"
                                  : "bg-yellow-300 text-neutral-900 dark:bg-yellow-600/60 dark:text-white"
                              )}>
                                Extrait JO
                              </span>
                            )}
                            {!isExtraitJoDoc(r) && isLegifranceJorfUrl(r.url) && (
                              <span className="rounded-full bg-neutral-200 px-2 py-0.5 text-[10px] font-semibold text-neutral-900 dark:bg-white/10 dark:text-neutral-100">
                                JO (page)
                              </span>
                            )}
                          </div>
                          <div className="text-[11px] text-neutral-500 dark:text-neutral-300 break-all">{r.url}</div>
                        </td>
                        <td className="px-3 py-2 text-right">
                          <Button
                            type="button"
                            variant="ghost"
                            className="h-7 px-2 text-[11px]"
                            onClick={() => openEduscolPreview(r.url, r.title)}
                          >
                            Ouvrir
                          </Button>
                        </td>
                      </tr>
                      );
                    })}
                  </tbody>
                </table>
              </div>
              );
            })()}
          </TabsContent>

          <TabsContent value="exam" className="mt-2 space-y-2">
  {refExamError && (
    <div className="text-[11px] text-red-700 dark:text-red-300">{refExamError}</div>
  )}

  {refExamResults.length > 0 && (
    <div className="space-y-3">
      {refExamGroups.map(([year, items]) => (
        <div
          key={year}
          className="overflow-hidden rounded-xl border border-neutral-200 dark:border-sky-400/35 bg-white dark:bg-[var(--night-surface)]"
        >
          <div className="px-3 py-2 text-xs font-semibold bg-neutral-50 dark:bg-[var(--night-hover)]">
            {year}
          </div>
          <div className="divide-y divide-neutral-200 dark:divide-sky-400/20">
            {items.map((r) => (
              <div key={r.url} className="px-3 py-2 flex items-start justify-between gap-3">
                <div className="min-w-0">
                  <div className="text-xs font-medium line-clamp-2">{r.title}</div>
                  <div className="text-[11px] text-neutral-500 dark:text-neutral-300 break-all">{r.url}</div>
                </div>
                <Button
                  type="button"
                  variant="ghost"
                  className="h-7 px-2 shrink-0 text-[11px]"
                  onClick={() => openEduscolPreview(r.url, r.title)}
                >
                  Ouvrir
                </Button>
              </div>
            ))}
          </div>
        </div>
      ))}
    </div>
  )}

  {refExamResults.length === 0 && !refExamError && (
    <div className="text-[11px] text-neutral-500 dark:text-neutral-300">
      {refExamLoading ? "Recherche‚Ä¶" : "Aucun r√©sultat (lance la recherche via le bouton ‚ÄúRecherche R√©f√©rentiel et Arr√™t√©s‚Äù)."}
    </div>
  )}
</TabsContent>


          <TabsContent value="livret" className="mt-2 space-y-2">
            {refLivretError && (
              <div className="text-[11px] text-red-700 dark:text-red-300">{refLivretError}</div>
            )}

            {refLivretResults.length > 0 && (
              <div className="space-y-3">
                {refLivretGroups.map(([year, items]) => (
                  <div
                    key={year}
                    className="overflow-hidden rounded-xl border border-neutral-200 dark:border-sky-400/35 bg-white dark:bg-[var(--night-surface)]"
                  >
                    <div className="px-3 py-2 text-xs font-semibold bg-neutral-50 dark:bg-[var(--night-hover)]">
                      {year}
                    </div>
                    <div className="divide-y divide-neutral-200 dark:divide-sky-400/20">
                      {items.map((r) => (
                        <div key={r.url} className="px-3 py-2 flex items-start justify-between gap-3">
                          <div className="min-w-0">
                            <div className="flex items-center gap-2">
                              <div className="text-xs font-medium line-clamp-2">{r.title}</div>
                              {r.isPdf && (
                                <span className="rounded-full bg-neutral-200 px-2 py-0.5 text-[10px] font-semibold text-neutral-900 dark:bg-white/10 dark:text-neutral-100">
                                  PDF
                                </span>
                              )}
                            </div>
                            <div className="text-[11px] text-neutral-500 dark:text-neutral-300 break-all">{r.url}</div>
                          </div>
                          <Button
                            type="button"
                            variant="ghost"
                            className="h-7 px-2 shrink-0 text-[11px]"
                            onClick={() => openEduscolPreview(r.url, r.title)}
                          >
                            Ouvrir
                          </Button>
                        </div>
                      ))}
                    </div>
                  </div>
                ))}
              </div>
            )}

            {refLivretResults.length === 0 && !refLivretError && (
              <div className="text-[11px] text-neutral-500 dark:text-neutral-300">
                {refLivretLoading ? "Recherche‚Ä¶" : "Aucun r√©sultat (lance la recherche via le bouton ‚ÄúRecherche R√©f√©rentiel et Arr√™t√©s‚Äù)."}
              </div>
            )}
          </TabsContent>

</Tabs>
      </div>

      {/* URL L√©gifrance */}
      <div className="mt-3 rounded-xl border border-neutral-200 dark:border-sky-400/35 bg-white/60 dark:bg-[var(--night-surface)] p-3">
        <div className="mb-2 text-[13px] font-semibold text-neutral-900 dark:text-neutral-100">URL L√©gifrance</div>
        <div className="text-[11px] text-neutral-600 dark:text-neutral-300">
          Colle une URL L√©gifrance (JORFTEXT/LEGITEXT/LEGIARTI...). En mode logiciel, la r√©cup√©ration passe par ton proxy backend (PISTE) si un identifiant est d√©tect√©.
        </div>

        <div className="mt-2 flex flex-col sm:flex-row gap-2">
          <input
            value={refLegifranceUrl}
            onChange={(e) => setRefLegifranceUrl(e.target.value)}
            placeholder="https://www.legifrance.gouv.fr/loda/id/JORFTEXT..."
            className="flex-1 h-9 rounded-md border border-neutral-300 dark:border-sky-400/35 bg-white dark:bg-[var(--night-panel)] px-3 text-[13px]"
          />
          <button
            className="h-9 px-3 rounded-md bg-neutral-900 text-white text-[12px] disabled:opacity-50"
            onClick={() => void runLegifranceUrlFetch()}
            disabled={refLegifranceLoading}
          >
            {refLegifranceLoading ? "Import..." : "Importer"}
          </button>
        </div>

        {refLegifranceError && <div className="mt-2 text-[11px] text-red-700 dark:text-red-300">{refLegifranceError}</div>}

        {refLegifranceRaw && (
          <details className="mt-2 rounded-lg border border-neutral-200 dark:border-sky-400/35 bg-white/60 dark:bg-[var(--night-panel)] p-2">
            <summary className="cursor-pointer text-[12px] text-neutral-700 dark:text-neutral-200">Aper√ßu contenu r√©cup√©r√©</summary>
            <pre className="mt-2 whitespace-pre-wrap break-words text-[11px] text-neutral-700 dark:text-neutral-200 max-h-[280px] overflow-auto">
{refLegifranceRaw.slice(0, 20000)}
            </pre>
          </details>
        )}
      </div>

<Tabs value={refTab} onValueChange={(v) => setRefTab(v as RefTab)}>
            <div className="w-full overflow-x-auto">
        <TabsList className="suivi-tabs inline-flex min-w-max rounded-full border border-neutral-200 dark:border-sky-400/35 bg-neutral-50 dark:bg-[var(--night-surface)] p-1 !flex !flex-row !flex-nowrap !justify-start gap-1 whitespace-nowrap">
          <TabsTrigger value="poles" className="suivi-btn inline-flex items-center rounded-full transition !bg-transparent !text-neutral-700 dark:!text-neutral-300 hover:!bg-amber-100/70 dark:hover:!bg-[var(--night-hover)] data-[state=active]:!bg-neutral-900 data-[state=active]:!text-white shrink-0 !w-auto">P√¥le</TabsTrigger>
          <TabsTrigger value="taches" className="suivi-btn inline-flex items-center rounded-full transition !bg-transparent !text-neutral-700 dark:!text-neutral-300 hover:!bg-amber-100/70 dark:hover:!bg-[var(--night-hover)] data-[state=active]:!bg-neutral-900 data-[state=active]:!text-white shrink-0 !w-auto">T√¢ches</TabsTrigger>
          <TabsTrigger value="competences" className="suivi-btn inline-flex items-center rounded-full transition !bg-transparent !text-neutral-700 dark:!text-neutral-300 hover:!bg-amber-100/70 dark:hover:!bg-[var(--night-hover)] data-[state=active]:!bg-neutral-900 data-[state=active]:!text-white shrink-0 !w-auto">Comp√©tences</TabsTrigger>
          <TabsTrigger value="capacites" className="suivi-btn inline-flex items-center rounded-full transition !bg-transparent !text-neutral-700 dark:!text-neutral-300 hover:!bg-amber-100/70 dark:hover:!bg-[var(--night-hover)] data-[state=active]:!bg-neutral-900 data-[state=active]:!text-white shrink-0 !w-auto">√ätre capable de</TabsTrigger>
          <TabsTrigger value="criteres" className="suivi-btn inline-flex items-center rounded-full transition !bg-transparent !text-neutral-700 dark:!text-neutral-300 hover:!bg-amber-100/70 dark:hover:!bg-[var(--night-hover)] data-[state=active]:!bg-neutral-900 data-[state=active]:!text-white shrink-0 !w-auto">Crit√®res d'√©valuation</TabsTrigger>
        </TabsList>
      </div>

      {/* P√îLE */}
      <TabsContent value="poles" className="mt-3">
        <div className="grid grid-cols-1 sm:grid-cols-[320px_1fr] gap-3">
          <div className="rounded-xl border border-neutral-200 dark:border-sky-400/35 bg-white dark:bg-[var(--night-surface)] p-3 space-y-2">
            <div className="text-xs font-semibold text-neutral-900 dark:text-neutral-200">P√¥les</div>

            <div className="flex items-center gap-2">
              <Input
                value={refNewPoleValue}
                onChange={(e) => setRefNewPoleValue(e.target.value)}
                placeholder="Ajouter un p√¥le‚Ä¶"
                className="h-8 text-xs bg-white dark:bg-[var(--night-panel)]"
                onKeyDown={(e) => {
                  if (e.key !== "Enter") return;
                  const v = String(refNewPoleValue || "").trim();
                  if (!v) return;
                  if ((refPoles || []).some((x) => x.toLowerCase() === v.toLowerCase())) {
                    setRefFeedback({ type: "error", message: "Ce p√¥le existe d√©j√†." });
                    return;
                  }
                  const nextPoles = [...(refPoles || []), v];
                  setRefPoles(nextPoles);
                  setRefPolesMap((p) => ({ ...(p || {}), [v]: (p as any)?.[v] || [] }));
                  setRefSelectedPole(v);
                  setRefNewPoleValue("");
                }}
              />
              <Button
                type="button"
                variant="ghost"
                className="h-8 px-2 text-xs"
                onClick={() => {
                  const v = String(refNewPoleValue || "").trim();
                  if (!v) return;
                  if ((refPoles || []).some((x) => x.toLowerCase() === v.toLowerCase())) {
                    setRefFeedback({ type: "error", message: "Ce p√¥le existe d√©j√†." });
                    return;
                  }
                  const nextPoles = [...(refPoles || []), v];
                  setRefPoles(nextPoles);
                  setRefPolesMap((p) => ({ ...(p || {}), [v]: (p as any)?.[v] || [] }));
                  setRefSelectedPole(v);
                  setRefNewPoleValue("");
                }}
              >
                Ajouter
              </Button>
            </div>

            <div className="space-y-1">
              {refPoles.map((p) => (
                <button
                  key={p}
                  type="button"
                  onClick={() => setRefSelectedPole(p)}
                  className={classNames("list-select-btn", refSelectedPole === p && "is-selected")}
                >
                  {p}
                </button>
              ))}
            </div>

            <div className="pt-2 border-t border-neutral-200 dark:border-sky-400/35 space-y-2">
              <div className="text-[11px] text-neutral-500 dark:text-neutral-300">Renommer le p√¥le s√©lectionn√©</div>
              <div className="flex items-center gap-2">
                <Input
                  value={refRenamePoleValue}
                  onChange={(e) => setRefRenamePoleValue(e.target.value)}
                  className="h-8 text-xs bg-white dark:bg-[var(--night-panel)]"
                />
                <Button
                  type="button"
                  className="h-8 px-2 text-xs"
                  onClick={() => {
                    const oldName = String(refSelectedPole || "").trim();
                    const newName = String(refRenamePoleValue || "").trim();
                    if (!oldName || !newName || oldName === newName) return;
                    if ((refPoles || []).some((x) => x.toLowerCase() === newName.toLowerCase())) {
                      setRefFeedback({ type: "error", message: "Un p√¥le avec ce nom existe d√©j√†." });
                      return;
                    }
                    setRefPoles((poles) => (poles || []).map((x) => (x === oldName ? newName : x)));
                    setRefPolesMap((pm) => {
                      const next: any = { ...(pm || {}) };
                      const val = next[oldName] || [];
                      delete next[oldName];
                      next[newName] = val;
                      return next;
                    });
                    setRefSelectedPole(newName);
                  }}
                >
                  Renommer
                </Button>
              </div>

              <Button
                type="button"
                variant="ghost"
                className="h-8 px-2 text-xs btn-ghost-danger"
                disabled={(refPoles || []).length <= 1}
                onClick={async () => {
                  if ((refPoles || []).length <= 1) return;
                  const pole = String(refSelectedPole || "").trim();
                  if (!pole) return;
                  const input = window.prompt(`Supprimer le p√¥le "${pole}" ?

Pour confirmer, tape : B`);
                  if (String(input || "").trim().toUpperCase() !== "B") return;

                  const nextPoles = (refPoles || []).filter((x) => x !== pole);
                  setRefPoles(nextPoles);
                  setRefPolesMap((pm) => {
                    const next: any = { ...(pm || {}) };
                    delete next[pole];
                    return next;
                  });
                  setRefSelectedPole(nextPoles[0] || "");
                }}
              >
                Supprimer ce p√¥le
              </Button>

              <div className="text-[11px] text-neutral-500 dark:text-neutral-300">
                Coche les t√¢ches/activit√©s associ√©es au p√¥le s√©lectionn√©.
              </div>
            </div>
          </div>

          <div className="rounded-xl border border-neutral-200 dark:border-sky-400/35 bg-white dark:bg-[var(--night-surface)] p-3 space-y-3">
            <div className="flex items-center justify-between gap-2">
              <div className="text-xs font-semibold text-neutral-900 dark:text-neutral-200">T√¢ches / Activit√©s</div>
              <div className="flex items-center gap-2">
                <Button
                  type="button"
                  variant="ghost"
                  className="h-8 px-2 text-xs"
                  onClick={() => {
                    const tasks = sortByTaskNumber(Object.keys(refTcMap || {}));
                    setRefPolesMap((p) => ({ ...p, [refSelectedPole]: tasks }));
                  }}
                >
                  Tout cocher
                </Button>
                <Button
                  type="button"
                  variant="ghost"
                  className="h-8 px-2 text-xs"
                  onClick={() => setRefPolesMap((p) => ({ ...p, [refSelectedPole]: [] }))}
                >
                  Tout d√©cocher
                </Button>
              </div>
            </div>

            {sortByTaskNumber(Object.keys(refTcMap || {})).length === 0 ? (
              <div className="text-xs text-neutral-600 dark:text-neutral-300">
                Ajoute d‚Äôabord des t√¢ches dans l‚Äôonglet ‚ÄúT√¢ches‚Äù, puis reviens ici pour les associer √† un p√¥le.
              </div>
            ) : (
              <div className="grid grid-cols-1 sm:grid-cols-2 gap-2">
                {sortByTaskNumber(Object.keys(refTcMap || {})).map((t) => {
                  const checked = (refPolesMap?.[refSelectedPole] || []).includes(t);
                  return (
                    <label key={t} className="flex items-start gap-2 text-xs text-neutral-800 dark:text-neutral-200">
                      <input
                        type="checkbox"
                        className="mt-0.5"
                        checked={checked}
                        onChange={() => {
                          setRefPolesMap((p) => {
                            const cur = p?.[refSelectedPole] || [];
                            const next = checked ? cur.filter((x) => x !== t) : [...cur, t];
                            return { ...p, [refSelectedPole]: __dedupe(next) };
                          });
                        }}
                      />
                      <span>{t}</span>
                    </label>
                  );
                })}
              </div>
            )}
          </div>
        </div>
      </TabsContent>

      {/* T√ÇCHES */}
      <TabsContent value="taches" className="mt-3">
        <div className="grid grid-cols-1 sm:grid-cols-[280px_1fr] gap-3">
          <div className="rounded-xl border border-neutral-200 dark:border-sky-400/35 bg-white dark:bg-[var(--night-surface)] p-3 space-y-2">
            <div className="text-xs font-semibold text-neutral-900 dark:text-neutral-200">Liste des t√¢ches</div>

            {sortByTaskNumber(Object.keys(refTcMap || {})).map((t) => (
              <button
                key={t}
                type="button"
                onClick={() => {
                  setRefSelectedTask(t);
                  setRefFeedback(null);
                }}
                className={classNames("list-select-btn", refSelectedTask === t && "is-selected")}
              >
                {t}
              </button>
            ))}

            <div className="pt-2 border-t border-neutral-200 dark:border-sky-400/35 space-y-2">
              <Input
                placeholder="Nouvelle t√¢che‚Ä¶ (Entr√©e)"
                className="h-9 text-xs bg-white dark:bg-[var(--night-panel)]"
                onKeyDown={(e) => {
                  if (e.key !== "Enter") return;
                  const v = (e.currentTarget.value || "").trim();
                  if (!v) return;
                  setRefTcMap((p) => ({ ...p, [v]: p[v] ?? [] }));
                  e.currentTarget.value = "";
                }}
              />
              <div className="text-[11px] text-neutral-500 dark:text-neutral-300">
                Astuce : une t√¢che = une cl√© dans la structure <span className="font-mono">tcMap</span>.
              </div>
            </div>
          </div>

          <div className="rounded-xl border border-neutral-200 dark:border-sky-400/35 bg-white dark:bg-[var(--night-surface)] p-3 space-y-3">
            {!refSelectedTask ? (
              <div className="text-xs text-neutral-600 dark:text-neutral-300">S√©lectionne une t√¢che √† gauche.</div>
            ) : (
              <>
                <div className="text-xs font-semibold text-neutral-900 dark:text-neutral-200">Renommer la t√¢che</div>
                <div className="flex items-center gap-2">
                  <Input
                    value={refRenameTaskValue}
                    onChange={(e) => setRefRenameTaskValue(e.target.value)}
                    className="h-9 text-xs bg-white dark:bg-[var(--night-panel)]"
                  />
                  <Button
                    type="button"
                    className="h-9 px-3 text-xs"
                    onClick={() => {
                      const oldName = refSelectedTask;
                      const newName = String(refRenameTaskValue || "").trim();
                      if (!oldName || !newName || newName === oldName) return;

                      setRefTcMap((p) => {
                        if ((p as any)[newName]) return p; // ne pas √©craser
                        const next: any = { ...p };
                        next[newName] = next[oldName] || [];
                        delete next[oldName];
                        return next;
                      });
                      // Met aussi √† jour les p√¥les (si la t√¢che √©tait coch√©e)
                      setRefPolesMap((p) => {
                        const next: PolesMap = { ...p };
                        for (const pole of refPoles) {
                          const arr = next[pole] || [];
                          next[pole] = arr.map((t) => (t === oldName ? newName : t));
                        }
                        return next;
                      });
                      setRefSelectedTask(newName);
                    }}
                  >
                    Renommer
                  </Button>
                </div>

                <div className="pt-2 border-t border-neutral-200 dark:border-sky-400/35 space-y-3">
                  <div className="flex items-center justify-between gap-2">
                    <div className="text-xs font-semibold text-neutral-900 dark:text-neutral-200">Comp√©tences de la t√¢che</div>
                    <div className="flex items-center gap-2">
                      <Button
                        type="button"
                        variant="ghost"
                        className="h-8 px-2 text-xs"
                        onClick={() => {
                          const t = refSelectedTask;
                          if (!t) return;
                          setRefTcMap((p) => ({ ...p, [t]: [...refAllCompetences] }));
                        }}
                        disabled={refAllCompetences.length === 0}
                      >
                        Tout cocher
                      </Button>
                      <Button
                        type="button"
                        variant="ghost"
                        className="h-8 px-2 text-xs"
                        onClick={() => {
                          const t = refSelectedTask;
                          if (!t) return;
                          setRefTcMap((p) => ({ ...p, [t]: [] }));
                        }}
                        disabled={refAllCompetences.length === 0}
                      >
                        Tout d√©cocher
                      </Button>
                    </div>
                  </div>

                  {refAllCompetences.length === 0 ? (
                    <div className="text-xs text-neutral-600 dark:text-neutral-300">
                      Ajoute d‚Äôabord des comp√©tences dans l‚Äôonglet <span className="font-semibold">Comp√©tences</span>.
                    </div>
                  ) : (
                    <div className="grid grid-cols-1 sm:grid-cols-2 gap-2">
                      {refAllCompetences.map((c) => {
                        const on = (refTcMap[refSelectedTask] || []).includes(c);
                        return (
                          <label key={c} className="flex items-center gap-2 text-xs text-neutral-800 dark:text-neutral-200">
                            <input
                              type="checkbox"
                              checked={on}
                              onChange={() => {
                                setRefTcMap((p) => {
                                  const cur = p[refSelectedTask] || [];
                                  const next = on ? cur.filter((x) => x !== c) : [...cur, c];
                                  return { ...p, [refSelectedTask]: next };
                                });
                              }}
                            />
                            <span>{c}</span>
                          </label>
                        );
                      })}
                    </div>
                  )}
                </div>

                <div className="pt-2 border-t border-neutral-200 dark:border-sky-400/35 flex items-center gap-2">
                  <Button
                    type="button"
                    variant="ghost"
                    className="h-9 px-3 text-xs btn-ghost-danger"
                    onClick={() => {
                      const t = refSelectedTask;
                      if (!t) return;
                      setRefTcMap((p) => {
                        const next: any = { ...p };
                        delete next[t];
                        return next;
                      });
                      setRefPolesMap((p) => {
                        const next: PolesMap = { ...p };
                        for (const pole of refPoles) {
                          next[pole] = (next[pole] || []).filter((x) => x !== t);
                        }
                        return next;
                      });
                      setRefSelectedTask(null);
                    }}
                  >
                    Supprimer la t√¢che
                  </Button>
                </div>
              </>
            )}
          </div>

        </div>
      </TabsContent>

      {/* COMP√âTENCES */}
      <TabsContent value="competences" className="mt-3">
        <div className="grid grid-cols-1 sm:grid-cols-[280px_1fr] gap-3">
          <div className="rounded-xl border border-neutral-200 dark:border-sky-400/35 bg-white dark:bg-[var(--night-surface)] p-3 space-y-2">
            <div className="text-xs font-semibold text-neutral-900 dark:text-neutral-200">Liste des comp√©tences</div>

            {refAllCompetences.map((c) => (
              <button
                key={c}
                type="button"
                onClick={() => {
                  setRefSelectedComp(c);
                  setRefSelectedItem(null);
                  setRefFeedback(null);
                }}
                className={classNames("list-select-btn", refSelectedComp === c && "is-selected")}
              >
                {c}
              </button>
            ))}

            <div className="pt-2 border-t border-neutral-200 dark:border-sky-400/35 space-y-2">
              <Input
                placeholder="Nouvelle comp√©tence‚Ä¶ (Entr√©e)"
                className="h-9 text-xs bg-white dark:bg-[var(--night-panel)]"
                onKeyDown={(e) => {
                  if (e.key !== "Enter") return;
                  const v = (e.currentTarget.value || "").trim();
                  if (!v) return;

                  setRefCritResDB((p) => (p[v] ? p : { ...p, [v]: {} }));
                  e.currentTarget.value = "";
                }}
              />
              <div className="text-[11px] text-neutral-500 dark:text-neutral-300">
                Astuce : une comp√©tence = une cl√© dans <span className="font-mono">critResDB</span>.
              </div>
            </div>
          </div>

          <div className="rounded-xl border border-neutral-200 dark:border-sky-400/35 bg-white dark:bg-[var(--night-surface)] p-3 space-y-3">
            {!refSelectedComp ? (
              <div className="text-xs text-neutral-600 dark:text-neutral-300">S√©lectionne une comp√©tence.</div>
            ) : (
              <>
                <div className="text-xs font-semibold text-neutral-900 dark:text-neutral-200">Renommer la comp√©tence</div>
                <div className="flex items-center gap-2">
                  <Input
                    value={refRenameCompValue}
                    onChange={(e) => setRefRenameCompValue(e.target.value)}
                    className="h-9 text-xs bg-white dark:bg-[var(--night-panel)]"
                  />
                  <Button
                    type="button"
                    className="h-9 px-3 text-xs"
                    onClick={() => {
                      const oldComp = refSelectedComp;
                      const newComp = String(refRenameCompValue || "").trim();
                      if (!oldComp || !newComp || newComp === oldComp) return;

                      setRefTcMap((p) => {
                        const next: TCMap = {};
                        for (const [t, arr] of Object.entries(p)) {
                          next[t] = __dedupe((arr || []).map((x) => (x === oldComp ? newComp : x)));
                        }
                        return next;
                      });

                      setRefCritResDB((p) => {
                        if ((p as any)[newComp]) return p; // ne pas √©craser
                        const next: any = { ...p };
                        next[newComp] = next[oldComp] || {};
                        delete next[oldComp];
                        return next;
                      });

                      setRefSelectedComp(newComp);
                      setRefSelectedItem(null);
                    }}
                  >
                    Renommer
                  </Button>
                </div>

                <div className="pt-2 border-t border-neutral-200 dark:border-sky-400/35">
                  <div className="text-xs font-semibold text-neutral-900 dark:text-neutral-200">√ätre capable de‚Ä¶ (items)</div>
                  <div className="text-[11px] text-neutral-500 dark:text-neutral-300">
                    {Object.keys((refCritResDB[refSelectedComp] || {}) as any).length} item(s)
                  </div>

                  <Button
                    type="button"
                    variant="ghost"
                    className="h-9 px-3 text-xs mt-2 btn-ghost-danger"
                    onClick={() => {
                      const comp = refSelectedComp;
                      if (!comp) return;

                      // supprime comp√©tence partout (tcMap + critResDB)
                      setRefTcMap((p) => {
                        const next: TCMap = {};
                        for (const [t, arr] of Object.entries(p)) {
                          next[t] = (arr || []).filter((x) => x !== comp);
                        }
                        return next;
                      });

                      setRefCritResDB((p) => {
                        const next: any = { ...p };
                        delete next[comp];
                        return next;
                      });

                      setRefSelectedComp(null);
                      setRefSelectedItem(null);
                    }}
                  >
                    Supprimer la comp√©tence
                  </Button>
                </div>
              </>
            )}
          </div>
        </div>
      </TabsContent>
      {/* √äTRE CAPABLE DE */}
      <TabsContent value="capacites" className="mt-3">
        <div className="rounded-xl border border-neutral-200 dark:border-sky-400/35 bg-white dark:bg-[var(--night-surface)] p-3 space-y-3">
          <div className="grid grid-cols-1 sm:grid-cols-[240px_1fr] gap-3 items-start">
            <div className="space-y-2">
              <div className="text-xs font-semibold text-neutral-900 dark:text-neutral-200">Comp√©tence</div>
              <select
                className="w-full rounded-md border border-neutral-200 bg-white px-3 py-2 text-xs text-neutral-900 dark:border-sky-400/35 dark:bg-[var(--night-panel)] dark:text-neutral-200"
                value={refSelectedComp || ""}
                onChange={(e) => {
                  const v = e.target.value || "";
                  setRefSelectedComp(v || null);
                  setRefSelectedItem(null);
                }}
              >
                <option value="">‚Äî Choisir ‚Äî</option>
                {refAllCompetences.map((c) => (
                  <option key={c} value={c}>{c}</option>
                ))}
              </select>

              {refSelectedComp && (
                <Input
                  placeholder="Nouvel ‚Äò√™tre capable de‚Ä¶‚Äô (Entr√©e)"
                  className="h-9 text-xs bg-white dark:bg-[var(--night-panel)]"
                  onKeyDown={(e) => {
                    if (e.key !== "Enter") return;
                    const v = (e.currentTarget.value || "").trim();
                    if (!v) return;
                    const comp = refSelectedComp;

                    setRefCritResDB((p) => {
                      const compObj = (p as any)[comp] || {};
                      if (compObj[v]) return p;
                      return {
                        ...(p as any),
                        [comp]: {
                          ...compObj,
                          [v]: { resultats: [], exigences: [] },
                        },
                      } as any;
                    });

                    e.currentTarget.value = "";
                  }}
                />
              )}
            </div>

            <div className="space-y-2">
              <div className="text-xs font-semibold text-neutral-900 dark:text-neutral-200">Liste</div>
              {!refSelectedComp ? (
                <div className="text-xs text-neutral-600 dark:text-neutral-300">Choisis une comp√©tence.</div>
              ) : (
                <div className="space-y-2">
                  {Object.keys((refCritResDB[refSelectedComp] || {}) as any).map((it) => (
                    <div key={it} className="flex items-center justify-between gap-2 rounded-lg border border-neutral-200 dark:border-sky-400/35 bg-white dark:bg-[var(--night-panel)] px-2 py-2">
                      <button
                        type="button"
                        className="text-left text-xs flex-1"
                        onClick={() => setRefSelectedItem(it)}
                      >
                        {it}
                      </button>
                      <Button
                        type="button"
                        variant="ghost"
                        className="h-8 px-2 text-xs"
                        onClick={() => {
                          const comp = refSelectedComp;
                          if (!comp) return;

                          setRefCritResDB((p) => {
                            const nextComp: any = { ...((p as any)[comp] || {}) };
                            delete nextComp[it];
                            return { ...(p as any), [comp]: nextComp } as any;
                          });

                          if (refSelectedItem === it) setRefSelectedItem(null);
                        }}
                      >
                        <Trash2 className="w-4 h-4" />
                      </Button>
                    </div>
                  ))}
                </div>
              )}

              {refSelectedComp && refSelectedItem ? (
                <div className="pt-2 border-t border-neutral-200 dark:border-sky-400/35">
                  <div className="text-xs font-semibold text-neutral-900 dark:text-neutral-200">Renommer ‚Äú√ätre capable de‚Ä¶‚Äù</div>
                  <div className="flex items-center gap-2 mt-2">
                    <Input
                      value={refRenameItemValue}
                      onChange={(e) => setRefRenameItemValue(e.target.value)}
                      className="h-9 text-xs bg-white dark:bg-[var(--night-panel)]"
                    />
                    <Button
                      type="button"
                      className="h-9 px-3 text-xs"
                      onClick={() => {
                        const comp = refSelectedComp;
                        const oldItem = refSelectedItem;
                        const newItem = String(refRenameItemValue || "").trim();
                        if (!comp || !oldItem || !newItem || newItem === oldItem) return;

                        setRefCritResDB((p) => {
                          const compObj: any = { ...((p as any)[comp] || {}) };
                          if (compObj[newItem]) return p; // ne pas √©craser
                          compObj[newItem] = compObj[oldItem];
                          delete compObj[oldItem];
                          return { ...(p as any), [comp]: compObj } as any;
                        });

                        setRefSelectedItem(newItem);
                      }}
                    >
                      Renommer
                    </Button>
                  </div>
                </div>
              ) : null}
            </div>
          </div>
        </div>
      </TabsContent>

      {/* CRIT√àRES D'√âVALUATION */}
      <TabsContent value="criteres" className="mt-3">
        <div className="rounded-xl border border-neutral-200 dark:border-sky-400/35 bg-white dark:bg-[var(--night-surface)] p-3 space-y-3">
          <div className="grid grid-cols-1 sm:grid-cols-2 gap-3">
            <div className="space-y-2">
              <div className="text-xs font-semibold text-neutral-900 dark:text-neutral-200">Comp√©tence</div>
              <select
                className="w-full rounded-md border border-neutral-200 bg-white px-3 py-2 text-xs text-neutral-900 dark:border-sky-400/35 dark:bg-[var(--night-panel)] dark:text-neutral-200"
                value={refSelectedComp || ""}
                onChange={(e) => {
                  const v = e.target.value || "";
                  setRefSelectedComp(v || null);
                  setRefSelectedItem(null);
                }}
              >
                <option value="">‚Äî Choisir ‚Äî</option>
                {refAllCompetences.map((c) => (
                  <option key={c} value={c}>{c}</option>
                ))}
              </select>
            </div>

            <div className="space-y-2">
              <div className="text-xs font-semibold text-neutral-900 dark:text-neutral-200">√ätre capable de‚Ä¶</div>
              <select
                className="w-full rounded-md border border-neutral-200 bg-white px-3 py-2 text-xs text-neutral-900 dark:border-sky-400/35 dark:bg-[var(--night-panel)] dark:text-neutral-200"
                value={refSelectedItem || ""}
                onChange={(e) => setRefSelectedItem(e.target.value || null)}
                disabled={!refSelectedComp}
              >
                <option value="">‚Äî Choisir ‚Äî</option>
                {refSelectedComp &&
                  Object.keys((refCritResDB[refSelectedComp] || {}) as any).map((it) => (
                    <option key={it} value={it}>{it}</option>
                  ))}
              </select>
            </div>
          </div>

          {(!refSelectedComp || !refSelectedItem) ? (
            <div className="text-xs text-neutral-600 dark:text-neutral-300">Choisis une comp√©tence et un item.</div>
          ) : (
            (() => {
              const node = (refCritResDB[refSelectedComp]?.[refSelectedItem] as any) || { resultats: [], exigences: [] };

              const joinLines = (arr: string[]) => (arr || []).join("\n");
              const splitLines = (txt: string) =>
                (txt || "")
                  .split("\n")
                  .map((s) => s.trim())
                  .filter(Boolean);

              return (
                <div className="grid grid-cols-1 sm:grid-cols-2 gap-3">
                  <div className="space-y-2">
                    <div className="text-xs font-semibold text-neutral-900 dark:text-neutral-200">R√©sultats (1 par ligne)</div>
                    <Textarea
                      className="min-h-[240px] text-xs bg-white dark:bg-[var(--night-panel)]"
                      value={joinLines(node.resultats)}
                      onChange={(e) => {
                        const lines = splitLines(e.target.value);
                        setRefCritResDB((p) => ({
                          ...(p as any),
                          [refSelectedComp]: {
                            ...((p as any)[refSelectedComp] || {}),
                            [refSelectedItem]: {
                              ...(((p as any)[refSelectedComp]?.[refSelectedItem]) || { resultats: [], exigences: [] }),
                              resultats: lines,
                            },
                          },
                        } as any));
                      }}
                    />
                  </div>

                  <div className="space-y-2">
                    <div className="text-xs font-semibold text-neutral-900 dark:text-neutral-200">Exigences (1 par ligne)</div>
                    <Textarea
                      className="min-h-[240px] text-xs bg-white dark:bg-[var(--night-panel)]"
                      value={joinLines(node.exigences)}
                      onChange={(e) => {
                        const lines = splitLines(e.target.value);
                        setRefCritResDB((p) => ({
                          ...(p as any),
                          [refSelectedComp]: {
                            ...((p as any)[refSelectedComp] || {}),
                            [refSelectedItem]: {
                              ...(((p as any)[refSelectedComp]?.[refSelectedItem]) || { resultats: [], exigences: [] }),
                              exigences: lines,
                            },
                          },
                        } as any));
                      }}
                    />
                  </div>
                </div>
              );
            })()
          )}

          <div className="pt-2 border-t border-neutral-200 dark:border-sky-400/35 flex items-center gap-2">
            <Button
              type="button"
              variant="ghost"
              className="h-9 px-3 text-xs btn-ghost-danger"
              onClick={async () => {
                const ok = await confirm("R√©initialiser le r√©f√©rentiel (retour au r√©f√©rentiel par d√©faut) ?", { title: "Mon r√©f√©rentiel", kind: "warning" } as any);
                if (!ok) return;

                setRefFeedback(null);
                setRefSwitching(true);
                try {
                  await clearReferentielCapFromStore();

                  // Met le catalogue en "Base" (sans supprimer les r√©f√©rentiels sauvegard√©s)
                  let cat = await loadReferentielCapCatalog();
                  if (!cat) cat = referentielCapCatalog ?? { schema: "referentiels_cap_catalog_v1", activeId: null, items: [] };
                  const nextCat = { ...cat, activeId: null };
                  setReferentielCapCatalog(nextCat);
                  setReferentielCapActiveId(null);
                  await saveReferentielCapCatalog(nextCat);

                  // Charge les seeds /data
                  const base = await loadBaseReferentielCap();
                  setTcMap(base.tcMap);
                  setCritResDB(base.critResDB);
                  setReferentielCapName("R√©f√©rentiel de base");

                  // R√©initialise le brouillon
                  setRefName("");
                  setRefTcMap(JSON.parse(JSON.stringify(base.tcMap || {})));
                  setRefCritResDB(JSON.parse(JSON.stringify(base.critResDB || {})));

                  setRefFeedback({ type: "success", message: "R√©f√©rentiel par d√©faut charg√©." });
                } finally {
                  setRefSwitching(false);
                }
              }}
            >
              R√©initialiser (par d√©faut)
            </Button>
          </div>
        </div>
      </TabsContent>
    </Tabs>
  </div>
      </div>
    </div>
  </div>
</Drawer>

{activeView === "evaluation" ? (

  <Tabs
    value={step === "params" ? "params" : step === 1 ? "step1" : step === 2 ? "step2" : step === 3 ? "step3" : "step4"}
    onValueChange={(v) =>
      setStep(
        v === "params" ? "params" :
        v === "step1" ? 1 :
        v === "step2" ? 2 :
        v === "step3" ? 3 : 4
      )
    }
  >

{/* üßÆ VUE CREER UN DEVOIR */}
<section className="space-y-4 px-2 sm:px-3 lg:px-4 pt-2 pb-12">
  {/* ‚úÖ BANDEAU FIXE : √©tapes + titre du devoir + enregistrer sur la m√™me ligne */}
  <div className="sticky top-[67px] z-50 backdrop-blur border-b border-black dark:border-sky-400/35 bg-white/70 dark:bg-[var(--night-panel)]/70 dark:bg-[var(--night-panel)]/95 dark:border-[var(--night-border-strong)] dark:text-white night-banner">
    <div className="flex flex-col gap-4 sm:flex-row sm:items-end py-2 px-2 sm:px-4 lg:px-6">
      {/* √âtapes (scroll horizontal si besoin, pour √©viter le retour √† la ligne) */}
      <div className="flex-1 min-w-0">
        <div className="overflow-x-auto overscroll-x-contain">
          <div className="suivi-tabs inline-flex rounded-full border border-neutral-200 dark:border-sky-400/35 bg-neutral-50 dark:bg-[var(--night-surface)] p-1 whitespace-nowrap">
            {(() => {
              const current =
                step === "params" ? "params" :
                step === 1 ? "step1" :
                step === 2 ? "step2" :
                step === 3 ? "step3" : "step4";

              const tabBtn = (opts: {
                value: "params" | "step1" | "step2" | "step3" | "step4";
                icon: string;
                short: string;
                long?: string;
                disabled?: boolean;
                onClick?: () => void;
              }) => {
                const active = current === opts.value;
                const disabled = !!opts.disabled;

                return (
                  <button
                    key={opts.value}
                    type="button"
                    role="tab"
                    aria-selected={active}
                    aria-disabled={disabled}
                    disabled={disabled}
                    onClick={() => {
                      if (disabled) return;
                      if (opts.onClick) opts.onClick();
                      setStep(
                        opts.value === "params" ? "params" :
                        opts.value === "step1" ? 1 :
                        opts.value === "step2" ? 2 :
                        opts.value === "step3" ? 3 : 4
                      );
                    }}
                    className={classNames(
                      "suivi-btn inline-flex items-center rounded-full transition",
                      active
                        ? "bg-neutral-900 text-white"
                        : "text-neutral-700 dark:text-neutral-300 hover:bg-amber-100/70 dark:hover:bg-[var(--night-hover)]",
                      disabled && "opacity-50 pointer-events-none"
                    )}
                  >
                    <span className="suivi-icon" aria-hidden="true">{opts.icon}</span>
                    {/* m√™me logique mobile/desktop que tes TabsTrigger */}
                    <span className="suivi-label sm:hidden">{opts.short}</span>
                    <span className="suivi-label hidden sm:inline">{opts.long ?? opts.short}</span>
                  </button>
                );
              };

              return (
                <>
                  {tabBtn({
                    value: "params",
                    icon: "‚öôÔ∏è",
                    short: "PARAM.",
                    long: "Param√®tres du devoir",
                  })}

                  {tabBtn({
                    value: "step1",
                    icon: "‚úÖ",
                    short: "T√¢ches",
                    long: "T√¢ches",
                  })}

                  {tabBtn({
                    value: "step2",
                    icon: "üéØ",
                    short: "COMP.",
                    long: "Comp√©tences",
                    disabled: !activeTask,
                  })}

                  {tabBtn({
                    value: "step3",
                    icon: "üìã",
                    short: "EXIG.",
                    long: "Exigences",
                    disabled: selectedCriteres.length === 0,
                  })}

                  {tabBtn({
                    value: "step4",
                    icon: "üìù",
                    short: "√âVAL.",
                    long: "√âvaluation",
                    disabled: selectedCriteres.length === 0,
                  })}
                </>
              );
            })()}
          </div>
        </div>
      </div>

        {/* Titre (centr√© entre la fin des √©tapes et le bouton enregistrer) */}
  <div className="flex-1 min-w-0 text-center px-2">
    <div className="text-xl sm:text-2xl font-semibold truncate mx-auto">
            {title?.trim() ? title : "Devoir sans titre"}
          </div>
        </div>

      {/* Actions */}
      <div className="shrink-0">
        <Button
          className="isolate gap-2 h-8 px-3 border border-neutral-200 dark:border-sky-400/35 !bg-green-600 !text-white hover:!bg-green-700 whitespace-nowrap"
          onClick={async () => {
            // ‚úÖ garde exactement ton code actuel (enregistrer)
          }}
        >
          üíæ ENREGISTRER
        </Button>
      </div>
    </div>
  </div>

  {/* üìÑ CADRE DE PAGE : identique NOTATION/SUIVI */}
  <div className="mt-4 mx-6 sm:mx-6 lg:mx-auto lg:max-w-8xl rounded-2xl border border-neutral-200 dark:border-sky-400/35 bg-white dark:bg-[var(--night-panel)] shadow-sm overflow-hidden">

{/* PARAM√àTRE DU DEVOIR */}
<TabsContent
  value="params"
  className="mt-2 px-4 sm:px-6 lg:px-8 h-[calc(100vh-180px)] overflow-hidden"
>
  <div className="h-full overflow-y-auto overscroll-contain pr-2 pt-4">
    <div className="max-w-6xl mx-auto">
      <div className="rounded-xl border border-neutral-200 dark:border-sky-400/35 overflow-hidden bg-white dark:bg-[var(--night-surface)]">
        <div className="px-4 py-3 border-b border-neutral-200 dark:border-sky-400/35 font-semibold text-neutral-900 dark:text-neutral-300">
          Param√®tres du devoir
        </div>

        <div className="p-4 bg-neutral-50 dark:bg-[var(--night-base)]">
          <div className="grid grid-cols-1 lg:grid-cols-2 gap-4">
            {/* Colonne gauche */}
            <div className="space-y-4">
              <div className="space-y-2">
                <Label htmlFor="title" className="text-neutral-900 dark:!text-neutral-50">
                  Titre
                </Label>
                <Input
                  id="title"
                  value={title}
                  onChange={(e) => setTitle(e.target.value)}
                  placeholder="Ex: Ma√ßonnerie ‚Äì Enduit vertical"
                  className="bg-white text-neutral-900 border-neutral-200 dark:!bg-[var(--night-panel)] dark:!text-neutral-50 dark:border-sky-400/35 dark:placeholder:text-neutral-400"
                />
              </div>

              <div className="space-y-2">
                <Label htmlFor="project" className="text-neutral-900 dark:!text-neutral-50">
                  Projet
                </Label>
                <Input
                  id="project"
                  value={project}
                  onChange={(e) => setProject(e.target.value)}
                  placeholder="Ex : Construction pavillon Hollander, chantier X..."
                  className="bg-white text-neutral-900 border-neutral-200 dark:!bg-[var(--night-panel)] dark:!text-neutral-50 dark:border-sky-400/35 dark:placeholder:text-neutral-400"
                />
              </div>

              <div className="space-y-2">
                <Label htmlFor="professionalSituation" className="text-neutral-900 dark:!text-neutral-50">
                  Situation professionnelle
                </Label>
                <Input
                  id="professionalSituation"
                  value={professionalSituation}
                  onChange={(e) => setProfessionalSituation(e.target.value)}
                  placeholder="Ex : Chantier r√©el, atelier √©cole, plateau technique..."
                  className="bg-white text-neutral-900 border-neutral-200 dark:!bg-[var(--night-panel)] dark:!text-neutral-50 dark:border-sky-400/35 dark:placeholder:text-neutral-400"
                />
              </div>

              <div className="space-y-2">
                <Label htmlFor="evaluator" className="text-neutral-900 dark:!text-neutral-50">
                  √âvaluateur
                </Label>
                <Input
                  id="evaluator"
                  value={evaluator}
                  onChange={(e) => setEvaluator(e.target.value)}
                  placeholder="Nom de l'√©valuateur"
                  className="bg-white text-neutral-900 border-neutral-200 dark:!bg-[var(--night-panel)] dark:!text-neutral-50 dark:border-sky-400/35 dark:placeholder:text-neutral-400"
                />
              </div>

              <div className="space-y-2">
                <Label className="text-neutral-900 dark:!text-neutral-50">Groupe</Label>
                <Select value={group} onValueChange={setGroup}>
                  <SelectTrigger className="bg-white text-neutral-900 border-neutral-200 dark:!bg-[var(--night-panel)] dark:!text-neutral-50 dark:border-sky-400/35">
                    <SelectValue placeholder="S√©lectionner" />
                  </SelectTrigger>
                  <SelectContent className="bg-white dark:bg-[var(--night-panel)] border border-neutral-200 dark:border-sky-400/35 text-neutral-900 dark:!text-neutral-50">
                    {/* Groupes issus des classes enregistr√©es dans eleves.json */}
                    {classGroups.map((classe) => (
                      <SelectItem key={classe.id} value={classe.name}>
                        {classe.name}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              </div>
            </div>

            {/* Colonne droite */}
            <div className="space-y-4">
              <div className="space-y-2">
<label className="text-neutral-900 dark:!text-neutral-50">
  Semestre de cette √©valuation
</label>

<select
  className="w-full rounded-md border border-neutral-200 bg-white px-3 py-2 text-sm text-neutral-900
             dark:border-sky-400/35 dark:bg-[var(--night-panel)] dark:text-neutral-300"
  value={evaluationSemester}
  onChange={(e) => setEvaluationSemester(e.target.value as SemesterKey)}
>
  <option value="Ne pas utiliser de semestre">Ne pas l‚Äôutiliser dans un semestre</option>
  <option value="S1">Semestre 1</option>
  <option value="S2">Semestre 2</option>
</select>

                <p className="text-[11px] text-neutral-500 dark:text-neutral-300">
                  Ce choix sera enregistr√© dans la base et utilis√© dans le suivi des comp√©tences.
                </p>
              </div>

              <div className="space-y-2">
<label className="text-neutral-900 dark:!text-neutral-50">
  Niveau d&apos;√©valuation
</label>

<select
  className="w-full rounded-md border border-neutral-200 bg-white px-3 py-2 text-sm text-neutral-900
             dark:border-sky-400/35 dark:bg-[var(--night-panel)] dark:text-neutral-300"
  value={evaluationCategory}
  onChange={(e) => setEvaluationCategory(e.target.value as EvaluationCategory)}
>
  <option value="D√©couverte professionnel">D√©couverte professionnel</option>
  <option value="Apprentissage des fondamentaux">Apprentissage des fondamentaux</option>
  <option value="Professionnalisation de niveau 3">Professionnalisation de niveau 3</option>
  <option value="Professionnalisation de niveau 4">Professionnalisation de niveau 4</option>
</select>
              </div>

              <div className="space-y-2">
                <Label htmlFor="objs" className="text-neutral-900 dark:!text-neutral-50">
                  Objectifs
                </Label>
                <Textarea
                  id="objs"
                  rows={5}
                  value={objectives}
                  onChange={(e) => setObjectives(e.target.value)}
                  placeholder="Objectifs p√©dagogiques de l'√©valuation"
                  className="bg-white text-neutral-900 border-neutral-200 dark:!bg-[var(--night-panel)] dark:!text-neutral-50 dark:border-sky-400/35 dark:placeholder:text-neutral-400"
                />
              </div>

              <div className="space-y-2">
                <Label className="text-neutral-900 dark:!text-neutral-50">Logo (PNG/JPG)</Label>
                <div className="flex items-center gap-3">
                  <Input
                    type="file"
                    accept="image/*"
                    onChange={(e) => {
                      const f = e.target.files?.[0];
                      if (f) onLogoUpload(f);
                    }}
                    className="bg-white text-neutral-900 border-neutral-200 dark:!bg-[var(--night-panel)] dark:!text-neutral-50 dark:border-sky-400/35 file:mr-3 file:px-2 file:py-1 file:rounded-md file:border-0 file:bg-neutral-100 file:text-neutral-700 dark:file:bg-[var(--night-panel)] dark:file:text-neutral-100"
                  />
                  <ImageIcon className="w-5 h-5 text-neutral-500 dark:text-neutral-300" />
                </div>
                {logoDataUrl && (
                  <div className="mt-2">
                    <img src={logoDataUrl} alt="Logo" className="h-16 object-contain" />
                  </div>
                )}
              </div>
            </div>
          </div>
        </div>
      </div>

<div className="mt-4 rounded-xl border border-neutral-200 dark:border-sky-400/35 bg-white dark:bg-[var(--night-surface)] keep-light p-4 shadow-sm">
  <div className="flex items-start justify-between gap-3">
    <div>
      <div className="text-sm font-semibold text-neutral-900 dark:text-neutral-100">CCF ‚Äî Fiches d‚Äô√©valuation (par √©l√®ve)</div>
      <div className="text-[11px] text-neutral-500 dark:text-neutral-300">
        S√©lectionnez une classe, un √©l√®ve et une √©preuve, puis renseignez les niveaux de ma√Ætrise (N/O / Rouge / Orange / Vert clair / Vert). La note /20 est calcul√©e selon les pond√©rations du livret.
      </div>
    </div>
  </div>

  {!ccfSelectedStudentName ? (
    <div className="mt-4 text-sm text-neutral-600 dark:text-neutral-300">
      S√©lectionnez d‚Äôabord une classe et un √©l√®ve.
    </div>
  ) : (
    (() => {
      const sheet = getCcfSheet(ccfSelectedStudentName, ccfEpKey);
      const computed = computeCcfTotal(ccfSelectedStudentName, ccfEpKey);

      return (
        <>
          
{/* Param√®tres de l'√©preuve ‚Äî panneau ouvrable sans pousser l'√©valuation */}
<div className="mt-4 relative">
  <div className="flex items-center justify-end gap-3 rounded-xl border border-neutral-200 dark:border-sky-400/35 bg-neutral-50/60 dark:bg-[var(--night-base)] px-3 py-2">
    <Button
      type="button"
      variant="outline"
      size="sm"
      onClick={() => setCcfEpParamsOpen((v) => !v)}
      className="h-8 gap-2"
    >
      <Settings2 className="h-4 w-4" />
      <span>Param√®tres de l‚Äô√©preuve</span>
      <ChevronRight
        className={classNames(
          "h-4 w-4 transition-transform",
          ccfEpParamsOpen ? "rotate-90" : "rotate-0"
        )}
      />
    </Button>
  </div>

  {ccfEpParamsOpen && (
    <div className="absolute right-0 top-full mt-2 w-full md:w-[560px] z-[60] rounded-xl border border-neutral-200 dark:border-sky-400/35 bg-white dark:bg-[var(--night-surface)] keep-light p-3 shadow-lg">
      <div className="grid grid-cols-1 md:grid-cols-3 gap-3">
        <div className="space-y-1">
          <Label className="text-xs">Date</Label>
          <Input
            type="date"
            value={sheet.meta?.date ?? ""}
            onChange={(e) => {
              setCcfSheet(ccfSelectedStudentName, ccfEpKey, {
                ...sheet,
                meta: { ...(sheet.meta || {}), date: e.target.value },
              });
            }}
          />
        </div>
        <div className="space-y-1 md:col-span-2">
          <Label className="text-xs">Contexte / lieu</Label>
          <Input
            value={sheet.meta?.contexte ?? ""}
            onChange={(e) => {
              setCcfSheet(ccfSelectedStudentName, ccfEpKey, {
                ...sheet,
                meta: { ...(sheet.meta || {}), contexte: e.target.value },
              });
            }}
            placeholder="Ex: Atelier / entreprise / chantier‚Ä¶"
          />
        </div>
      </div>

      <div className="mt-3 grid grid-cols-1 md:grid-cols-3 gap-3 items-end">
        <div className="md:col-span-2" />
        <div className="space-y-1">
          <Label className="text-xs">Note propos√©e au jury</Label>
          <Input
            value={sheet.meta?.noteProposee ?? ""}
            onChange={(e) => {
              setCcfSheet(ccfSelectedStudentName, ccfEpKey, {
                ...sheet,
                meta: { ...(sheet.meta || {}), noteProposee: e.target.value },
              });
            }}
            placeholder="Ex: 14,5"
          />
        </div>
      </div>
    </div>
  )}
</div>

{/* R√©sum√© note ‚Äî toujours visible (laisse la place √† l'√©valuation) */}
          <div className="mt-3 flex flex-col md:flex-row md:items-center md:justify-between gap-2">
            <div className="text-sm">
              <div className="font-semibold text-neutral-900 dark:text-neutral-100">
                Note calcul√©e : {computed.total.toFixed(2)} / 20
              </div>
              <div className="text-[11px] text-neutral-500 dark:text-neutral-300">
                Calcul = somme des notes de comp√©tences (pond√©ration du livret) ‚Äî les items ‚ÄúNON‚Äù ne sont pas pris en compte.
              </div>
            </div>
          </div>

          <div className="mt-4 overflow-x-auto">
            <table className="ccf-table min-w-[980px] w-full text-xs border-collapse">
              <thead>
                <tr className="bg-neutral-50 dark:bg-[var(--night-base)]">
                  <th className="text-left px-2 py-2 border border-neutral-200 dark:border-sky-400/35 w-[110px]">Code</th>
                  <th className="text-left px-2 py-2 border border-neutral-200 dark:border-sky-400/35">Comp√©tence / item</th>
                  <th className="text-left px-2 py-2 border border-neutral-200 dark:border-sky-400/35">Crit√®res</th>
                  <th className="text-right px-2 py-2 border border-neutral-200 dark:border-sky-400/35 w-[90px]">Poids</th>
                  <th className="text-center px-2 py-2 border border-neutral-200 dark:border-sky-400/35 w-[420px]">Niveau</th>
                </tr>
              </thead>
              <tbody>
                {(ccfTemplates?.[ccfEpKey] ?? CCF_TEMPLATES[ccfEpKey]).map((g) => {
                  const gInfo = computed.groupDetails.find((x) => x.code === g.code);
                  return (
                    <React.Fragment key={g.code}>
                      <tr className="bg-white dark:bg-[var(--night-surface)]" style={(g as any).bgColor || (g as any).fontColor ? { backgroundColor: (g as any).bgColor, color: (g as any).fontColor } : undefined}>
                        <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35 font-semibold">{g.code}</td>
                        <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35 font-semibold" colSpan={2}>
                          {g.title}
                          <span className="ml-2 text-[11px] font-normal text-neutral-500 dark:text-neutral-300">
                            ({(g.groupPoints ?? 0).toFixed(2)} pts) ‚Äî Score: {(gInfo?.groupScore ?? 0).toFixed(2)} / {(g.groupPoints ?? 0).toFixed(2)}
                          </span>
                        </td>
                        <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35 text-right">
                          {(g.groupPoints ?? 0).toFixed(2)}
                        </td>
                        <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35" />
                      </tr>

                      {g.items.map((it) => {
                        const current = (sheet.levels[it.code] as CcfLevel | undefined) ?? undefined;
                        const options: CcfLevel[] = ["NON", "0", "1", "2", "3"];
                        return (
                          <tr key={it.code} className="bg-white dark:bg-[var(--night-surface)]" style={(it as any).bgColor || (it as any).fontColor ? { backgroundColor: (it as any).bgColor, color: (it as any).fontColor } : undefined}>
                            <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35">{it.code}</td>
                            <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35">{it.label}</td>
                            <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35">
                              <div className="line-clamp-4 whitespace-pre-wrap">{it.criteria}</div>
                            </td>
                            <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35 text-right">
                              {(it.realWeight ?? 0).toFixed(2)}
                            </td>
                            <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35">
                              <div className="flex items-center justify-center gap-1 flex-wrap">
                                {options.map((opt) => {
                                  const active = current === opt;
                                  return (
                                    <button
                                      key={opt}
                                      type="button"
                                      onClick={() => {
                                        const nextLevels = { ...(sheet.levels || {}) };
                                        nextLevels[it.code] = active ? undefined : opt;
                                        setCcfSheet(ccfSelectedStudentName, ccfEpKey, {
                                          ...sheet,
                                          levels: nextLevels,
                                        });
                                      }}
                                      className={ccfLevelButtonClass(opt, active)}
                                      title={opt === "NON" ? "Non observ√© / d√©j√† √©valu√©" : `Niveau ${opt}/3`}
                                    >
                                      {ccfLevelLabel(opt)}
                                    </button>
                                  );
                                })}
                              </div>
                            </td>
                          </tr>
                        );
                      })}
                    </React.Fragment>
                  );
                })}
              </tbody>
            </table>
          </div>
        </>
      );
    })()
  )}
</div>
    </div>
  </div>
</TabsContent>

{/* STEP 1 */}
<TabsContent
  value="step1"
  className="mt-2 px-4 sm:px-6 lg:px-8 h-[calc(100vh-180px)] overflow-hidden"
>
  {/* zone scrollable interne */}
  <div className="h-full overflow-y-auto overscroll-contain pr-2">
    <div className="grid gap-6 lg:grid-cols-3 pt-4">
      {GROUPS.map((g) => {
      const styles = GROUP_STYLES[g.key];
      const keys = Object.keys(tcMap);
      const tasks = sortByTaskNumber(
        keys.filter((k) => {
          const n = taskNumber(k);
          return n >= g.range[0] && n <= g.range[1];
        })
      );

      return (
        <div key={g.key} className={classNames("shadow-sm border rounded-xl", styles.accentBorder)}>
          <div className={classNames(styles.headerBg, styles.headerText, "rounded-t-xl px-4 py-3 font-semibold text-base")}>
            {g.title}
          </div>

          <div className="p-4 grid gap-2">
            {tasks.length === 0 ? (
              <div className="text-xs text-neutral-500 dark:text-neutral-300 italic">Aucune t√¢che dans ce groupe.</div>
            ) : (
              tasks.map((task) => {
                const isSelected = selectedTasks.includes(task);

                return (
                  <button
                    key={task}
                    type="button"
                    aria-pressed={isSelected}
                    onClick={() => {
                      setSelectedTasks((prev) => {
                        const wasSelected = prev.includes(task);
                        const next = wasSelected ? prev.filter((t) => t !== task) : [...prev, task];

                        // si on s√©lectionne => activeTask = task ; si on d√©s√©lectionne la derni√®re => null
                        setActiveTask(wasSelected ? (next[0] ?? null) : task);

                        return next;
                      });
                    }}
                    className={classNames(
                      "text-left rounded-xl border p-3 transition focus:outline-none focus:ring-2 text-neutral-900 dark:text-neutral-300",
                      isSelected
                        ? classNames(styles.buttonSelected)
                        : classNames("bg-white hover:bg-amber-100/70 dark:bg-[var(--night-surface)]", styles.buttonHover, "border-neutral-200 dark:border-sky-400/35")
                    )}
                  >
                    <div className="text-sm font-medium leading-snug flex items-center gap-2">
                      <span>{task}</span>
                    </div>
                  </button>
                );
              })
            )}
          </div>
        </div>
      );
    })}
  </div>
  </div>
</TabsContent>

 {/* STEP 2 */}
<TabsContent 
value="step2" className="mt-6 px-4 sm:px-6 lg:px-8">
  {(() => {
    const tasksForStep2 =
      selectedTasks && selectedTasks.length > 0
        ? sortByTaskNumber(selectedTasks)
        : activeTask
        ? [activeTask]
        : [];

    if (tasksForStep2.length === 0) {
      return (
        <div className="text-neutral-600 dark:text-neutral-300">
          Choisissez d&apos;abord une t√¢che.
        </div>
      );
    }

    return (
      <div className="space-y-6">
        {tasksForStep2.map((taskLabel) => (
          <section key={taskLabel}>
            {/* üîπ ENCADR√â autour de toute l'activit√© de la t√¢che */}
            <div className="border border-neutral-200 dark:border-sky-400/35/60 rounded-xl bg-white dark:bg-[var(--night-surface)] shadow-sm px-3 py-2 space-y-3">
              {/* En-t√™te de la t√¢che */}
              <div className="flex items-center justify-between">
                <div className="flex items-center gap-2">
                  <button
                    onClick={() => toggleTaskExpanded(taskLabel)}
                    className="h-7 w-7 inline-flex items-center justify-center rounded-md border border-neutral-300 dark:border-sky-400/35 bg-white hover:bg-amber-100/70 dark:bg-[var(--night-surface)] hover:bg-amber-100/70 dark:bg-[var(--night-panel)] focus:outline-none focus:ring-2 focus:ring-neutral-400"
                    aria-label={
                      isTaskExpanded(taskLabel)
                        ? "Fermer la t√¢che"
                        : "Ouvrir la t√¢che"
                    }
                    title={
                      isTaskExpanded(taskLabel)
                        ? "Fermer la t√¢che"
                        : "Ouvrir la t√¢che"
                    }
                    type="button"
                  >
                    <ChevronRight
                      className={classNames(
                        "h-4 w-4 transition-transform",
                        isTaskExpanded(taskLabel) && "rotate-90"
                      )}
                    />
                  </button>

                  <h2 className="text-[12px] sm:text-sm font-semibold text-neutral-900 dark:text-neutral-300">
                    {taskLabel}
                  </h2>
                </div>

                <div className="text-xs sm:text-sm text-neutral-600 dark:text-neutral-300">
                  {(tcMap[taskLabel] ?? []).length} comp√©tence(s)
                </div>
              </div>

              {/* Contenu de la t√¢che : comp√©tences par familles */}
              {isTaskExpanded(taskLabel) && (
                <div className="grid gap-6 xl:grid-cols-4 md:grid-cols-2 grid-cols-1">
                  {(
                    ["C1", "C2", "C3", "C4"] as Array<
                      "C1" | "C2" | "C3" | "C4"
                    >
                  ).map((fam) => {
                    const comps = (tcMap[taskLabel] ?? []).filter(
                      (c) => parseCompetencyFamily(c) === fam
                    );
                    const s = FAMILY_STYLES[fam];
                    const famLabel =
                      fam === "C1"
                        ? "COMMUNIQUER"
                        : fam === "C2"
                        ? "PR√âPARER"
                        : fam === "C3"
                        ? "R√âALISER"
                        : "CONTR√îLE";

                    return (
                      <div
                        key={fam + "|" + taskLabel}
                        className={classNames(
                          "rounded-2xl border bg-white dark:bg-[var(--night-surface)] overflow-hidden",
                          s.border,
                          s.accentBorder
                        )}
                      >
                        <div
                          className={classNames(
                            "px-2 py-1 border-b-[0.5px]",
                            s.border,
                            s.chipBg
                          )}
                        >
                          <div
                            className={classNames(
                              "flex items-center gap-2 text-[12px] font-semibold",
                              s.headerText
                            )}
                          >
                            {famLabel}
                          </div>
                        </div>

                        <div className="p-3 space-y-2">
                          {comps.length === 0 ? (
                            <div className="text-xs text-neutral-400 italic">
                              Aucune comp√©tence pour cette famille.
                            </div>
                          ) : (
                            comps.map((comp) => {
                              const compKey = taskLabel + "||" + comp;
                              const selected =
                                selectedCompetences.includes(compKey);
                              const entries =
                                critResDB && critResDB[comp]
                                  ? Object.entries(critResDB[comp])
                                  : [];

                              return (
                                <div
                                  key={compKey}
                                  className="border rounded-xl shadow-sm"
                                >
                                  <div
                                    className={classNames(
                                      "w-full text-left rounded-t-lg px-2 py-1 text-[11px] leading-tight transition border-b-[0.5px] cursor-pointer select-none",
                                      selected
                                        ? classNames(
                                            FAMILY_STYLES[
                                              parseCompetencyFamily(comp) as
                                                | "C1"
                                                | "C2"
                                                | "C3"
                                                | "C4"
                                            ].selectedDarkBg,
                                            FAMILY_STYLES[
                                              parseCompetencyFamily(comp) as
                                                | "C1"
                                                | "C2"
                                                | "C3"
                                                | "C4"
                                            ].selectedDarkText,
                                            "border-transparent"
                                          )
                                        : classNames(
                                            s.chipBg,
                                            s.chipText,
                                            s.border
                                          )
                                    )}
                                    onClick={() => toggleCompExpanded(compKey)}
                                    role="button"
                                    aria-expanded={isCompExpanded(compKey)}
                                  >
                                    <div className="text-[11px] leading-snug font-bold flex items-center gap-2">
                                      <button
                                        onClick={(e) => {
                                          e.stopPropagation();
                                          toggleCompExpanded(compKey);
                                        }}
                                        className="h-6 w-6 inline-flex items-center justify-center rounded border border-current/30 bg-transparent hover:bg-amber-100/70/10 dark:bg-[var(--night-surface)]/10 focus:outline-none focus:ring-2 focus:ring-current/40"
                                        aria-label={
                                          isCompExpanded(compKey)
                                            ? "Fermer la comp√©tence"
                                            : "Ouvrir la comp√©tence"
                                        }
                                        title={
                                          isCompExpanded(compKey)
                                            ? "Fermer la comp√©tence"
                                            : "Ouvrir la comp√©tence"
                                        }
                                        type="button"
                                      >
                                        <ChevronRight
                                          className={classNames(
                                            "h-3.5 w-3.5 transition-transform",
                                            isCompExpanded(compKey) &&
                                              "rotate-90"
                                          )}
                                        />
                                      </button>

                                      <span>{comp}</span>
                                    </div>
                                  </div>

                                  {isCompExpanded(compKey) && (
                                    <div className="p-3 space-y-2 text-xs">
                                      {entries.length === 0 ? (
                                        <div className="text-neutral-400 italic">
                                          Aucun crit√®re disponible.
                                        </div>
                                      ) : (
                                        entries.map(([item, obj]) => {
                                          const subCritList =
                                            (obj as any)?.resultats ?? [];
                                          const critBaseKey =
                                            taskLabel + "||" + comp + "::" + item;

                                          return (
                                            <div
                                              key={critBaseKey}
                                              className="border rounded-lg p-2 space-y-1"
                                            >
                                              <div className="font-semibold text-xs">
                                                {item}
                                              </div>
                                              <div className="flex flex-wrap gap-2 mt-1">
                                                {subCritList.map(
                                                  (res: string, idx: number) => {
                                                    const key =
                                                      critBaseKey + "::" + idx;
                                                    const on =
                                                      selectedSubCrit.includes(
                                                        key
                                                      );
                                                    return (
                                                      <button
                                                        key={key}
                                                        type="button"
                                                        onClick={() =>
                                                          toggleSubCrit(
                                                            key,
                                                            comp,
                                                            item
                                                          )
                                                        }
                                                        className={classNames(
                                                          "px-2 py-1 rounded-full border text-[11px] leading-tight",
                                                          on
                                                            ? FAMILY_STYLES[
                                                                parseCompetencyFamily(
                                                                  comp
                                                                ) as
                                                                  | "C1"
                                                                  | "C2"
                                                                  | "C3"
                                                                  | "C4"
                                                              ]
                                                                .selectedBg
                                                            : "bg-white dark:bg-[var(--night-panel)] hover:bg-amber-100/70 dark:bg-[var(--night-panel)] border-neutral-200 dark:border-sky-400/35"
                                                        )}
                                                      >
                                                        {res}
                                                      </button>
                                                    );
                                                  }
                                                )}
                                              </div>
                                            </div>
                                          );
                                        })
                                      )}
                                    </div>
                                  )}
                                </div>
                              );
                            })
                          )}
                        </div>
                      </div>
                    );
                  })}
                </div>
              )}
            </div>
          </section>
        ))}
      </div>
    );
  })()}
</TabsContent>

  {/* STEP 3 */}
<TabsContent value="step3" className="mt-6 px-4 sm:px-6 lg:px-8 pb-20">
            {selectedCriteres.length === 0 ? (
              <div className="text-neutral-600 dark:text-neutral-300">S√©lectionnez d'abord des crit√®res en √©tape 2.</div>
            ) : (
              <div className="space-y-4">
                <div className="flex items-center justify-between">
                </div>

                <div className="overflow-auto rounded-xl border">
<table className="min-w-[900px] w-full text-xs leading-tight table-fixed border-collapse text-neutral-900 dark:text-neutral-300 border border-neutral-300 dark:border-sky-400/35 [&_th]:border [&_th]:border-neutral-300 dark:[&_th]:border-neutral-700/60 [&_th]:text-center [&_th]:px-3 [&_th]:py-1 [&_td]:border [&_td]:border-neutral-200 dark:[&_td]:border-neutral-700/60 [&_td]:px-3 [&_td]:py-1 [&_td]:align-middle [&_td]:text-left">
                    <thead className="bg-neutral-50 dark:bg-[var(--night-panel)] border-b border-neutral-300 dark:border-sky-400/35">
  <tr className="text-center">
    <th className="py-1 w-[10%]">
      <span className="mx-4">T√¢che</span>
    </th>
    <th className="py-1 w-[15%]">
      <span className="mx-4">Comp√©tence</span>
    </th>
    <th className="py-1 w-[20%]">
      <span className="mx-4">√ätre capable</span>
    </th>
    <th className="py-1 w-[20%]">
      <span className="mx-4">Crit√®re d&apos;√©valuation</span>
    </th>
    <th className="py-1 w-[12%]">
      <span className="mx-4">Exigences</span>
    </th>
  </tr>
</thead>

<tbody>
  {sortByTaskNumber(selectedTasks).flatMap((task) => {
    const comps = (tcMap[task] || []) as string[];

    const compItems = comps
      .map((comp) => {
        const allItems = Object.keys(
          (critResDB && (critResDB as any)[comp]) || {}
        );
        const items = allItems.filter((item) => {
          const prefix = task + "||" + comp + "::" + item + "::";
          return selectedSubCrit.some((k) => k.startsWith(prefix));
        });
        return { comp, items };
      })
      .filter((ci) => ci.items.length > 0);

    if (compItems.length === 0) return [] as JSX.Element[];

    type Row = {
      task: string;
      comp: string;
      item: string;
      compRowSpan: number;
      isFirstOfComp: boolean;
    };

    const rows: Row[] = compItems.flatMap((ci) =>
      ci.items.map((item, idx) => ({
        task,
        comp: ci.comp,
        item,
        compRowSpan: ci.items.length,
        isFirstOfComp: idx === 0,
      }))
    );

    // üîπ D√©terminer le groupe de la t√¢che (G1 / G2 / G3)
    const tNum = taskNumber(task);
    const group = GROUPS.find(
      (g) => tNum >= g.range[0] && tNum <= g.range[1]
    );

    // üîπ Classe de couleur pour la bordure interne de la cellule "T√¢che"
    const taskColorClass =
      group?.key === "G1"
        ? "border-sky-400"
        : group?.key === "G2"
        ? "border-amber-400"
        : group?.key === "G3"
        ? "border-violet-400"
        : "border-neutral-300 dark:border-sky-400/35";

    return rows.map((r, rowIdx) => {
      const critKey = `${r.task}||${r.comp}::${r.item}`;
      const normKey = normalizeKeyFromCritKey(critKey);

      const options = Array.from(
        new Set(
          [
            ...getEffectiveExigences(critKey),
            ...(persistedExigencesDB?.[normKey] ?? []),
            ...(getPersistedExigencesFor(r.comp, r.item) ?? []),
            ...(customExigences?.[critKey] ?? []),
          ] as string[]
        )
      );

      const chosenAll = (
        selectedExigence[critKey] ?? getEffectiveExigences(critKey)
      ).filter((v, i, a) => a.indexOf(v) === i);

      const chosenCustom = chosenAll.filter((ex) => options.includes(ex));

      const prefix = `${r.task}||${r.comp}::${r.item}::`;
      const subList: string[] =
        (critResDB &&
          (critResDB as any)[r.comp] &&
          (critResDB as any)[r.comp][r.item]?.resultats) ||
        [];

      const selectedIdx = selectedSubCrit
        .filter((k) => k.startsWith(prefix) && !/::E\d+$/.test(k))
        .map((k) => {
          const m = k.match(/::(\d+)$/);
          return m ? Number(m[1]) : null;
        })
        .filter((n): n is number => n !== null);

      return (
        <tr
          key={`${r.task}|${r.comp}|${r.item}`}
          className="border-t align-top"
        >
          {/* COL 1 ‚Äî T√¢che (avec bordure verticale color√©e interne) */}
          {rowIdx === 0 && (
            <td className="px-4 py-3 align-top" rowSpan={rows.length}>
              <div
                className={classNames(
                  "font-medium pl-3 border-l-4",
                  taskColorClass
                )}
              >
                {formatEvalLabel(r.task, r.comp)}
              </div>
            </td>
          )}

          {/* COL 2 ‚Äî Comp√©tence */}
          {r.isFirstOfComp && (
            <td className="px-4 py-3 align-top" rowSpan={r.compRowSpan}>
              <div className="font-medium">{r.comp}</div>
            </td>
          )}

          {/* COL 3 ‚Äî √ätre capable */}
          <td className="px-4 py-3">{r.item}</td>

          {/* COL 4 ‚Äî Crit√®re d'√©valuation */}
          <td className="px-4 py-3">
            {selectedIdx.length === 0 ? (
              <div className="text-xs text-neutral-500 italic">‚Äî</div>
            ) : (
              <ul className="list-disc pl-4 space-y-1 text-xs">
                {selectedIdx.map((i) => (
                  <li key={i}>{subList[i]}</li>
                ))}
              </ul>
            )}
          </td>

          {/* COL 5 ‚Äî Exigences personnalis√©es */}
          <td className="px-4 py-3">
            <div className="flex items-center gap-2">
              <DropdownMenu
                onOpenChange={(open) => {
                  if (!open) {
                    setInlineAddKey(null);
                    setInlineAddValue("");
                  }
                }}
              >
                <DropdownMenuTrigger asChild>
                  <button
                    type="button"
                    className="inline-flex items-center gap-1 text-xs px-2 py-1 rounded border border-neutral-300 dark:border-sky-400/35 bg-white hover:bg-amber-100/70 dark:bg-[var(--night-surface)] hover:bg-amber-100/70 dark:bg-[var(--night-surface)]"
                    title="Choisir les exigences personnalis√©es √† afficher"
                  >
                    <ChevronRight className="h-3.5 w-3.5" />
                    {`S√©lection${
                      chosenCustom.length ? ` (${chosenCustom.length})` : ""
                    }`}
                  </button>
                </DropdownMenuTrigger>

                <DropdownMenuContent
                  key={`${critKey}-${options.length}-${
                    (selectedExigence[critKey] ?? []).length
                  }`}
                  className="w-96 p-2"
                >
                  {options.length === 0 ? (
                    <>
                      <div className="px-2 py-1.5 text-xs text-neutral-500 flex items-center gap-2">
                        Aucune exigence personnalis√©e.
                        <button
                          onClick={() => openManage(critKey)}
                          className="underline"
                        >
                          Ouvrir la biblioth√®que
                        </button>
                      </div>

                      <DropdownMenuSeparator />

                      <div className="px-1 pt-1">
                        <div className="text-[11px] mb-1 text-neutral-500">
                          Ajouter une exigence
                        </div>
                        <div className="flex items-center gap-2">
                          <Input
                            value={
                              inlineAddKey === critKey ? inlineAddValue : ""
                            }
                            onChange={(e) => {
                              setInlineAddKey(critKey);
                              setInlineAddValue(e.target.value);
                            }}
                            onKeyDown={(e) => {
                              if (e.key === "Enter") {
                                const v = (
                                  inlineAddKey === critKey
                                    ? inlineAddValue
                                    : ""
                                ).trim();
                                if (!v) return;
                                setCustomExigences((prev) => {
                                  const base = prev[critKey] ?? [];
                                  const arr = [...base];
                                  if (!arr.includes(v)) arr.push(v);
                                  return { ...prev, [critKey]: arr };
                                });
                                setSelectedExigence((prev) => {
                                  const cur = prev[critKey] ?? [];
                                  return cur.includes(v)
                                    ? prev
                                    : {
                                        ...prev,
                                        [critKey]: [...cur, v],
                                      };
                                });
                                setInlineAddValue("");
                                setInlineAddKey(null);
                              }
                            }}
                            placeholder="Nouvelle exigence‚Ä¶"
                            className="h-8"
                          />
                          <Button
                            className="h-8 px-2"
                            onClick={() => {
                              const v = (
                                inlineAddKey === critKey
                                  ? inlineAddValue
                                  : ""
                              ).trim();
                              if (!v) return;
                              setCustomExigences((prev) => {
                                const base = prev[critKey] ?? [];
                                const arr = [...base];
                                if (!arr.includes(v)) arr.push(v);
                                return { ...prev, [critKey]: arr };
                              });
                              setSelectedExigence((prev) => {
                                const cur = prev[critKey] ?? [];
                                return cur.includes(v)
                                  ? prev
                                  : {
                                      ...prev,
                                      [critKey]: [...cur, v],
                                    };
                              });
                              setInlineAddValue("");
                              setInlineAddKey(null);
                            }}
                          >
                            <Plus className="w-3.5 h-3.5 mr-1" />
                            Ajouter
                          </Button>
                        </div>
                      </div>
                    </>
                  ) : (
                    <>
                      <DropdownMenuLabel className="text-xs text-neutral-500">
                        Exigences personnalis√©es (cocher pour afficher)
                      </DropdownMenuLabel>
                      <DropdownMenuSeparator />
                      <div className="max-h-64 overflow-auto pr-1">
                        {options.map((ex, i) => (
                          <DropdownMenuCheckboxItem
                            key={i}
                            checked={chosenCustom.includes(ex)}
                            onCheckedChange={(checked) => {
                              if (checked) toggleExigenceSelection(critKey, ex);
                              else removeFromCell(critKey, ex);
                            }}
                            className="text-xs whitespace-normal leading-snug pr-7"
                          >
                            {ex}
                          </DropdownMenuCheckboxItem>
                        ))}
                      </div>
                      <DropdownMenuSeparator />
                      <div className="px-1 pt-1">
                        <div className="text-[11px] mb-1 text-neutral-500">
                          Ajouter une exigence
                        </div>
                        <div className="flex items-center gap-2">
                          <Input
                            value={
                              inlineAddKey === critKey ? inlineAddValue : ""
                            }
                            onChange={(e) => {
                              setInlineAddKey(critKey);
                              setInlineAddValue(e.target.value);
                            }}
                            onKeyDown={(e) => {
                              if (e.key === "Enter") {
                                const v = (
                                  inlineAddKey === critKey
                                    ? inlineAddValue
                                    : ""
                                ).trim();
                                if (!v) return;
                                setCustomExigences((prev) => {
                                  const base = prev[critKey] ?? [];
                                  const arr = [...base];
                                  if (!arr.includes(v)) arr.push(v);
                                  return { ...prev, [critKey]: arr };
                                });
                                setSelectedExigence((prev) => {
                                  const cur = prev[critKey] ?? [];
                                  return cur.includes(v)
                                    ? prev
                                    : {
                                        ...prev,
                                        [critKey]: [...cur, v],
                                      };
                                });
                                setInlineAddValue("");
                                setInlineAddKey(null);
                              }
                            }}
                            placeholder="Nouvelle exigence‚Ä¶"
                            className="h-8"
                          />
                          <Button
                            className="h-8 px-2"
                            onClick={() => {
                              const v = (
                                inlineAddKey === critKey
                                  ? inlineAddValue
                                  : ""
                              ).trim();
                              if (!v) return;
                              setCustomExigences((prev) => {
                                const base = prev[critKey] ?? [];
                                const arr = [...base];
                                if (!arr.includes(v)) arr.push(v);
                                return { ...prev, [critKey]: arr };
                              });
                              setSelectedExigence((prev) => {
                                const cur = prev[critKey] ?? [];
                                return cur.includes(v)
                                  ? prev
                                  : {
                                      ...prev,
                                      [critKey]: [...cur, v],
                                    };
                              });
                              setInlineAddValue("");
                              setInlineAddKey(null);
                            }}
                          >
                            <Plus className="w-3.5 h-3.5 mr-1" />
                            Ajouter
                          </Button>
                        </div>
                      </div>
                    </>
                  )}
                </DropdownMenuContent>
              </DropdownMenu>

              <button
                type="button"
                onClick={() => openManage(critKey)}
                className="h-7 w-7 inline-flex items-center justify-center rounded border border-neutral-300 dark:border-sky-400/35 bg-white hover:bg-amber-100/70 dark:bg-[var(--night-surface)] hover:bg-amber-100/70 dark:bg-[var(--night-surface)]"
                title="G√©rer la biblioth√®que"
                aria-label="G√©rer"
              >
                <Settings2 className="w-3.5 h-3.5" />
              </button>
            </div>

            {/* R√©sum√© s√©lectionn√© */}
            <div className="mt-2">
              {chosenCustom.length === 0 ? (
                <span className="text-xs text-neutral-500">
                  Aucune s√©lection personnalis√©e
                </span>
              ) : (
                <ul className="list-disc pl-4 space-y-1 text-xs">
                  {chosenCustom.map((ex) => (
                    <li key={ex} className="flex items-start gap-2">
                      <span className="flex-1">{ex}</span>
                      <button
                        onClick={() => removeFromCell(critKey, ex)}
                        className="inline-flex items-center justify-center h-5 w-5 rounded border border-neutral-300 dark:border-sky-400/35 hover:bg-amber-100/70 dark:bg-[var(--night-surface)]"
                        aria-label="Retirer de la cellule"
                        title="Retirer de la cellule"
                      >
                        <Trash2 className="h-3.5 w-3.5" />
                      </button>
                    </li>
                  ))}
                </ul>
              )}
            </div>
          </td>
        </tr>
      );
    });
  })}
</tbody>


                  </table>
                </div>
              </div>
            )}
</TabsContent>

  {/* STEP 4 ‚Äì NOTATION (CRIT√âRI√âE PAR CRIT√àRE) */}
<TabsContent value="step4" className="mt-6 px-4 sm:px-6 lg:px-8 pb-20">
  {renderNotationCriteree()}
</TabsContent>


</div>
</section>
</Tabs>

) : activeView === "ccf" ? (
  <section className="space-y-4 px-2 sm:px-3 lg:px-4 pt-2 pb-12">
    <div className="rounded-2xl border border-neutral-200 dark:border-sky-400/35 bg-white dark:bg-[var(--night-surface)] keep-light p-4 shadow-sm">

      <div className="mb-3 flex flex-col gap-2 rounded-xl border border-neutral-200 dark:border-sky-400/35 bg-neutral-50 dark:bg-[var(--night-base)] px-3 py-2">
        <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-2">
          <div className="text-sm">
            <div className="font-medium">Source CCF (Excel national)</div>
            <div className="text-xs text-neutral-600 dark:text-neutral-300 break-all">
              {ccfExcelPath ? `Branch√© : ${ccfExcelPath}` : "Non branch√© : mod√®le embarqu√©"}
            </div>
          </div>
          <div className="flex gap-2">
            <Button type="button" variant="secondary" onClick={linkCcfExcel}>
              Ajouter le fichier de r√©f√©rence Excel
            </Button>
            <Button type="button" variant="outline" onClick={unlinkCcfExcel} disabled={!ccfExcelPath}>
              Enlever le fichier
            </Button>
          </div>
        </div>
        <div className="text-xs text-neutral-600 dark:text-neutral-300">
          Si le fichier est modifi√© et enregistr√©, l‚Äôonglet CCF se met √† jour automatiquement.
        </div>
      </div>

	      <Tabs value={ccfTab} onValueChange={(v) => {
  const next = v as CcfCcfTab;
  setCcfTab(next);
  if (next !== "EVALUATION") setCcfEpKey(next);
}}>
	        {/* Sous-onglets CCF en petites bulles, align√©s sur une seule ligne */}
	        <div className="flex items-center justify-between gap-2 flex-wrap">
<TabsList className="suivi-tabs inline-flex rounded-full border border-neutral-200 dark:border-sky-400/35 bg-neutral-50 dark:bg-[var(--night-surface)] p-1 !flex !flex-row !flex-nowrap flex-1 max-w-full items-center gap-1 overflow-x-auto !overflow-y-visible">
  <TabsTrigger value="EP1" className="suivi-btn inline-flex items-center rounded-full transition !bg-transparent !text-neutral-700 dark:!text-neutral-300 hover:!bg-amber-100/70 dark:hover:!bg-[var(--night-hover)] data-[state=active]:!bg-neutral-900 data-[state=active]:!text-white whitespace-nowrap !w-auto !flex-none shrink-0">
    EPI
  </TabsTrigger>
  <TabsTrigger value="EP2A1" className="suivi-btn inline-flex items-center rounded-full transition !bg-transparent !text-neutral-700 dark:!text-neutral-300 hover:!bg-amber-100/70 dark:hover:!bg-[var(--night-hover)] data-[state=active]:!bg-neutral-900 data-[state=active]:!text-white whitespace-nowrap !w-auto !flex-none shrink-0">
    EP2 A1
  </TabsTrigger>
  <TabsTrigger value="EP2A2" className="suivi-btn inline-flex items-center rounded-full transition !bg-transparent !text-neutral-700 dark:!text-neutral-300 hover:!bg-amber-100/70 dark:hover:!bg-[var(--night-hover)] data-[state=active]:!bg-neutral-900 data-[state=active]:!text-white whitespace-nowrap !w-auto !flex-none shrink-0">
    EP2 A2
  </TabsTrigger>
  <TabsTrigger value="EP3" className="suivi-btn inline-flex items-center rounded-full transition !bg-transparent !text-neutral-700 dark:!text-neutral-300 hover:!bg-amber-100/70 dark:hover:!bg-[var(--night-hover)] data-[state=active]:!bg-neutral-900 data-[state=active]:!text-white whitespace-nowrap !w-auto !flex-none shrink-0">
    EP3
  </TabsTrigger>
<TabsTrigger value="EVALUATION" className="suivi-btn inline-flex items-center rounded-full transition !bg-transparent !text-neutral-700 dark:!text-neutral-300 hover:!bg-amber-100/70 dark:hover:!bg-[var(--night-hover)] data-[state=active]:!bg-neutral-900 data-[state=active]:!text-white whitespace-nowrap !w-auto !flex-none shrink-0">
  √âvaluation
</TabsTrigger>
</TabsList>
<div className="flex items-center gap-2 flex-wrap justify-end">
  <Button
    type="button"
    variant="secondary"
    className="h-9 px-3 text-xs"
    disabled={!ccfSelectedClassId || ccfExportBusy}
    onClick={handleExportCcfJsonForSelectedClass}
    title="Exporter les r√©sultats CCF (JSON) pour la classe s√©lectionn√©e"
  >
    {ccfExportBusy ? "Export‚Ä¶" : "Enregistrer"}
  </Button>

  <div className="min-w-[170px]">
    <select
      className="h-9 w-full rounded-md border border-neutral-300 dark:border-sky-400/35 bg-white dark:bg-[var(--night-surface)] px-2 text-xs text-neutral-900 dark:text-neutral-100"
      value={ccfSelectedClassId ?? ""}
      onChange={(e) => {
        const v = e.target.value;
        const next = v ? v : null;
        setCcfSelectedClassId(next);
        const students = getStudentsForClassCCF(next);
        setCcfSelectedStudentName(students[0] ?? null);
      }}
    >
      <option value="" disabled>
        Classe
      </option>
      {classGroups.map((c) => (
        <option key={c.id ?? c.name} value={c.id ?? c.name}>
          {c.name}
        </option>
      ))}
    </select>
  </div>

  <div className="min-w-[170px]">
    <select
      className="h-9 w-full rounded-md border border-neutral-300 dark:border-sky-400/35 bg-white dark:bg-[var(--night-surface)] px-2 text-xs text-neutral-900 dark:text-neutral-100 disabled:opacity-60"
      value={ccfSelectedStudentName ?? ""}
      disabled={!ccfSelectedClassId}
      onChange={(e) => setCcfSelectedStudentName(e.target.value ? e.target.value : null)}
    >
      <option value="" disabled>
        √âl√®ve
      </option>
      {(ccfSelectedClassId ? getStudentsForClassCCF(ccfSelectedClassId) : []).map((name) => (
        <option key={name} value={name}>
          {name}
        </option>
      ))}
    </select>
  </div>

  <div className="min-w-[210px]">
    <select
      className="h-9 w-full rounded-md border border-neutral-300 dark:border-sky-400/35 bg-white dark:bg-[var(--night-surface)] px-2 text-xs text-neutral-900 dark:text-neutral-100"
      value={ccfEpKey}
      onChange={(e) => setCcfEpKey(e.target.value as CcfEpKey)}
    >
      <option value="EP1">EP1 ‚Äî √âtude & pr√©paration</option>
      <option value="EP2A1">EP2 A1 ‚Äî Travaux courants (centre)</option>
      <option value="EP2A2">EP2 A2 ‚Äî Travaux courants (entreprise)</option>
      <option value="EP3">EP3 ‚Äî Travaux sp√©cifiques</option>
    </select>
  </div>
</div>
</div>

<TabsContent value="EVALUATION" className="mt-4">
{/* √âvaluation (r√®glement + notes coefficient√©es) */}
  <div className="w-full">
    <div className="rounded-xl border border-black/30 bg-white dark:bg-[var(--night-surface)] keep-light p-3 shadow-sm">
      <div className="flex items-center justify-between gap-2">
        <div className="text-xs font-semibold text-neutral-900 dark:text-neutral-100">√âvaluation</div>
        <div className="text-[11px] text-neutral-600 dark:text-neutral-300">R√®glement + notes coefficient√©es</div>
      </div>

      {(() => {
        if (!ccfSelectedStudentName) {
          return <div className="mt-2 text-xs text-neutral-600 dark:text-neutral-300">S√©lectionnez un √©l√®ve.</div>;
        }

        const rows = ccfEvaluationRows || CCF_EVALUATION_FALLBACK;
        const byEp: Record<CcfEpKey, { note20: number; noteCoef: number }> = {
          EP1: { note20: 0, noteCoef: 0 },
          EP2A1: { note20: 0, noteCoef: 0 },
          EP2A2: { note20: 0, noteCoef: 0 },
          EP3: { note20: 0, noteCoef: 0 },
        };

        (Object.keys(byEp) as CcfEpKey[]).forEach((k) => {
          const note20 = computeCcfTotal(ccfSelectedStudentName, k).total;
          const coef = (rows.find((r) => r.epKey === k)?.coef ?? 0) || 0;
          byEp[k] = { note20, noteCoef: note20 * coef };
        });

        const totalCoef = rows.reduce((a, r) => a + (r.coef || 0), 0);
        const totalCoefNote = (Object.values(byEp) as any[]).reduce((a, x) => a + (x.noteCoef || 0), 0);

        const fmt = (v: number) => (typeof v === "number" && isFinite(v) ? v.toFixed(2).replace(".", ",") : "‚Äî");

        return (
          <div className="mt-2 overflow-x-auto">
            <table className="w-full border-collapse ccf-table">
              <thead>
                <tr className="bg-neutral-50 dark:bg-[var(--night-base)]">
                  <th className="border border-black px-2 py-1 text-left text-[11px] font-semibold">R√©f.</th>
                  <th className="border border-black px-2 py-1 text-left text-[11px] font-semibold">√âpreuve</th>
                  <th className="border border-black px-2 py-1 text-center text-[11px] font-semibold">Unit√©</th>
                  <th className="border border-black px-2 py-1 text-center text-[11px] font-semibold">Coef.</th>
                  <th className="border border-black px-2 py-1 text-center text-[11px] font-semibold">Mode</th>
                  <th className="border border-black px-2 py-1 text-center text-[11px] font-semibold">Dur√©e</th>
                  <th className="border border-black px-2 py-1 text-center text-[11px] font-semibold">Note /20</th>
                  <th className="border border-black px-2 py-1 text-center text-[11px] font-semibold">Note coef.</th>
                </tr>
              </thead>
<tbody>
  {rows.map((r) => {
    const calc = byEp[r.epKey];

    const rowStyle =
      r.bgColor || r.fontColor
        ? ({
            backgroundColor: r.bgColor,
            color: r.fontColor,
          } as React.CSSProperties)
        : undefined;

    return (
      <tr
        key={r.epKey}
        className="bg-white dark:bg-[var(--night-surface)]"
        style={rowStyle}
      >
        <td className="border border-black px-2 py-1 text-[11px] font-semibold">{r.ref}</td>
        <td className="border border-black px-2 py-1 text-[11px]">{r.epreuve}</td>
        <td className="border border-black px-2 py-1 text-[11px] text-center">{r.unite || "‚Äî"}</td>
        <td className="border border-black px-2 py-1 text-[11px] text-center">{r.coef}</td>
        <td className="border border-black px-2 py-1 text-[11px] text-center">{r.mode || "‚Äî"}</td>
        <td className="border border-black px-2 py-1 text-[11px] text-center">{r.duree || "‚Äî"}</td>
        <td className="border border-black px-2 py-1 text-[11px] text-center font-semibold">{fmt(calc?.note20 ?? 0)}</td>
        <td className="border border-black px-2 py-1 text-[11px] text-center font-semibold">{fmt(calc?.noteCoef ?? 0)}</td>
      </tr>
    );
  })}


                <tr className="bg-neutral-50 dark:bg-[var(--night-base)]">
                  <td className="border border-black px-2 py-1 text-[11px] font-semibold" colSpan={3}>Total</td>
                  <td className="border border-black px-2 py-1 text-[11px] text-center font-semibold">{totalCoef}</td>
                  <td className="border border-black px-2 py-1" colSpan={3} />
                  <td className="border border-black px-2 py-1 text-[11px] text-center font-semibold">{fmt(totalCoefNote)}</td>
                </tr>
              </tbody>
            </table>
          </div>
        );
      })()}
    </div>
  </div>
</TabsContent>

<TabsContent value="EP1" className="mt-4">
          <div className="flex items-start justify-between gap-3">
        <div>
        </div>
      </div>

      {ccfEpParamsOpen && (
        <div className="mt-1 rounded-xl border border-neutral-200 dark:border-sky-400/35 bg-white dark:bg-[var(--night-surface)] keep-light p-4 shadow-sm">
          <div className="flex items-start justify-between gap-3">
            <div>
            </div>
          </div>

          <div className="mt-3 grid grid-cols-1 md:grid-cols-4 gap-3">
            <div className="space-y-1">
              <Label className="text-xs">Date d‚Äô√©valuation</Label>
<Input
  type="date"
  defaultValue={ccfSettings.date ?? ""}
  onBlur={(e) =>
    setCcfSettings((p) => ({ ...p, date: e.target.value }))
  }
/>
            </div>

            <div className="space-y-1">
              <Label className="text-xs">√âvaluateur (d√©faut)</Label>
              <Input
                value={ccfSettings.evaluator ?? ""}
                placeholder="Nom / Pr√©nom"
                onChange={(e) => setCcfSettings((p) => ({ ...p, evaluator: e.target.value }))}
              />
            </div>

            <div className="space-y-1">
              <Label className="text-xs">Centre / √©tablissement</Label>
              <Input
                value={ccfSettings.center ?? ""}
                placeholder="GRETA / Lyc√©e / CFA..."
                onChange={(e) => setCcfSettings((p) => ({ ...p, center: e.target.value }))}
              />
            </div>
          </div>
        </div>
      )}

      {!ccfSelectedStudentName ? (
        <div className="mt-4 text-sm text-neutral-600 dark:text-neutral-300">S√©lectionnez d‚Äôabord une classe et un √©l√®ve.</div>
      ) : (
        (() => {
          const sheet = getCcfSheet(ccfSelectedStudentName, ccfEpKey);
          const computed = computeCcfTotal(ccfSelectedStudentName, ccfEpKey);
          const __epKeyN = String(ccfEpKey || "").replace(/\s+/g, "");
          const template = (ccfTemplates?.[__epKeyN] ?? (CCF_TEMPLATES as any)[__epKeyN] ?? []);

          return (
            <>
              {/* R√©sum√© toujours visible (prend peu de place) */}
                            <div className="mt-4 grid grid-cols-1 md:grid-cols-3 gap-3">

                <div className="space-y-1 md:col-span-2">
                  <Label className="text-xs">Contexte / lieu</Label>
                  <Input
                    value={sheet.meta?.contexte ?? ""}
                    onChange={(e) =>
                      setCcfSheet(ccfSelectedStudentName, ccfEpKey, {
                        ...sheet,
                        meta: { ...(sheet.meta || {}), contexte: e.target.value },
                      })
                    }
                    placeholder="Atelier / entreprise / chantier‚Ä¶"
                  />
                </div>
              </div>

              {/* R√©sum√© toujours visible (prend peu de place) */}
              <div className="mt-3 flex flex-col sm:flex-row sm:items-end sm:justify-between gap-2 rounded-xl border border-neutral-200 dark:border-sky-400/35 bg-neutral-50 dark:bg-[var(--night-base)] px-3 py-2">
                <div className="text-sm">
                  <div className="font-semibold text-neutral-900 dark:text-neutral-100">
                    Note calcul√©e : {computed.total.toFixed(2)} / 20
                  </div>
                  <div className="text-[11px] text-neutral-500 dark:text-neutral-300">
                    Les items ‚ÄúNON‚Äù ne sont pas pris en compte.
                  </div>
                </div>

                <div className="w-full sm:w-auto">
                  <div className="text-[11px] text-neutral-500 dark:text-neutral-300 mb-1 sm:text-right">
                    Note propos√©e au jury
                  </div>
                  <Input
                    className="h-9 sm:h-8 w-full sm:w-[150px]"
                    value={sheet.meta?.noteProposee ?? ""}
                    onChange={(e) =>
                      setCcfSheet(ccfSelectedStudentName, ccfEpKey, {
                        ...sheet,
                        meta: { ...(sheet.meta || {}), noteProposee: e.target.value },
                      })
                    }
                    placeholder="Ex: 14,5"
                  />
                </div>
              </div>

              <div className="mt-4 overflow-x-auto">
                <table className="ccf-table min-w-[980px] w-full text-xs border-collapse">
                  <thead>
                    <tr className="bg-neutral-50 dark:bg-[var(--night-base)]">
                      <th className="text-left px-2 py-2 border border-neutral-200 dark:border-sky-400/35 w-[110px]">Code</th>
                      <th className="text-left px-2 py-2 border border-neutral-200 dark:border-sky-400/35">Comp√©tence / item</th>
                      <th className="text-left px-2 py-2 border border-neutral-200 dark:border-sky-400/35">Crit√®res</th>
                      <th className="text-right px-2 py-2 border border-neutral-200 dark:border-sky-400/35 w-[90px]">Poids</th>
                      <th className="text-center px-2 py-2 border border-neutral-200 dark:border-sky-400/35 w-[420px]">Niveau</th>
                    </tr>
                  </thead>
                  <tbody>
                    {template.map((g) => {
                      const gInfo = computed.groupDetails.find((x) => x.code === g.code);
                      return (
                        <React.Fragment key={g.code}>
                          <tr className="bg-white dark:bg-[var(--night-surface)]" style={(g as any).bgColor || (g as any).fontColor ? { backgroundColor: (g as any).bgColor, color: (g as any).fontColor } : undefined}>
                            <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35 font-semibold">{g.code}</td>
                            <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35 font-semibold" colSpan={2}>
                              {g.title}
                              <span className="ml-2 text-[11px] font-normal text-neutral-500 dark:text-neutral-300">
                                ({(g.groupPoints ?? 0).toFixed(2)} pts) ‚Äî Score: {(gInfo?.groupScore ?? 0).toFixed(2)} / {(g.groupPoints ?? 0).toFixed(2)}
                              </span>
                            </td>
                            <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35 text-right">
                              {(g.groupPoints ?? 0).toFixed(2)}
                            </td>
                            <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35" />
                          </tr>

                          {g.items.map((it) => {
                            const current = (sheet.levels?.[it.code] as CcfLevel | undefined) ?? undefined;
                            const options: CcfLevel[] = ["NON", "0", "1", "2", "3"];
                            return (
                              <tr key={it.code} className="bg-white dark:bg-[var(--night-surface)]" style={(it as any).bgColor || (it as any).fontColor ? { backgroundColor: (it as any).bgColor, color: (it as any).fontColor } : undefined}>
                                <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35">{it.code}</td>
                                <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35">{it.label}</td>
                                <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35">
                                  <div className="line-clamp-4 whitespace-pre-wrap">{it.criteria}</div>
                                </td>
                                <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35 text-right">
                                  {(it.realWeight ?? 0).toFixed(2)}
                                </td>
                                <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35">
                                  <div className="flex items-center justify-center gap-1 flex-wrap">
                                    {options.map((opt) => {
                                      const active = current === opt;
                                      return (
                                        <button
                                          key={opt}
                                          type="button"
                                          onClick={() => {
                                            const nextLevels = { ...(sheet.levels ?? {}) } as Record<string, CcfLevel | undefined>;
                                            nextLevels[it.code] = active ? undefined : opt;
                                            setCcfSheet(ccfSelectedStudentName, ccfEpKey, {
                                              ...sheet,
                                              levels: nextLevels,
                                            });
                                          }}
                                          className={ccfLevelButtonClass(opt, active)}
                                          title={opt === "NON" ? "Non observ√© / d√©j√† √©valu√©" : `Niveau ${opt}/3`}
                                        >
                                          {opt}
                                        </button>
                                      );
                                    })}
                                  </div>
                                </td>
                              </tr>
                            );
                          })}
                        </React.Fragment>
                      );
                    })}
                  </tbody>
                </table>
              </div>
            </>
          );
        })()
      )}
    
        </TabsContent>

<TabsContent value="EP2A1" className="mt-4">
          <div className="flex items-start justify-between gap-3">
        <div>
        </div>
      </div>

      {ccfEpParamsOpen && (
        <div className="mt-1 rounded-xl border border-neutral-200 dark:border-sky-400/35 bg-white dark:bg-[var(--night-surface)] keep-light p-4 shadow-sm">
          <div className="flex items-start justify-between gap-3">
            <div>
            </div>
          </div>

          <div className="mt-3 grid grid-cols-1 md:grid-cols-4 gap-3">
            <div className="space-y-1">
              <Label className="text-xs">Date d‚Äô√©valuation</Label>
<Input
  type="date"
  defaultValue={ccfSettings.date ?? ""}
  onBlur={(e) =>
    setCcfSettings((p) => ({ ...p, date: e.target.value }))
  }
/>
            </div>

            <div className="space-y-1">
              <Label className="text-xs">√âvaluateur (d√©faut)</Label>
              <Input
                value={ccfSettings.evaluator ?? ""}
                placeholder="Nom / Pr√©nom"
                onChange={(e) => setCcfSettings((p) => ({ ...p, evaluator: e.target.value }))}
              />
            </div>

            <div className="space-y-1">
              <Label className="text-xs">Centre / √©tablissement</Label>
              <Input
                value={ccfSettings.center ?? ""}
                placeholder="GRETA / Lyc√©e / CFA..."
                onChange={(e) => setCcfSettings((p) => ({ ...p, center: e.target.value }))}
              />
            </div>
          </div>
        </div>
      )}

      {!ccfSelectedStudentName ? (
        <div className="mt-4 text-sm text-neutral-600 dark:text-neutral-300">S√©lectionnez d‚Äôabord une classe et un √©l√®ve.</div>
      ) : (
        (() => {
          const sheet = getCcfSheet(ccfSelectedStudentName, ccfEpKey);
          const computed = computeCcfTotal(ccfSelectedStudentName, ccfEpKey);
          const __epKeyN = String(ccfEpKey || "").replace(/\s+/g, "");
          const template = (ccfTemplates?.[__epKeyN] ?? (CCF_TEMPLATES as any)[__epKeyN] ?? []);

          return (
            <>
              {/* R√©sum√© toujours visible (prend peu de place) */}
                            <div className="mt-4 grid grid-cols-1 md:grid-cols-3 gap-3">

                <div className="space-y-1 md:col-span-2">
                  <Label className="text-xs">Contexte / lieu</Label>
                  <Input
                    value={sheet.meta?.contexte ?? ""}
                    onChange={(e) =>
                      setCcfSheet(ccfSelectedStudentName, ccfEpKey, {
                        ...sheet,
                        meta: { ...(sheet.meta || {}), contexte: e.target.value },
                      })
                    }
                    placeholder="Atelier / entreprise / chantier‚Ä¶"
                  />
                </div>
              </div>

              {/* R√©sum√© toujours visible (prend peu de place) */}
              <div className="mt-3 flex flex-col sm:flex-row sm:items-end sm:justify-between gap-2 rounded-xl border border-neutral-200 dark:border-sky-400/35 bg-neutral-50 dark:bg-[var(--night-base)] px-3 py-2">
                <div className="text-sm">
                  <div className="font-semibold text-neutral-900 dark:text-neutral-100">
                    Note calcul√©e : {computed.total.toFixed(2)} / 20
                  </div>
                  <div className="text-[11px] text-neutral-500 dark:text-neutral-300">
                    Les items ‚ÄúNON‚Äù ne sont pas pris en compte.
                  </div>
                </div>

                <div className="w-full sm:w-auto">
                  <div className="text-[11px] text-neutral-500 dark:text-neutral-300 mb-1 sm:text-right">
                    Note propos√©e au jury
                  </div>
                  <Input
                    className="h-9 sm:h-8 w-full sm:w-[150px]"
                    value={sheet.meta?.noteProposee ?? ""}
                    onChange={(e) =>
                      setCcfSheet(ccfSelectedStudentName, ccfEpKey, {
                        ...sheet,
                        meta: { ...(sheet.meta || {}), noteProposee: e.target.value },
                      })
                    }
                    placeholder="Ex: 14,5"
                  />
                </div>
              </div>

              <div className="mt-4 overflow-x-auto">
                <table className="ccf-table min-w-[980px] w-full text-xs border-collapse">
                  <thead>
                    <tr className="bg-neutral-50 dark:bg-[var(--night-base)]">
                      <th className="text-left px-2 py-2 border border-neutral-200 dark:border-sky-400/35 w-[110px]">Code</th>
                      <th className="text-left px-2 py-2 border border-neutral-200 dark:border-sky-400/35">Comp√©tence / item</th>
                      <th className="text-left px-2 py-2 border border-neutral-200 dark:border-sky-400/35">Crit√®res</th>
                      <th className="text-right px-2 py-2 border border-neutral-200 dark:border-sky-400/35 w-[90px]">Poids</th>
                      <th className="text-center px-2 py-2 border border-neutral-200 dark:border-sky-400/35 w-[420px]">Niveau</th>
                    </tr>
                  </thead>
                  <tbody>
                    {template.map((g) => {
                      const gInfo = computed.groupDetails.find((x) => x.code === g.code);
                      return (
                        <React.Fragment key={g.code}>
                          <tr className="bg-white dark:bg-[var(--night-surface)]" style={(g as any).bgColor || (g as any).fontColor ? { backgroundColor: (g as any).bgColor, color: (g as any).fontColor } : undefined}>
                            <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35 font-semibold">{g.code}</td>
                            <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35 font-semibold" colSpan={2}>
                              {g.title}
                              <span className="ml-2 text-[11px] font-normal text-neutral-500 dark:text-neutral-300">
                                ({(g.groupPoints ?? 0).toFixed(2)} pts) ‚Äî Score: {(gInfo?.groupScore ?? 0).toFixed(2)} / {(g.groupPoints ?? 0).toFixed(2)}
                              </span>
                            </td>
                            <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35 text-right">
                              {(g.groupPoints ?? 0).toFixed(2)}
                            </td>
                            <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35" />
                          </tr>

                          {g.items.map((it) => {
                            const current = (sheet.levels?.[it.code] as CcfLevel | undefined) ?? undefined;
                            const options: CcfLevel[] = ["NON", "0", "1", "2", "3"];
                            return (
                              <tr key={it.code} className="bg-white dark:bg-[var(--night-surface)]" style={(it as any).bgColor || (it as any).fontColor ? { backgroundColor: (it as any).bgColor, color: (it as any).fontColor } : undefined}>
                                <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35">{it.code}</td>
                                <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35">{it.label}</td>
                                <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35">
                                  <div className="line-clamp-4 whitespace-pre-wrap">{it.criteria}</div>
                                </td>
                                <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35 text-right">
                                  {(it.realWeight ?? 0).toFixed(2)}
                                </td>
                                <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35">
                                  <div className="flex items-center justify-center gap-1 flex-wrap">
                                    {options.map((opt) => {
                                      const active = current === opt;
                                      return (
                                        <button
                                          key={opt}
                                          type="button"
                                          onClick={() => {
                                            const nextLevels = { ...(sheet.levels ?? {}) } as Record<string, CcfLevel | undefined>;
                                            nextLevels[it.code] = active ? undefined : opt;
                                            setCcfSheet(ccfSelectedStudentName, ccfEpKey, {
                                              ...sheet,
                                              levels: nextLevels,
                                            });
                                          }}
                                          className={ccfLevelButtonClass(opt, active)}
                                          title={opt === "NON" ? "Non observ√© / d√©j√† √©valu√©" : `Niveau ${opt}/3`}
                                        >
                                          {opt}
                                        </button>
                                      );
                                    })}
                                  </div>
                                </td>
                              </tr>
                            );
                          })}
                        </React.Fragment>
                      );
                    })}
                  </tbody>
                </table>
              </div>
            </>
          );
        })()
      )}
    
        </TabsContent>

<TabsContent value="EP2A2" className="mt-4">
          <div className="flex items-start justify-between gap-3">
        <div>
        </div>
      </div>

      {ccfEpParamsOpen && (
        <div className="mt-1 rounded-xl border border-neutral-200 dark:border-sky-400/35 bg-white dark:bg-[var(--night-surface)] keep-light p-4 shadow-sm">
          <div className="flex items-start justify-between gap-3">
            <div>
            </div>
          </div>

          <div className="mt-3 grid grid-cols-1 md:grid-cols-4 gap-3">
            <div className="space-y-1">
              <Label className="text-xs">Date d‚Äô√©valuation</Label>
<Input
  type="date"
  defaultValue={ccfSettings.date ?? ""}
  onBlur={(e) =>
    setCcfSettings((p) => ({ ...p, date: e.target.value }))
  }
/>
            </div>

            <div className="space-y-1">
              <Label className="text-xs">√âvaluateur (d√©faut)</Label>
              <Input
                value={ccfSettings.evaluator ?? ""}
                placeholder="Nom / Pr√©nom"
                onChange={(e) => setCcfSettings((p) => ({ ...p, evaluator: e.target.value }))}
              />
            </div>

            <div className="space-y-1">
              <Label className="text-xs">Centre / √©tablissement</Label>
              <Input
                value={ccfSettings.center ?? ""}
                placeholder="GRETA / Lyc√©e / CFA..."
                onChange={(e) => setCcfSettings((p) => ({ ...p, center: e.target.value }))}
              />
            </div>
          </div>
        </div>
      )}

      {!ccfSelectedStudentName ? (
        <div className="mt-4 text-sm text-neutral-600 dark:text-neutral-300">S√©lectionnez d‚Äôabord une classe et un √©l√®ve.</div>
      ) : (
        (() => {
          const sheet = getCcfSheet(ccfSelectedStudentName, ccfEpKey);
          const computed = computeCcfTotal(ccfSelectedStudentName, ccfEpKey);
          const __epKeyN = String(ccfEpKey || "").replace(/\s+/g, "");
          const template = (ccfTemplates?.[__epKeyN] ?? (CCF_TEMPLATES as any)[__epKeyN] ?? []);

          return (
            <>
              {/* R√©sum√© toujours visible (prend peu de place) */}
                            <div className="mt-4 grid grid-cols-1 md:grid-cols-3 gap-3">

                <div className="space-y-1 md:col-span-2">
                  <Label className="text-xs">Contexte / lieu</Label>
                  <Input
                    value={sheet.meta?.contexte ?? ""}
                    onChange={(e) =>
                      setCcfSheet(ccfSelectedStudentName, ccfEpKey, {
                        ...sheet,
                        meta: { ...(sheet.meta || {}), contexte: e.target.value },
                      })
                    }
                    placeholder="Atelier / entreprise / chantier‚Ä¶"
                  />
                </div>
              </div>

              {/* R√©sum√© toujours visible (prend peu de place) */}
              <div className="mt-3 flex flex-col sm:flex-row sm:items-end sm:justify-between gap-2 rounded-xl border border-neutral-200 dark:border-sky-400/35 bg-neutral-50 dark:bg-[var(--night-base)] px-3 py-2">
                <div className="text-sm">
                  <div className="font-semibold text-neutral-900 dark:text-neutral-100">
                    Note calcul√©e : {computed.total.toFixed(2)} / 20
                  </div>
                  <div className="text-[11px] text-neutral-500 dark:text-neutral-300">
                    Les items ‚ÄúNON‚Äù ne sont pas pris en compte.
                  </div>
                </div>

                <div className="w-full sm:w-auto">
                  <div className="text-[11px] text-neutral-500 dark:text-neutral-300 mb-1 sm:text-right">
                    Note propos√©e au jury
                  </div>
                  <Input
                    className="h-9 sm:h-8 w-full sm:w-[150px]"
                    value={sheet.meta?.noteProposee ?? ""}
                    onChange={(e) =>
                      setCcfSheet(ccfSelectedStudentName, ccfEpKey, {
                        ...sheet,
                        meta: { ...(sheet.meta || {}), noteProposee: e.target.value },
                      })
                    }
                    placeholder="Ex: 14,5"
                  />
                </div>
              </div>

              <div className="mt-4 overflow-x-auto">
                <table className="ccf-table min-w-[980px] w-full text-xs border-collapse">
                  <thead>
                    <tr className="bg-neutral-50 dark:bg-[var(--night-base)]">
                      <th className="text-left px-2 py-2 border border-neutral-200 dark:border-sky-400/35 w-[110px]">Code</th>
                      <th className="text-left px-2 py-2 border border-neutral-200 dark:border-sky-400/35">Comp√©tence / item</th>
                      <th className="text-left px-2 py-2 border border-neutral-200 dark:border-sky-400/35">Crit√®res</th>
                      <th className="text-right px-2 py-2 border border-neutral-200 dark:border-sky-400/35 w-[90px]">Poids</th>
                      <th className="text-center px-2 py-2 border border-neutral-200 dark:border-sky-400/35 w-[420px]">Niveau</th>
                    </tr>
                  </thead>
                  <tbody>
                    {template.map((g) => {
                      const gInfo = computed.groupDetails.find((x) => x.code === g.code);
                      return (
                        <React.Fragment key={g.code}>
                          <tr className="bg-white dark:bg-[var(--night-surface)]" style={(g as any).bgColor || (g as any).fontColor ? { backgroundColor: (g as any).bgColor, color: (g as any).fontColor } : undefined}>
                            <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35 font-semibold">{g.code}</td>
                            <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35 font-semibold" colSpan={2}>
                              {g.title}
                              <span className="ml-2 text-[11px] font-normal text-neutral-500 dark:text-neutral-300">
                                ({(g.groupPoints ?? 0).toFixed(2)} pts) ‚Äî Score: {(gInfo?.groupScore ?? 0).toFixed(2)} / {(g.groupPoints ?? 0).toFixed(2)}
                              </span>
                            </td>
                            <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35 text-right">
                              {(g.groupPoints ?? 0).toFixed(2)}
                            </td>
                            <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35" />
                          </tr>

                          {g.items.map((it) => {
                            const current = (sheet.levels?.[it.code] as CcfLevel | undefined) ?? undefined;
                            const options: CcfLevel[] = ["NON", "0", "1", "2", "3"];
                            return (
                              <tr key={it.code} className="bg-white dark:bg-[var(--night-surface)]" style={(it as any).bgColor || (it as any).fontColor ? { backgroundColor: (it as any).bgColor, color: (it as any).fontColor } : undefined}>
                                <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35">{it.code}</td>
                                <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35">{it.label}</td>
                                <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35">
                                  <div className="line-clamp-4 whitespace-pre-wrap">{it.criteria}</div>
                                </td>
                                <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35 text-right">
                                  {(it.realWeight ?? 0).toFixed(2)}
                                </td>
                                <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35">
                                  <div className="flex items-center justify-center gap-1 flex-wrap">
                                    {options.map((opt) => {
                                      const active = current === opt;
                                      return (
                                        <button
                                          key={opt}
                                          type="button"
                                          onClick={() => {
                                            const nextLevels = { ...(sheet.levels ?? {}) } as Record<string, CcfLevel | undefined>;
                                            nextLevels[it.code] = active ? undefined : opt;
                                            setCcfSheet(ccfSelectedStudentName, ccfEpKey, {
                                              ...sheet,
                                              levels: nextLevels,
                                            });
                                          }}
                                          className={ccfLevelButtonClass(opt, active)}
                                          title={opt === "NON" ? "Non observ√© / d√©j√† √©valu√©" : `Niveau ${opt}/3`}
                                        >
                                          {opt}
                                        </button>
                                      );
                                    })}
                                  </div>
                                </td>
                              </tr>
                            );
                          })}
                        </React.Fragment>
                      );
                    })}
                  </tbody>
                </table>
              </div>
            </>
          );
        })()
      )}
    
        </TabsContent>

<TabsContent value="EP3" className="mt-4">
          <div className="flex items-start justify-between gap-3">
        <div>
        </div>
      </div>

      {ccfEpParamsOpen && (
        <div className="mt-1 rounded-xl border border-neutral-200 dark:border-sky-400/35 bg-white dark:bg-[var(--night-surface)] keep-light p-4 shadow-sm">
          <div className="flex items-start justify-between gap-3">
            <div>
            </div>
          </div>

          <div className="mt-3 grid grid-cols-1 md:grid-cols-4 gap-3">
            <div className="space-y-1">
              <Label className="text-xs">Date d‚Äô√©valuation</Label>
<Input
  type="date"
  defaultValue={ccfSettings.date ?? ""}
  onBlur={(e) =>
    setCcfSettings((p) => ({ ...p, date: e.target.value }))
  }
/>
            </div>

            <div className="space-y-1">
              <Label className="text-xs">√âvaluateur (d√©faut)</Label>
              <Input
                value={ccfSettings.evaluator ?? ""}
                placeholder="Nom / Pr√©nom"
                onChange={(e) => setCcfSettings((p) => ({ ...p, evaluator: e.target.value }))}
              />
            </div>

            <div className="space-y-1">
              <Label className="text-xs">Centre / √©tablissement</Label>
              <Input
                value={ccfSettings.center ?? ""}
                placeholder="GRETA / Lyc√©e / CFA..."
                onChange={(e) => setCcfSettings((p) => ({ ...p, center: e.target.value }))}
              />
            </div>
          </div>
        </div>
      )}

      {!ccfSelectedStudentName ? (
        <div className="mt-4 text-sm text-neutral-600 dark:text-neutral-300">S√©lectionnez d‚Äôabord une classe et un √©l√®ve.</div>
      ) : (
        (() => {
          const sheet = getCcfSheet(ccfSelectedStudentName, ccfEpKey);
          const computed = computeCcfTotal(ccfSelectedStudentName, ccfEpKey);
          const __epKeyN = String(ccfEpKey || "").replace(/\s+/g, "");
          const template = (ccfTemplates?.[__epKeyN] ?? (CCF_TEMPLATES as any)[__epKeyN] ?? []);

          return (
            <>
              {/* R√©sum√© toujours visible (prend peu de place) */}
                            <div className="mt-4 grid grid-cols-1 md:grid-cols-3 gap-3">

                <div className="space-y-1 md:col-span-2">
                  <Label className="text-xs">Contexte / lieu</Label>
                  <Input
                    value={sheet.meta?.contexte ?? ""}
                    onChange={(e) =>
                      setCcfSheet(ccfSelectedStudentName, ccfEpKey, {
                        ...sheet,
                        meta: { ...(sheet.meta || {}), contexte: e.target.value },
                      })
                    }
                    placeholder="Atelier / entreprise / chantier‚Ä¶"
                  />
                </div>
              </div>

              {/* R√©sum√© toujours visible (prend peu de place) */}
              <div className="mt-3 flex flex-col sm:flex-row sm:items-end sm:justify-between gap-2 rounded-xl border border-neutral-200 dark:border-sky-400/35 bg-neutral-50 dark:bg-[var(--night-base)] px-3 py-2">
                <div className="text-sm">
                  <div className="font-semibold text-neutral-900 dark:text-neutral-100">
                    Note calcul√©e : {computed.total.toFixed(2)} / 20
                  </div>
                  <div className="text-[11px] text-neutral-500 dark:text-neutral-300">
                    Les items ‚ÄúNON‚Äù ne sont pas pris en compte.
                  </div>
                </div>

                <div className="w-full sm:w-auto">
                  <div className="text-[11px] text-neutral-500 dark:text-neutral-300 mb-1 sm:text-right">
                    Note propos√©e au jury
                  </div>
                  <Input
                    className="h-9 sm:h-8 w-full sm:w-[150px]"
                    value={sheet.meta?.noteProposee ?? ""}
                    onChange={(e) =>
                      setCcfSheet(ccfSelectedStudentName, ccfEpKey, {
                        ...sheet,
                        meta: { ...(sheet.meta || {}), noteProposee: e.target.value },
                      })
                    }
                    placeholder="Ex: 14,5"
                  />
                </div>
              </div>

              <div className="mt-4 overflow-x-auto">
                <table className="ccf-table min-w-[980px] w-full text-xs border-collapse">
                  <thead>
                    <tr className="bg-neutral-50 dark:bg-[var(--night-base)]">
                      <th className="text-left px-2 py-2 border border-neutral-200 dark:border-sky-400/35 w-[110px]">Code</th>
                      <th className="text-left px-2 py-2 border border-neutral-200 dark:border-sky-400/35">Comp√©tence / item</th>
                      <th className="text-left px-2 py-2 border border-neutral-200 dark:border-sky-400/35">Crit√®res</th>
                      <th className="text-right px-2 py-2 border border-neutral-200 dark:border-sky-400/35 w-[90px]">Poids</th>
                      <th className="text-center px-2 py-2 border border-neutral-200 dark:border-sky-400/35 w-[420px]">Niveau</th>
                    </tr>
                  </thead>
                  <tbody>
                    {template.map((g) => {
                      const gInfo = computed.groupDetails.find((x) => x.code === g.code);
                      return (
                        <React.Fragment key={g.code}>
                          <tr className="bg-white dark:bg-[var(--night-surface)]" style={(g as any).bgColor || (g as any).fontColor ? { backgroundColor: (g as any).bgColor, color: (g as any).fontColor } : undefined}>
                            <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35 font-semibold">{g.code}</td>
                            <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35 font-semibold" colSpan={2}>
                              {g.title}
                              <span className="ml-2 text-[11px] font-normal text-neutral-500 dark:text-neutral-300">
                                ({(g.groupPoints ?? 0).toFixed(2)} pts) ‚Äî Score: {(gInfo?.groupScore ?? 0).toFixed(2)} / {(g.groupPoints ?? 0).toFixed(2)}
                              </span>
                            </td>
                            <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35 text-right">
                              {(g.groupPoints ?? 0).toFixed(2)}
                            </td>
                            <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35" />
                          </tr>

                          {g.items.map((it) => {
                            const current = (sheet.levels?.[it.code] as CcfLevel | undefined) ?? undefined;
                            const options: CcfLevel[] = ["NON", "0", "1", "2", "3"];
                            return (
                              <tr key={it.code} className="bg-white dark:bg-[var(--night-surface)]" style={(it as any).bgColor || (it as any).fontColor ? { backgroundColor: (it as any).bgColor, color: (it as any).fontColor } : undefined}>
                                <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35">{it.code}</td>
                                <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35">{it.label}</td>
                                <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35">
                                  <div className="line-clamp-4 whitespace-pre-wrap">{it.criteria}</div>
                                </td>
                                <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35 text-right">
                                  {(it.realWeight ?? 0).toFixed(2)}
                                </td>
                                <td className="px-2 py-2 border border-neutral-200 dark:border-sky-400/35">
                                  <div className="flex items-center justify-center gap-1 flex-wrap">
                                    {options.map((opt) => {
                                      const active = current === opt;
                                      return (
                                        <button
                                          key={opt}
                                          type="button"
                                          onClick={() => {
                                            const nextLevels = { ...(sheet.levels ?? {}) } as Record<string, CcfLevel | undefined>;
                                            nextLevels[it.code] = active ? undefined : opt;
                                            setCcfSheet(ccfSelectedStudentName, ccfEpKey, {
                                              ...sheet,
                                              levels: nextLevels,
                                            });
                                          }}
                                          className={ccfLevelButtonClass(opt, active)}
                                          title={opt === "NON" ? "Non observ√© / d√©j√† √©valu√©" : `Niveau ${opt}/3`}
                                        >
                                          {opt}
                                        </button>
                                      );
                                    })}
                                  </div>
                                </td>
                              </tr>
                            );
                          })}
                        </React.Fragment>
                      );
                    })}
                  </tbody>
                </table>
              </div>
            </>
          );
        })()
      )}
    
        </TabsContent>

      </Tabs>
    </div>
  </section>
) : activeView === "suivi" ? (
  <>
    {/* üåü VUE : SUIVI DES COMP√âTENCES */}
    <section className="space-y-4 px-2 sm:px-3 lg:px-4 pt-2 pb-12">
      {(() => {
        const classe = classGroups.find((c) => c.name === selectedClassIdForSuivi);
        const students = classe
          ? (classe.students || "")
              .split("\n")
              .map((s) => s.trim())
              .filter(Boolean)
          : [];

        const evalForClass = classe
          ? evalMetaList.filter((ev) => ev.group === classe.name)
          : [];

        const selectedEvalMeta =
          selectedEvalIdForClasse && evalForClass.length > 0
            ? evalForClass.find((ev) => ev.id === selectedEvalIdForClasse) || null
            : null;

        const compLabelsForClasse: string[] =
          selectedEvalMeta && selectedCompetences.length > 0
            ? selectedCompetences
            : [];

        return (
          <>
{/* üîù BANDEAU STICKY : classe + mode + √©l√®ve + export */}
<div className="sticky top-[67px] z-50 backdrop-blur border-b border-black dark:border-sky-400/35 bg-white/70 dark:bg-[var(--night-panel)]/70 dark:bg-[var(--night-panel)]/95 dark:border-[var(--night-border-strong)] dark:text-white night-banner">
  <div className="flex flex-col gap-4 sm:flex-row sm:items-end py-2 px-2 sm:px-4 lg:px-6">
    {/* Choix du mode : √©l√®ve / classe */}
    <div className="flex-1 space-y-1">
      <div className="suivi-tabs inline-flex rounded-full border border-neutral-200 dark:border-sky-400/35 bg-neutral-50 dark:bg-[var(--night-surface)] p-1">
        <button
          type="button"
          onClick={() => setSuiviMode("eleve")}
          className={classNames(
            "suivi-btn inline-flex items-center rounded-full transition",
            suiviMode === "eleve"
              ? "bg-neutral-900 text-white"
              : "bg-transparent text-neutral-700 dark:text-neutral-300 hover:bg-amber-100/70 dark:bg-[var(--night-surface)] dark:hover:bg-[var(--night-hover)]"
          )}
        >
          <span className="suivi-icon" aria-hidden="true">üßë‚Äçüéì</span>
          <span className="suivi-label sm:hidden">Synth√®se</span>
          <span className="suivi-label hidden sm:inline">Synth√®se des comp√©tences √©l√®ves</span>
        </button>

        <button
          type="button"
          onClick={() => setSuiviMode("evolutions")}
          className={classNames(
            "suivi-btn inline-flex items-center rounded-full transition",
            suiviMode === "evolutions"
              ? "bg-neutral-900 text-white"
              : "bg-transparent text-neutral-700 dark:text-neutral-300 hover:bg-amber-100/70 dark:bg-[var(--night-surface)] dark:hover:bg-[var(--night-hover)]"
          )}
        >
          <span className="suivi-icon" aria-hidden="true">üìà</span>
          <span className="suivi-label sm:hidden">√âvol.</span>
          <span className="suivi-label hidden sm:inline">√âvolutions des comp√©tences</span>
        </button>

        <button
          type="button"
          onClick={() => setSuiviMode("bilan")}
          className={classNames(
            "suivi-btn inline-flex items-center rounded-full transition",
            suiviMode === "bilan"
              ? "bg-neutral-900 text-white"
              : "bg-transparent text-neutral-700 dark:text-neutral-300 hover:bg-amber-100/70 dark:bg-[var(--night-surface)] dark:hover:bg-[var(--night-hover)]"
          )}
        >
          <span className="suivi-icon" aria-hidden="true">üóìÔ∏è</span>
          <span className="suivi-label sm:hidden">Bilan</span>
          <span className="suivi-label hidden sm:inline">Bilan p√©riodique</span>
        </button>
      </div>
    </div>

    {/* Ann√©e / Classe / √âl√®ve (au m√™me niveau que les sous-onglets) */}
    <div className="flex flex-wrap items-end gap-2 sm:ml-auto sm:justify-end">
      {/* Ann√©e : 1√®re / 2√®me */}
      <div className="suivi-tabs inline-flex rounded-full border border-neutral-200 dark:border-sky-400/35 bg-neutral-50 dark:bg-[var(--night-surface)] p-1">
        <button
          type="button"
          onClick={() => switchTrainingYear("premiere")}
          className={classNames(
            "suivi-btn inline-flex items-center rounded-full transition",
            trainingYear === "premiere"
              ? "bg-neutral-900 text-white"
              : "bg-transparent text-neutral-700 dark:text-neutral-300 hover:bg-amber-100/70 dark:hover:bg-[var(--night-hover)]"
          )}
        >
          1√®re
        </button>
        <button
          type="button"
          onClick={() => switchTrainingYear("deuxieme")}
          className={classNames(
            "suivi-btn inline-flex items-center rounded-full transition",
            trainingYear === "deuxieme"
              ? "bg-neutral-900 text-white"
              : "bg-transparent text-neutral-700 dark:text-neutral-300 hover:bg-amber-100/70 dark:hover:bg-[var(--night-hover)]"
          )}
        >
          2√®me
        </button>
      </div>

      {/* Classe */}
      <select
        className="h-8 w-[170px] sm:w-[220px] border border-neutral-300 dark:border-sky-400/35 rounded-md bg-white dark:bg-[var(--night-surface)] px-2 text-xs"
        value={selectedClassIdForSuivi ?? ""}
        onChange={(e) => {
          const next = e.target.value || null;
          setSelectedClassIdForSuivi(next);
          setSelectedStudentForSuivi(null);
          setSelectedEvalIdForClasse(null);
        }}
      >
        <option value="" disabled>Classe‚Ä¶</option>
        {classGroups.map((c) => (
          <option key={c.id} value={c.name}>
            {c.name}
          </option>
        ))}
      </select>

      {/* √âl√®ve */}
      {(() => {
        const classe = classGroups.find((c) => c.name === selectedClassIdForSuivi);
        const students = classe
          ? (classe.students || "")
              .split("\n")
              .map((s) => s.trim())
              .filter(Boolean)
          : [];
        const disabled = !classe || students.length === 0;

        return (
          <select
            className="h-8 w-[130px] sm:w-[160px] border border-neutral-300 dark:border-sky-400/35 rounded-md bg-white dark:bg-[var(--night-surface)] px-2 text-xs disabled:opacity-60"
            value={selectedStudentForSuivi ?? ""}
            onChange={(e) => setSelectedStudentForSuivi(e.target.value)}
            disabled={disabled}
          >
            <option value="" disabled>√âl√®ve‚Ä¶</option>
            {students.map((st) => (
              <option key={st} value={st}>
                {st}
              </option>
            ))}
          </select>
        );
      })()}
    </div>

  </div>
</div>

            {/* üîª CONTENU SOUS LE BANDEAU (scrollable) */}
            <div className="mt-4 space-y-4 pb-12">
              {/* === VUE √âL√àVE === */}
              {suiviMode === "eleve" && (
                !classe || !selectedStudentForSuivi ? (
                  <p className="text-sm text-neutral-600 dark:text-neutral-300">
                    S√©lectionnez une classe puis un √©l√®ve pour afficher le suivi des comp√©tences.
                  </p>
                ) : (
                  (() => {
                    const classId = classe.name;
                    const studentName = selectedStudentForSuivi;
                    const schoolYear = getCurrentSchoolYear();

                    const studentRecord = skillsDB[classId]?.[studentName] || {};

                    // Devoirs de la classe utilisables (S1/S2) tri√©s
                    const evalsForClass = evalMetaList
                      .filter(
                        (ev) =>
                          ev.group === classId &&
                          ev.semester !== "Ne pas utiliser de semestre"
                      )
                      .slice()
                      .sort((a, b) => {
                        if (a.semester !== b.semester) {
                          if (a.semester === "S1") return -1;
                          if (b.semester === "S1") return 1;
                        }
                        return (a.createdAt || "").localeCompare(b.createdAt || "");
                      });

                    const evalsS1 = evalsForClass.filter((ev) => ev.semester === "S1");
                    const evalsS2 = evalsForClass.filter((ev) => ev.semester === "S2");

                    const allowedEvalIds = new Set(evalsForClass.map((ev) => ev.id));
                    const allowedEvalNames = new Set(evalsForClass.map((ev) => ev.name));
                    const epByComp = {
                      EP1: new Set(["C1.01", "C2.01", "C2.02"]),
                      EP2: new Set([
                        "C2.03",
                        "C3.01",
                        "C3.02",
                        "C3.04",
                        "C3.06",
                        "C3.09",
                        "C3.10",
                        "C3.11",
                        "C3.12",
                        "C3.15",
                        "C3.16",
                        "C3.17",
                        "C4.01",
                        "C4.02",
                      ]),
                      EP3: new Set(["C1.02", "C3.03", "C3.05", "C3.07", "C3.08", "C3.13", "C3.14"]),
                    } as const;

                    const getEpForComp = (
                      code: string
                    ): "EP1" | "EP2" | "EP3" | null => {
                      if (epByComp.EP1.has(code)) return "EP1";
                      if (epByComp.EP2.has(code)) return "EP2";
                      if (epByComp.EP3.has(code)) return "EP3";
                      return null;
                    };


                    // Toutes les comp√©tences √† partir du tcMap
                    const allCompetenceDefs = Array.from(
                      new Set(Object.values(tcMap).flat())
                    )
                      .map((compStr) => {
                        const code = compactCode(compStr);
                        const label = compStr
                          .replace(/^C\s*\d+\.\d+\s*[:.]\s*/, "")
                          .trim();
                        return { code, label };
                      })
                      .sort((a, b) =>
                        a.code.localeCompare(b.code, "fr", {
                          numeric: true,
                          sensitivity: "base",
                        })
                      );

                    // üîπ Compter le NOMBRE DE CRIT√àRES not√©s par comp√©tence et par semestre
                    const countsByComp: Record<string, { S1: number; S2: number }> = {};

                    try {
                      const yearBucket = (notationDB as any)?.[schoolYear] || {};
                      const classBucket = yearBucket[classId] || {};

                      Object.entries(classBucket).forEach(([bucketKey, evalBucketAny]) => {
                        const evalBucket = evalBucketAny as Record<string, NotationEntry>;
                        const entry = evalBucket[studentName];
                        const entryAny = entry as any;
                        if (!entryAny || !entryAny.scoresByCriteria) return;

                        // Support nouveau format (id) + legacy (nom) + m√©tadonn√©es stock√©es dans l'entr√©e
                        const isActive =
                          allowedEvalIds.has(bucketKey) ||
                          allowedEvalNames.has(bucketKey) ||
                          (entryAny.evalId && allowedEvalIds.has(entryAny.evalId)) ||
                          (entryAny.evalName && allowedEvalNames.has(entryAny.evalName));
                        if (!isActive) return;

                        const sem = entryAny.semester;
                        if (sem !== "S1" && sem !== "S2") return;

                        Object.keys(entryAny.scoresByCriteria).forEach((critKey) => {
                          const score = entryAny.scoresByCriteria?.[critKey];
                          if (typeof score !== "number" || !isFinite(score) || score <= 0) return; // crit√®re non not√© / NR

                          // critKey = `${task}||${comp}::${item}::crit#${idx}`
                          const parts = critKey.split("||");
                          if (parts.length < 2) return;
                          const rest = parts[1];
                          const compPart = rest.split("::")[0] || "";

                          const code = compactCode(compPart); // ex : "C2.02"
                          if (!code) return;

                          if (!countsByComp[code]) {
                            countsByComp[code] = { S1: 0, S2: 0 };
                          }
                          if (sem === "S1") countsByComp[code].S1++;
                          else if (sem === "S2") countsByComp[code].S2++;
                        });
                      });
                    } catch (e) {
                      console.warn(
                        "Erreur lors du calcul des compteurs crit√®re/comp√©tence :",
                        e
                      );
                    }

                    
                    // üîé Fallback : calcule le niveau √† partir des notes enregistr√©es (notationDB),
                    // utile si le skillsDB n'a pas √©t√© rempli / migr√©.
                    const computeLevelFromNotation = (
                      ev: { id: string; name: string },
                      compCode: string
                    ): Level1to4 | null => {
                      const classBucket =
                        (notationDB as any)?.[schoolYear]?.[classId] || {};
                      const evalBucket = classBucket?.[ev.id] || classBucket?.[ev.name];
                      const entry = evalBucket?.[studentName];

                      const scores: Record<string, any> =
                        (entry as any)?.scoresByCriteria || {};
                      const weights: Record<string, any> =
                        (weightsByEvalId as any)?.[ev.id] || {};

                      let weighted = 0;
                      let totalWeight = 0;

                      Object.entries(scores).forEach(([critKey, score]) => {
                        if (typeof score !== "number" || !isFinite(score) || score <= 0) return;
                        if (!critKey.includes("||")) return;

                        const right = (critKey.split("||")[1] || "").trim();
                        const compLabel = (right.split("::")[0] || "").trim();

                        if (compactCode(compLabel) !== compCode) return;

                        const wRaw = (weights as any)[critKey];
                        const w = typeof wRaw === "number" ? wRaw : 1;
                        if (!isFinite(w) || w <= 0) return;

                        weighted += score * w;
                        totalWeight += w;
                      });

                      if (totalWeight <= 0) return null;

                      const avg = weighted / totalWeight;
                      if (avg < 1.5) return 1;
                      else if (avg < 2.5) return 2;
                      else if (avg < 3.5) return 3;
                      else return 4;
                    };

// üîπ On stocke toutes les valeurs pour pouvoir faire une moyenne
                    const semesterAgg: Record<
                      string,
                      { label: string; S1Vals: number[]; S2Vals: number[] }
                    > = {};

                    Object.entries(studentRecord).forEach(([rawLabel, semLevels]) => {
                      // On ignore les entr√©es li√©es √† des devoirs qui ne sont plus dans la classe (√©vite les "fant√¥mes" en synth√®se)
                      let compPart = rawLabel;
                      if (rawLabel.includes("||")) {
                        const [left, compRaw] = rawLabel.split("||");
                        const key = (left || "").trim();
                        const isActive =
                          allowedEvalIds.has(key) || allowedEvalNames.has(key); // support legacy (nom) + nouveau (id)
                        if (!isActive) return;
                        compPart = (compRaw || "").trim();
                      }

                      const code = compactCode(compPart);
                      const text = compPart
                        .replace(/^C\s*\d+\.\d+\s*[:.]\s*/, "")
                        .trim();

                      if (!semesterAgg[code]) {
                        semesterAgg[code] = { label: text, S1Vals: [], S2Vals: [] };
                      }

                      (["S1", "S2"] as SemesterKey[]).forEach((sem) => {
                        const v = (semLevels as any)[sem];
                        if (typeof v === "number") {
                          if (sem === "S1") {
                            semesterAgg[code].S1Vals.push(v);
                          } else if (sem === "S2") {
                            semesterAgg[code].S2Vals.push(v);
                          }
                        }
                      });
                    });

                    
                    // --- R√©f√©rence 1√®re ann√©e (S1/S2 + moyenne) pour la vue 2√®me ann√©e ---
                    const showPremiereSynth = trainingYear === "deuxieme";

                    const evalsForClassPremiere = showPremiereSynth
                      ? evalMetaListPremiere
                          .filter(
                            (ev) =>
                              ev.group === classId &&
                              ev.semester !== "Ne pas utiliser de semestre"
                          )
                          .slice()
                          .sort((a, b) => {
                            if (a.semester !== b.semester) {
                              if (a.semester === "S1") return -1;
                              if (b.semester === "S1") return 1;
                            }
                            return (a.createdAt || "").localeCompare(b.createdAt || "");
                          })
                      : [];

                    const evalsS1Premiere = evalsForClassPremiere.filter(
                      (ev) => ev.semester === "S1"
                    );
                    const evalsS2Premiere = evalsForClassPremiere.filter(
                      (ev) => ev.semester === "S2"
                    );

                    const allowedEvalIdsPremiere = new Set(
                      evalsForClassPremiere.map((ev) => ev.id)
                    );
                    const allowedEvalNamesPremiere = new Set(
                      evalsForClassPremiere.map((ev) => ev.name)
                    );

                    const studentRecordPremiere = showPremiereSynth
                      ? (skillsDBPremiere as any)?.[classId]?.[studentName] || {}
                      : {};

                    // Agr√©gat niveaux 1√®re ann√©e, par comp√©tence et par semestre
                    const semesterAggPremiere: Record<
                      string,
                      { label: string; S1Vals: number[]; S2Vals: number[] }
                    > = {};

                    if (showPremiereSynth) {
                      Object.entries(studentRecordPremiere).forEach(
                        ([rawLabel, semLevels]) => {
                          // Filtre "fant√¥mes"
                          let compPart = rawLabel;
                          if (rawLabel.includes("||")) {
                            const [left, compRaw] = rawLabel.split("||");
                            const key = (left || "").trim();
                            const isActive =
                              allowedEvalIdsPremiere.has(key) ||
                              allowedEvalNamesPremiere.has(key);
                            if (!isActive) return;
                            compPart = (compRaw || "").trim();
                          }

                          const code = compactCode(compPart);
                          const text = compPart
                            .replace(/^C\s*\d+\.\d+\s*[:.]\s*/, "")
                            .trim();

                          if (!semesterAggPremiere[code]) {
                            semesterAggPremiere[code] = {
                              label: text,
                              S1Vals: [],
                              S2Vals: [],
                            };
                          }

                          (["S1", "S2"] as SemesterKey[]).forEach((sem) => {
                            const v = (semLevels as any)[sem];
                            if (typeof v === "number") {
                              if (sem === "S1") {
                                semesterAggPremiere[code].S1Vals.push(v);
                              } else if (sem === "S2") {
                                semesterAggPremiere[code].S2Vals.push(v);
                              }
                            }
                          });
                        }
                      );
                    }

                    const resolveSchoolYearFor = (
                      db: any,
                      preferred: string,
                      cls: string
                    ): string | null => {
                      if (db?.[preferred]?.[cls]) return preferred;
                      const keys = Object.keys(db || {});
                      const candidates = keys.filter((k) => db?.[k]?.[cls]);
                      if (candidates.length === 0) return null;

                      const startYear = (k: string) => {
                        const m = String(k).match(/^(\d{4})/);
                        return m ? parseInt(m[1], 10) : 0;
                      };

                      candidates.sort((a, b) => startYear(b) - startYear(a));
                      return candidates[0] || null;
                    };

                    const schoolYearPremiere = resolveSchoolYearFor(
                      notationDBPremiere as any,
                      schoolYear,
                      classId
                    );

                    const countsByCompPremiere: Record<
                      string,
                      { S1: number; S2: number }
                    > = {};

                    try {
                      if (showPremiereSynth && schoolYearPremiere) {
                        const yearBucket =
                          (notationDBPremiere as any)?.[schoolYearPremiere] || {};
                        const classBucket = yearBucket[classId] || {};

                        Object.entries(classBucket).forEach(
                          ([bucketKey, evalBucketAny]) => {
                            const evalBucket = evalBucketAny as Record<
                              string,
                              NotationEntry
                            >;
                            const entry = evalBucket[studentName];
                            const entryAny = entry as any;
                            if (!entryAny || !entryAny.scoresByCriteria) return;

                            const isActive =
                              allowedEvalIdsPremiere.has(bucketKey) ||
                              allowedEvalNamesPremiere.has(bucketKey) ||
                              (entryAny.evalId &&
                                allowedEvalIdsPremiere.has(entryAny.evalId)) ||
                              (entryAny.evalName &&
                                allowedEvalNamesPremiere.has(entryAny.evalName));
                            if (!isActive) return;

                            const sem = entryAny.semester;
                            if (sem !== "S1" && sem !== "S2") return;

                            Object.keys(entryAny.scoresByCriteria).forEach((critKey) => {
                              const score = entryAny.scoresByCriteria?.[critKey];
                              if (typeof score !== "number" || !isFinite(score) || score <= 0) return;

                              const parts = critKey.split("||");
                              if (parts.length < 2) return;
                              const rest = parts[1];
                              const compPart = rest.split("::")[0] || "";
                              const code = compactCode(compPart);
                              if (!code) return;

                              if (!countsByCompPremiere[code]) {
                                countsByCompPremiere[code] = { S1: 0, S2: 0 };
                              }
                              if (sem === "S1") countsByCompPremiere[code].S1++;
                              else if (sem === "S2")
                                countsByCompPremiere[code].S2++;
                            });
                          }
                        );
                      }
                    } catch (e) {
                      console.warn(
                        "Erreur lors du calcul des compteurs 1√®re ann√©e :",
                        e
                      );
                    }

                    const computeLevelFromNotationPremiere = (
                      ev: { id: string; name: string },
                      compCode: string
                    ): Level1to4 | null => {
                      if (!showPremiereSynth || !schoolYearPremiere) return null;

                      const classBucket =
                        (notationDBPremiere as any)?.[schoolYearPremiere]?.[classId] ||
                        {};
                      const evalBucket = classBucket?.[ev.id] || classBucket?.[ev.name];
                      const entry = evalBucket?.[studentName];

                      const scores: Record<string, any> =
                        (entry as any)?.scoresByCriteria || {};
                      const weights: Record<string, any> =
                        (weightsByEvalId as any)?.[ev.id] || {};

                      let weighted = 0;
                      let totalWeight = 0;

                      Object.entries(scores).forEach(([critKey, score]) => {
                        if (typeof score !== "number" || !isFinite(score) || score <= 0) return;
                        if (!critKey.includes("||")) return;

                        const right = (critKey.split("||")[1] || "").trim();
                        const compLabel = (right.split("::")[0] || "").trim();
                        if (compactCode(compLabel) !== compCode) return;

                        const wRaw = (weights as any)[critKey];
                        const w = typeof wRaw === "number" ? wRaw : 1;
                        if (!isFinite(w) || w <= 0) return;

                        weighted += score * w;
                        totalWeight += w;
                      });

                      if (totalWeight <= 0) return null;

                      const avg = weighted / totalWeight;
                      if (avg < 1.5) return 1;
                      else if (avg < 2.5) return 2;
                      else if (avg < 3.5) return 3;
                      else return 4;
                    };

// üîπ On convertit en lignes avec une MOYENNE par semestre
                    const rows = allCompetenceDefs.map(({ code, label }) => {
                      const agg = semesterAgg[code];
                      const counts = countsByComp[code] || { S1: 0, S2: 0 };

                      let S1: Level1to4 | undefined;
                      let S2: Level1to4 | undefined;
                      let finalLabel = label;

                      if (agg) {
                        finalLabel = agg.label || label;

                        if (agg.S1Vals.length > 0) {
                          const avg =
                            agg.S1Vals.reduce((sum, v) => sum + v, 0) /
                            agg.S1Vals.length;

                          if (avg < 1.5) S1 = 1;
                          else if (avg < 2.5) S1 = 2;
                          else if (avg < 3.5) S1 = 3;
                          else S1 = 4;
                        }

                        if (agg.S2Vals.length > 0) {
                          const avg =
                            agg.S2Vals.reduce((sum, v) => sum + v, 0) /
                            agg.S2Vals.length;

                          if (avg < 1.5) S2 = 1;
                          else if (avg < 2.5) S2 = 2;
                          else if (avg < 3.5) S2 = 3;
                          else S2 = 4;
                        }
                      }

                      // Fallback : si skillsDB ne fournit pas de synth√®se, on calcule √† partir de notationDB
                      if (S1 == null) {
                        const vals = evalsS1
                          .map((ev) => computeLevelFromNotation(ev, code))
                          .filter((v): v is Level1to4 => typeof v === "number");

                        if (vals.length > 0) {
                          const avg =
                            vals.reduce((sum, v) => sum + v, 0) / vals.length;

                          if (avg < 1.5) S1 = 1;
                          else if (avg < 2.5) S1 = 2;
                          else if (avg < 3.5) S1 = 3;
                          else S1 = 4;
                        }
                      }

                      if (S2 == null) {
                        const vals = evalsS2
                          .map((ev) => computeLevelFromNotation(ev, code))
                          .filter((v): v is Level1to4 => typeof v === "number");

                        if (vals.length > 0) {
                          const avg =
                            vals.reduce((sum, v) => sum + v, 0) / vals.length;

                          if (avg < 1.5) S2 = 1;
                          else if (avg < 2.5) S2 = 2;
                          else if (avg < 3.5) S2 = 3;
                          else S2 = 4;
                        }
                      }

                      const countAll = counts.S1 + counts.S2;

                      const toLevel = (avg: number): Level1to4 => {
                        if (avg < 1.5) return 1;
                        if (avg < 2.5) return 2;
                        if (avg < 3.5) return 3;
                        return 4;
                      };

                      let ALL: Level1to4 | undefined;

                      const allValsFromSkills: number[] = [];
                      if (agg) {
                        allValsFromSkills.push(...agg.S1Vals, ...agg.S2Vals);
                      }
                      if (allValsFromSkills.length > 0) {
                        const avg =
                          allValsFromSkills.reduce((sum, v) => sum + v, 0) /
                          allValsFromSkills.length;
                        ALL = toLevel(avg);
                      }

                      // Fallback global (tous les devoirs) : utile si skillsDB est incomplet
                      if (ALL == null) {
                        const vals = evalsForClass
                          .map((ev) => computeLevelFromNotation(ev, code))
                          .filter((v): v is Level1to4 => typeof v === "number");

                        if (vals.length > 0) {
                          const avg = vals.reduce((sum, v) => sum + v, 0) / vals.length;
                          ALL = toLevel(avg);
                        }
                      }

                      // --- Synth√®ses 1√®re ann√©e (r√©f√©rence) ---
                      let prevS1: Level1to4 | undefined;
                      let prevS2: Level1to4 | undefined;
                      let prevMean: Level1to4 | undefined;

                      const prevCounts = (countsByCompPremiere as any)?.[code] || {
                        S1: 0,
                        S2: 0,
                      };
                      const prevCountS1 = prevCounts.S1 || 0;
                      const prevCountS2 = prevCounts.S2 || 0;
                      const prevCountAll = prevCountS1 + prevCountS2;

                      if (showPremiereSynth) {
                        const aggP = (semesterAggPremiere as any)?.[code];

                        if (aggP) {
                          if (Array.isArray(aggP.S1Vals) && aggP.S1Vals.length > 0) {
                            const avg =
                              aggP.S1Vals.reduce((sum: number, v: number) => sum + v, 0) /
                              aggP.S1Vals.length;

                            if (avg < 1.5) prevS1 = 1;
                            else if (avg < 2.5) prevS1 = 2;
                            else if (avg < 3.5) prevS1 = 3;
                            else prevS1 = 4;
                          }

                          if (Array.isArray(aggP.S2Vals) && aggP.S2Vals.length > 0) {
                            const avg =
                              aggP.S2Vals.reduce((sum: number, v: number) => sum + v, 0) /
                              aggP.S2Vals.length;

                            if (avg < 1.5) prevS2 = 1;
                            else if (avg < 2.5) prevS2 = 2;
                            else if (avg < 3.5) prevS2 = 3;
                            else prevS2 = 4;
                          }
                        }

                        if (prevS1 == null) {
                          const vals = evalsS1Premiere
                            .map((ev) => computeLevelFromNotationPremiere(ev, code))
                            .filter((v): v is Level1to4 => typeof v === "number");

                          if (vals.length > 0) {
                            const avg =
                              vals.reduce((sum, v) => sum + v, 0) / vals.length;
                            prevS1 = toLevel(avg);
                          }
                        }

                        if (prevS2 == null) {
                          const vals = evalsS2Premiere
                            .map((ev) => computeLevelFromNotationPremiere(ev, code))
                            .filter((v): v is Level1to4 => typeof v === "number");

                          if (vals.length > 0) {
                            const avg =
                              vals.reduce((sum, v) => sum + v, 0) / vals.length;
                            prevS2 = toLevel(avg);
                          }
                        }

                        const meanVals: number[] = [];
                        if (typeof prevS1 === "number") meanVals.push(prevS1);
                        if (typeof prevS2 === "number") meanVals.push(prevS2);

                        if (meanVals.length > 0) {
                          const avg =
                            meanVals.reduce((sum, v) => sum + v, 0) / meanVals.length;
                          prevMean = toLevel(avg);
                        }
                      }

                      return {
                        code,
                        label: finalLabel,
                        S1,
                        S2,
                        ALL,
                        countS1: counts.S1,
                        countS2: counts.S2,
                        countAll,
                        prevS1,
                        prevS2,
                        prevMean,
                        prevCountS1,
                        prevCountS2,
                        prevCountAll,
                      };
                    });

                    const renderStaticLevelDot = (level?: number | null) => {
                      if (!level) return null;

                      let cls = "";
                      if (level === 1) cls = "bg-red-500 border-red-500";
                      else if (level === 2)
                        cls = "bg-orange-400 border-orange-400";
                      else if (level === 3)
                        cls = "bg-emerald-300 border-emerald-300";
                      else cls = "bg-emerald-600 border-emerald-600";

                      return (
                        <div
                          className={
                            "inline-block w-3 h-3 shrink-0 rounded-full border " + cls
                          }
                        />
                      );
                    };

                    const renderMiniLegend = (variant: "numeric" | "ep" = "numeric") => {
                      const levels: (1 | 2 | 3 | 4)[] = [1, 2, 3, 4];

                      const labelFor = (val: 1 | 2 | 3 | 4) => {
                        if (variant === "ep") {
                          if (val === 1) return "NE";
                          if (val === 2) return "NA";
                          if (val === 3) return "EA";
                          return "A";
                        }
                        return String(val);
                      };

                      const getColorFor = (val: 1 | 2 | 3 | 4) => {
                        if (val === 1) return "bg-red-500";
                        if (val === 2) return "bg-orange-400";
                        if (val === 3) return "bg-emerald-400";
                        return "bg-emerald-600";
                      };

                      return (
                        <div className="flex w-full overflow-hidden rounded-[2px] mt-1">
                          {levels.map((val) => (
                            <div
                              key={val}
                              className={
                                "flex-1 flex items-center justify-center h-[12px] " +
                                "text-[10px] font-semibold text-white " +
                                getColorFor(val)
                              }
                            >
                              {labelFor(val)}
                            </div>
                          ))}
                        </div>
                      );
                    };

                    const renderHistogramCell = (level?: number, count?: number) => {
                      if (level == null || isNaN(level)) {
                        return (
                          <span className="text-[10px] text-neutral-400">
                            -
                          </span>
                        );
                      }

                      const pct = Math.max(
                        0,
                        Math.min(100, (level / 4) * 100)
                      );

                      const rounded = Math.min(
                        4,
                        Math.max(1, Math.round(level))
                      ) as 1 | 2 | 3 | 4;
                      const getColorFor = (val: 1 | 2 | 3 | 4) => {
                        if (val === 1) return "bg-red-500";
                        if (val === 2) return "bg-orange-400";
                        if (val === 3) return "bg-emerald-400";
                        return "bg-emerald-600";
                      };

                      const barColor = getColorFor(rounded);

                      return (
                        <div className="flex items-center gap-[4px]">
                          <div className="flex-1">
                            <div className="w-full h-[10px] bg-neutral-200 dark:bg-[var(--night-panel)] rounded">
                              <div
                                className={`h-[10px] rounded ${barColor}`}
                                style={{ width: `${pct}%` }}
                              />
                            </div>
                          </div>

                          {typeof count === "number" && count > 0 && (
                            <span className="text-[10px] text-neutral-600 dark:text-neutral-300 font-semibold">
                              {count}
                            </span>
                          )}
                        </div>
                      );
                    };

return (
  <div className="mt-4 space-y-4 pb-12">
<div
  ref={suiviElevePdfRef}
  className=""
>
      <div className="no-print px-3 py-2  border-neutral  text-[12px] font-semibold flex items-center justify-between gap-2">
  <span>
    Suivi de {studentName}
  </span>
</div>

{evalsForClass.length === 0 ? (
  <div className="p-3 text-[12px] text-neutral-500">
    Aucun devoir enregistr√© pour cette classe.
  </div>
) : (
  <table className="min-w-full border-collapse text-[11px] leading-tight text-neutral-900 dark:text-neutral-300">
    <thead>

        {/* Colonne Famille */}
        <th
          rowSpan={2}
          className="border border-neutral-300 dark:border-sky-400/35 bg-white dark:bg-[var(--night-panel)] sticky left-0 z-30 w-10 px-1 py-2 text-[11px] font-semibold text-neutral-700 dark:text-neutral-300 text-center align-middle"
        >
          <span className="app-verticalHeader">
          </span>
        </th>

        {/* Colonne Comp√©tences */}
        <th
          rowSpan={2}
          className="border border-neutral-300 dark:border-sky-400/35 bg-white dark:bg-[var(--night-panel)] sticky left-0 z-20 w-80 px-3 py-2 align-middle text-[14px] font-semibold text-neutral-700 dark:text-neutral-300"
        >
          COMP√âTENCES
        </th>

        {/* Synth√®ses 1√®re ann√©e (r√©f√©rence) ‚Äì affich√©es en 2√®me ann√©e */}
        {trainingYear === "deuxieme" && (
          <>
            
            
            <th
              rowSpan={2}
              className="border border-neutral-300 dark:border-sky-400/35 bg-sky-50 dark:bg-sky-950/35 px-1 py-1 text-center align-top w-[80px] min-w-[80px] max-w-[80px]"
            >
              <div className="flex flex-col h-full">
                <span className="mb-0 leading-tight">Synth√®se 1A</span>
                <span className="mb-1 text-[9px] text-neutral-600 dark:text-neutral-300 leading-tight">(moy S1+S2)</span>
                <div className="mt-auto w-full flex justify-center">
                  {renderMiniLegend()}
                </div>
              </div>
            </th>
          </>
        )}

        {/* Bandeau S1 */}
        {evalsS1.length > 0 && (
          <th
            colSpan={evalsS1.length}
            className="border border-neutral-300 dark:border-sky-400/35 bg-amber-100 dark:bg-amber-950/45 px-2 py-1 text-center text-[11px] font-semibold"
          >
            SEMESTRE 1
          </th>
        )}

        {/* S√©paration */}
        <th rowSpan={2} className="w-4 bg-white dark:bg-[var(--night-panel)]" aria-hidden="true" />

        {/* Bandeau S2 */}
        {evalsS2.length > 0 && (
          <th
            colSpan={evalsS2.length}
            className="border border-neutral-300 dark:border-sky-400/35 bg-lime-100 dark:bg-lime-950/45 px-2 py-1 text-center text-[11px] font-semibold"
          >
            SEMESTRE 2
          </th>
        )}

        {/* S√©paration */}
        <th rowSpan={2} className="w-4 bg-white dark:bg-[var(--night-panel)]" aria-hidden="true" />

                {/* Synth√®ses / √âpreuves (2e ann√©e) */}
        {trainingYear === "deuxieme" ? (
          <>
            <th
              rowSpan={2}
              className="border border-neutral-300 dark:border-sky-400/35 bg-sky-50 dark:bg-sky-950/35 px-1 py-1 text-center align-top w-[40px] max-w-[40px]"
            >
              <div className="flex flex-col h-full">
                <span className="mb-1">EP1</span>
                <div className="text-[9px] text-neutral-600 dark:text-neutral-300 leading-tight">
                  √âtude et pr√©paration d&apos;une intervention
                </div>
                <div className="mt-auto w-full flex justify-center">
                  {renderMiniLegend("ep")}
                </div>
              </div>
            </th>

            <th
              rowSpan={2}
              className="border border-neutral-300 dark:border-sky-400/35 bg-sky-50 dark:bg-sky-950/35 px-1 py-1 text-center align-top w-[40px] max-w-[40px]"
            >
              <div className="flex flex-col h-full">
                <span className="mb-1">EP2</span>
                <div className="text-[9px] text-neutral-600 dark:text-neutral-300 leading-tight">
                  R√©alisation et contr√¥le d&apos;un ouvrage
                </div>
                <div className="mt-auto w-full flex justify-center">
                  {renderMiniLegend("ep")}
                </div>
              </div>
            </th>

            <th
              rowSpan={2}
              className="border border-neutral-300 dark:border-sky-400/35 bg-sky-50 dark:bg-sky-950/35 px-1 py-1 text-center align-top w-[40px] max-w-[40px]"
            >
              <div className="flex flex-col h-full">
                <span className="mb-1">EP3</span>
                <div className="text-[9px] text-neutral-600 dark:text-neutral-300 leading-tight">
                  R√©alisation de travaux sp√©cifiques
                </div>
                <div className="mt-auto w-full flex justify-center">
                  {renderMiniLegend("ep")}
                </div>
              </div>
            </th>
          </>
        ) : (
          <>
            <th
              rowSpan={2}
              className="border border-neutral-300 dark:border-sky-400/35 bg-sky-50 dark:bg-sky-950/35 px-1 py-1 text-center align-top w-[80px] max-w-[80px]"
            >
              <div className="flex flex-col h-full">
                <span className="mb-1">Synth√®se S1</span>
                <div className="mt-auto w-full flex justify-center">
                  {renderMiniLegend()}
                </div>
              </div>
            </th>

            <th
              rowSpan={2}
              className="border border-neutral-300 dark:border-sky-400/35 bg-sky-50 dark:bg-sky-950/35 px-1 py-1 text-center align-top w-[80px] max-w-[80px]"
            >
              <div className="flex flex-col h-full">
                <span className="mb-1">Synth√®se S2</span>
                <div className="mt-auto w-full flex justify-center">
                  {renderMiniLegend()}
                </div>
              </div>
            </th>
          </>
        )}

<tr>
        {/* En-t√™tes devoirs S1 */}
        {evalsS1.map((ev) => (
          <th
            key={ev.id}
            className="border border-neutral-300 dark:border-sky-400/35 text-center px-0 py-0 align-bottom bg-white dark:bg-[var(--night-surface)] w-[22px]"
          >
            <div className="h-[90px] flex flex-col items-center justify-end gap-1 py-1">
             
              <span
                className="text-[10px] font-medium leading-tight text-neutral-700 dark:text-neutral-300 app-verticalHeader"
                title={ev.name}
              >
                {ev.name}
              </span>
            </div>
          </th>
        ))}

        {/* En-t√™tes devoirs S2 */}
        {evalsS2.map((ev) => (
          <th
            key={ev.id}
            className="border border-neutral-300 dark:border-sky-400/35 text-center px-0 py-0 align-bottom bg-white dark:bg-[var(--night-surface)] w-[22px]"
          >
            <div className="h-[110px] flex flex-col items-center justify-end gap-1 py-1">

              <span
                className="text-[10px] font-medium leading-tight text-neutral-700 dark:text-neutral-300 app-verticalHeader"
                title={ev.name}
              >
                {ev.name}
              </span>
            </div>
          </th>
        ))}
      </tr>
    </thead>

    <tbody>
      {rows.map((row, rowIndex) => {
        const fam = parseCompetencyFamily(row.code);
        const prevFam =
          rowIndex > 0 ? parseCompetencyFamily(rows[rowIndex - 1].code) : undefined;
        const nextFam =
          rowIndex < rows.length - 1 ? parseCompetencyFamily(rows[rowIndex + 1].code) : undefined;

        const hasFam = fam === "C1" || fam === "C2" || fam === "C3" || fam === "C4";
        const isFamFirst = hasFam && fam !== prevFam;
        const isFamLast = hasFam && fam !== nextFam;

        const famTopColor =
          fam === "C1" ? "border-t-sky-400" :
          fam === "C2" ? "border-t-amber-400" :
          fam === "C3" ? "border-t-lime-400" :
          fam === "C4" ? "border-t-fuchsia-400" : "";

        const famBottomColor =
          fam === "C1" ? "border-b-sky-400" :
          fam === "C2" ? "border-b-amber-400" :
          fam === "C3" ? "border-b-lime-400" :
          fam === "C4" ? "border-b-fuchsia-400" : "";

        const famLeftColor =
          fam === "C1" ? "border-l-sky-400" :
          fam === "C2" ? "border-l-amber-400" :
          fam === "C3" ? "border-l-lime-400" :
          fam === "C4" ? "border-l-fuchsia-400" : "";

        const famRightColor =
          fam === "C1" ? "border-r-sky-400" :
          fam === "C2" ? "border-r-amber-400" :
          fam === "C3" ? "border-r-lime-400" :
          fam === "C4" ? "border-r-fuchsia-400" : "";

        const famBg =
          fam === "C1" ? "bg-sky-50 dark:bg-sky-950/35" :
          fam === "C2" ? "bg-amber-50 dark:bg-amber-950/35" :
          fam === "C3" ? "bg-lime-50 dark:bg-lime-950/35" :
          fam === "C4" ? "bg-fuchsia-50 dark:bg-fuchsia-950/35" : "bg-white dark:bg-[var(--night-panel)]";

        const topThicknessClass = hasFam && isFamFirst ? "border-t-2" : hasFam ? "border-t" : "";
        const bottomThicknessClass = hasFam && isFamLast ? "border-b-2" : hasFam ? "border-b" : "";
        const topColorClass = hasFam && isFamFirst ? famTopColor : "";
        const bottomColorClass = hasFam && isFamLast ? famBottomColor : "";

        // RowSpan Famille
        let famRowSpan = 0;
        if (hasFam && isFamFirst) {
          let span = 1;
          for (let i = rowIndex + 1; i < rows.length; i++) {
            if (parseCompetencyFamily(rows[i].code) !== fam) break;
            span++;
          }
          famRowSpan = span;
        }

        const famLabel =
          fam === "C1" ? "COM." :
          fam === "C2" ? "PR√âP." :
          fam === "C3" ? "R√âAL." :
          fam === "C4" ? "CONT." : "";

        const CELL_W = 20;
        const CELL_H = 12;

        return (
          <tr
            key={row.code}
            className="odd:bg-white even:bg-neutral-50 hover:bg-amber-100/70/80 dark:odd:bg-[var(--night-panel)] dark:even:bg-[var(--night-panel)] dark:hover:bg-[var(--night-hover)] transition-colors"
          >
            {/* Famille */}
            {hasFam ? (
              isFamFirst && famRowSpan > 0 ? (
                <td
                  rowSpan={famRowSpan}
                  className={classNames(
                    "border border-neutral-300 dark:border-sky-400/35 sticky left-0 z-20 w-10 px-1 py-1 text-[11px] text-neutral-900 dark:text-neutral-300 text-center align-middle",
                    famBg,
                    "border-l-2",
                    famLeftColor,
                    topThicknessClass,
                    topColorClass,
                    bottomThicknessClass,
                    bottomColorClass
                  )}
                >
                  <div className="flex items-center justify-center h-full">
                    <span
                      className="font-semibold app-verticalHeader"
                    >
                      {famLabel}
                    </span>
                  </div>
                </td>
              ) : null
            ) : (
              <td className="border border-neutral-300 dark:border-sky-400/35 bg-white dark:bg-[var(--night-panel)] sticky left-0 z-20 w-10 px-1 py-1" />
            )}

            {/* Comp√©tence (code + libell√© sur la m√™me ligne, max 2 lignes) */}
            <td
              className={classNames(
                "sticky left-0 z-10 px-2 py-[2px] text-[11px] leading-tight align-middle border border-neutral-300 dark:border-sky-400/35",
                hasFam ? famBg : "bg-white dark:bg-[var(--night-surface)]",
                topThicknessClass,
                topColorClass,
                bottomThicknessClass,
                bottomColorClass
              )}
            >
              <div className="grid grid-cols-[auto,1fr] gap-x-2 items-start">
                <span className="font-semibold text-neutral-900 dark:text-neutral-300 whitespace-nowrap">
                  {row.code}
                </span>
                <span
                  className="text-neutral-800 dark:text-neutral-300 break-words app-lineClamp2"title={row.label}
                >
                  {row.label}
                </span>
              </div>
            </td>

            {/* Synth√®ses 1√®re ann√©e (r√©f√©rence) ‚Äì affich√©es en 2√®me ann√©e */}
            {trainingYear === "deuxieme" && (
              <>
                
                
                <td
                  className={classNames(
                    "border border-neutral-300 dark:border-sky-400/35 px-1 py-[1px] w-[80px] min-w-[80px] max-w-[80px] leading-none",
                    hasFam ? famBg : "bg-white dark:bg-[var(--night-surface)]",
                    topThicknessClass,
                    topColorClass,
                    bottomThicknessClass,
                    bottomColorClass
                  )}
                >
                  {renderHistogramCell((row as any).prevMean, (row as any).prevCountAll)}
                </td>
              </>
            )}

            {/* Devoirs S1 */}
            {evalsS1.map((ev) => {
              const usedInDevoir = (compsByEvalId[ev.id] || []).some((raw) => {
                let compPart = raw;
                if (raw.includes("||")) compPart = raw.split("||")[1].trim();
                return compactCode(compPart) === row.code;
              });

              let levelForEval: number | null = null;
              for (const [rawLabel, semLevels] of Object.entries(studentRecord)) {
                let evalIdPart: string | null = null;
                let evalNamePart: string | null = null;
                let compPart = rawLabel;
                if (rawLabel.includes("||")) {
                  const [evalRaw, compRaw] = rawLabel.split("||");
                  const key = (evalRaw || "").trim();
                  if (key === ev.id) evalIdPart = key;
                  else evalNamePart = key; // legacy (ancien format : nom du devoir)
                  compPart = (compRaw || "").trim();
                }
                if (compactCode(compPart) !== row.code) continue;
                if (evalIdPart && evalIdPart !== ev.id) continue;
                if (!evalIdPart && evalNamePart && evalNamePart !== ev.name) continue;

                const v = (semLevels as any)[ev.semester];
                if (typeof v === "number") {
                  levelForEval = v;
                  break;
                }
              }

              const level =
                levelForEval != null
                  ? levelForEval
                  : computeLevelFromNotation(ev, row.code);

              return (
                <td
                  key={`${ev.id}-${row.code}-S1`}
                  className={classNames(
                    "border border-neutral-300 dark:border-sky-400/35 w-[22px] px-0 py-0 align-middle",
                    hasFam ? famBg : "bg-white dark:bg-[var(--night-surface)]",
                    topThicknessClass,
                    topColorClass,
                    bottomThicknessClass,
                    bottomColorClass
                  )}
                  style={{ width: CELL_W }}
                >
                  <div
                    className="flex items-center justify-center leading-none"
                    style={{ height: CELL_H }}
                  >
                    {(usedInDevoir || level != null) ? renderStaticLevelDot(level) : null}
                  </div>
                </td>
              );
            })}

            <td className="w-4 bg-white dark:bg-[var(--night-panel)]" />

            {/* Devoirs S2 */}
            {evalsS2.map((ev) => {
              const usedInDevoir = (compsByEvalId[ev.id] || []).some((raw) => {
                let compPart = raw;
                if (raw.includes("||")) compPart = raw.split("||")[1].trim();
                return compactCode(compPart) === row.code;
              });

              let levelForEval: number | null = null;
              for (const [rawLabel, semLevels] of Object.entries(studentRecord)) {
                let evalIdPart: string | null = null;
                let evalNamePart: string | null = null;
                let compPart = rawLabel;
                if (rawLabel.includes("||")) {
                  const [evalRaw, compRaw] = rawLabel.split("||");
                  const key = (evalRaw || "").trim();
                  if (key === ev.id) evalIdPart = key;
                  else evalNamePart = key; // legacy (ancien format : nom du devoir)
                  compPart = (compRaw || "").trim();
                }
                if (compactCode(compPart) !== row.code) continue;
                if (evalIdPart && evalIdPart !== ev.id) continue;
                if (!evalIdPart && evalNamePart && evalNamePart !== ev.name) continue;

                const v = (semLevels as any)[ev.semester];
                if (typeof v === "number") {
                  levelForEval = v;
                  break;
                }
              }

              const level =
                levelForEval != null
                  ? levelForEval
                  : computeLevelFromNotation(ev, row.code);

              return (
                <td
                  key={`${ev.id}-${row.code}-S2`}
                  className={classNames(
                    "border border-neutral-300 dark:border-sky-400/35 w-[22px] px-0 py-0 align-middle",
                    hasFam ? famBg : "bg-white dark:bg-[var(--night-surface)]",
                    topThicknessClass,
                    topColorClass,
                    bottomThicknessClass,
                    bottomColorClass
                  )}
                  style={{ width: CELL_W }}
                >
                  <div
                    className="flex items-center justify-center leading-none"
                    style={{ height: CELL_H }}
                  >
                    {(usedInDevoir || level != null) ? renderStaticLevelDot(level) : null}
                  </div>
                </td>
              );
            })}

            <td className="w-4 bg-white dark:bg-[var(--night-panel)]" />

                        {/* Synth√®ses / EP */}
            {trainingYear === "deuxieme" ? (
              (() => {
                const ep = getEpForComp(row.code);
                const levelAll = row.ALL ?? row.S2 ?? row.S1;

                const epLabelFor = (val: 1 | 2 | 3 | 4) => {
                  if (val === 1) return "NE";
                  if (val === 2) return "NA";
                  if (val === 3) return "EA";
                  return "A";
                };

                const epColorFor = (val: 1 | 2 | 3 | 4) => {
                  if (val === 1) return "bg-red-500";
                  if (val === 2) return "bg-orange-400";
                  if (val === 3) return "bg-emerald-400";
                  return "bg-emerald-600";
                };

                const renderEpBadge = (lvl?: number | null) => {
                  // Par d√©faut (non √©valu√©) : NE
                  const v =
                    typeof lvl === "number" && !Number.isNaN(lvl)
                      ? (Math.min(4, Math.max(1, Math.round(lvl))) as 1 | 2 | 3 | 4)
                      : (1 as 1 | 2 | 3 | 4);

                  return (
                    <span
                      className={
                        "inline-flex items-center justify-center rounded-[4px] px-2 py-[2px] text-[10px] font-semibold text-white " +
                        epColorFor(v)
                      }
                    >
                      {epLabelFor(v)}
                    </span>
                  );
                };

                const renderEp = (target: "EP1" | "EP2" | "EP3") => {
                  if (ep !== target) return null;
                  return renderEpBadge(levelAll);
                };

                return (
                  <>
                    <td
                      className={classNames(
                        "border border-neutral-300 dark:border-sky-400/35 px-1 py-[1px] min-w-[30px] max-w-[30px] leading-none",
                        hasFam ? famBg : "bg-white dark:bg-[var(--night-surface)]",
                        topThicknessClass,
                        topColorClass,
                        bottomThicknessClass,
                        bottomColorClass
                      )}
                    >
                      <div className="flex items-center justify-center leading-none">
                        {renderEp("EP1")}
                      </div>
                    </td>

                    <td
                      className={classNames(
                        "border border-neutral-300 dark:border-sky-400/35 px-1 py-[1px] min-w-[30px] max-w-[30px] leading-none",
                        hasFam ? famBg : "bg-white dark:bg-[var(--night-surface)]",
                        topThicknessClass,
                        topColorClass,
                        bottomThicknessClass,
                        bottomColorClass
                      )}
                    >
                      <div className="flex items-center justify-center leading-none">
                        {renderEp("EP2")}
                      </div>
                    </td>

                    <td
                      className={classNames(
                        "border border-neutral-300 dark:border-sky-400/35 px-1 py-[1px] min-w-[30px] max-w-[30px] leading-none",
                        hasFam ? famBg : "bg-white dark:bg-[var(--night-surface)]",
                        hasFam && "border-r-2",
                        hasFam && famRightColor,
                        topThicknessClass,
                        topColorClass,
                        bottomThicknessClass,
                        bottomColorClass
                      )}
                    >
                      <div className="flex items-center justify-center leading-none">
                        {renderEp("EP3")}
                      </div>
                    </td>
                  </>
                );
              })()
            ) : (
              <>
                <td
                  className={classNames(
                    "border border-neutral-300 dark:border-sky-400/35 px-1 py-[1px] min-w-[30px] max-w-[30px] leading-none",
                    hasFam ? famBg : "bg-white dark:bg-[var(--night-surface)]",
                    topThicknessClass,
                    topColorClass,
                    bottomThicknessClass,
                    bottomColorClass
                  )}
                >
                  {renderHistogramCell(row.S1, row.countS1)}
                </td>

                <td
                  className={classNames(
                    "border border-neutral-300 dark:border-sky-400/35 px-1 py-[1px] min-w-[30px] max-w-[30px] leading-none",
                    hasFam ? famBg : "bg-white dark:bg-[var(--night-surface)]",
                    hasFam && "border-r-2",
                    hasFam && famRightColor,
                    topThicknessClass,
                    topColorClass,
                    bottomThicknessClass,
                    bottomColorClass
                  )}
                >
                  {renderHistogramCell(row.S2, row.countS2)}
                </td>
              </>
            )}
</tr>
        );
      })}
    </tbody>
  </table>
)}

    </div>
  </div>
);

                  })()
                )
              )}

              {/* === VUE √âVOLUTIONS (2 ans) === */}
              {suiviMode === "evolutions" && (
                !classe || !selectedStudentForSuivi ? (
                  <p className="text-sm text-neutral-600 dark:text-neutral-300">
                    S√©lectionnez une classe puis un √©l√®ve pour afficher l'√©volution des comp√©tences.
                  </p>
                ) : (
                  <div ref={suiviEvolutionsPdfRef} className="mt-3 print:mt-0">
                    {(() => {
                    const classId = classe.name;
                    const studentName = selectedStudentForSuivi;

                    const waitingOtherYear =
                      trainingYear === "premiere"
                        ? !deuxiemeBootstrapped
                        : !premiereBootstrapped;

                    if (waitingOtherYear) {
                      return (
                        <p className="text-sm text-neutral-600 dark:text-neutral-300">
                          Chargement des donn√©es de l'autre ann√©e‚Ä¶
                        </p>
                      );
                    }

                    // Donn√©es ann√©e 1 (premi√®re) + ann√©e 2 (deuxi√®me)
                    const y1Skills = trainingYear === "premiere" ? skillsDB : skillsDBPremiere;
                    const y1EvalsBase = trainingYear === "premiere" ? evalMetaList : evalMetaListPremiere;
                    const y1Notation = trainingYear === "premiere" ? notationDB : notationDBPremiere;

                    const y2Skills = trainingYear === "deuxieme" ? skillsDB : skillsDBDeuxieme;
                    const y2EvalsBase = trainingYear === "deuxieme" ? evalMetaList : evalMetaListDeuxieme;
                    const y2Notation = trainingYear === "deuxieme" ? notationDB : notationDBDeuxieme;

                    const normalizeEvals = (list: EvalMeta[]) =>
                      list
                        .filter(
                          (ev) =>
                            ev.group === classId &&
                            ev.semester !== "Ne pas utiliser de semestre"
                        )
                        .slice()
                        .sort((a, b) => {
                          if (a.semester !== b.semester) {
                            if (a.semester === "S1") return -1;
                            if (b.semester === "S1") return 1;
                          }
                          return (a.createdAt || "").localeCompare(b.createdAt || "");
                        });

                    const evalsY1 = normalizeEvals(y1EvalsBase);
                    const evalsY2 = normalizeEvals(y2EvalsBase);

                    const pickLatestSchoolYear = (ndb: NotationDB) => {
                      const keys = Object.keys(ndb || {});
                      if (!keys.length) return getCurrentSchoolYear();
                      const scoreKey = (k: string) => {
                        const m = k.match(/^(\d{4})/);
                        return m ? parseInt(m[1], 10) : 0;
                      };
                      return keys.slice().sort((a, b) => scoreKey(b) - scoreKey(a))[0];
                    };

                    const schoolYearY1 = pickLatestSchoolYear(y1Notation);
                    const schoolYearY2 = pickLatestSchoolYear(y2Notation);

                    const studentRecordY1: any = (y1Skills as any)?.[classId]?.[studentName] || {};
                    const studentRecordY2: any = (y2Skills as any)?.[classId]?.[studentName] || {};

                    const getLevelFromSkillsRecord = (
                      record: any,
                      ev: EvalMeta,
                      compCode: string
                    ): number | null => {
                      if (!record) return null;
                      for (const [rawLabel, semLevelsAny] of Object.entries(record)) {
                        if (typeof rawLabel !== "string" || !rawLabel.includes("||")) continue;
                        const [idOrName, compPart] = rawLabel.split("||");
                        if (!idOrName || !compPart) continue;
                        if (idOrName !== ev.id && idOrName !== ev.name) continue;
                        if (compactCode(compPart) !== compCode) continue;

                        // Valeur directe
                        if (typeof (semLevelsAny as any) === "number") return semLevelsAny as any;

                        const v = (semLevelsAny as any)?.[ev.semester as any];
                        if (typeof v === "number") return v;
                      }

                      // Fallback : niveau de synth√®se (cl√© sans "||")
                      for (const [rawLabel, semLevelsAny] of Object.entries(record)) {
                        if (typeof rawLabel !== "string" || rawLabel.includes("||")) continue;
                        if (compactCode(rawLabel) !== compCode) continue;

                        if (typeof (semLevelsAny as any) === "number") return semLevelsAny as any;
                        const v = (semLevelsAny as any)?.[ev.semester as any];
                        if (typeof v === "number") return v;
                      }

                      return null;
                    };

                    const getScore20FromNotation = (
                      ndb: NotationDB,
                      schoolYear: string,
                      ev: EvalMeta,
                      compCode: string
                    ): number | null => {
                      const bucket: any =
                        (ndb as any)?.[schoolYear]?.[classId]?.[ev.id]?.[studentName];
                      const legacyBucket: any =
                        (ndb as any)?.[schoolYear]?.[classId]?.[ev.name]?.[studentName];
                      const rec: any = bucket || legacyBucket;

                      const status = rec?.status;
                      if (status === "AB" || status === "N.NOT") return null;

                      const scores: any = rec?.scoresByCriteria;
                      if (!scores || typeof scores !== "object") return null;

                      let sum = 0;
                      let count = 0;

                      for (const [k, v] of Object.entries(scores)) {
                        if (typeof v !== "number") continue;
                        const right = String(k).split("||")[1] || "";
                        const compPart = right.split("::")[0] || "";
                        if (compactCode(compPart) !== compCode) continue;
                        sum += v;
                        count += 1;
                      }

                      if (!count) return null;

                      // scoresByCriteria est sur 4 ‚Üí conversion /20
                      const avgOn4 = sum / count;
                      return Math.max(0, Math.min(20, avgOn4 * 5));
                    };

                    const getScore20FromSkillsRecord = (
                      record: any,
                      ev: EvalMeta,
                      compCode: string
                    ): number | null => {
                      const lvl = getLevelFromSkillsRecord(record, ev, compCode);
                      if (lvl == null) return null;

                      // skillsDB stocke g√©n√©ralement un niveau 1..4. Si > 4.5, on consid√®re que c'est d√©j√† une note /20.
                      const score20 = lvl > 4.5 ? lvl : (lvl / 4) * 20;
                      return Math.max(0, Math.min(20, score20));
                    };


                    // Mapping comp√©tence -> groupe (COMMUNIQUER / R√âALISER / SP√âCIFIQUES) via les t√¢ches
                    const compFirstTaskNum: Record<string, number> = {};
                    for (const [taskLabel, comps] of Object.entries(tcMap)) {
                      const n = taskNumber(taskLabel);
                      if (!n) continue;
                      (comps || []).forEach((c) => {
                        const code = compactCode(String(c));
                        if (!code) return;
                        const prev = compFirstTaskNum[code];
                        if (prev == null || n < prev) compFirstTaskNum[code] = n;
                      });
                    }

                    const groupForCode = (code: string): GroupKey | "OTHER" => {
                      const n = compFirstTaskNum[code];
                      if (!n) return "OTHER";
                      const g = GROUPS.find((x) => n >= x.range[0] && n <= x.range[1]);
                      return (g?.key as any) || "OTHER";
                    };

                    // Regroupement alternatif par √©preuves (EP1/EP2/EP3)
                    const epByComp = {
                      EP1: new Set(["C1.01", "C2.01", "C2.02"]),
                      EP2: new Set([
                        "C2.03",
                        "C3.01",
                        "C3.02",
                        "C3.04",
                        "C3.06",
                        "C3.09",
                        "C3.10",
                        "C3.11",
                        "C3.12",
                        "C3.15",
                        "C3.16",
                        "C3.17",
                        "C4.01",
                        "C4.02",
                      ]),
                      EP3: new Set(["C1.02", "C3.03", "C3.05", "C3.07", "C3.08", "C3.13", "C3.14"]),
                    } as const;

                    const getEpForComp = (code: string): "EP1" | "EP2" | "EP3" | null => {
                      if (epByComp.EP1.has(code)) return "EP1";
                      if (epByComp.EP2.has(code)) return "EP2";
                      if (epByComp.EP3.has(code)) return "EP3";
                      return null;
                    };

                    const groupKeyForCode = (code: string): string => {
                      if (evolutionGroupMode === "ep") return getEpForComp(code) ?? "OTHER";
                      return String(groupForCode(code));
                    };

                    const allCompLabels = Array.from(
                      new Set([
                        ...Object.values(tcMap).flat().map(String),
                        ...(critResDB ? Object.keys(critResDB) : []),
                      ])
                    );

                    const stripLabel = (label: string) =>
                      label
                        .replace(/^C\s*\d\.?\d{2}\s*:\s*/i, "")
                        .replace(/^C\s*\d\s*\.\s*\d{2}\s*:\s*/i, "")
                        .trim();

                    type Card = {
                      code: string;
                      label: string;
                      group: string;
                      bars: EvolutionBar[];
                      hasData: boolean;
                    };

                    const cards: Card[] = allCompLabels
                      .map((label) => {
                        const code = compactCode(label);
                        return { code, label };
                      })
                      .filter((x) => !!x.code)
                      .map(({ code, label }) => {
                        const bars: EvolutionBar[] = [];

                        evalsY1.forEach((ev, i) => {
                          const score =
                            getScore20FromNotation(y1Notation, schoolYearY1, ev, code) ??
                            getScore20FromSkillsRecord(studentRecordY1, ev, code);

                          const label = String((ev as any)?.name || `Devoir ${i + 1}`);
                          bars.push({
                            label,
                            fullLabel: label,
                            value: score,
                          });
                        });

                        evalsY2.forEach((ev, i) => {
                          const score =
                            getScore20FromNotation(y2Notation, schoolYearY2, ev, code) ??
                            getScore20FromSkillsRecord(studentRecordY2, ev, code);

                          const label = String(
                            (ev as any)?.name || `Devoir ${evalsY1.length + i + 1}`
                          );
                          bars.push({
                            label,
                            fullLabel: label,
                            value: score,
                          });
                        });

                        const hasData = bars.some((b) => b.value != null);
                        return {
                          code,
                          label,
                          group: groupKeyForCode(code),
                          bars,
                          hasData,
                        };
                      });

                    const totalEvals = evalsY1.length + evalsY2.length;

                    if (!totalEvals) {
                      return (
                        <p className="text-sm text-neutral-600 dark:text-neutral-300">
                          Aucun devoir (S1/S2) n'est disponible pour cette classe sur la 1√®re ou la 2√®me ann√©e.
                        </p>
                      );
                    }

                    if (!cards.length) {
                      return (
                        <p className="text-sm text-neutral-600 dark:text-neutral-300">
                          Aucune comp√©tence n'est disponible (r√©f√©rentiel) pour afficher l'√©volution.
                        </p>
                      );
                    }

                    const hasAnyData = cards.some((c) => c.hasData);

                    const grouped: Record<string, Card[]> = {};
                    cards.forEach((c) => {
                      const k = c.group;
                      if (!grouped[k]) grouped[k] = [];
                      grouped[k].push(c);
                    });

                    const activityOrder: Array<{ key: string; title: string }> = [
                      { key: "G1", title: GROUPS.find((g) => g.key === "G1")?.title || "G1" },
                      { key: "G2", title: GROUPS.find((g) => g.key === "G2")?.title || "G2" },
                      { key: "G3", title: GROUPS.find((g) => g.key === "G3")?.title || "G3" },
                      { key: "OTHER", title: "AUTRES" },
                    ];

                    const order: Array<{ key: string; title: string }> =
                      evolutionGroupMode === "ep"
                        ? (EP_GROUP_ORDER as any)
                        : activityOrder;

                    const getHeaderStyle = (key: string) => {
                      if (evolutionGroupMode === "ep") {
                        return (EP_GROUP_STYLES as any)[key] || EP_GROUP_STYLES.OTHER;
                      }
                      if (key !== "OTHER") {
                        return (GROUP_STYLES as any)[key] as any;
                      }
                      return EP_GROUP_STYLES.OTHER;
                    };

                    const EP_BADGE_STYLES: Record<string, string> = {
                      EP1: "border-sky-200 bg-sky-50 dark:bg-sky-950/35 text-sky-800 dark:text-sky-500 dark:border-sky-400/40",
                      EP2: "border-emerald-200 bg-emerald-50 dark:bg-emerald-950/35 text-emerald-800 dark:text-emerald-100 dark:border-emerald-400/40",
                      EP3: "border-amber-200 bg-amber-50 dark:bg-amber-950/35 text-amber-900 dark:text-amber-100 dark:border-amber-400/40",
                      OTHER: "border-neutral-200 dark:border-sky-400/35 bg-neutral-50 dark:bg-[var(--night-panel)] text-neutral-700 dark:text-neutral-300",
                    };

                    const ACT_BADGE_STYLES: Record<string, string> = {
                      G1: "border-indigo-200 bg-indigo-50 dark:bg-indigo-950/35 text-indigo-800 dark:text-indigo-100 dark:border-indigo-400/40",
                      G2: "border-fuchsia-200 bg-fuchsia-50 dark:bg-fuchsia-950/35 text-fuchsia-800 dark:text-fuchsia-100 dark:border-fuchsia-400/40",
                      G3: "border-rose-200 bg-rose-50 dark:bg-rose-950/35 text-rose-800 dark:text-rose-100 dark:border-rose-400/40",
                      OTHER: "border-neutral-200 dark:border-sky-400/35 bg-neutral-50 dark:bg-[var(--night-panel)] text-neutral-700 dark:text-neutral-300",
                    };

                    const ACT_BADGE_LABELS: Record<string, string> = {
                      G1: "COMMUNIQUER / PR√âPARER",
                      G2: "R√âALISER / CONTR√îLER",
                      G3: "R√âALISER SP√âC.",
                      OTHER: "AUTRES",
                    };


                    const getOppositeBadge = (code: string) => {
                      if (evolutionGroupMode === "activite") {
                        const ep = getEpForComp(code) ?? "OTHER";
                        const cls = EP_BADGE_STYLES[ep] || EP_BADGE_STYLES.OTHER;
                        return {
                          text: ep === "OTHER" ? "AUTRE" : ep,
                          className: cls,
                          title: ep === "OTHER" ? "√âpreuve non d√©finie" : `√âpreuve ${ep}`,
                        };
                      }
                      const k = String(groupForCode(code));
                      const cls = ACT_BADGE_STYLES[k] || ACT_BADGE_STYLES.OTHER;
                      const title =
                        k !== "OTHER" ? GROUPS.find((g) => g.key === k)?.title || k : "AUTRES";
                      return {
                        text: ACT_BADGE_LABELS[k] || (k === "OTHER" ? "AUTRES" : k),
                        className: cls,
                        title,
                      };
                    };

                    return (
                      <div className="space-y-6">
                        <div className="flex items-start justify-between gap-3">
                          <div className="no-print min-w-0">
                            <div className="mt-1 text-xs text-neutral-500 dark:text-neutral-300 font-semibold">
                              {evolutionGroupMode === "ep" ? "√âpreuves (EP1/EP2/EP3)" : "Activit√©s"} ¬∑ Moyenne positionn√©e d'acquisition du niveau 3 : {Math.round(evolutionCapLine * 10) / 10}/20
                            </div>
                          </div>

                          <button
                            type="button"
                            onClick={() => setEvolutionSettingsOpen(true)}
                            className="h-8 shrink-0 inline-flex items-center gap-2 rounded-md border border-neutral-300 dark:border-sky-400/35 bg-white hover:bg-amber-100/70 dark:bg-[var(--night-surface)] px-3 text-xs font-semibold text-neutral-800 dark:text-neutral-300 hover:bg-amber-100/70 dark:bg-[var(--night-surface)]"
                          >
                            <Settings2 className="h-4 w-4" />
                            Param√®tres
                          </button>
                        </div>

                        <Drawer
                          open={evolutionSettingsOpen}
                          onClose={() => setEvolutionSettingsOpen(false)}
                          side="right"
                          className="w-[360px]"
                        >
                          <div className="p-4 space-y-4 text-neutral-900 dark:text-neutral-300">
                            <div className="flex items-center justify-between">
                              <div className="text-sm font-semibold">Param√®tres ‚Äî √âvolutions</div>
                              <button
                                type="button"
                                onClick={() => setEvolutionSettingsOpen(false)}
                                className="h-8 w-8 inline-flex items-center justify-center rounded-md border border-neutral-200 dark:border-sky-400/35 bg-white hover:bg-amber-100/70 dark:bg-[var(--night-surface)] hover:bg-amber-100/70 dark:bg-[var(--night-surface)] text-neutral-300 dark:text-white"
                                aria-label="Fermer"
                              >
                                <X className="h-4 w-4" />
                              </button>
                            </div>

                            <div className="space-y-2">
                              <Label className="text-xs">Afficher les devoirs dans les graphiques</Label>
                              <label className="flex items-center gap-2 text-xs text-neutral-800 dark:text-neutral-300">
                                <input
                                  type="checkbox"
                                  className="h-4 w-4 rounded border border-neutral-300 dark:border-sky-400/35"
                                  checked={evolutionShowDevoirs}
                                  onChange={(e) => setEvolutionShowDevoirs(e.target.checked)}
                                />
                                <span>Afficher les devoirs dans les graphiques</span>
                              </label>                             <div className="text-[11px] text-neutral-500 dark:text-neutral-300">
                                D√©sactive le nom des devoirs.
                              </div>
                            </div>

                            <div className="space-y-2">
                              <Label className="text-xs">Position de la ligne CAP (niveau 3) ‚Äî note /20</Label>
                              <div className="flex items-center gap-2">
                                <Input
                                  type="number"
                                  min={0}
                                  max={20}
                                  step={0.5}
                                  value={String(evolutionCapLine)}
                                  onChange={(e) => {
                                    const raw = (e.target.value || "").replace(",", ".");
                                    const n = raw === "" ? 0 : parseFloat(raw);
                                    if (!isFinite(n)) return;
                                    setEvolutionCapLine(Math.max(0, Math.min(20, n)));
                                  }}
                                  className="h-8"
                                />
                                <div className="text-xs text-neutral-500 dark:text-white whitespace-nowrap">/ 20</div>
                              </div>
                              <div className="flex flex-wrap gap-2">
                             {[].map((v) => (
                                  <button
                                    key={v}
                                    type="button"
                                    onClick={() => setEvolutionCapLine(v)}
                                    className={classNames(
                                      "h-7 px-2 rounded-md border text-xs",
                                      Math.round(evolutionCapLine) === v
                                        ? "border-neutral-900 bg-neutral-900 text-white"
                                        : "border-neutral-300 dark:border-sky-400/35 bg-white hover:bg-amber-100/70 dark:bg-[var(--night-surface)] text-neutral-800 dark:text-neutral-300 hover:bg-amber-100/70 dark:bg-[var(--night-surface)]"
                                    )}
                                  >
                                    {v}
                                  </button>
                                ))}
                              </div>
                            </div>

                            <div className="space-y-2">
                              <Label className="text-xs">Affichage des fen√™tres (regroupement)</Label>
                              <select
                                className="block w-full border border-neutral-300 dark:border-sky-400/35 rounded-md bg-white dark:bg-[var(--night-surface)] px-2 py-1 text-xs"
                                value={evolutionGroupMode}
                                onChange={(e) => setEvolutionGroupMode(e.target.value as any)}
                              >
                                <option value="activite">Par activit√©s (Communiquer / Pr√©parer / R√©aliser‚Ä¶)</option>
                                <option value="ep">Par √©preuves (EP1 / EP2 / EP3)</option>
                              </select>
                              <div className="text-[11px] text-neutral-500 dark:text-neutral-300">
                                Ces param√®tres sont enregistr√©s sur cet appareil.
                              </div>
                            </div>

                            <div className="space-y-2">
                              <Label className="text-xs">Affichage des tableaux ‚Äî nombre par ligne</Label>
                              <select
                                className="block w-full border border-neutral-300 dark:border-sky-400/35 rounded-md bg-white dark:bg-[var(--night-surface)] px-2 py-1 text-xs"
                                value={String(evolutionCardsPerRow)}
                                onChange={(e) => {
                                  const n = parseInt(e.target.value, 10);
                                  if (!isFinite(n)) return;
                                  setEvolutionCardsPerRow(Math.max(1, Math.min(10, n)));
                                }}
                              >
                                {[1, 2, 3, 4, 5, 6, 8, 10].map((n) => (
                                  <option key={n} value={n}>
                                    {n} par ligne
                                  </option>
                                ))}
                              </select>
                              <div className="text-[11px] text-neutral-500 dark:text-neutral-300">
                                Ajuste la taille des cartes sur l‚Äô√©cran.
                              </div>
                            </div>
</div>
                        </Drawer>

                        {!hasAnyData && (
                          <div className="rounded-lg border border-amber-200 bg-amber-50 dark:bg-amber-950/35 px-3 py-2 text-xs text-amber-800">
                            Aucun niveau n'a √©t√© trouv√© pour cet √©l√®ve sur ces devoirs (barres vides). V√©rifiez que les devoirs ont des notes enregistr√©es ou que le suivi a √©t√© aliment√©.
                          </div>
                        )}

                        {order.map(({ key, title }) => {
                          const list = (grouped as any)[key] as Card[] | undefined;
                          if (!list || !list.length) return null;
                          const gStyle = getHeaderStyle(String(key));
                          return (
                            <section key={String(key)} className="space-y-3">
                              <div
                                className={classNames(
                                  "flex items-center justify-between rounded-lg border px-3 py-2",
                                  gStyle ? gStyle.headerBg : "bg-neutral-50 dark:bg-[var(--night-panel)]",
                                  gStyle ? gStyle.accentBorder : ""
                                )}
                              >
                                <h3
                                  className={classNames(
                                    "text-xs font-semibold tracking-wide",
                                    gStyle ? gStyle.headerText : "text-neutral-700 dark:text-neutral-300"
                                  )}
                                >
                                  {title}
                                </h3>
                                <div className="text-[11px] text-neutral-600 dark:text-neutral-300">
                                  {list.length} comp√©tence(s)
                                </div>
                              </div>

                              <div className="grid gap-4" style={{ gridTemplateColumns: `repeat(${evolutionCardsPerRow}, minmax(0, 1fr))` }}>
                                {list
                                  .slice()
                                  .sort((a, b) => a.code.localeCompare(b.code))
                                  .map((card) => {
                                    const badge = getOppositeBadge(card.code);
                                    return (
                                    <div
                                      key={card.code}
                                      className="rounded-lg border border-neutral-200 dark:border-sky-400/35 bg-white dark:bg-[var(--night-surface)] keep-light pt-3 px-3 pb-2 shadow-sm min-w-0 overflow-hidden"
                                      title={card.label}
                                    >
                                      <div className="flex items-start justify-between gap-2">
                                        <div className="min-w-0">
                                          <div className="flex items-center gap-2 min-w-0">
                                            <div className="text-[11px] font-semibold text-neutral-900 dark:text-neutral-300 shrink-0">
                                              {card.code}
                                            </div>
                                            <div className="text-[10px] text-neutral-700 dark:text-neutral-300 truncate">
                                              {stripLabel(card.label)}
                                            </div>
                                          </div>
                                        </div>
                                        <div className="flex flex-col items-end gap-1 shrink-0">
                                          <div
                                            className={classNames(
                                              "no-print h-3 px-1 rounded-full border text-[10px] font-semibold leading-3",
                                              badge.className
                                            )}
                                            title={badge.title}
                                          >
                                            {badge.text}
                                          </div>
                                        </div>
                                      </div>

                                      <div className="mt-2">
                                        <MiniEvolutionChart
                                          bars={card.bars}
                                          splitIndex={evalsY1.length}
                                          capLine={evolutionCapLine}
                                          showDevoirs={evolutionShowDevoirs}
                                        />
                                      </div>
                                    </div>
                                  );
                                  })}
                              </div>
                            </section>
                          );
                        })}
                      </div>
                    );
                  })()}
                  </div>
                )
              )}

              {/* === BILAN P√âRIODIQUE === */}
              {suiviMode === "bilan" && (
                !classe || !selectedStudentForSuivi ? (
                  <p className="text-sm text-neutral-600 dark:text-neutral-300">
                    S√©lectionnez une classe puis un √©l√®ve pour afficher le bilan p√©riodique.
                  </p>
                ) : (
                  <div className="mt-4 space-y-4 pb-12">
                    {(() => {
                      const classId = classe.name;
                      const studentName = selectedStudentForSuivi;
                      const schoolYear = bilanSchoolYear;

                      const evalsForClass = evalMetaList
                        .filter(
                          (ev) =>
                            ev.group === classId &&
                            ev.semester !== "Ne pas utiliser de semestre"
                        )
                        .slice()
                        .sort((a, b) => {
                          if (a.semester !== b.semester) {
                            if (a.semester === "S1") return -1;
                            if (b.semester === "S1") return 1;
                          }
                          return (a.createdAt || "").localeCompare(b.createdAt || "");
                        });

                      const sem = bilanSemester === "S2" ? "S2" : "S1";
                      const evalsForSem = evalsForClass.filter((ev: EvalMeta) => ev.semester === sem);
                      const allowedEvalIds = new Set<string>(evalsForSem.map((ev: EvalMeta) => ev.id));
                      const allowedEvalNames = new Set<string>(evalsForSem.map((ev: EvalMeta) => ev.name));

                      // Comp√©tences de r√©f√©rence (issues du mapping des t√¢ches)
                      const allCompetenceDefs = Array.from(
                        new Set(Object.values(tcMap).flat())
                      )
                        .map((compStr) => {
                          const code = compactCode(String(compStr));
                          const label = String(compStr)
                            .replace(/^C\s*\d+\.\d+\s*[:.]\s*/i, "")
                            .trim();
                          return { code, label };
                        })
                        .filter((d) => !!d.code)
                        .sort((a, b) =>
                          a.code.localeCompare(b.code, "fr", {
                            numeric: true,
                            sensitivity: "base",
                          })
                        );

                      const defByCode: Record<string, { label: string }> = {};
                      allCompetenceDefs.forEach((d) => {
                        defByCode[d.code] = { label: d.label };
                      });

                      // Fallback : construit un agr√©gat depuis les notes (notationDB) si le suivi manuel (skillsDB) n'est pas renseign√©
                      const buildAggFromNotationForStudent = (stName: string): SemesterAgg => {
                        const agg: SemesterAgg = {};
                        const classBucketAny: any = (notationDB as any)?.[schoolYear]?.[classId] || {};

                        for (const [evalKey, evalBucketAny] of Object.entries(classBucketAny || {})) {
                          const evalBucket: any = evalBucketAny as any;

                          // Tol√©rant aux diff√©rences mineures d‚Äô√©criture du nom (espaces, casse)
                          const normName = (x: any) =>
                            String(x ?? "")
                              .normalize("NFKC")
                              .replace(/\u00A0/g, " ")
                              .replace(/\s+/g, " ")
                              .trim()
                              .toLowerCase();

                          let entry: any = evalBucket?.[stName];
                          if (!entry) {
                            const target = normName(stName);
                            const matchKey = Object.keys(evalBucket || {}).find(
                              (k) => normName(k) === target
                            );
                            if (matchKey) entry = (evalBucket as any)?.[matchKey];
                          }
                          if (!entry) continue;
                          if (entry?.status && entry.status !== "OK") continue;

                          const entrySem: any = entry?.semester;
                          if (entrySem && String(entrySem) !== String(sem)) continue;

                          const scores: Record<string, any> = entry?.scoresByCriteria || {};
                          const weightKey = String(entry?.evalId || evalKey);
                          const weights: Record<string, any> =
                            (weightsByEvalId as any)?.[weightKey] || {};

                          const perComp: Record<string, { w: number; tw: number }> = {};

                          Object.entries(scores).forEach(([critKey, score]) => {
                            if (typeof score !== "number") return;
                            if (!isFinite(score) || score <= 0) return;

                            const right = String(critKey).includes("||")
                              ? (String(critKey).split("||")[1] || "")
                              : String(critKey);
                            const compLabel = (right.split("::")[0] || "").trim();
                            const code = compactCode(compLabel);
                            if (!code) return;

                            const wRaw = (weights as any)[critKey];
                            const w =
                              typeof wRaw === "number" && isFinite(wRaw) && wRaw > 0
                                ? wRaw
                                : 1;

                            if (!perComp[code]) perComp[code] = { w: 0, tw: 0 };
                            perComp[code].w += score * w;
                            perComp[code].tw += w;
                          });

                          Object.entries(perComp).forEach(([code, a]) => {
                            if (!a || a.tw <= 0) return;
                            const avg = a.w / a.tw;
                            if (!agg[code]) {
                              agg[code] = {
                                label: defByCode[code]?.label || "",
                                S1Vals: [],
                                S2Vals: [],
                              };
                            }
                            if (sem === "S1") agg[code].S1Vals.push(avg);
                            else agg[code].S2Vals.push(avg);
                          });
                        }

                        return agg;
                      };

                      const normalizeItemLabel = (v: any): string =>
                        String(v ?? "")
                          .normalize("NFKC")
                          .replace(/\u00A0/g, " ")
                          .replace(/[‚Äô‚Äò]/g, "'")
                          .replace(/[‚Äú‚Äù¬´¬ª]/g, '"')
                          .replace(/[‚Äê‚Äë‚Äí‚Äì‚Äî‚àí]/g, "-")
                          .replace(/\s+/g, " ")
                          .trim()
                          .replace(/^((√©l√®ve|eleve)\s+est\s+capable\s+de\s*:?\s*)/i, "")
                          .replace(/^(?:√™|e)tre\s+capable\s+de\s*:?\s*/i, "")
                          .replace(/^\-\s*/, "")
                          // Normalisation ‚Äúrobuste‚Äù pour matcher les libell√©s
                          // (r√©f√©rentiel vs cl√©s de notation : parenth√®ses, ":" final, etc.)
                          .replace(/\([^)]*\)/g, " ")
                          .replace(/\s+/g, " ")
                          .trim()
                          .replace(/\s*[:Ôºö;,.]+\s*$/g, "")
                          .trim()
                          .toLowerCase();

                      // ‚úÖ Source principale : skillsDB (validations)
                      // On agr√®ge les niveaux par comp√©tence sur le semestre s√©lectionn√©.
                      const buildAggFromSkillsForStudent = (stName: string): SemesterAgg => {
                        const agg: SemesterAgg = {};
                        const studentRec: any = (skillsDB as any)?.[classId]?.[stName] || {};

                        Object.entries(studentRec).forEach(([rawKey, semRecAny]) => {
                          const semRec: any = semRecAny || {};
                          const lvl = semRec?.[sem];
                          if (typeof lvl !== "number" || !isFinite(lvl) || lvl <= 0) return;

                          // Cl√© typique : evalId||C 1.01 : ...
                          let compLabelPart = String(rawKey);
                          if (compLabelPart.includes("||")) {
                            const parts = compLabelPart.split("||");
                            const left = parts[0] || "";
                            const right = parts.slice(1).join("||");
                            const looksLikeEvalId =
                              left.length >= 6 && !compactCode(left) && !!compactCode(right);
                            if (looksLikeEvalId) compLabelPart = right;
                          }

                          const code = compactCode(compLabelPart);
                          if (!code) return;

                          if (!agg[code]) {
                            const fallbackLabel = String(compLabelPart)
                              .replace(/^C\s*\d+\.\d+\s*[:.]\s*/i, "")
                              .trim();
                            agg[code] = {
                              label: defByCode[code]?.label || fallbackLabel || "",
                              S1Vals: [],
                              S2Vals: [],
                            };
                          }

                          if (sem === "S1") agg[code].S1Vals.push(lvl);
                          else agg[code].S2Vals.push(lvl);
                        });

                        return agg;
                      };


                      const buildAggForStudent = (stName: string): SemesterAgg => {
                        const fromNotation = buildAggFromNotationForStudent(stName);
                        const fromSkills = buildAggFromSkillsForStudent(stName);

                        // ‚úÖ Mix : on conserve les niveaux manuels (skillsDB) pour les comp√©tences
                        // qui n'ont pas (encore) de notes crit√©ri√©es, et on laisse la notation
                        // prioritaire quand elle existe.
                        return { ...fromSkills, ...fromNotation };
                      };

                      const studentAgg = buildAggForStudent(studentName);

                      // --- Crit√®res (items) par comp√©tence, comme dans le PDF ---
                      // On r√©cup√®re la liste des items depuis critResDB (r√©f√©rentiel),
                      // puis on calcule les niveaux via la notation (scoresByCriteria).
                      const critResKeyByCode: Record<string, string> = {};
                      if (critResDB) {
                        Object.keys(critResDB).forEach((k) => {
                          const code = compactCode(String(k));
                          if (!code) return;
                          if (!critResKeyByCode[code]) critResKeyByCode[code] = String(k);
                        });
                      }

                      type ItemAgg = { weighted: number; totalW: number; count: number };
                      const buildItemAggFromNotationForStudent = (stName: string) => {
                        const map: Record<string, ItemAgg> = {};
                        const classBucketAny: any = (notationDB as any)?.[schoolYear]?.[classId] || {};

                        for (const [evalKey, evalBucketAny] of Object.entries(classBucketAny || {})) {
                          const evalBucket: any = evalBucketAny as any;

                          // Tol√©rant aux diff√©rences mineures d‚Äô√©criture du nom (espaces, casse)
                          const normName = (x: any) =>
                            String(x ?? "")
                              .normalize("NFKC")
                              .replace(/\u00A0/g, " ")
                              .replace(/\s+/g, " ")
                              .trim()
                              .toLowerCase();

                          let entry: any = evalBucket?.[stName];
                          if (!entry) {
                            const target = normName(stName);
                            const matchKey = Object.keys(evalBucket || {}).find(
                              (k) => normName(k) === target
                            );
                            if (matchKey) entry = (evalBucket as any)?.[matchKey];
                          }
                          if (!entry) continue;
                          if (entry?.status && entry.status !== "OK") continue;

                          const entrySem: any = entry?.semester;
                          if (entrySem && String(entrySem) !== String(sem)) continue;

                          const scores: Record<string, any> = entry?.scoresByCriteria || {};
                          const weightKey = String(entry?.evalId || evalKey);
                          const weights: Record<string, any> =
                            (weightsByEvalId as any)?.[weightKey] || {};

                          Object.entries(scores).forEach(([critKey, score]) => {
                            if (typeof score !== "number") return;
                            if (!isFinite(score) || score <= 0) return;

                            const right = String(critKey).includes("||")
                              ? (String(critKey).split("||")[1] || "")
                              : String(critKey);

                            const parts = right.split("::");
                            const compLabel = (parts[0] || "").trim();
                            const itemLabel = normalizeItemLabel(parts[1] || "");
                            if (!compLabel || !itemLabel) return;

                            const code = compactCode(compLabel);
                            if (!code) return;

                            const k = `${code}||${itemLabel}`;
                            const wRaw = (weights as any)[critKey];
                            const w =
                              typeof wRaw === "number" && isFinite(wRaw) && wRaw > 0 ? wRaw : 1;

                            if (!map[k]) map[k] = { weighted: 0, totalW: 0, count: 0 };
                            map[k].weighted += score * w;
                            map[k].totalW += w;
                            map[k].count += 1;
                          });
                        }

                        return map;
                      };

                      const studentItemAgg = buildItemAggFromNotationForStudent(studentName);

                      // üîπ Sert √† d√©tecter si une comp√©tence a d√©j√† au moins un crit√®re not√©
                      // (pour √©viter de "cocher" tous les crit√®res restants par h√©ritage).
                      const codesWithAnyItemData = new Set<string>();
                      Object.keys(studentItemAgg || {}).forEach((k) => {
                        const code = String(k).split("||")[0];
                        if (code) codesWithAnyItemData.add(code);
                      });

                      // Regroupement par p√¥le (bas√© sur la famille C1/C2/C3/C4)
type PoleKey = "COMMUNIQUER" | "PR√âPARER" | "R√âALISER" | "CONTR√îLER" | "OTHER";

const poleForCode = (code: string): PoleKey => {
  const m = String(code || "").match(/^C\s*([1-4])\./i);
  if (!m) return "OTHER";
  const n = Number(m[1]);
  if (n === 1) return "COMMUNIQUER";
  if (n === 2) return "PR√âPARER";
  if (n === 3) return "R√âALISER";
  if (n === 4) return "CONTR√îLER";
  return "OTHER";
};

const groupOrder: Record<PoleKey, number> = { "COMMUNIQUER": 1, "PR√âPARER": 2, "R√âALISER": 3, "CONTR√îLER": 4, "OTHER": 9 };
const groupTitle = (g: PoleKey) => (g === "OTHER" ? "AUTRES" : g);

const rows = allCompetenceDefs
                        .map((def) => {
                          const d: any = (studentAgg as any)?.[def.code];
                          const vals: number[] = d
                            ? (sem === "S1" ? (d.S1Vals || []) : (d.S2Vals || []))
                            : [];
                          const avg = vals.length ? mean(vals) : 0;
                          const lvl: Level1to4 = vals.length ? (avg <= 0 ? 1 : levelFromAvg(avg)) : 0;
                          const group = poleForCode(def.code);

                          const hasAnyCritDataForComp = codesWithAnyItemData.has(def.code);

                          const compKey = critResKeyByCode[def.code];
                          const itemsDef: string[] = compKey && critResDB ? Object.keys(critResDB[compKey] || {}) : [];
                          const items = itemsDef.map((it) => {
                            const normIt = normalizeItemLabel(it);
                            const a = studentItemAgg[`${def.code}||${normIt}`];
                            const hasData = !!(a && a.totalW > 0 && (a.count || 0) > 0);
                            const aAvg = hasData ? a.weighted / a.totalW : 0;
                            // Niveau de l'item ("√ätre capable de‚Ä¶") :
                            // - uniquement √† partir des notes crit√©ri√©es (scoresByCriteria)
                            // - si aucun crit√®re n'a √©t√© not√© pour cet item : non √©valu√© (niveau 0)
                            const inherit = false;
                            const itemLvl: Level1to4 = hasData
                              ? (aAvg <= 0 ? 1 : levelFromAvg(aAvg))
                              : 0;

                            return {
                              item: it,
                              avg: aAvg,
                              lvl: itemLvl,
                              count: a?.count || 0,
                              inherited: inherit,
                            };
                          });
                          return {
                            code: def.code,
                            label: def.label || d?.label || "",
                            avg,
                            lvl,
                            group,
                            groupTitle: groupTitle(group as any),
                            count: vals.length,
                            items,
                          };
                        })
                        .sort((a, b) => {
                          const ga = (groupOrder as any)[String(a.group)] ?? 9;
                          const gb = (groupOrder as any)[String(b.group)] ?? 9;
                          if (ga !== gb) return ga - gb;
                          return a.code.localeCompare(b.code, "fr", {
                            numeric: true,
                            sensitivity: "base",
                          });
                        });

                                            // === Graphique : toutes les comp√©tences (/20) + comparaison p√©riode pr√©c√©dente ===
                                            const toScore20 = (avgOn4: number) =>
                                              Math.max(0, Math.min(20, (avgOn4 || 0) * 5));

                                            type SumCount = { sum: number; count: number };
                                            const initSumCountMap = (): Record<string, SumCount> => {
                                              const m: Record<string, SumCount> = {};
                                              (allCompetenceDefs || []).forEach((d) => (m[d.code] = { sum: 0, count: 0 }));
                                              return m;
                                            };

                                            const computeStudentSumCountByCode = (
                                              stName: string,
                                              semWanted: SemesterKey,
                                              yearWanted: TrainingYear,
                                              schoolYearWanted: string
                                            ): Record<string, SumCount> => {
                                              const out = initSumCountMap();

                                              const ndb: NotationDB =
                                                yearWanted === trainingYear
                                                  ? (notationDB as any)
                                                  : yearWanted === "premiere"
                                                    ? (notationDBPremiere as any)
                                                    : (notationDBDeuxieme as any);

                                              const sdb: SkillsDB =
                                                yearWanted === trainingYear
                                                  ? (skillsDB as any)
                                                  : yearWanted === "premiere"
                                                    ? (skillsDBPremiere as any)
                                                    : (skillsDBDeuxieme as any);

                                              // 1) skillsDB (validations manuelles)
                                              const skillsMap = initSumCountMap();
                                              const studentRec: any = (sdb as any)?.[classId]?.[stName] || {};
                                              Object.entries(studentRec).forEach(([rawKey, semRecAny]) => {
                                                const semRec: any = semRecAny || {};
                                                const rawLvl = semRec?.[semWanted];
                                                if (typeof rawLvl !== "number" || !isFinite(rawLvl) || rawLvl <= 0) return;

                                                // Si on a enregistr√© une note /20 dans skillsDB, on reconvertit vers /4.
                                                let lvlOn4 = rawLvl;
                                                if (rawLvl > 4.5) lvlOn4 = (rawLvl / 20) * 4;

                                                // Cl√© typique : evalId||C 1.01 : ...
                                                let compLabelPart = String(rawKey);
                                                if (compLabelPart.includes("||")) {
                                                  const parts = compLabelPart.split("||");
                                                  const left = parts[0] || "";
                                                  const right = parts.slice(1).join("||");
                                                  const looksLikeEvalId = left.length >= 6 && !compactCode(left) && !!compactCode(right);
                                                  if (looksLikeEvalId) compLabelPart = right;
                                                }

                                                const code = compactCode(compLabelPart);
                                                if (!code) return;

                                                if (!skillsMap[code]) skillsMap[code] = { sum: 0, count: 0 };
                                                skillsMap[code].sum += lvlOn4;
                                                skillsMap[code].count += 1;
                                              });

                                              // 2) notationDB (scoresByCriteria) ‚Äî prioritaire si pr√©sent
                                              const notationMap = initSumCountMap();
                                              const classBucketAny: any = (ndb as any)?.[schoolYearWanted]?.[classId] || {};

                                              const normName = (x: any) =>
                                                String(x ?? "")
                                                  .normalize("NFKC")
                                                  .replace(/\u00A0/g, " ")
                                                  .replace(/\s+/g, " ")
                                                  .trim()
                                                  .toLowerCase();

                                              for (const [evalKey, evalBucketAny] of Object.entries(classBucketAny || {})) {
                                                const evalBucket: any = evalBucketAny as any;

                                                let entry: any = evalBucket?.[stName];
                                                if (!entry) {
                                                  const target = normName(stName);
                                                  const matchKey = Object.keys(evalBucket || {}).find((k) => normName(k) === target);
                                                  if (matchKey) entry = (evalBucket as any)?.[matchKey];
                                                }
                                                if (!entry) continue;
                                                if (entry?.status && entry.status !== "OK") continue;

                                                const entrySem: any = entry?.semester;
                                                if (entrySem && String(entrySem) !== String(semWanted)) continue;

                                                const scores: Record<string, any> = entry?.scoresByCriteria || {};
                                                const weightKey = String(entry?.evalId || evalKey);
                                                const weights: Record<string, any> = (weightsByEvalId as any)?.[weightKey] || {};

                                                const perComp: Record<string, { w: number; tw: number }> = {};

                                                Object.entries(scores).forEach(([critKey, score]) => {
                                                  if (typeof score !== "number") return;
                                                  // NR (=0) ou non not√© ‚Üí ignor√©
                                                  if (!isFinite(score) || score <= 0) return;

                                                  const right = String(critKey).includes("||")
                                                    ? (String(critKey).split("||")[1] || "")
                                                    : String(critKey);
                                                  const compLabel = (right.split("::")[0] || "").trim();
                                                  const code = compactCode(compLabel);
                                                  if (!code) return;

                                                  const wRaw = (weights as any)[critKey];
                                                  const w = typeof wRaw === "number" && isFinite(wRaw) && wRaw > 0 ? wRaw : 1;

                                                  if (!perComp[code]) perComp[code] = { w: 0, tw: 0 };
                                                  perComp[code].w += score * w;
                                                  perComp[code].tw += w;
                                                });

                                                Object.entries(perComp).forEach(([code, a]) => {
                                                  if (!a || a.tw <= 0) return;
                                                  const avg = a.w / a.tw;

                                                  if (!notationMap[code]) notationMap[code] = { sum: 0, count: 0 };
                                                  notationMap[code].sum += avg;
                                                  notationMap[code].count += 1;
                                                });
                                              }

                                              // 3) Merge : notation prioritaire (sinon skills)
                                              (allCompetenceDefs || []).forEach((d) => {
                                                const code = d.code;
                                                const n = notationMap[code];
                                                const s = skillsMap[code];

                                                if (n && n.count > 0) out[code] = n;
                                                else if (s && s.count > 0) out[code] = s;
                                                else out[code] = { sum: 0, count: 0 };
                                              });

                                              return out;
                                            };

                                            const computeClassAvgOn4ByCode = (semWanted: SemesterKey): Record<string, number | null> => {
                                              const sum: Record<string, number> = {};
                                              const cnt: Record<string, number> = {};
                                              (allCompetenceDefs || []).forEach((d) => {
                                                sum[d.code] = 0;
                                                cnt[d.code] = 0;
                                              });

                                              (students || []).forEach((st) => {
                                                const sc = computeStudentSumCountByCode(st, semWanted, trainingYear, schoolYear);
                                                (allCompetenceDefs || []).forEach((d) => {
                                                  const a = sc[d.code];
                                                  if (!a || a.count <= 0) return;
                                                  const avg = a.sum / a.count;
                                                  if (!isFinite(avg) || avg <= 0) return;
                                                  sum[d.code] += avg;
                                                  cnt[d.code] += 1;
                                                });
                                              });

                                              const out: Record<string, number | null> = {};
                                              (allCompetenceDefs || []).forEach((d) => {
                                                out[d.code] = cnt[d.code] ? sum[d.code] / cnt[d.code] : null;
                                              });
                                              return out;
                                            };

                                            // R√©f√©rence : p√©riode pr√©c√©dente (selon les r√®gles demand√©es)
                                            const refConfig = (() => {
                                              if (trainingYear === "premiere") {
                                                if (sem === "S2") return { label: "Semestre 1", kind: "prev" as const };
                                                return { label: "", kind: "none" as const };
                                              }
                                              // 2√®me ann√©e
                                              if (sem === "S1") return { label: "Moyenne de 1√®re ann√©e", kind: "premiereAvg" as const };
                                              return { label: "Semestre 1", kind: "prev" as const };
                                            })();

                                            const schoolYearPremiereRef = pickLatestSchoolYearFromNotationDB(
                                              notationDBPremiere,
                                              getCurrentSchoolYear()
                                            );

                                            const refSumCountByCode: Record<string, SumCount> = (() => {
                                              if (refConfig.kind === "prev") {
                                                return computeStudentSumCountByCode(studentName, "S1", trainingYear, schoolYear);
                                              }
                                              if (refConfig.kind === "premiereAvg") {
                                                const s1 = computeStudentSumCountByCode(studentName, "S1", "premiere", schoolYearPremiereRef);
                                                const s2 = computeStudentSumCountByCode(studentName, "S2", "premiere", schoolYearPremiereRef);
                                                const out = initSumCountMap();
                                                (allCompetenceDefs || []).forEach((d) => {
                                                  out[d.code] = {
                                                    sum: (s1[d.code]?.sum || 0) + (s2[d.code]?.sum || 0),
                                                    count: (s1[d.code]?.count || 0) + (s2[d.code]?.count || 0),
                                                  };
                                                });
                                                return out;
                                              }
                                              return initSumCountMap();
                                            })();

                                            const currentSumCountByCode = computeStudentSumCountByCode(studentName, sem, trainingYear, schoolYear);
                                            const classAvgOn4ByCode = computeClassAvgOn4ByCode(sem);

                                            const chartData = (allCompetenceDefs || []).map((d) => {
                                              const cur = currentSumCountByCode[d.code];
                                              const ref = refSumCountByCode[d.code];

                                              const curAvg4 = cur && cur.count ? cur.sum / cur.count : null;
                                              const refAvg4 = ref && ref.count ? ref.sum / ref.count : null;
                                              const clsAvg4 = classAvgOn4ByCode[d.code];

                                              return {
                                                competence: d.code,
                                                label: d.label || "",
                                                Reference: refAvg4 != null ? round1(toScore20(refAvg4)) : null,
                                                Eleve: curAvg4 != null ? round1(toScore20(curAvg4)) : null,
                                                Classe: clsAvg4 != null ? round1(toScore20(clsAvg4)) : null,
                                              };
                                            });

                                            const studentGlobal = (() => {
                                              const arr = (chartData || [])
                                                .map((x: any) => x?.Eleve)
                                                .filter((v: any) => typeof v === "number" && isFinite(v));
                                              return arr.length ? mean(arr) : 0;
                                            })();

                                            const classGlobal = (() => {
                                              const arr = (chartData || [])
                                                .map((x: any) => x?.Classe)
                                                .filter((v: any) => typeof v === "number" && isFinite(v));
                                              return arr.length ? mean(arr) : 0;
                                            })();

// Absences + Motivation (√† partir de l'onglet NOTE)
                      const classBucket: any = (notationDB as any)?.[schoolYear]?.[classId] || {};
                      let absencesCount = 0;
                      const motivationScores: number[] = [];
                      
                      for (const ev of evalsForSem) {
                        const evalBucket: any = classBucket?.[ev.id] || classBucket?.[ev.name] || {};
                        const entry: any = evalBucket?.[studentName];
                        const status = entry?.status;
                        if (status === "AB") absencesCount += 1;
                        if (status !== "OK") continue;
                        const level = entry?.engagementLevel as EngagementLevel | undefined;
                        if (!level) continue;
                        const score = ENGAGEMENT_SCORE[level];
                        if (typeof score === "number" && isFinite(score) && score > 0) motivationScores.push(score);
}

                      const motivationAvg = motivationScores.length ? mean(motivationScores) : 0;
                      const motivationResult = motivationScores.length ? engagementLabelFromAvg(motivationAvg) : "‚Äî";


                      const legend = [
                        levelBadge(0),
                        levelBadge(1),
                        levelBadge(2),
                        levelBadge(3),
                        levelBadge(4),
                      ];

                      const renderCompetencesPanel = () => (
                        <div className="rounded-xl border border-neutral-200 dark:border-sky-400/35 bg-white dark:bg-[var(--night-panel)] p-4 shadow-sm bilan-competences">
                                                                                    <div className="flex items-center justify-between">
                                                                                    </div>

                                                                                    <div className="mt-2 flex flex-wrap gap-3">
                                                                                      {legend.map((b) => (
                                                                                        <div
                                                                                          key={b.text}
                                                                                          className="inline-flex items-center gap-2 text-[11px] text-neutral-800 dark:text-neutral-300"
                                                                                          title={b.title}
                                                                                        >
                                                                                          <span
                                                                                            className={classNames("w-4 h-4 rounded-sm border", b.className)}
                                                                                            aria-hidden="true"
                                                                                          />
                                                                                          <span className="whitespace-nowrap">{b.text}</span>
                                                                                        </div>
                                                                                      ))}
                                                                                    </div>

                                                                                    {!evalsForSem.length && (
                                                                                      <div className="mt-3 rounded-lg border border-amber-200 bg-amber-50 dark:bg-amber-950/35 px-3 py-2 text-xs text-amber-800">
                                                                                        Aucun devoir n'est associ√© √† ce semestre pour cette classe.
                                                                                      </div>
                                                                                    )}

                                                                                    {rows.length ? (
                                                                                      <div className="mt-3 space-y-3">
                                                                                        {(() => {
                                                                                          const groups: Array<{ key: string; title: string; rows: any[] }> = [];
                                                                                          let lastKey: string | null = null;

                                                                                          rows.forEach((r: any) => {
                                                                                            const title =
                                                                                              (r as any).groupTitle ||
                                                                                              ((r as any).group === "OTHER" ? "AUTRES" : String((r as any).group));
                                                                                            const key = String((r as any).group ?? title);

                                                                                            if (key !== lastKey) {
                                                                                              groups.push({ key, title: String(title), rows: [] });
                                                                                              lastKey = key;
                                                                                            }

                                                                                            groups[groups.length - 1].rows.push(r);
                                                                                          });

                                                                                          return groups.map((g) => {
                                                                                            const chip = libelleChipMeta(String(g.title));

                                                                                            return (
                                                                                              <div
                                                                                                key={g.key}
                                                                                                className={classNames("rounded-xl bg-white dark:bg-[var(--night-panel)] shadow-sm overflow-hidden border-2 bilan-group", chip.border)}
                                                                                              >
                                                                                                <div className={classNames("px-3 py-2 border-b flex items-center justify-between gap-2 bilan-group-header", chip.headerBg, chip.line)}>
                                                                                                  <span
                                                                                                    className={classNames(
                                                                                                      "inline-flex items-center gap-2 rounded-full border px-2 py-0.5 text-[10px] font-semibold",
                                                                                                      chip.bubble
                                                                                                    )}
                                                                                                  >
                                                                                                    <span className={classNames("w-2 h-2 rounded-full", chip.dot)} aria-hidden="true" />
                                                                                                    <span className="whitespace-nowrap">{String(g.title)}</span>
                                                                                                  </span>

                                                                                                  <span className="text-[11px] text-neutral-500 dark:text-neutral-300">{g.rows.length} comp√©tence(s)</span>
                                                                                                </div>

                                                                                                <div className="p-3 grid grid-cols-1 md:grid-cols-2 print:grid-cols-2 gap-2 bilan-group-grid dark:bg-[var(--night-surface)]">
                                                                                                  {g.rows.map((r: any) => {
                                                                                                    const badge = levelBadge(r.lvl);
                                                                                                    const hasItems = Array.isArray(r.items) && r.items.length > 0;

                                                                                                    return (
                                                                                                      <div key={r.code} className={classNames("border rounded-xl shadow-sm overflow-hidden bilan-competence-card", chip.cardBorder)}>
                                                                                                        <div className="px-2 py-1 border-b border-neutral-200 dark:border-sky-400/35 bg-white dark:bg-[var(--night-panel)] flex items-start justify-between gap-3 bilan-competence-head">
                                                                                                          <div className="min-w-0 flex items-start gap-2">
                                                                                                            <div className="text-[11px] font-bold text-neutral-900 dark:text-neutral-300 shrink-0 whitespace-nowrap">
                                                                                                              {r.code}
                                                                                                            </div>
                                                                                                            <div className="text-[11px] font-bold text-neutral-900 dark:text-neutral-300 min-w-0 break-words">{r.label || "‚Äî"}</div>
                                                                                                          </div>

                                                                                                          <span className="shrink-0 inline-flex items-center gap-2" title={badge.title}>
                                                                                                            <span
                                                                                                              className={classNames("w-4 h-4 rounded-sm border", badge.className)}
                                                                                                              aria-hidden="true"
                                                                                                            />
                                                                                                            <span className="text-[11px] font-semibold text-neutral-800 dark:text-neutral-300">{badge.text}</span>
                                                                                                          </span>
                                                                                                        </div>

                                                                                                        {hasItems ? (
                                                                                                          <div className="px-2 py-1 space-y-0.5 bg-white dark:bg-[var(--night-panel)] bilan-competence-items">
                                                                                                            {(r.items as any[]).map((it: any, j: number) => {
                                                                                                              const b = levelBadge(it.lvl);

                                                                                                              return (
                                                                                                                <div
                                                                                                                  key={`${r.code}::item::${j}`}
                                                                                                                  className={classNames(
                                                                                                                    "flex items-start justify-between gap-2 text-[10px] leading-tight rounded-md border px-1 py-0.5 bilan-competence-item",
                                                                                                                    levelRowTint(it.lvl)
                                                                                                                  )}
                                                                                                                >
                                                                                                                  <div className="min-w-0 break-words leading-tight">{it.item || "‚Äî"}</div>
                                                                                                                  <span
                                                                                                                    className={classNames("inline-block w-3.5 h-3.5 rounded-sm border", b.className)}
                                                                                                                    title={b.text}
                                                                                                                    aria-label={b.text}
                                                                                                                  />
                                                                                                                </div>
                                                                                                              );
                                                                                                            })}
                                                                                                          </div>
                                                                                                        ) : (
                                                                                                          <div className="px-2 py-2 text-[11px] text-neutral-500 italic bg-white dark:bg-[var(--night-surface)]">
                                                                                                            Aucun crit√®re.
                                                                                                          </div>
                                                                                                        )}
                                                                                                      </div>
                                                                                                    );
                                                                                                  })}
                                                                                                </div>
                                                                                              </div>
                                                                                            );
                                                                                          });
                                                                                        })()}
                                                                                      </div>
                                                                                    ) : (
                                                                                      <div className="mt-3 rounded-lg border border-neutral-200 dark:border-sky-400/35 bg-neutral-50 dark:bg-[var(--night-surface)] px-3 py-2 text-xs text-neutral-700 dark:text-neutral-300">
                                                                                        Aucun niveau enregistr√© pour cet √©l√®ve sur ce semestre.
                                                                                      </div>
                                                                                    )}
                                                                                  </div>
                      );

                      return (
                        <>
<div className="flex items-start justify-between gap-3 flex-wrap">
  <div className="min-w-0 flex-1">
    <h2 className="text-sm font-semibold text-neutral-900 dark:text-neutral-300">
      Bilan p√©riodique ‚Äì {studentName}
    </h2>

	    <div className="mt-0.5 flex flex-wrap items-center justify-between md:justify-start gap-x-3 md:gap-x-12 gap-y-2">
      <div className="text-[11px] text-neutral-600 dark:text-neutral-300 whitespace-nowrap">
        Ann√©e scolaire : {schoolYear} ‚Ä¢ {trainingYearLabel(trainingYear)}
      </div>

      {/* L√©gende de l'histogramme (d√©plac√©e √† droite de l'ann√©e scolaire, au-dessus du graphe) */}
	      <div className="mt-0.5 flex flex-wrap items-center justify-between md:justify-start gap-x-3 md:gap-x-7 gap-y-2 text-[11px]">
        {refConfig.kind !== "none" && (
          <div className="inline-flex items-center gap-2">
            <span
	              className="w-2.5 h-2.5 md:w-3 md:h-3 rounded-sm border border-neutral-300 dark:border-sky-400/35 app-bgChartReference"
            />
	            <span className="max-w-[260px] leading-tight">{refConfig.label}</span>
          </div>
        )}
        <div className="inline-flex items-center gap-2">
          <span
	            className="w-2.5 h-2.5 md:w-3 md:h-3 rounded-sm border border-neutral-300 dark:border-sky-400/35 app-bgChartStudent"
          />
          <span className="whitespace-nowrap">√âl√®ve</span>
        </div>
        <div className="inline-flex items-center gap-2">
          <span
	            className="w-2.5 h-2.5 md:w-3 md:h-3 rounded-sm border border-neutral-300 dark:border-sky-400/35 app-bgChartClass"
          />
          <span className="whitespace-nowrap">Moy.Classe</span>
        </div>
      </div>
    </div>
  </div>

                            <div className="suivi-tabs inline-flex rounded-full border border-neutral-200 dark:border-sky-400/35 bg-neutral-50 dark:bg-[var(--night-surface)] p-1">
                              <button
                                type="button"
                                onClick={() => setBilanSemester("S1")}
                                className={classNames(
                                  "suivi-btn inline-flex items-center rounded-full transition",
                                  sem === "S1" ? "bg-neutral-900 text-white" : "bg-transparent text-neutral-700 dark:text-neutral-300 hover:bg-amber-100/70 dark:bg-[var(--night-surface)]  dark:hover:bg-[var(--night-hover)]"
                                )}
                              >
                                Semestre 1
                              </button>
                              <button
                                type="button"
                                onClick={() => setBilanSemester("S2")}
                                className={classNames(
                                  "suivi-btn inline-flex items-center rounded-full transition",
                                  sem === "S2" ? "bg-neutral-900 text-white" : "bg-transparent text-neutral-700 dark:text-neutral-300 hover:bg-amber-100/70 dark:bg-[var(--night-surface)]  dark:hover:bg-[var(--night-hover)]"
                                )}
                              >
                                Semestre 2
                              </button>
                            </div>
                          </div>

                                                    <div ref={suiviBilanPdfRef} className="space-y-3 bilan-print-root">

  {/* Livret p√©riodique (impression) ‚Äî visuel type "Camara Lancin√©" */}
  <div className="hidden print-only bilan-livret">
    {(() => {
      const normCode = (c: any) => String(c ?? "").replace(/\s+/g, "");
      const isPage1Code = (code: string) => {
        const c = normCode(code);
        const m = c.match(/^C([1-4])\.(\d+)/i);
        if (!m) return false;
        const major = Number(m[1]);
        const minor = Number(m[2]);
        // Mod√®le Camara : page 1 = C3.11‚ÜíC3.17 + C4.1‚ÜíC4.2
        if (major === 4) return minor === 1 || minor === 2;
        if (major === 3) return minor >= 11 && minor <= 17;
        return false;
      };

      const page1Rows = (rows || []).filter((r: any) => isPage1Code(String(r.code)));
      const page2Rows = (rows || []).filter((r: any) => !isPage1Code(String(r.code)));

      const isPage2Right = (code: string) => {
        const c = normCode(code);
        const m = c.match(/^C([1-4])\.(\d+)/i);
        if (!m) return false;
        const major = Number(m[1]);
        const minor = Number(m[2]);
        return major === 3 && minor >= 2 && minor <= 10;
      };

      const page2LeftRows = (page2Rows || []).filter((r: any) => !isPage2Right(String(r.code)));
      const page2RightRows = (page2Rows || []).filter((r: any) => isPage2Right(String(r.code)));

      const semLabel = sem === "S1" ? "PREMIER SEMESTRE" : "DEUXI√àME SEMESTRE";

      const prettyCompCode = (code: string) => {
        const c = normCode(code);
        const m = c.match(/^C(\d)\.(\d+)/i);
        if (!m) return String(code || "");
        const major = Number(m[1]);
        const minor = Number(m[2]);
        return `C${major}.${minor}`;
      };

      const lvlToBucket = (lvl: Level1to4): "NE" | "NA" | "EA" | "A" => {
        if (lvl === 0) return "NE";
        if (lvl === 1) return "NA";
        if (lvl === 2) return "EA";
        return "A"; // 3 ou 4 ‚Üí acquis
      };

      const overallBucket = (items: any[]): "NE" | "NA" | "EA" | "A" => {
        const lvls = (items || [])
          .map((it: any) => Number(it?.lvl ?? 0))
          .filter((n: number) => isFinite(n) && n > 0);
        if (!lvls.length) return "NE";
        const avg = lvls.reduce((a: number, b: number) => a + b, 0) / lvls.length;
        if (avg < 1.5) return "NA";
        if (avg < 2.5) return "EA";
        return "A";
      };

      // Affichage des niveaux : carr√© color√© (sans "X")
      const Status = ({ b }: { b: "NE" | "NA" | "EA" | "A" }) => (
        <span className={classNames("lp-status", b)} aria-label={b} />
      );

      const renderCompList = (rs: any[]) => (
        <div>
          {(rs || []).map((r: any, idx: number) => {
            const items = Array.isArray(r.items) && r.items.length ? r.items : [{ item: "", lvl: 0 }];
            const bHead = overallBucket(items);
            return (
              <div key={String(r.code) + "__" + idx} className="lp-compBlock" style={idx === 0 ? { marginTop: 0 } : undefined}>
                <div className="lp-compHead">
                  <div>
                    <span>{prettyCompCode(String(r.code))} </span>
                    <span>{String(r.label ?? "")}</span>
                  </div>
                  <div className="text-right">
                    <Status b={bHead} />
                  </div>
                </div>

                {(items || []).map((it: any, j: number) => {
                  const b = lvlToBucket(it?.lvl as any);
                  const txt = String(it?.item ?? "").trim();
                  if (!txt) return null;
                  return (
                    <div key={`${r.code}__${j}`} className="lp-compItem">
                      <div className="lp-pl10">{txt}</div>
                      <div className="text-right">
                        <Status b={b} />
                      </div>
                    </div>
                  );
                })}
              </div>
            );
          })}
        </div>
      );

      // Activit√©s r√©alis√©es (d'apr√®s les t√¢ches associ√©es aux devoirs du semestre)
      const tasksDoneCodes = new Set<string>();

      const toTaskCode = (val: any): string | null => {
        const raw = String(val ?? "").trim();
        const m = raw.match(/T\s*0*(\d+)/i);
        if (!m) return null;
        const n = Number(m[1]);
        if (!isFinite(n) || n <= 0) return null;
        return `T${String(n).padStart(2, "0")}`;
      };

      // Agr√®ge toutes les t√¢ches s√©lectionn√©es dans les devoirs du semestre affich√©
      (evalsForSem || []).forEach((ev: any) => {
        const arr = (tasksByEvalId as any)?.[String(ev.id)] || [];
        (arr || []).forEach((t: any) => {
          const code = toTaskCode(t);
          if (code) tasksDoneCodes.add(code);
        });
      });

      // Liste exhaustive (T01 ‚Üí T17) √† partir du r√©f√©rentiel tcMap
      const allTasks = Object.keys(tcMap || {})
        .filter((t: any) => {
          const code = toTaskCode(t);
          if (!code) return false;
          const n = Number(code.replace(/^T/i, ""));
          return isFinite(n) && n >= 1 && n <= 17;
        })
        .sort((a, b) => taskNumber(a) - taskNumber(b));

      const splitTask = (t: string) => {
        const raw = String(t || "").trim();
        const m = raw.match(/^T\s*0*(\d+)\s*/i);
        if (!m) return { code: raw, label: "", codeKey: raw };
        const n = Number(m[1]);
        const codeKey = `T${String(n).padStart(2, "0")}`;
        const code = `T ${String(n).padStart(2, "0")}`;
        const label = raw.replace(/^T\s*0*\d+\s*/i, "").trim();
        return { code, label, codeKey };
      };

      const renderTasksList = () => (
        <div className="lp-mt6">
          {allTasks.map((t: string) => {
            const { code, label, codeKey } = splitTask(t);
            return (
              <div key={t} className="lp-taskRow">
                <div className="lp-taskCode">{code}</div>
                <div>{label || " "}</div>
                <div className="lp-taskMark">{tasksDoneCodes.has(codeKey) ? "X" : ""}</div>
              </div>
            );
          })}
        </div>
      );

      const bars = Array.isArray(chartData) ? chartData : [];
      const CHART_CODES = [
        "C1.01","C1.02","C2.01","C2.02","C2.03","C3.01","C3.02","C3.03","C3.04","C3.05","C3.06","C3.07","C3.08","C3.09","C3.10","C3.11","C3.12","C3.13","C3.14","C3.15","C3.16","C3.17","C4.01","C4.02"
      ];
      const byCode = new Map<string, any>();
      (bars || []).forEach((d: any) => {
        const k = String(d?.competence ?? d?.Competence ?? "").trim();
        if (k) byCode.set(k, d);
      });
      const barItems = CHART_CODES.map((code) => ({ code, d: byCode.get(code) }));

      const light = bilanAbsencesTrafficAuto as any;
      const dotClass = (c: "red" | "yellow" | "green") =>
        classNames("lp-trafficDot", light === c ? c : "");

      const appreciationText = (bilanAppreciationNote || "").trim() ? bilanAppreciationNote : " ";
      const absAutoSummary = bilanAbsencesAuto
        ? (bilanAbsencesAuto.denom > 0
            ? `AB: ${bilanAbsencesAuto.ab} (${Math.round(bilanAbsencesAuto.abPct * 10) / 10}%) ‚Ä¢ RT: ${bilanAbsencesAuto.rt} (${Math.round(bilanAbsencesAuto.rtPct * 10) / 10}%)`
            : "")
        : "";
      const absNote = (bilanAbsencesNote || "").trim();
      const absText = [absAutoSummary, absNote].filter(Boolean).join(" ‚Äî ") || " ";

      const legendLine = (
        <div className="lp-legendLine">
          <span className="lp-legItem">¬´ <Status b="NA" /> ¬ª Comp√©tence non acquise</span>
          <span className="lp-legItem">¬´ <Status b="A" /> ¬ª Comp√©tence acquise</span>
          <span className="lp-legItem">¬´ <Status b="EA" /> ¬ª Comp√©tence en voie d&apos;acquisition</span>
          <span className="lp-legItem">¬´ <Status b="NE" /> ¬ª Comp√©tence non √©valu√©e</span>
        </div>
      );

      return (
        <div>
          {/* PAGE 1 */}
          <div className="livret-page lp-page">
            <div className="lp-grid">
              <div className="lp-col">{renderCompList(page1Rows)}</div>

              <div className="lp-col">
                <div className="lp-rightTitle">Livret p√©riodique d&apos;√©valuation {schoolYear}</div>
                <div className="lp-sem">{semLabel}</div>
                <div className="lp-nameBox">{studentName}</div>
                <div className="lp-centerInfo">
                  {(() => {
                    const classKey = selectedClassIdForSuivi || "";
                    const referent =
                      (generalSettings.classReferents?.[classKey] || generalSettings.defaultReferents || "‚Äî");
                    const etab = generalSettings.establishmentName || "‚Äî";
                    const loc = (generalSettings.establishmentLocation || "").trim();
                    const locLines = loc
                      ? loc
                          .replace(/[‚Äî‚Äì]/g, "-")
                          .split(/\r?\n/)
                          .flatMap((l) => l.split(/\s*-\s*/))
                          .map((s) => s.trim())
                          .filter(Boolean)
                      : [];
                    return (
                      <>
                        <div>R√©f√©rent {referent}</div>
                        <div className="lp-etabRow">
                          <span className="lp-etabLabel">√âtablissement </span>
                          <span className="lp-etabName">{etab}</span>
                        </div>
                        {locLines.map((line, idx) => (
                          <div key={idx} className="lp-etabLine">{line}</div>
                        ))}
                      </>
                    );
                  })()}
                </div>

                <div className="lp-chartFrame">
                  <div className="lp-chart">
                    <div className="lp-plot">
                      <div className="lp-band top" />
                      <div className="lp-band mid" />
                      <div className="lp-band bot" />
                      <div className="lp-midLine" />
                      <div className="lp-bars">
                        {barItems.map(({ code, d }: any, i: number) => {
                          const vE = Number(d?.Eleve ?? d?.eleve ?? 0);
                          const vC = Number(d?.Classe ?? d?.classe ?? 0);
                          const hE = Math.max(0, Math.min(1, vE / 20));
                          const hC = Math.max(0, Math.min(1, vC / 20));
                          return (
                            <div key={`${code}__${i}`} className="lp-barWrap">
                              <div className="lp-barPair">
                                <div className="lp-bar" style={{ height: `${hE * 100}%` }} />
                                <div className="lp-bar gray" style={{ height: `${hC * 100}%` }} />
                              </div>
                            </div>
                          );
                        })}
                      </div>
                    </div>

                    <div className="lp-labels">
                      {barItems.map(({ code }: any, i: number) => (
                        <div key={`${code}__lbl__${i}`} className="lp-labelWrap">
                          <div className="lp-xlbl">{code}</div>
                        </div>
                      ))}
                    </div>
                  </div>
                </div>

                <div className="lp-absBox">
                  <div className="lp-traffic">
                    <span className={dotClass("red")} />
                    <span className={dotClass("yellow")} />
                    <span className={dotClass("green")} />
                  </div>
                  <div className="lp-absText">{absText}</div>
                </div>

                <div className="lp-motivTitle">Int√©r√™t pour la pratique professionnelle</div>
                <div
                  className={classNames(
                    "lp-motivBox",
                    !motivationScores.length
                      ? ""
                      : motivationAvg >= 3.5
                        ? "good"
                        : motivationAvg >= 2.5
                          ? "mid"
                          : "bad"
                  )}
                >
                  {motivationResult}
                </div>

                <div className="lp-appTitle">Appr√©ciation g√©n√©rale de l&apos;√©quipe p√©dagogique</div>
                <div className="lp-appBox">{appreciationText}</div>

                <table className="lp-signTable">
                  <thead>
                    <tr>
                      <th>Equipe p√©dagogique</th>
                      <th>El√®ve</th>
                      <th>Responsables l√©gaux</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td className="lp-signBlank" />
                      <td className="lp-signBlank" />
                      <td className="lp-signBlank" />
                    </tr>
                  </tbody>
                </table>
              </div>
            </div>
          </div>

          {/* PAGE 2 */}
          <div className="livret-page lp-page">
            <div className="lp-grid">
              <div className="lp-col">
                <div className="lp-grayTitle">ACTIVIT√â R√âALIS√âES</div>
                <div className="lp-note">¬´ X ¬ª VUE EN COURS DE PRATIQUE PROFESSIONNELLE</div>
                {renderTasksList()}

                <div className="lp-grayTitle lp-mt12">RELEV√â DES COMP√âTENCES</div>
                {legendLine}
                {renderCompList(page2LeftRows)}
              </div>

              <div className="lp-col">{renderCompList(page2RightRows)}</div>
            </div>
          </div>
        </div>
      );
    })()}
  </div>

  <div className="bilan-screen-layout">
                            {/* Synth√®se */}
                            <div className="space-y-3 bilan-page-1">
                                                          <div className="grid grid-cols-1 lg:grid-cols-12 print:grid-cols-12 print:items-start gap-3">
                                                            <div className="lg:col-span-9 print:col-span-9 h-full flex min-h-0 min-w-0">
                                                            <div className="rounded-lg border border-neutral-200 dark:border-sky-400/35 bg-white dark:bg-[var(--night-surface)] keep-light p-2 shadow-sm h-full flex flex-col min-h-0 flex-1 min-w-0">                         
                                                                                                                        <div className="mt-0 bilan-chart-wrap flex-1 min-h-[140px] print:min-h-[200px] min-w-0 w-full overflow-hidden">
                                                                                                                          <div className="w-full h-full">
                                                                                                                            <ResponsiveContainer width="100%" height="100%">
                                                                                                                              <BarChart data={chartData} margin={{ top: 0, right: 6, left: 0, bottom: 4 }}>
                                                                                                                                {/* Zones (m√™mes couleurs que l'histogramme "√âvolutions") */}
                                                                                                                                {/* D√©couverte */}
                                                                                                                                <ReferenceArea y1={0} y2={5} fill="var(--bilan-zone-decouverte)" />
                                                                                                                                {/* Apprentissage */}
                                                                                                                                <ReferenceArea y1={5} y2={10} fill="var(--bilan-zone-apprentissage)" />
                                                                                                                                {/* Acquisition */}
                                                                                                                                <ReferenceArea y1={10} y2={20} fill="var(--bilan-zone-acquisition)" />
                                                                                                                                <ReferenceLine y={10} stroke="var(--bilan-midline-stroke)" strokeWidth={1} strokeOpacity={0.9} />

                                                                                                                                <CartesianGrid stroke="var(--bilan-grid-stroke)" strokeDasharray="3 3" />
                                                                                                                                <XAxis
                                                                                                                                  dataKey="competence"
                                                                                                                                  interval={0}
                                                                                                                                  angle={-25}
                                                                                                                                  textAnchor="end"
                                                                                                                                  height={28}
                                                                                                                                  tickMargin={2}
                                                                                                                                  tick={{ fontSize: 8, fill: "var(--bilan-axis-text)" }}
                                                                                                                                  axisLine={{ stroke: "var(--bilan-axis-line)" }}
                                                                                                                                  tickLine={{ stroke: "var(--bilan-axis-line)" }}
                                                                                                                                />
                                                                                                                                <YAxis domain={[0, 20]} hide width={0} />
                                                                                                                                <Tooltip
                                                                                                                                  contentStyle={{
                                                                                                                                    backgroundColor: "var(--bilan-tooltip-bg)",
                                                                                                                                    border: "1px solid var(--bilan-tooltip-border)",
                                                                                                                                    borderRadius: 8,
                                                                                                                                    color: "var(--bilan-tooltip-text)",
                                                                                                                                    fontSize: 12,
                                                                                                                                    padding: "8px 10px",
                                                                                                                                  }}
                                                                                                                                  labelStyle={{
                                                                                                                                    color: "var(--bilan-tooltip-text)",
                                                                                                                                    fontWeight: 700,
                                                                                                                                  }}
                                                                                                                                  itemStyle={{
                                                                                                                                    color: "var(--bilan-tooltip-text)",
                                                                                                                                  }}
                                                                                                                                  cursor={{ fill: "var(--bilan-cursor-fill)" }}

                                                                                                                                  labelFormatter={(code: any) => {
                                                                                                                                    const found = (chartData as any[])?.find((d: any) => d?.competence === code);
                                                                                                                                    return found?.label ? `${String(code)} ‚Äî ${String(found.label)}` : String(code);
                                                                                                                                  }}
                                                                                                                                  formatter={(v: any, name: any) => {
                                                                                                                                    if (typeof v !== "number" || !isFinite(v)) return ["‚Äî", name];
                                                                                                                                    return [`${v.toFixed(1)} /20`, name];
                                                                                                                                  }}
                                                                                                                                />
                                                                                                                                
                                                                                                                                {refConfig.kind !== "none" && (
																					<Bar name={refConfig.label} dataKey="Reference" fill="var(--chart-reference)" />
                                                                                                                                )}
																				<Bar name="√âl√®ve" dataKey="Eleve" fill="var(--chart-student)" />
																				<Bar name="Moy.Classe" dataKey="Classe" fill="var(--chart-class)" />
                                                                                                                              </BarChart>
                                                                                                                            </ResponsiveContainer>
                                                                                                                          </div>
                                                                                                                        </div>

																					<div className="hidden print-only mt-1 flex flex-wrap items-center justify-center gap-x-3 gap-y-1 text-[10px] text-neutral-700 dark:text-neutral-300">
																					  {refConfig.kind !== "none" && (
																					    <div className="inline-flex items-center gap-2">
																					      <span className="w-2.5 h-2.5 rounded-sm border border-neutral-300 dark:border-sky-400/35 app-bgChartReference" />
																					      <span className="max-w-[260px] leading-tight">{refConfig.label}</span>
																					    </div>
																					  )}
																					  <div className="inline-flex items-center gap-2">
																					    <span className="w-2.5 h-2.5 rounded-sm border border-neutral-300 dark:border-sky-400/35 app-bgChartStudent" />
																					    <span className="whitespace-nowrap">√âl√®ve</span>
																					  </div>
																					  <div className="inline-flex items-center gap-2">
																					    <span className="w-2.5 h-2.5 rounded-sm border border-neutral-300 dark:border-sky-400/35 app-bgChartClass" />
																					    <span className="whitespace-nowrap">Moy.Classe</span>
																					  </div>
																					</div>
                                                                                                                      </div>
                                                            </div>
                                                            <div className="lg:col-span-3 print:col-span-3 print:self-start space-y-3">
                                                            <div className="rounded-lg border border-neutral-200 dark:border-sky-400/35 bg-white dark:bg-[var(--night-surface)] keep-light p-2 shadow-sm">
  <div className="flex items-start gap-2">
    <div className="shrink-0 pt-0.5">
      {/* √âcran : s√©lecteur (interactif) */}
      <div className="no-print">
        <TrafficLightPicker
  value={bilanAbsencesTrafficAuto}
  onChange={() => {}}
  className="pointer-events-none opacity-90"
/>

      </div>

      {/* Impression / aper√ßu : rendu statique (les <button> sont masqu√©s dans le CSS d'impression) */}
      <div className="hidden print-only">
        <div className="inline-flex flex-col items-center gap-0.5 rounded-md border border-neutral-200 dark:border-sky-400/35 bg-white dark:bg-[var(--night-panel)] px-0.5 py-0.5">
          {(
            [
              { v: "green" as const, colorClass: "bg-emerald-500", label: "Vert" },
              { v: "yellow" as const, colorClass: "bg-amber-400", label: "Orange" },
              { v: "red" as const, colorClass: "bg-red-500", label: "Rouge" },
            ]
          ).map((it) => {
            const active = bilanAbsencesTrafficAuto === it.v;
            return (
              <span key={it.v} title={it.label} aria-label={it.label} className="rounded-full p-0.5">
                <span
                  className={classNames(
                    "block h-3 w-3 rounded-full border app-border",
                    it.colorClass,
                    active ? "opacity-100 ring-2 ring-inset ring-neutral-900/30" : "opacity-30"
                  )}
                />
              </span>
            );
          })}
        </div>
      </div>
    </div>

    <div className="min-w-0 flex-1">
      <h3 className="text-xs font-semibold tracking-wide text-neutral-900 dark:text-neutral-300">Absences / retards</h3>

      <div className="mt-1 text-xs text-neutral-700 dark:text-neutral-300">
        {bilanAbsencesAuto ? (
          bilanAbsencesAuto.denom > 0 ? (
            <div className="space-y-0.5">
              <div>
                P√©riode : <b>{bilanAbsencesAuto.periodLabel}</b> ‚Ä¢ Jours de cours effectifs : <b>{bilanAbsencesAuto.denom}</b>
              </div>
              <div>
                Absences : <b>{bilanAbsencesAuto.ab}</b> ({Math.round(bilanAbsencesAuto.abPct * 10) / 10}%) ‚Ä¢ Retards :{" "}
                <b>{bilanAbsencesAuto.rt}</b> ({Math.round(bilanAbsencesAuto.rtPct * 10) / 10}%)
              </div>
            </div>
          ) : (
            <div className="text-neutral-500 dark:text-neutral-300">
              Aucun jour de cours effectif sur la p√©riode (planning / vacances / PFMP).
            </div>
          )
        ) : (
          <div className="text-neutral-500 dark:text-neutral-300">‚Äî</div>
        )}
      </div>

      <div className="mt-1">


        <div className="hidden print-only mt-1 min-h-[48px] rounded-md border border-neutral-200 dark:border-sky-400/35 bg-white dark:bg-[var(--night-panel)] px-2 py-1 text-xs text-neutral-900 dark:text-neutral-300 whitespace-pre-wrap">
          {(bilanAbsencesNote || "").trim() ? bilanAbsencesNote : "‚Äî"}
        </div>
        <div className="hidden print-only mt-2">
          <div className="text-[10px] font-semibold tracking-wide text-neutral-900 dark:text-neutral-300">
            Int√©r√™t pour la pratique professionnelle
          </div>
          <div
            className={classNames(
              "mt-1 inline-flex items-center justify-center rounded-md border-2 bg-white dark:bg-[var(--night-panel)] px-2 py-1 text-[11px] font-extrabold tracking-wide text-neutral-900 dark:text-neutral-300",
              !motivationScores.length
                ? "border-neutral-200 dark:border-sky-400/35"
                : motivationAvg >= 3.5
                  ? "border-emerald-500"
                  : motivationAvg >= 2.5
                    ? "border-amber-400"
                    : "border-red-500"
            )}
          >
            {motivationResult}
          </div>
        </div>

      </div>
    </div>
  </div>
</div>
<div className="no-print rounded-lg border border-neutral-200 dark:border-sky-400/35 bg-white dark:bg-[var(--night-surface)] keep-light p-2 shadow-sm">
                                                              <h3 className="text-xs font-semibold tracking-wide text-neutral-900 dark:text-neutral-300">
                                                                Int√©r√™t pour la pratique professionnelle
                                                              </h3>
                                                              <div
                                                                className={classNames(
                                                                  "mt-2 flex items-center justify-center rounded-md border-2 bg-white dark:bg-[var(--night-panel)] p-2 text-center",
                                                                  !motivationScores.length
                                                                    ? "border-neutral-200 dark:border-sky-400/35"
                                                                    : motivationAvg >= 3.5
                                                                      ? "border-emerald-500"
                                                                      : motivationAvg >= 2.5
                                                                        ? "border-amber-400"
                                                                        : "border-red-500"
                                                                )}
                                                              >
                                                                <div className="text-lg font-extrabold tracking-wide text-neutral-900 dark:text-neutral-300">{motivationResult}</div>
                                                              </div>
                                                            </div>
<div className="rounded-lg border border-neutral-200 dark:border-sky-400/35 bg-white dark:bg-[var(--night-surface)] keep-light  p-2 shadow-sm">
  <h3 className="text-xs font-semibold tracking-wide text-neutral-900 dark:text-neutral-300">Appr√©ciation g√©n√©rale</h3>
  <div className="mt-1">
    <Textarea
      value={bilanAppreciationNote}
      onChange={(e) => setBilanAppreciationNote(e.target.value)}
      placeholder="Ex : Progr√®s constants, s√©rieux et implication satisfaisante."
      className="no-print min-h-[72px] text-xs bg-white text-neutral-900 placeholder:text-neutral-500 border border-neutral-200 focus-visible:ring-0 focus-visible:ring-offset-0 dark:!bg-[var(--night-panel)] dark:!text-neutral-50 dark:placeholder:text-neutral-400 dark:!border-neutral-700/60"
    />
    <div className="hidden print-only mt-1 min-h-[72px] rounded-md border border-neutral-200 dark:border-sky-400/35 bg-white dark:bg-[var(--night-panel)] px-2 py-1 text-xs text-neutral-900 dark:text-neutral-300 whitespace-pre-wrap">
      {(bilanAppreciationNote || "").trim() ? bilanAppreciationNote : "‚Äî"}
    </div>
  </div>
</div>

                                                          </div>
                                                          {/* Relev√© des comp√©tences (impression) */}
                                                          <div className="hidden print-only bilan-page-2 print:col-span-12">
                                                            {renderCompetencesPanel()}
                                                          </div>
                                                          </div>
                                                        </div>
                            {/* Relev√© des comp√©tences (√©cran) */}
                            <div className="no-print bilan-page-2">
                              {renderCompetencesPanel()}
                            </div>
                          </div>
                          </div>
                        </>
                      );
                    })()}
                  </div>
                )
              )}


              {suiviMode === "classe" && (
                !classe ? (
                  <p className="text-sm text-neutral-600 dark:text-neutral-300">
                    S√©lectionnez une classe pour afficher la vue d'ensemble.
                  </p>
                ) : (
<div ref={suiviClassePdfRef} className="mt-4 space-y-4">
  <div className="no-print flex items-center justify-between">
    <div>
      <h2 className="text-sm font-semibold text-neutral-900 dark:text-neutral-300">
        Vue d&apos;ensemble ‚Äì {classe.name}
      </h2>
    </div>
  </div>

  {/* ... ton contenu existant (TasksVoletTotal + DoubleSemesterMatrix) ... */}


                     <div className="flex gap-2 items-start overflow-x-auto pb-6">
                      {/* Colonne de boutons (T√¢ches) */}
                      <div className="flex flex-col items-center mt-10 space-y-2">
                        <button
                          type="button"
                          onClick={() => setShowTasksVolet((prev) => !prev)}
                          className="w-8 h-16 flex items-center justify-center rounded-r-lg border border-neutral-300 dark:border-sky-400/35 bg-white hover:bg-amber-100/70 dark:bg-[var(--night-surface)] shadow-sm hover:bg-amber-100/70 dark:bg-[var(--night-surface)]"
                          title={
                            showTasksVolet
                              ? "Masquer le volet des t√¢ches"
                              : "Afficher le volet des t√¢ches"
                          }
                        >
                          <span
                            className={
                    "text-[10px] font-semibold tracking-wide " +
                    (showTasksVolet ? "text-neutral-900 dark:text-neutral-300" : "text-neutral-500") +
                    " app-verticalHeaderWrap"
                  }
                            
                          >
                            T√ÇCHES
                          </span>
                        </button>
                      </div>

                      {/* Volet T√¢ches TOTAL repliable */}
                      <div className="flex flex-col gap-2">
                        <div
                          className={`transition-all duration-200 ease-in-out ${
                            showTasksVolet
                              ? "opacity-100 translate-x-0 w-auto min-w-[260px]"
                              : "opacity-0 -translate-x-4 w-0 pointer-events-none"
                          }`}
                        >
                          {showTasksVolet && (
                            <TasksVoletTotal selectedClassId={selectedClassIdForSuivi} />
                          )}
                        </div>
                      </div>

                      {/* Zone principale : tableau combin√© S1 + S2 */}
                      <div className="flex flex-col gap-4 flex-1 min-w-[600px]">
                        <DoubleSemesterMatrix
                          allCompetences={allCompetencesForSuivi}
                          evalMetaList={evalMetaList}
                          selectedClassId={selectedClassIdForSuivi}
                          compsByEvalId={compsByEvalId}
                          onAddDevoirS1={() => {
                            setClasseSemesterForSuivi("S1");
                            handleOpenDevoirDatabase();
                          }}
                          onAddDevoirS2={() => {
                            setClasseSemesterForSuivi("S2");
                            handleOpenDevoirDatabase();
                          }}
                          onRemoveDevoir={(ev) => {
                            handleRemoveEvalFromClasseSemester(ev.id);
                          }}
                          onOpenDevoir={handleOpenClasseDevoir}
                        />
                      </div>
                    </div>
                  </div>
                )
              )}
            </div>
          </>
        );
      })()}
    </section>
  </>

) : activeView === "suivi_eleves" ? (
  <>
    {/* üóÇÔ∏è VUE : SUIVI D'√âL√àVES (DOCUMENTS PDF) */}
    <section className="space-y-4 px-2 sm:px-3 lg:px-4 pt-2 pb-12">
      {(() => {
        const classe = classGroups.find((c) => c.name === selectedClassIdForSuiviDocs);
        const students = classe
          ? (classe.students || "")
              .split("\n")
              .map((s) => s.trim())
              .filter(Boolean)
          : [];

        // Absences / retards : s'appuie sur la s√©lection de classe du suivi (selectedClassIdForSuivi)
        const classeAbs = classGroups.find((c) => c.name === selectedClassIdForSuivi);
        const studentsAbs = classeAbs
          ? (classeAbs.students || "")
              .split("\n")
              .map((s) => s.trim())
              .filter(Boolean)
          : [];
          
        const studentsAbsFiltered = studentsAbs;
        const ready = Boolean(classe && selectedStudentForDocs);

        const DOC_ROOT = "suivi_eleves_docs";
        const folders = docFolders;

        const basePath = (folderKey: string) => {
          const classPart = sanitizeFileNamePart(selectedClassIdForSuiviDocs || "classe");
          const studentPart = sanitizeFileNamePart(selectedStudentForDocs || "eleve");
          const folderPart = sanitizeFileNamePart(folderKey);
          return `${DOC_ROOT}/${trainingYear}/${classPart}/${studentPart}/${folderPart}`;
        };

        const handleUploadPdf = async (folderKey: string) => {
          if (!ready) return;
          if (!isTauriRuntime()) {
            alert("L'ajout de PDF est disponible uniquement dans la version install√©e (Tauri).");
            return;
          }

          const picked = await open({
            multiple: false,
            filters: [{ name: "PDF", extensions: ["pdf"] }],
          });

          const srcPath = Array.isArray(picked) ? picked[0] : picked;
          if (!srcPath) return;

          const srcName = String(srcPath).split(/[\\/]/).pop() || "document.pdf";
          const safeName = sanitizeFileNamePart(srcName.replace(/\.pdf$/i, "")) + ".pdf";
          const destDir = basePath(folderKey);
          const destName = `${tsForFileName()}_${safeName}`;
          const destRel = `${destDir}/${destName}`;

          try {
            await mkdir(destDir, { baseDir: BaseDirectory.AppLocalData, recursive: true });
            const bytes = await readFile(srcPath);
            await writeFile(destRel, bytes, { baseDir: BaseDirectory.AppLocalData });
            setDocsRefreshNonce((n) => n + 1);
          } catch (e: any) {
            alert(`Impossible d'ajouter le PDF.\n${e?.message || e}`);
          }
        };

        const handleViewPdf = async (relPath: string) => {
          try {
            const bytes = await readFile(relPath, { baseDir: BaseDirectory.AppLocalData });
            const blob = new Blob([bytes], { type: "application/pdf" });
            const url = URL.createObjectURL(blob);
            const name = String(relPath).split(/[\\/]/).pop() || "document.pdf";
            setPdfViewer({ url, name, relPath });
          } catch (e: any) {
            alert(`Impossible d'ouvrir le PDF.\n${e?.message || e}`);
          }
        };

        const handleDeletePdf = async (relPath: string) => {
          const ok = await confirm("Supprimer ce PDF ?", { title: "Suppression", kind: "warning" });
          if (!ok) return;
          try {
            await remove(relPath, { baseDir: BaseDirectory.AppLocalData });
            setDocsRefreshNonce((n) => n + 1);
          } catch (e: any) {
            alert(`Impossible de supprimer.\n${e?.message || e}`);
          }
        };

        return (
          <>

{/* üîù BANDEAU STICKY : sous-onglets + filtres (comme NOTATION / SUIVI) */}
<div className="sticky top-[67px] z-50 backdrop-blur border-b border-black dark:border-sky-400/35 bg-white/70 dark:bg-[var(--night-panel)]/70 dark:bg-[var(--night-panel)]/95 dark:border-[var(--night-border-strong)] dark:text-white night-banner">
  <div className="flex flex-col gap-4 sm:flex-row sm:items-end py-2 px-2 sm:px-4 lg:px-6">
    {/* Sous-onglets */}
    <div className="flex-1 space-y-1">
      <div className="suivi-tabs inline-flex rounded-full border border-neutral-200 dark:border-sky-400/35 bg-neutral-50 dark:bg-[var(--night-surface)] p-1">
        <button
          type="button"
          onClick={() => setSuiviElevesMode("docs")}
          className="suivi-btn"
          data-state={suiviElevesMode === "docs" ? "active" : "inactive"}
        >
          <span className="suivi-icon" aria-hidden="true">üìÑ</span>
          <span className="suivi-label">Documents</span>
        </button>
        <button
          type="button"
          onClick={() => setSuiviElevesMode("absences")}
          className="suivi-btn"
          data-state={suiviElevesMode === "absences" ? "active" : "inactive"}
        >
          <span className="suivi-icon" aria-hidden="true">‚è±Ô∏è</span>
          <span className="suivi-label">Absences / retards</span>
        </button>
      </div>
    </div>

    {/* Actions / filtres */}
    <div className="flex flex-wrap items-end gap-2 sm:ml-auto sm:justify-end">
      {isDocsView && (
        <Button
          type="button"
          className="h-8 px-2 text-xs border border-neutral-300 dark:border-sky-400/35 !bg-white dark:!bg-[var(--night-surface)] !text-neutral-900 dark:!text-neutral-50 hover:!bg-amber-100/70 dark:hover:!bg-[var(--night-hover)]"
          onClick={handleAddDocFolder}
          title="Ajouter un porte-document"
        >
          <Plus className="w-4 h-4 mr-1" /> Ajouter un dossier
        </Button>
      )}

      {/* 1√®re / 2√®me */}
      <div className="suivi-tabs inline-flex rounded-full border border-neutral-200 dark:border-sky-400/35 bg-neutral-50 dark:bg-[var(--night-surface)] p-1">
        <button
          type="button"
          onClick={() => switchTrainingYear("premiere")}
          className="suivi-btn"
          data-state={trainingYear === "premiere" ? "active" : "inactive"}
        >
          1√®re
        </button>
        <button
          type="button"
          onClick={() => switchTrainingYear("deuxieme")}
          className="suivi-btn"
          data-state={trainingYear === "deuxieme" ? "active" : "inactive"}
        >
          2√®me
        </button>
      </div>

      {/* Classe */}
      {isDocsView ? (
        <select
          className="h-8 w-[130px] sm:w-[180px] border border-neutral-300 dark:border-sky-400/35 rounded-md bg-white dark:bg-[var(--night-surface)] px-2 text-xs"
          value={selectedClassIdForSuiviDocs ?? ""}
          onChange={(e) => {
            const next = e.target.value || null;
            setSelectedClassIdForSuiviDocs(next);
            setSelectedStudentForDocs(null);
          }}
        >
          <option value="" disabled>Classe‚Ä¶</option>
          {classGroups.map((c) => (
            <option key={c.id} value={c.name}>
              {c.name}
            </option>
          ))}
        </select>
      ) : (
        <select
          className="h-8 w-[130px] sm:w-[180px] border border-neutral-300 dark:border-sky-400/35 rounded-md bg-white dark:bg-[var(--night-surface)] px-2 text-xs"
          value={selectedClassIdForSuivi ?? ""}
          onChange={(e) => {
            const next = e.target.value || null;
            setSelectedClassIdForSuivi(next);
            setSelectedStudentForSuivi(null);
            setSelectedEvalIdForClasse(null);
          }}
        >
          <option value="" disabled>Classe‚Ä¶</option>
          {classGroups.map((c) => (
            <option key={c.id} value={c.name}>
              {c.name}
            </option>
          ))}
        </select>
      )}

      {/* √âl√®ve */}
      {isDocsView ? (
        <select
          className="h-8 w-[190px] sm:w-[200px] border border-neutral-300 dark:border-sky-400/35 rounded-md bg-white dark:bg-[var(--night-surface)] px-2 text-xs disabled:opacity-60"
          value={selectedStudentForDocs ?? ""}
          onChange={(e) => setSelectedStudentForDocs(e.target.value || null)}
          disabled={!classe || students.length === 0}
        >
          <option value="" disabled>√âl√®ve‚Ä¶</option>
          {students.map((st) => (
            <option key={st} value={st}>
              {st}
            </option>
          ))}
        </select>
      ) : !isAbsencesView ? (
        (() => {
          const classe = classGroups.find((c) => c.name === selectedClassIdForSuivi);
          const students = classe
            ? (classe.students || "")
                .split("\n")
                .map((s) => s.trim())
                .filter(Boolean)
            : [];
          const disabled = !classe || students.length === 0;

          return (
            <select
              className="h-8 w-[130px] sm:w-[200px] border border-neutral-300 dark:border-sky-400/35 rounded-md bg-white dark:bg-[var(--night-surface)] px-2 text-xs disabled:opacity-60"
              value={selectedStudentForSuivi ?? ""}
              onChange={(e) => setSelectedStudentForSuivi(e.target.value)}
              disabled={disabled}
            >
              <option value="">Tous les √©l√®ves</option>
              {students.map((st) => (
                <option key={st} value={st}>
                  {st}
                </option>
              ))}
            </select>
          );
        })()
      ) : null}
    </div>
  </div>
</div>

          <div className="flex gap-3">
            <div className="flex-1 flex flex-col gap-3 rounded-xl border border-neutral-200 dark:border-sky-400/35 bg-white dark:bg-[var(--night-panel)] px-3 py-3 shadow-sm">          
              
              {isAbsencesView && (
                !classeAbs ? (
                  <p className="text-sm text-neutral-600 dark:text-neutral-300">
                    S√©lectionnez une classeAbs pour afficher le planning annuel.
                  </p>
                ) : (
                  (() => {
                    const classId = classeAbs.name;
                    const classLabel = sanitizeAbsencesClassName(classId);
                    const yearBucket =
                      (absencesStore.records?.[absencesSchoolYear]?.[classId] || {}) as Record<
                        string,
                        Record<string, AttendanceStatus>
                      >;

                    const startYmd = absencesPlanningSettings.startYmd;
                    const endYmd = absencesPlanningSettings.endYmd;

                    const vacationRanges: VacationRange[] =
                      absencesPlanningSettings.vacationsMode === "auto"
                        ? absencesAutoVacationsForKey || []
                        : (absencesPlanningSettings.vacationsManual || []).map((r) => ({
                            startYmd: r.startYmd,
                            endYmdExclusive: addDaysYmd(r.endYmd, 1),
                            label: r.label || "Vacances",
                          }));

                    const stageRanges: VacationRange[] = (absencesPlanningSettings.stages || []).map((r) => ({
                      startYmd: r.startYmd,
                      endYmdExclusive: addDaysYmd(r.endYmd, 1),
                      label: r.label || "Stage",
                    }));

                    // Base de calcul des % : jours de COURS effectifs (hors vacances et PFMP), du d√©but jusqu'√† aujourd'hui
                    const cutoffYmd = todayYmd < endYmd ? todayYmd : endYmd;
                    const effectiveCourseYmdSet = (() => {
                      const set = new Set<string>();
                      const s = fromYmd(startYmd);
                      const e = fromYmd(cutoffYmd);
                      if (!s || !e) return set;
                      for (let d = new Date(s.getTime()); d <= e; d = addDays(d, 1)) {
                        const wdKey = weekdayKeyFromDate(d);
                        if (!absencesPlanningSettings.courseDays?.[wdKey]) continue;
                        const ymd = toYmd(d);
                        if (findLabelInRanges(ymd, vacationRanges)) continue;
                        if (findLabelInRanges(ymd, stageRanges)) continue;
                        set.add(ymd);
                      }
                      return set;
                    })();
                    const effectiveCourseDaysSoFar = effectiveCourseYmdSet.size;


                    // Comptages AB/RT par jour
                    const dayCounts: Record<string, { ab: number; rt: number }> = {};
                    for (const st of studentsAbsFiltered) {
                      const byDate = yearBucket?.[st] || {};
                      for (const [ymd, status] of Object.entries(byDate)) {
                        if (status !== "AB" && status !== "RT") continue;
                        if (!dayCounts[ymd]) dayCounts[ymd] = { ab: 0, rt: 0 };
                        if (status === "AB") dayCounts[ymd].ab += 1;
                        else dayCounts[ymd].rt += 1;
                      }
                    }

                    // Comptages AB/RT par √©l√®ve (sur la p√©riode, jusqu'√† aujourd'hui)
                    const studentCounts: Record<string, { ab: number; rt: number }> = {};
                    for (const st of studentsAbsFiltered) {
                      const byDate = yearBucket?.[st] || {};
                      let ab = 0;
                      let rt = 0;
                      for (const [ymd, status] of Object.entries(byDate)) {
                        if (ymd < startYmd || ymd > endYmd) continue;
                        if (!effectiveCourseYmdSet.has(ymd)) continue;
                        if (status === "AB") ab += 1;
                        else if (status === "RT") rt += 1;
                      }
                      studentCounts[st] = { ab, rt };
                    }

                    const studentRisk = (st: string) => {
                      const c = studentCounts[st] || { ab: 0, rt: 0 };
                      const abPct = effectiveCourseDaysSoFar > 0 ? (c.ab / effectiveCourseDaysSoFar) * 100 : 0;
                      const rtPct = effectiveCourseDaysSoFar > 0 ? (c.rt / effectiveCourseDaysSoFar) * 100 : 0;

                      const tooAb = absencesAlertAbsPct > 0 && abPct >= absencesAlertAbsPct;
                      const tooRt = absencesAlertRtPct > 0 && rtPct >= absencesAlertRtPct;
                      const midAb = absencesWarnAbsPct > 0 && abPct >= absencesWarnAbsPct;
                      const midRt = absencesWarnRtPct > 0 && rtPct >= absencesWarnRtPct;
                      const severity: TrafficLightColor = (tooAb || tooRt) ? "red" : (midAb || midRt) ? "yellow" : "green";
                      return { ...c, abPct, rtPct, tooAb, tooRt, midAb, midRt, severity };
                    };

                    const studentTintClass = (st: string) => {
                      const r = studentRisk(st);
                      if (r.severity === "red") return "bg-red-50 dark:bg-red-950/30 text-red-900 dark:text-red-50";
                      if (r.severity === "yellow") return "bg-amber-50 dark:bg-amber-950/30 text-amber-900 dark:text-amber-50";
                      return "bg-white dark:bg-[var(--night-panel)] text-neutral-900 dark:text-neutral-300";
                    };

                    const studentCardTintClass = (st: string) => {
                      const r = studentRisk(st);
                      if (r.severity === "red") return "border-red-300 bg-red-50/60 dark:bg-red-950/20 dark:border-red-500/40";
                      if (r.severity === "yellow") return "border-amber-300 bg-amber-50/60 dark:bg-amber-950/20 dark:border-amber-500/40";
                      return "border-neutral-200 dark:border-sky-400/35";
                    };

                    const selectedDateRaw = absencesSelectedDateYmd;

                    // Timeline (style "progression") : colonnes = jours de cours entre d√©but/fin
                    const MONTHS_FR_SHORT = ["jan","f√©v","mar","avr","mai","juin","juil","ao√ªt","sept","oct","nov","d√©c"];

                    const getIsoWeekInfo = (d: Date) => {
                      // ISO week based on UTC (robuste autour des changements d'ann√©e)
                      const dt = new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate()));
                      const dayNum = dt.getUTCDay() || 7; // 1..7 (lundi..dimanche)
                      dt.setUTCDate(dt.getUTCDate() + 4 - dayNum); // jeudi de la semaine courante
                      const isoYear = dt.getUTCFullYear();
                      const yearStart = new Date(Date.UTC(isoYear, 0, 1));
                      const weekNo = Math.ceil((((dt.getTime() - yearStart.getTime()) / 86400000) + 1) / 7);
                      const key = `${isoYear}-W${String(weekNo).padStart(2, "0")}`;
                      return { isoYear, weekNo, key };
                    };

                    type AbsTimelineCol = {
                      ymd: string;
                      date: Date;
                      y: number;
                      m0: number;
                      day: number;
                      wdLabel: string;
                      isoWeekKey: string;
                      isoWeekNo: number;
                      isoYear: number;
                      vacLabel: string | null;
                      stageLabel: string | null;
                    };

                    const timelineDaysAll: AbsTimelineCol[] = (() => {
                      const s = fromYmd(startYmd);
                      const e = fromYmd(endYmd);
                      if (!s || !e) return [];
                      const out: AbsTimelineCol[] = [];
                      const wdLabels = ["L", "M", "M", "J", "V", "S", "D"];
                      for (let d = new Date(s.getTime()); d <= e; d = addDays(d, 1)) {
                        const wdKey = weekdayKeyFromDate(d);
                        if (!absencesPlanningSettings.courseDays?.[wdKey]) continue;
                        const ymd = toYmd(d);
                        const iso = getIsoWeekInfo(d);
                        out.push({
                          ymd,
                          date: new Date(d.getTime()),
                          y: d.getFullYear(),
                          m0: d.getMonth(),
                          day: d.getDate(),
                          wdLabel: wdLabels[weekdayIndexMon0(d)] || "",
                          isoWeekKey: iso.key,
                          isoWeekNo: iso.weekNo,
                          isoYear: iso.isoYear,
                          vacLabel: findLabelInRanges(ymd, vacationRanges),
                          stageLabel: findLabelInRanges(ymd, stageRanges),
                        });
                      }
                      return out;
                    })();

                    // D√©marrage d'affichage : semaine en cours (lundi) ‚Üí fin
                    const currentWeekStartYmd = (() => {
                      const td = fromYmd(todayYmd);
                      if (!td) return todayYmd;
                      return toYmd(addDays(td, -weekdayIndexMon0(td)));
                    })();

                    const displayStartYmd = (() => {
                      if (absencesShowAllWeeks) return startYmd;
                      if (!timelineDaysAll.length) return startYmd;
                      const anchor = absencesDisplayStartYmd || currentWeekStartYmd;
                      const first = timelineDaysAll.find((c) => c.ymd >= anchor);
                      if (first) return first.ymd;
                      // si on est apr√®s la p√©riode, on montre la derni√®re semaine disponible
                      const idx = Math.max(0, timelineDaysAll.length - 5);
                      return timelineDaysAll[idx].ymd;
                    })();

                    const timelineDays: AbsTimelineCol[] = absencesShowAllWeeks
                      ? timelineDaysAll
                      : timelineDaysAll.filter((c) => c.ymd >= displayStartYmd);

                    // Date s√©lectionn√©e : si hors affichage (filtr√©), on prend la 1√®re date visible
                    const selectedDate = (() => {
                      if (!timelineDays.length) return selectedDateRaw;
                      if (timelineDays.some((d) => d.ymd === selectedDateRaw)) return selectedDateRaw;
                      return timelineDays[0].ymd;
                    })();

                    const selectedCounts = dayCounts[selectedDate] || { ab: 0, rt: 0 };

                    const selectedDateObj = fromYmd(selectedDate);
                    const selectedWeekday =
                      selectedDateObj ? WEEKDAYS_FR_SHORT[weekdayIndexMon0(selectedDateObj)] : "";

                    const selectedVacationLabel = findLabelInRanges(selectedDate, vacationRanges);
                    const selectedStageLabel = findLabelInRanges(selectedDate, stageRanges);

                    const monthSegments = (() => {
                      const segs: Array<{ key: string; label: string; span: number }> = [];
                      for (const col of timelineDays) {
                        const k = `${col.y}-${col.m0}`;
                        const label =
                          (MONTHS_FR[col.m0] ? MONTHS_FR[col.m0].slice(0, 1).toUpperCase() + MONTHS_FR[col.m0].slice(1) : `M${col.m0 + 1}`) +
                          " " +
                          col.y;
                        const last = segs[segs.length - 1];
                        if (!last || last.key !== k) segs.push({ key: k, label, span: 1 });
                        else last.span += 1;
                      }
                      return segs;
                    })();

                    const weekSegments = (() => {
                      const segs: Array<{ key: string; isoWeekNo: number; isoYear: number; startYmd: string; endYmd: string; span: number }> = [];
                      for (const col of timelineDays) {
                        const last = segs[segs.length - 1];
                        if (!last || last.key !== col.isoWeekKey) {
                          segs.push({ key: col.isoWeekKey, isoWeekNo: col.isoWeekNo, isoYear: col.isoYear, startYmd: col.ymd, endYmd: col.ymd, span: 1 });
                        } else {
                          last.span += 1;
                          last.endYmd = col.ymd;
                        }
                      }
                      return segs;
                    })();

                    type PeriodKind = "PFMP" | "VACANCES" | "COURS";
                    const periodKindOf = (col: AbsTimelineCol): PeriodKind =>
                      col.stageLabel ? "PFMP" : col.vacLabel ? "VACANCES" : "COURS";

                    type AbsWeekCol = {
                      key: string;
                      isoWeekNo: number;
                      isoYear: number;
                      startYmd: string;
                      endYmd: string;
                      days: AbsTimelineCol[];
                      kind: PeriodKind;
                      label: string;
                      mixed: boolean;
                    };

                    const weekCols: AbsWeekCol[] = (() => {
                      const out: AbsWeekCol[] = [];
                      for (const day of timelineDays) {
                        const last = out[out.length - 1];
                        if (!last || last.key !== day.isoWeekKey) {
                          out.push({
                            key: day.isoWeekKey,
                            isoWeekNo: day.isoWeekNo,
                            isoYear: day.isoYear,
                            startYmd: day.ymd,
                            endYmd: day.ymd,
                            days: [day],
                            kind: "COURS",
                            label: "",
                            mixed: false,
                          });
                        } else {
                          last.days.push(day);
                          last.endYmd = day.ymd;
                        }
                      }

                      for (const w of out) {
                        const kinds = w.days.map(periodKindOf);
                        const allSameKind = kinds.every((k) => k === kinds[0]);
                        const containsVac = kinds.includes("VACANCES");
                        const containsStage = kinds.includes("PFMP");

                        if (allSameKind && kinds[0] !== "COURS") {
                          w.kind = kinds[0];
                          if (w.kind === "VACANCES") {
                            const labels = w.days.map((d) => d.vacLabel || "Vacances");
                            const first = labels[0];
                            w.label = labels.every((x) => x === first) ? first : "Vacances";
                          } else if (w.kind === "PFMP") {
                            const labels = w.days.map((d) => d.stageLabel || "PFMP");
                            const first = labels[0];
                            w.label = labels.every((x) => x === first) ? first : "PFMP";
                          }
                          w.mixed = false;
                        } else if (!containsVac && !containsStage) {
                          w.kind = "COURS";
                          w.label = "";
                          w.mixed = false;
                        } else {
                          w.kind = "COURS";
                          w.label = "Mixte";
                          w.mixed = true;
                        }
                      }

                      return out;
                    })();

                    
                                        type SemesterKey = "S1" | "S2";
                    type SemesterInfo = {
                      key: SemesterKey;
                      title: string;
                      startYmd: string;
                      endYmdExclusive: string;
                    };

                    const yearEndExclusive = addDaysYmd(endYmd, 1);

                    const winterVac = vacationRanges.find((r) => /vacances.*hiver/i.test(r.label || ""));
                    const summerVac = vacationRanges.find((r) => /vacances.*(ete|√©t√©)/i.test(r.label || ""));

                    const syParsed = parseSchoolYearString(absencesSchoolYear);
                    const fallbackWinterStart = syParsed ? `${syParsed.endYear}-02-01` : `${new Date().getFullYear()}-02-01`;

                    const clampYmd = (ymdIn: string, minYmd: string, maxYmd: string) => {
                      if (ymdIn < minYmd) return minYmd;
                      if (ymdIn > maxYmd) return maxYmd;
                      return ymdIn;
                    };

                    const s1StartYmd = startYmd;
                    const s1EndExclYmd = clampYmd(winterVac?.startYmd || fallbackWinterStart, startYmd, yearEndExclusive);
                    const s2StartYmd = clampYmd(winterVac?.endYmdExclusive || s1EndExclYmd, startYmd, yearEndExclusive);
                    const s2EndExclYmd = clampYmd(summerVac?.startYmd || yearEndExclusive, startYmd, yearEndExclusive);

                    const semestersBase: SemesterInfo[] = [
  { key: "S1", title: "Semestre 1", startYmd: s1StartYmd, endYmdExclusive: s1EndExclYmd },
  { key: "S2", title: "Semestre 2", startYmd: s2StartYmd, endYmdExclusive: s2EndExclYmd },
];

const semesters: SemesterInfo[] = semestersBase.map((s): SemesterInfo => {
  let st = clampYmd(s.startYmd, startYmd, yearEndExclusive);
  let en = clampYmd(s.endYmdExclusive, startYmd, yearEndExclusive);
  if (en <= st) en = addDaysYmd(st, 1);
  return { ...s, startYmd: st, endYmdExclusive: en };
});

                    const semS1: SemesterInfo =
                      semesters.find((s) => s.key === "S1") ||
                      semesters[0] ||
                      { key: "S1", title: "Semestre 1", startYmd: startYmd, endYmdExclusive: addDaysYmd(startYmd, 1) };

                    const semS2: SemesterInfo =
                      semesters.find((s) => s.key === "S2") ||
                      semesters[1] ||
                      { key: "S2", title: "Semestre 2", startYmd: addDaysYmd(startYmd, 1), endYmdExclusive: addDaysYmd(startYmd, 2) };

                    const currentSemesterKey: SemesterKey = (() => {
                      if (todayYmd >= semS2.startYmd) return "S2";
                      return "S1";
                    })();

                    const formatSemesterRangeShort = (sem: SemesterInfo) => {
                      const endIncl = addDaysYmd(sem.endYmdExclusive, -1);
                      return formatWeekRangeShort(sem.startYmd, endIncl);
                    };

                    const plannedCourseDaysBySemester: Record<SemesterKey, number> = (() => {
                      const out: Record<SemesterKey, number> = { S1: 0, S2: 0 };
                      for (const day of timelineDaysAll) {
                        if (periodKindOf(day) !== "COURS") continue;
                        for (const sem of semesters) {
                          if (day.ymd >= sem.startYmd && day.ymd < sem.endYmdExclusive) out[sem.key] += 1;
                        }
                      }
                      return out;
                    })();

                    const effectiveCourseDaysBySemesterSoFar: Record<SemesterKey, number> = (() => {
                      const out: Record<SemesterKey, number> = { S1: 0, S2: 0 };
                      for (const ymd of effectiveCourseYmdSet) {
                        for (const sem of semesters) {
                          if (ymd >= sem.startYmd && ymd < sem.endYmdExclusive) out[sem.key] += 1;
                        }
                      }
                      return out;
                    })();

                    const studentSemesterCounts: Record<string, Record<SemesterKey, { ab: number; rt: number }>> = (() => {
                      const out: Record<string, Record<SemesterKey, { ab: number; rt: number }>> = {};
                      for (const st of studentsAbsFiltered) {
                        const byDate = yearBucket?.[st] || {};
                        const semMap: Record<SemesterKey, { ab: number; rt: number }> = {
                          S1: { ab: 0, rt: 0 },
                          S2: { ab: 0, rt: 0 },
                        };

                        for (const [ymd, status] of Object.entries(byDate)) {
                          if (status !== "AB" && status !== "RT") continue;
                          if (ymd < startYmd || ymd > cutoffYmd) continue;
                          if (!effectiveCourseYmdSet.has(ymd)) continue;

                          const sem = semesters.find((s) => ymd >= s.startYmd && ymd < s.endYmdExclusive);
                          if (!sem) continue;

                          if (status === "AB") semMap[sem.key].ab += 1;
                          else semMap[sem.key].rt += 1;
                        }

                        out[st] = semMap;
                      }
                      return out;
                    })();

const absencesWeekColPx = Math.max(34, absencesDayColPx);
                    const absencesMergedDayColPx = 12; // largeur fixe pour les jours fusionn√©s (vacances / PFMP)
                    const absencesMergedWeekDayColPx = 4; // largeur par jour quand la semaine est 100% VACANCES / PFMP (vue compacte)
                    const mergedWeekKeys = new Set(weekCols.filter((w) => w.kind !== "COURS").map((w) => w.key));

                    const colPxForDay = (col: AbsTimelineCol) => {
                      if (periodKindOf(col) === "COURS") return absencesDayColPx;
                      if (mergedWeekKeys.has(col.isoWeekKey)) return absencesMergedWeekDayColPx;
                      return absencesMergedDayColPx;
                    };
const monthSegmentsWeeks = (() => {
                      const segs: Array<{ key: string; label: string; span: number }> = [];
                      for (const w of weekCols) {
                        const d = fromYmd(w.startYmd);
                        if (!d) continue;
                        const y = d.getFullYear();
                        const m0 = d.getMonth();
                        const k = `${y}-${m0}`;
                        const label =
                          (MONTHS_FR[m0] ? MONTHS_FR[m0].slice(0, 1).toUpperCase() + MONTHS_FR[m0].slice(1) : `M${m0 + 1}`) +
                          " " +
                          y;
                        const last = segs[segs.length - 1];
                        if (!last || last.key !== k) segs.push({ key: k, label, span: 1 });
                        else last.span += 1;
                      }
                      return segs;
                    })();

                    const borderLeftWeekClass = (idx: number) => {
                      if (idx === 0) return "";
                      const prev = weekCols[idx - 1];
                      const cur = weekCols[idx];
                      const prevD = fromYmd(prev.startYmd);
                      const curD = fromYmd(cur.startYmd);
                      if (prevD && curD) {
                        if (prevD.getMonth() !== curD.getMonth() || prevD.getFullYear() !== curD.getFullYear()) {
                          return "border-l-4 border-l-neutral-900/80 dark:border-l-neutral-200/70";
                        }
                      }
                      return "border-l-2 border-l-neutral-900/70 dark:border-l-neutral-200/60";
                    };

                    type DaySeg =
                      | { kind: "MERGED"; period: Exclude<PeriodKind, "COURS">; label: string; startIdx: number; span: number; startYmd: string; endYmd: string }
                      | { kind: "DAY"; idx: number };

                    const daySegments: DaySeg[] = (() => {
                      const segs: DaySeg[] = [];

                      for (let i = 0; i < timelineDays.length; ) {
                        const col = timelineDays[i];
                        const k = periodKindOf(col);

                        // COURS => 1 cellule par jour
                        if (k === "COURS") {
                          segs.push({ kind: "DAY", idx: i });
                          i += 1;
                          continue;
                        }

                        // VACANCES ou PFMP => fusion des jours cons√©cutifs avec m√™me kind ET m√™me label
                        const label =
                          k === "PFMP"
                            ? (col.stageLabel || "PFMP")
                            : (col.vacLabel || "Vacances");

                        let j = i + 1;
                        while (j < timelineDays.length) {
                          const c2 = timelineDays[j];
                          const k2 = periodKindOf(c2);
                          if (k2 !== k) break;

                          const prevDay = timelineDays[j - 1];
                          if (c2.isoWeekKey !== prevDay.isoWeekKey) break; // coupe √† chaque changement de semaine

                          if (c2.m0 !== prevDay.m0 || c2.y !== prevDay.y) break; // coupe √† chaque changement de mois

                          const label2 =
                            k2 === "PFMP"
                              ? (c2.stageLabel || "PFMP")
                              : (c2.vacLabel || "Vacances");

                          if (label2 !== label) break;
                          j += 1;
                        }

                        segs.push({
                          kind: "MERGED",
                          period: k as Exclude<PeriodKind, "COURS">,
                          label,
                          startIdx: i,
                          span: j - i,
                          startYmd: timelineDays[i].ymd,
                          endYmd: timelineDays[j - 1].ymd,
                        });

                        i = j;
                      }

                      return segs;
                    })();

                    const periodBgClass = (kind: PeriodKind) => {
                      if (kind === "PFMP") return "bg-orange-200/90 text-orange-900 dark:bg-orange-900/25 dark:text-orange-100";
                      if (kind === "VACANCES") return "bg-blue-800/90 text-white dark:bg-blue-900/45 dark:text-white";
                      return "bg-white dark:bg-[var(--night-panel)] text-neutral-900 dark:text-neutral-300";
                    };


                    const weekCellBgClass = (w: AbsWeekCol) => {
                      if (w.mixed) return "bg-neutral-100 dark:bg-[var(--night-cell-mixed)] text-neutral-900 dark:text-neutral-300";
                      return periodBgClass(w.kind);
                    };

                    const formatWeekRangeShort = (startYmdIn: string, endYmdIn: string) => {
                      const sD = fromYmd(startYmdIn);
                      const eD = fromYmd(endYmdIn);
                      if (!sD || !eD) return `${formatYmdFr(startYmdIn)} ‚Üí ${formatYmdFr(endYmdIn)}`;
                      const sd = String(sD.getDate()).padStart(2, "0");
                      const ed = String(eD.getDate()).padStart(2, "0");
                      const sm = MONTHS_FR_SHORT[sD.getMonth()] || "";
                      const em = MONTHS_FR_SHORT[eD.getMonth()] || "";
                      if (sD.getMonth() === eD.getMonth()) return `du ${sd} au ${ed} ${sm}`;
                      return `du ${sd} ${sm} au ${ed} ${em}`;
                    };

                    const monthBandBgClass = (m0: number) =>
                      m0 % 2 === 0 ? "bg-white dark:bg-[var(--night-panel)]" : "bg-neutral-100 dark:bg-[var(--night-cell-mixed)]";

                    const monthHeaderBgClass = (key: string) => {
                      const parts = key.split("-");
                      const m0 = parseInt(parts[1] ?? "0", 10);
                      return monthBandBgClass(Number.isFinite(m0) ? m0 : 0);
                    };

                    const cellBgClass = (col: AbsTimelineCol) => {
                      const k = periodKindOf(col);
                      if (k === "COURS") return classNames(monthBandBgClass(col.m0), "text-neutral-900 dark:text-neutral-300");
                      return periodBgClass(k);
                    };

                    const borderLeftClass = (idx: number) => {
                      if (idx === 0) return "";
                      const prev = timelineDays[idx - 1];
                      const cur = timelineDays[idx];
                      if (prev.isoWeekKey !== cur.isoWeekKey) return "border-l-2 border-l-neutral-900/70 dark:border-l-neutral-200/60";
                      if (prev.m0 !== cur.m0 || prev.y !== cur.y) return ""; // mois diff√©renci√©s par fond (pas de barre noire)
                      return "";
                    };

const isMonthStartIdx = (idx: number) => {
                      if (idx <= 0) return true;
                      const prev = timelineDays[idx - 1];
                      const cur = timelineDays[idx];
                      return prev.m0 !== cur.m0 || prev.y !== cur.y;
                    };

                    const isMonthEndIdx = (idx: number) => {
                      if (idx >= timelineDays.length - 1) return true;
                      const cur = timelineDays[idx];
                      const next = timelineDays[idx + 1];
                      return cur.m0 !== next.m0 || cur.y !== next.y;
                    };

                    const monthFrameLeftClass = (idx: number) =>
                      isMonthStartIdx(idx) ? "border-l-2 border-l-neutral-400 dark:border-l-neutral-500" : "";

                    const monthFrameRightClass = (idx: number) =>
                      isMonthEndIdx(idx) ? "border-r-2 border-r-neutral-400 dark:border-r-neutral-500" : "";

                                        const renderProgressionTable = () => {
                      if (!timelineDays.length) {
                        return (
                          <p className="text-xs text-neutral-500 dark:text-neutral-300">
                            Aucune date dans la plage.
                          </p>
                        );
                      }

                                            if (absencesTimelineView === "week") {
                        // Vue "Semaine" : on garde les semaines en en-t√™te, mais on conserve le d√©tail Jour (Lun..Ven)
                        // et on fusionne verticalement (rowSpan) les p√©riodes VACANCES / PFMP.
                        return (
                          <div className="rounded-xl border border-neutral-200 dark:border-sky-400/35 bg-white dark:bg-[var(--night-panel)] overflow-hidden">
                            <div className="overflow-x-auto">
                              <table className="absences-grid border-collapse text-[10px] table-fixed w-max">

                                <colgroup>
                                  <col style={{ width: 200 }} />
                                  {timelineDays.map((col) => (
                                    <col key={col.ymd} style={{ width: colPxForDay(col) }} />
                                  ))}
                                </colgroup>

                                <thead className="sticky top-0 bg-white dark:bg-[var(--night-panel)] z-10">
                                  <tr>
                                    <th className="sticky left-0 z-20 bg-white dark:bg-[var(--night-panel)] border border-neutral-200 dark:border-sky-400/35 w-[200px] min-w-[200px] max-w-[200px] px-2 py-1 text-[11px] font-semibold text-neutral-700 dark:text-neutral-300">
                                      CALENDRIER {absencesSchoolYear}
                                    </th>
                                    {monthSegments.map((m) => (
                                      <th
                                        key={m.key}
                                        colSpan={m.span}
                                        className={classNames("border border-neutral-200 dark:border-sky-400/35 px-2 py-1 text-[11px] font-semibold text-neutral-900 dark:text-neutral-300 text-center", monthHeaderBgClass(m.key))}
                                      >
                                        {m.label}
                                      </th>
                                    ))}
                                  </tr>

                                  <tr>
                                    <th className="sticky left-0 z-20 bg-white dark:bg-[var(--night-panel)] border border-neutral-200 dark:border-sky-400/35 w-[200px] min-w-[200px] max-w-[200px] px-2 py-1 text-[11px] font-semibold text-neutral-700 dark:text-neutral-300">
                                      SEMAINE
                                    </th>
                                 {weekSegments.map((w) => (
  <th
    key={w.key}
    colSpan={w.span}
    className="border border-neutral-200 dark:border-sky-400/35 px-0 py-1 text-[10px] text-neutral-700 dark:text-neutral-300 text-center align-middle"
  >
    <div className="w-full h-full flex items-center justify-center">
      <span
        className="app-verticalHeaderSimple px-1 leading-none inline-block">
        {formatWeekRangeShort(w.startYmd, w.endYmd)}
      </span>
    </div>
  </th>
))}

                                  </tr>

                                  <tr>
                                    <th className="sticky left-0 z-20 bg-white dark:bg-[var(--night-panel)] border border-neutral-200 dark:border-sky-400/35 w-[200px] min-w-[200px] max-w-[200px] px-2 py-1 text-[11px] font-semibold text-neutral-700 dark:text-neutral-300">
                                      SEMAINE N¬∞
                                    </th>
                                    {weekSegments.map((w) => (
                                      <th
                                        key={w.key + "-no"}
                                        colSpan={w.span}
                                        className="border border-neutral-200 dark:border-sky-400/35 px-0 py-1 text-[11px] font-semibold text-neutral-900 dark:text-neutral-300 text-center"
                                      >
                                        <div className="relative w-full h-full">
                                          {w.endYmd < todayYmd && (
                                            <svg
                                              aria-hidden
                                              className="absolute inset-0 w-full h-full pointer-events-none"
                                              viewBox="0 0 100 40"
                                              preserveAspectRatio="none"
                                            >
                                              <line
                                                x1="0"
                                                y1="0"
                                                x2="100"
                                                y2="40"
                                                stroke="currentColor"
                                                strokeWidth="4"
                                                className="text-neutral-900/70 dark:text-neutral-300/70"
                                              />
                                              <line
                                                x1="0"
                                                y1="40"
                                                x2="100"
                                                y2="0"
                                                stroke="currentColor"
                                                strokeWidth="4"
                                                className="text-neutral-900/70 dark:text-neutral-300/70"
                                              />
                                            </svg>
                                          )}
                                          <div className="relative z-10 flex items-center justify-center">{w.isoWeekNo}</div>
                                        </div>
                                      </th>
                                    ))}
                                  </tr>

                                  <tr>
                                    <th className="sticky left-0 z-20 bg-white dark:bg-[var(--night-panel)] border border-neutral-200 dark:border-sky-400/35 w-[200px] min-w-[200px] max-w-[200px] px-2 py-1 text-[11px] font-semibold text-neutral-700 dark:text-neutral-300">
                                      JOUR
                                    </th>

                                    {daySegments.map((seg) => {
                                      if (seg.kind === "MERGED") {
                                        const sD = fromYmd(seg.startYmd);
                                        const eD = fromYmd(seg.endYmd);
                                        const dom =
                                          sD && eD
                                            ? sD.getMonth() === eD.getMonth()
                                              ? `${String(sD.getDate()).padStart(2, "0")}‚Äì${String(eD.getDate()).padStart(2, "0")}`
                                              : `${String(sD.getDate()).padStart(2, "0")}${MONTHS_FR_SHORT[sD.getMonth()]}‚Äì${String(eD.getDate()).padStart(2, "0")}${MONTHS_FR_SHORT[eD.getMonth()]}`
                                            : "";

                                        const first = timelineDays[seg.startIdx];
                                        return (
                                          <th
                                            key={`dom-${seg.period}-${seg.startYmd}`}
                                            colSpan={seg.span}
                                            style={{ height: absencesDayColPx }}
                                            className={classNames(
                                              "border border-neutral-200 dark:border-sky-400/35 text-center font-semibold",
                                              cellBgClass(first),
                                              borderLeftClass(seg.startIdx), monthFrameLeftClass(seg.startIdx), monthFrameRightClass(seg.startIdx + seg.span - 1)
                                            )}
                                            title={`${formatYmdFr(seg.startYmd)} ‚Üí ${formatYmdFr(seg.endYmd)} ‚Äî ${seg.period}: ${seg.label}`}
                                          >
                                            {dom}
                                          </th>
                                        );
                                      }

                                      const col = timelineDays[seg.idx];
                                      const idx = seg.idx;
                                      return (
                                        <th
                                          key={col.ymd + "-dom"}
                                          style={{ height: absencesDayColPx }}
                                          className={classNames(
                                            "border border-neutral-200 dark:border-sky-400/35 text-center font-semibold",
                                            cellBgClass(col),
                                            borderLeftClass(idx), monthFrameLeftClass(idx), monthFrameRightClass(idx)
                                          )}
                                          title={formatYmdFr(col.ymd)}
                                        >
                                          {col.date.getDate()}
                                        </th>
                                      );
                                    })}
                                  </tr>

                                  <tr>
                                    <th className="sticky left-0 z-20 bg-white dark:bg-[var(--night-panel)] border border-neutral-200 dark:border-sky-400/35 w-[200px] min-w-[200px] max-w-[200px] px-2 py-1 text-[11px] font-semibold text-neutral-700 dark:text-neutral-300">
                                      JOURS SEMAINE
                                    </th>

                                    {daySegments.map((seg) => {
                                      // pour VACANCES / PFMP : pas de libell√© ici (il est dans la cellule fusionn√©e du tbody)
                                      if (seg.kind === "MERGED") {
                                        const first = timelineDays[seg.startIdx];
                                        return (
                                          <th
                                            key={`h-week-${seg.period}-${seg.startYmd}`}
                                            colSpan={seg.span}
                                            style={{ height: absencesDayColPx }}
                                            className={classNames(
                                              "border border-neutral-200 dark:border-sky-400/35 text-center font-semibold",
                                              cellBgClass(first),
                                              borderLeftClass(seg.startIdx), monthFrameLeftClass(seg.startIdx), monthFrameRightClass(seg.startIdx + seg.span - 1)
                                            )}
                                            title={`${formatYmdFr(seg.startYmd)} ‚Üí ${formatYmdFr(seg.endYmd)} ‚Äî ${seg.period}: ${seg.label}`}
                                          />
                                        );
                                      }

                                      const col = timelineDays[seg.idx];
                                      const idx = seg.idx;

                                      return (
                                        <th
                                          key={col.ymd}
                                          style={{ height: absencesDayColPx }}
                                          className={classNames(
                                            "border border-neutral-200 dark:border-sky-400/35 text-center font-semibold",
                                            cellBgClass(col),
                                            borderLeftClass(idx), monthFrameLeftClass(idx), monthFrameRightClass(idx)
                                          )}
                                          title={`${formatYmdFr(col.ymd)}${col.stageLabel ? ` ‚Äî PFMP: ${col.stageLabel}` : ""}${col.vacLabel ? ` ‚Äî Vacances: ${col.vacLabel}` : ""}`}
                                        >
                                          <button type="button" className="w-full h-full" onClick={() => setAbsencesSelectedDateYmd(col.ymd)}>
                                            {col.wdLabel}
                                          </button>
                                        </th>
                                      );
                                    })}
                                  </tr>
                                </thead>

                                <tbody>
                                  {studentsAbsFiltered.map((st, stIdx) => (
                                    <tr key={st}>
                                      <td
  className={classNames(
    "sticky left-0 z-10 border border-neutral-200 dark:border-sky-400/35 w-[200px] min-w-[200px] max-w-[200px] px-2 py-1 text-[13px] font-medium whitespace-nowrap",
    studentTintClass(st)
  )}
>
  <div className="student-name-row flex items-center justify-between gap-2 min-w-0">
    <span className="student-name truncate flex-1 min-w-0">{st}</span>
    {(() => {
      const r = studentRisk(st);
      if (!r.ab && !r.rt) return null;
      const abp = Math.round(r.abPct || 0);
      const rtp = Math.round(r.rtPct || 0);
    })()}
  </div>
</td>

                                      {daySegments.map((seg) => {
                                        // VACANCES / PFMP : 1 seule cellule sur toute la hauteur + colSpan sur la plage
                                        if (seg.kind === "MERGED") {
                                          if (stIdx !== 0) return null;
                                          const first = timelineDays[seg.startIdx];

                                          return (
                                            <td
                                              key={`merged-${seg.period}-${seg.startYmd}`}
                                              rowSpan={Math.max(1, studentsAbs.length)}
                                              colSpan={seg.span}
                                              style={{ height: absencesDayColPx }}
                                              className={classNames(
                                                "border border-neutral-200 dark:border-sky-400/35 text-center select-none cursor-pointer",
                                                cellBgClass(first),
                                                borderLeftClass(seg.startIdx), monthFrameLeftClass(seg.startIdx), monthFrameRightClass(seg.startIdx + seg.span - 1)
                                              )}
                                              onClick={() => setAbsencesSelectedDateYmd(seg.startYmd)}
                                              title={`${formatYmdFr(seg.startYmd)} ‚Üí ${formatYmdFr(seg.endYmd)} ‚Äî ${seg.period}: ${seg.label}`}
                                            >
                                              <div
                                                className="mx-auto flex items-center justify-center h-full w-[12px] min-w-[12px] max-w-[12px] overflow-hidden px-0 text-[10px] font-semibold app-verticalHeaderSimple"
                                              >
                                                {seg.label}
                                              </div>
                                            </td>
                                          );
                                        }

                                        // jour normal => cellule cliquable AB/RT
                                        const col = timelineDays[seg.idx];
                                        const idx = seg.idx;

                                        const curStatus = yearBucket?.[st]?.[col.ymd] || null;
                                        const isSel = col.ymd === selectedDate;
                                        const nextStatus: AttendanceStatus | null =
                                          curStatus === "RT" ? "AB" : curStatus === "AB" ? null : "RT";

                                        return (
                                          <td
                                            key={st + "-" + col.ymd}
                                            style={{ height: absencesDayColPx }}
                                            className={classNames(
                                              "border border-neutral-200 dark:border-sky-400/35 text-center cursor-pointer select-none",
                                              cellBgClass(col),
                                              borderLeftClass(idx), monthFrameLeftClass(idx), monthFrameRightClass(idx),
                                              isSel && "ring-2 ring-inset ring-neutral-900 dark:ring-neutral-200"
                                            )}
                                            onClick={() => {
                                              setAbsencesSelectedDateYmd(col.ymd);
                                              setAbsenceStatus(absencesSchoolYear, classId, st, col.ymd, nextStatus);
                                            }}
                                            title={`${st} ‚Äî ${formatYmdFr(col.ymd)}`}
                                          >
                                            {curStatus === "AB" ? (
                                              <span className="text-[10px] font-bold text-red-600 dark:text-red-200">AB</span>
                                            ) : curStatus === "RT" ? (
                                              <span className="text-[10px] font-bold text-amber-700 dark:text-amber-200">RT</span>
                                            ) : (
                                              ""
                                            )}
                                          </td>
                                        );
                                      })}
                                    </tr>
                                  ))}
                                </tbody>
                              </table>
                            </div>
                          </div>
                        );
                      }




                      return (
                        <div className="rounded-xl border border-neutral-200 dark:border-sky-400/35 bg-white dark:bg-[var(--night-panel)] overflow-hidden">
                          <div className="overflow-x-auto">
                            <table className="absences-grid border-collapse text-[10px] table-fixed w-max">

                              <colgroup>
                                <col style={{ width: 200 }} />
                                {timelineDays.map((col) => (
                                  <col key={col.ymd} style={{ width: colPxForDay(col) }} />
                                ))}
                              </colgroup>
                              <thead className="sticky top-0 bg-white dark:bg-[var(--night-panel)] z-10">
                                <tr>
                                  <th className="sticky left-0 z-20 bg-white dark:bg-[var(--night-panel)] border border-neutral-200 dark:border-sky-400/35 w-[200px] min-w-[200px] max-w-[200px] px-2 py-1 text-[11px] font-semibold text-neutral-700 dark:text-neutral-300"></th>
                                  CALENDRIER {absencesSchoolYear} 
                                  {monthSegments.map((m) => (
                                    <th
                                      key={m.key}
                                      colSpan={m.span}
                                      className={classNames("border border-neutral-200 dark:border-sky-400/35 px-2 py-1 text-[11px] font-semibold text-neutral-900 dark:text-neutral-300 text-center", monthHeaderBgClass(m.key))}
                                    >
                                      {m.label}
                                    </th>
                                  ))}
                                </tr>

     <tr className="h-24">
  <th className="sticky left-0 z-20 bg-white dark:bg-[var(--night-panel)] border border-neutral-200 dark:border-sky-400/35 w-[200px] min-w-[200px] max-w-[200px] px-2 py-1 text-[11px] font-semibold text-neutral-700 dark:text-neutral-300 align-middle">
    SEMAINE
  </th>

{weekSegments.map((w) => (
  <th
    key={w.key}
    colSpan={w.span}
    className="border border-neutral-200 dark:border-sky-400/35 px-0 py-1 text-[10px] text-neutral-700 dark:text-neutral-300 text-center align-middle"
  >
    <div className="w-full h-full flex items-center justify-center">
      <span
        className="px-1 leading-none inline-block app-verticalHeaderSimple"
      >
        {formatWeekRangeShort(w.startYmd, w.endYmd)}
      </span>
    </div>
  </th>
))}

</tr>


                                <tr>
                                  <th className="sticky left-0 z-20 bg-white dark:bg-[var(--night-panel)] border border-neutral-200 dark:border-sky-400/35 w-[200px] min-w-[200px] max-w-[200px] px-2 py-1 text-[11px] font-semibold text-neutral-700 dark:text-neutral-300">
                                    SEMAINE N¬∞
                                  </th>
                                  {weekSegments.map((w) => (
                                    <th
                                      key={w.key + "-no"}
                                      colSpan={w.span}
                                      className="border border-neutral-200 dark:border-sky-400/35 px-0 py-1 text-[11px] font-semibold text-neutral-900 dark:text-neutral-300 text-center"
                                    >
                                      <div className="relative w-full h-full">
                                        {w.endYmd < todayYmd && (
                                          <svg
                                            aria-hidden
                                            className="absolute inset-0 w-full h-full pointer-events-none"
                                            viewBox="0 0 100 40"
                                            preserveAspectRatio="none"
                                          >
                                            <line
                                              x1="0"
                                              y1="0"
                                              x2="100"
                                              y2="40"
                                              stroke="currentColor"
                                              strokeWidth="4"
                                              className="text-neutral-900/70 dark:text-neutral-300/70"
                                            />
                                            <line
                                              x1="0"
                                              y1="40"
                                              x2="100"
                                              y2="0"
                                              stroke="currentColor"
                                              strokeWidth="4"
                                              className="text-neutral-900/70 dark:text-neutral-300/70"
                                            />
                                          </svg>
                                        )}
                                        <div className="relative z-10 flex items-center justify-center">{w.isoWeekNo}</div>
                                      </div>
                                    </th>
                                  ))}
                                </tr>

                                <tr>
                                  <th className="sticky left-0 z-20 bg-white dark:bg-[var(--night-panel)] border border-neutral-200 dark:border-sky-400/35 w-[200px] min-w-[200px] max-w-[200px] px-2 py-1 text-[11px] font-semibold text-neutral-700 dark:text-neutral-300">
                                    √âl√®ves
                                  </th>
                                                                    {daySegments.map((seg) => {
                                    // cellule fusionn√©e (VACANCES ou PFMP)
                                    if (seg.kind === "MERGED") {
                                      const first = timelineDays[seg.startIdx];

                                      return (
                                        <th
                                          key={`h-${seg.period}-${seg.startYmd}`}
                                          colSpan={seg.span}
                                          style={{ height: absencesDayColPx }}
                                          className={classNames(
                                            "border border-neutral-200 dark:border-sky-400/35 text-center font-semibold",
                                            cellBgClass(first),
                                            borderLeftClass(seg.startIdx), monthFrameLeftClass(seg.startIdx), monthFrameRightClass(seg.startIdx + seg.span - 1)
                                          )}
                                          title={`${formatYmdFr(seg.startYmd)} ‚Üí ${formatYmdFr(seg.endYmd)} ‚Äî ${seg.period}: ${seg.label}`}
                                        >
                                          <button
                                            type="button"
                                            className="w-full h-full"
                                            onClick={() => setAbsencesSelectedDateYmd(seg.startYmd)}
                                          >
                                            {seg.label}
                                          </button>
                                        </th>
                                      );
                                    }

                                    // jour normal
                                    const col = timelineDays[seg.idx];
                                    const idx = seg.idx;

                                    return (
                                      <th
                                        key={col.ymd}
                                        style={{ height: absencesDayColPx }}
                                        className={classNames(
                                          "border border-neutral-200 dark:border-sky-400/35 text-center font-semibold",
                                          cellBgClass(col),
                                          borderLeftClass(idx), monthFrameLeftClass(idx), monthFrameRightClass(idx)
                                        )}
                                        title={`${formatYmdFr(col.ymd)}${col.vacLabel ? ` ‚Äî Vacances: ${col.vacLabel}` : ""}${col.stageLabel ? ` ‚Äî PFMP: ${col.stageLabel}` : ""}`}
                                      >
                                        <button
                                          type="button"
                                          className="w-full h-full"
                                          onClick={() => setAbsencesSelectedDateYmd(col.ymd)}
                                        >
                                          {col.wdLabel}
                                        </button>
                                      </th>
                                    );
                                  })}
                                </tr>
                              </thead>

                              <tbody>
                                {studentsAbsFiltered.map((st, stIdx) => (
                                  <tr key={st}>
                                    <td
  className={classNames(
    "sticky left-0 z-10 border border-neutral-200 dark:border-sky-400/35 w-[200px] min-w-[200px] max-w-[200px] px-2 py-1 text-[11px] font-medium whitespace-nowrap",
    studentTintClass(st)
  )}
>
  <div className="flex items-center justify-between gap-2">
    <span className="truncate">{st}</span>
    {(() => {
      const r = studentRisk(st);
      if (!r.ab && !r.rt) return null;
      const abp = Math.round(r.abPct || 0);
      const rtp = Math.round(r.rtPct || 0);
      return (
        <span className="text-[10px] font-semibold opacity-80 whitespace-nowrap shrink-0">
          {r.ab}AB {abp}% ¬∑ {r.rt}RT {rtp}%
        </span>
      );
    })()}
  </div>
</td>

                                                                        {daySegments.map((seg) => {
                                                                            // cellule fusionn√©e (VACANCES ou PFMP) : 1 seule cellule sur toute la hauteur (rowSpan) + colSpan sur la plage
                                      if (seg.kind === "MERGED") {
                                        if (stIdx !== 0) return null;
                                        const first = timelineDays[seg.startIdx];

                                        return (
                                          <td
                                            key={`merged-${seg.period}-${seg.startYmd}`}
                                            rowSpan={Math.max(1, studentsAbs.length)}
                                            colSpan={seg.span}
                                            style={{ height: absencesDayColPx }}
                                            className={classNames(
                                              "border border-neutral-200 dark:border-sky-400/35 text-center select-none cursor-pointer",
                                              cellBgClass(first),
                                              borderLeftClass(seg.startIdx), monthFrameLeftClass(seg.startIdx), monthFrameRightClass(seg.startIdx + seg.span - 1)
                                            )}
                                            onClick={() => setAbsencesSelectedDateYmd(seg.startYmd)}
                                            title={`${formatYmdFr(seg.startYmd)} ‚Üí ${formatYmdFr(seg.endYmd)} ‚Äî ${seg.period}: ${seg.label}`}
                                          >
                                            <div
                                              className="mx-auto flex items-center justify-center h-full w-[12px] min-w-[12px] max-w-[12px] overflow-hidden px-0 text-[10px] font-semibold app-verticalHeaderSimple"
                                            >
                                              {seg.label}
                                            </div>
                                          </td>
                                        );
                                      }
// jour normal => cellule cliquable AB/RT
                                      const col = timelineDays[seg.idx];
                                      const idx = seg.idx;

                                      const curStatus = yearBucket?.[st]?.[col.ymd] || null;
                                      const isSel = col.ymd === selectedDate;
                                      const nextStatus: AttendanceStatus | null =
                                        curStatus === "RT" ? "AB" : curStatus === "AB" ? null : "RT";

                                      return (
                                        <td
                                          key={st + "-" + col.ymd}
                                          style={{ height: absencesDayColPx }}
                                          className={classNames(
                                            "border border-neutral-200 dark:border-sky-400/35 text-center cursor-pointer select-none",
                                            cellBgClass(col),
                                            borderLeftClass(idx), monthFrameLeftClass(idx), monthFrameRightClass(idx),
                                            isSel && "ring-2 ring-inset ring-neutral-900 dark:ring-neutral-200"
                                          )}
                                          onClick={() => {
                                            setAbsencesSelectedDateYmd(col.ymd);
                                            setAbsenceStatus(absencesSchoolYear, classId, st, col.ymd, nextStatus);
                                          }}
                                          title={`${st} ‚Äî ${formatYmdFr(col.ymd)}`}
                                        >
                                          {curStatus === "AB" ? (
                                            <span className="text-[10px] font-bold text-red-600 dark:text-red-200">AB</span>
                                          ) : curStatus === "RT" ? (
                                            <span className="text-[10px] font-bold text-amber-700 dark:text-amber-200">RT</span>
                                          ) : (
                                            ""
                                          )}
                                        </td>
                                      );
                                    })}
                                  </tr>
                                ))}
                              </tbody>
                            </table>
                          </div>
                        </div>
                      );
                    };

                    return (
                      <div ref={suiviAbsencesPdfRef} className="mt-0 space-y-3 absences-print-root">
                        <div className="hidden print-only rounded-md border border-neutral-300 bg-white px-3 py-3 text-[22px] leading-snug text-neutral-900">
                          <div className="text-[24px] font-extrabold leading-tight">Absences / retards{classLabel ? ` ‚Äî ${classLabel}` : ""}</div>
                          <div className="mt-1 text-[18px]">
                            Ann√©e scolaire : {absencesSchoolYear} ‚Ä¢ P√©riode : {formatYmdFr(absencesShowAllWeeks ? startYmd : (timelineDays[0]?.ymd || startYmd))} ‚Üí {formatYmdFr(endYmd)} ‚Ä¢ Vue : {absencesTimelineView === "day" ? "Jour" : "Semaine"}
                          </div>
                          <div className="mt-2 flex flex-wrap gap-3 items-center text-[13px] font-medium">
                            <span className="inline-flex items-center gap-2">
                              <span className="h-3 w-3 rounded-sm bg-blue-800/90" /> Vacances
                            </span>
                            <span className="inline-flex items-center gap-2">
                              <span className="h-3 w-3 rounded-sm bg-orange-200" /> PFMP
                            </span>
                            <span className="inline-flex items-center gap-2">
                              <span className="h-3 w-3 rounded-sm bg-white border border-neutral-300" /> Cours
                            </span>
                            <span className="inline-flex items-center gap-2">
                              <span className="h-3 w-3 rounded-full bg-red-500" /> AB
                            </span>
                            <span className="inline-flex items-center gap-2">
                              <span className="h-3 w-3 rounded-full bg-amber-500" /> RT
                            </span>
                          </div>
                        </div>

                        <div className="absences-controls flex flex-col gap-2 sm:flex-row sm:items-end sm:justify-between">
                          <div className="flex flex-wrap items-end gap-2">
                            <div className="space-y-1">
                              <Input
                                value={absencesSchoolYear}
                                onChange={(e) => setAbsencesSchoolYear(e.target.value)}
                                className="h-8 w-[132px] text-xs bg-white dark:bg-[var(--night-surface)] border border-neutral-300 dark:border-sky-400/35"
                                placeholder="2025-2026"
                              />
                            </div>

                            <Button
                              type="button"
                              variant="outline"
                              onClick={() => setAbsencesSettingsOpen(true)}
                              className="h-8 px-3 text-xs border border-neutral-300 dark:border-sky-400/35 bg-white hover:bg-amber-100/70 dark:bg-[var(--night-surface)] text-neutral-900 dark:text-neutral-300 hover:bg-amber-100/70 dark:hover:bg-[var(--night-hover)]"
                            >
                              Param√®tres du planning
                            </Button>

                            <Button
                              type="button"
                              variant="outline"
                              onClick={() => setAbsencesRecapOpen(true)}
                              className="h-8 px-3 text-xs border border-neutral-300 dark:border-sky-400/35 bg-white hover:bg-amber-100/70 dark:bg-[var(--night-surface)] text-neutral-900 dark:text-neutral-300 hover:bg-amber-100/70 dark:hover:bg-[var(--night-hover)]"
                            >
                              R√©cap absence/retard
                            </Button>
                          </div>

                          <div className="text-[11px] text-neutral-500 dark:text-neutral-300 flex flex-wrap gap-2 items-center">
                          <div className="inline-flex items-center gap-1 rounded-md border border-neutral-300 dark:border-sky-400/35 bg-white hover:bg-amber-100/70 dark:bg-[var(--night-surface)] px-1 py-1">
                            <button
                              type="button"
                              className="h-6 w-6 rounded border border-neutral-300 dark:border-sky-400/35 bg-white hover:bg-amber-100/70 dark:bg-[var(--night-surface)] text-neutral-900 dark:text-neutral-300 text-xs font-semibold leading-none hover:bg-amber-100/70 dark:hover:bg-[var(--night-hover)]"
                              onClick={() => setAbsencesDayColPx((v) => Math.max(12, v - 4))}
                              title="R√©tr√©cir les colonnes"
                            >
                              ‚àí
                            </button>
                            <span className="px-1 text-[11px] text-neutral-600 dark:text-neutral-300 whitespace-nowrap">
                              Taille
                            </span>
                            <button
                              type="button"
                              className="h-6 w-6 rounded border border-neutral-300 dark:border-sky-400/35 bg-white hover:bg-amber-100/70 dark:bg-[var(--night-surface)] text-neutral-900 dark:text-neutral-300 text-xs font-semibold leading-none hover:bg-amber-100/70 dark:hover:bg-[var(--night-hover)]"
                              onClick={() => setAbsencesDayColPx((v) => Math.min(80, v + 4))}
                              title="Agrandir les colonnes"
                            >
                              +
                            </button>
                          </div>

                            <span className="inline-flex items-center gap-1">
                              <span className="h-2 w-2 rounded-sm bg-blue-800/90 dark:bg-blue-900/45" /> Vacances
                            </span>
                            <span className="inline-flex items-center gap-1">
                              <span className="h-2 w-2 rounded-sm bg-orange-200 dark:bg-orange-900/25" /> PFMP
                            </span>
                            <span className="inline-flex items-center gap-1">
                              <span className="h-2 w-2 rounded-sm bg-white border border-neutral-300 dark:bg-[var(--night-surface)] dark:border-neutral-600" /> Cours
                            </span>
                            <span className="inline-flex items-center gap-1">
                              <span className="h-2 w-2 rounded-full bg-red-500" /> AB
                            </span>
                            <span className="inline-flex items-center gap-1">
                              <span className="h-2 w-2 rounded-full bg-amber-500" /> RT
                            </span>
                          </div>
                        </div>

                        {!absencesBootstrapped ? (
                          <p className="text-xs text-neutral-500">
                            Chargement de la base absences / retards‚Ä¶
                          </p>
                        ) : (
                          <div className="absences-grid grid grid-cols-1 lg:grid-cols-[1fr_360px] gap-3">
                            <div className="min-w-0">
                              {renderProgressionTable()}
                              <div className="hidden print-only" data-absences-recap-anchor="1" />
                            </div>

                            <div className="absences-sidepanel rounded-xl border border-neutral-200 dark:border-sky-400/35 bg-white dark:bg-[var(--night-panel)] p-3 h-fit lg:sticky lg:top-[140px]">
                              <div className="flex items-start justify-between gap-2">
                                <div>
                                  <div className="text-xs font-semibold text-neutral-900 dark:text-neutral-300">
                                    {selectedWeekday} {formatYmdFr(selectedDate)}
                                  </div>
                                  <div className="text-[11px] text-neutral-500 dark:text-neutral-300">
                                    AB : {selectedCounts.ab} ‚Ä¢ RT : {selectedCounts.rt}
                                  </div>
                                  {(selectedVacationLabel || selectedStageLabel) && (
                                    <div className="mt-1 text-[11px] text-neutral-600 dark:text-neutral-300">
                                      {selectedVacationLabel ? `Vacances : ${selectedVacationLabel}` : ""}
                                      {selectedVacationLabel && selectedStageLabel ? " ‚Ä¢ " : ""}
                                      {selectedStageLabel ? `PFMP : ${selectedStageLabel}` : ""}
                                    </div>
                                  )}
                                </div>
                              </div>

                              <div className="mt-3 flex flex-wrap gap-2">
                                <Button
                                  type="button"
                                  variant="outline"
                                  onClick={() =>
                                    setAbsenceStatusForAllStudents(
                                      absencesSchoolYear,
                                      classId,
                                      studentsAbs,
                                      selectedDate,
                                      null
                                    )
                                  }
                                  className="h-7 px-2 text-[11px] border border-neutral-300 dark:border-sky-400/35 bg-white hover:bg-amber-100/70 dark:bg-[var(--night-surface)] text-neutral-900 dark:text-white hover:bg-amber-100/70 dark:hover:bg-[var(--night-hover)]"

                                >
                                  Tous pr√©sents
                                </Button>
                                <Button
                                  type="button"
                                  variant="outline"
                                  onClick={() =>
                                    setAbsenceStatusForAllStudents(
                                      absencesSchoolYear,
                                      classId,
                                      studentsAbs,
                                      selectedDate,
                                      "RT"
                                    )
                                  }
                                  className="h-7 px-2 text-[11px] border border-neutral-300 dark:border-sky-400/35 bg-white hover:bg-amber-100/70 dark:bg-[var(--night-surface)] text-neutral-900 dark:text-white hover:bg-amber-100/70 dark:hover:bg-[var(--night-hover)]"
                                >
                                  Tous RT
                                </Button>
                                <Button
                                  type="button"
                                  variant="outline"
                                  onClick={() =>
                                    setAbsenceStatusForAllStudents(
                                      absencesSchoolYear,
                                      classId,
                                      studentsAbs,
                                      selectedDate,
                                      "AB"
                                    )
                                  }
                                  className="h-7 px-2 text-[11px] border border-neutral-300 dark:border-sky-400/35 bg-white hover:bg-amber-100/70 dark:bg-[var(--night-surface)] text-neutral-900 dark:text-white hover:bg-amber-100/70 dark:hover:bg-[var(--night-hover)]"

                                >
                                  Tous AB
                                </Button>
                              </div>

                              <div className="mt-3">
                                {studentsAbs.length === 0 ? (
                                  <p className="text-xs text-neutral-500">
                                    Ajoutez des √©l√®ves via le menu üìö Classe.
                                  </p>
                                ) : (
                                  <div className="space-y-2 max-h-[560px] overflow-auto pr-1">
                                    {studentsAbsFiltered.map((st) => {
                                      const cur = yearBucket?.[st]?.[selectedDate] || null;
                                      const isP = !cur;
                                      const isR = cur === "RT";
                                      const isA = cur === "AB";

                                      const r = studentRisk(st);
                                      const abp = Math.round(r.abPct || 0);

                                      const btnBase =
                                        "h-7 px-2 text-[11px] border border-neutral-300 dark:border-sky-400/35";
                                      const btnOn =
                                        "bg-neutral-900 text-white dark:bg-neutral-50 dark:text-neutral-300";
                                      const btnOff =
                                        "bg-white dark:bg-[var(--night-panel)] text-neutral-700 dark:text-neutral-300 hover:bg-amber-100/70 dark:hover:bg-[var(--night-hover)]";

                                      return (
                                        <div
                                          key={st}
                                          className={classNames(
                                            "flex items-center justify-between gap-2 rounded-lg border px-2 py-1.5 bg-white dark:bg-[var(--night-surface)]",
                                            studentCardTintClass(st)
                                          )}
                                        >
                                          <div className="min-w-0">
                                            <div className="flex items-center justify-between gap-2 min-w-0">
                                              <div className="text-xs font-medium text-neutral-900 dark:text-neutral-300 truncate">
                                                {st}
                                              </div>
                                              <div
                                                className={classNames(
                                                  "shrink-0 text-[10px] font-semibold tabular-nums",
                                                  r.tooAb
                                                    ? "text-red-700 dark:text-red-200"
                                                    : "text-neutral-600 dark:text-neutral-300"
                                                )}
                                                title={`Absences: ${r.ab} / ${effectiveCourseDaysSoFar} jours de cours`}
                                              >
                                                {effectiveCourseDaysSoFar > 0 ? `${abp}%` : "‚Äî%"}
                                              </div>
                                            </div>

                                            {(r.ab || r.rt) ? (
                                              <div className="text-[10px] text-neutral-600 dark:text-neutral-300 whitespace-nowrap">
                                                AB {r.ab} ‚Ä¢ RT {r.rt}
                                              </div>
                                            ) : null}
                                          </div>

                                          <div className="inline-flex rounded-md overflow-hidden">
                                            <button
                                              type="button"
                                              onClick={() =>
                                                setAbsenceStatus(
                                                  absencesSchoolYear,
                                                  classId,
                                                  st,
                                                  selectedDate,
                                                  null
                                                )
                                              }
                                              className={classNames(btnBase, isP ? btnOn : btnOff)}
                                              title="Pr√©sent"
                                            >
                                              ‚úì
                                            </button>
                                            <button
                                              type="button"
                                              onClick={() =>
                                                setAbsenceStatus(
                                                  absencesSchoolYear,
                                                  classId,
                                                  st,
                                                  selectedDate,
                                                  "RT"
                                                )
                                              }
                                              className={classNames(btnBase, isR ? btnOn : btnOff)}
                                              title="Retard"
                                            >
                                              RT
                                            </button>
                                            <button
                                              type="button"
                                              onClick={() =>
                                                setAbsenceStatus(
                                                  absencesSchoolYear,
                                                  classId,
                                                  st,
                                                  selectedDate,
                                                  "AB"
                                                )
                                              }
                                              className={classNames(btnBase, isA ? btnOn : btnOff)}
                                              title="Absent"
                                            >
                                              AB
                                            </button>
                                          </div>
                                        </div>
                                      );
                                    })}
                                  </div>
                                )}
                              </div>

                              {absencesPlanningSettings.vacationsMode === "auto" && (
                                <div className="mt-3 text-[11px] text-neutral-500 dark:text-neutral-300">
                                  Vacances auto (zone {absencesPlanningSettings.zone}) :{" "}
                                  {absencesAutoVacIsLoading ? "chargement‚Ä¶" : vacationRanges.length + " p√©riode(s)"}
                                </div>
                              )}
                            </div>
                          </div>
                        )}

                        {/* Drawer Param√®tres planning */}
                        <Drawer
                          open={absencesSettingsOpen}
                          onClose={() => setAbsencesSettingsOpen(false)}
                          side="right"
                          className="w-[360px] sm:w-[520px]"
                        >
                          <div className="px-4 py-3 border-b border-neutral-200 dark:border-sky-400/35">
                            <div className="text-sm font-semibold text-neutral-900 dark:text-neutral-300">
                              Planning annuel ‚Äî Absences / retards
                            </div>
                            <div className="text-xs text-neutral-500 dark:text-neutral-300 mt-0.5">
                              Ann√©e scolaire : {absencesSchoolYear}
                            </div>
                          </div>

                          <div className="p-4 space-y-4 text-neutral-900 dark:text-neutral-300">
                            {!selectedClassIdForSuivi ? (
                              <p className="text-sm text-neutral-600 dark:text-neutral-300">
                                S√©lectionnez une classeAbs pour r√©gler le planning.
                              </p>
                            ) : (
                              <>
                                <div className="grid grid-cols-2 gap-3">
                                  <div className="space-y-1">
                                    <Label className="text-xs">D√©but d'ann√©e</Label>
                                    <Input
                                      type="date"
                                      value={absencesPlanningSettings.startYmd}
                                      onChange={(e) =>
                                        updateAbsencesPlanning(absencesSchoolYear, selectedClassIdForSuivi, (cur) => ({
                                          ...cur,
                                          startYmd: e.target.value || cur.startYmd,
                                        }))
                                      }
                                      className="h-9 text-xs bg-white dark:bg-[var(--night-surface)]"
                                    />
                                  </div>
                                  <div className="space-y-1">
                                    <Label className="text-xs">Fin d'ann√©e</Label>
                                    <Input
                                      type="date"
                                      value={absencesPlanningSettings.endYmd}
                                      onChange={(e) =>
                                        updateAbsencesPlanning(absencesSchoolYear, selectedClassIdForSuivi, (cur) => ({
                                          ...cur,
                                          endYmd: e.target.value || cur.endYmd,
                                        }))
                                      }
                                      className="h-9 text-xs bg-white dark:bg-[var(--night-surface)]"
                                    />
                                  </div>
                                </div>

                                <div className="space-y-2">
                                  <Label className="text-xs">Selectionner les journ√©es de cours</Label>
                                  {(() => {
                                    const dayDefs: Array<{ k: keyof PlanningWeekdays; label: string }> = [
                                      { k: "mon", label: "L" },
                                      { k: "tue", label: "M" },
                                      { k: "wed", label: "M" },
                                      { k: "thu", label: "J" },
                                      { k: "fri", label: "V" },
                                    ];
                                    return (
                                      <div className="grid grid-cols-7 gap-2">
                                        {dayDefs.map((d) => (
                                          <label
                                            key={d.k}
                                            className="flex items-center justify-center gap-1 rounded-md border border-neutral-200 dark:border-sky-400/35 px-2 py-2 text-xs dark:bg-[var(--night-surface)]"
                                          >
                                            <input
                                              type="checkbox"
                                              checked={!!absencesPlanningSettings.courseDays?.[d.k]}
                                              onChange={(e) =>
                                                updateAbsencesPlanning(absencesSchoolYear, selectedClassIdForSuivi, (cur) => ({
                                                  ...cur,
                                                  courseDays: { ...cur.courseDays, [d.k]: e.target.checked },
                                                }))
                                              }
                                            />
                                            <span>{d.label}</span>
                                          </label>
                                        ))}
                                      </div>
                                    );
                                  })()}
                                </div>

                                <div className="flex items-center justify-end">
                                </div>


                                <div className="space-y-2 border-t border-neutral-200 dark:border-sky-400/35 pt-3">
                                  <div className="flex items-center justify-between gap-2">
                                    <Label className="text-xs">Vacances</Label>
                                    <div className="suivi-tabs inline-flex rounded-full border border-neutral-200 dark:border-sky-400/35 bg-neutral-50 dark:bg-[var(--night-surface)] p-1">
                                      <button
                                        type="button"
                                        onClick={() =>
                                          updateAbsencesPlanning(absencesSchoolYear, selectedClassIdForSuivi, (cur) => ({
                                            ...cur,
                                            vacationsMode: "auto",
                                          }))
                                        }
                                        className={classNames(
                                          "suivi-btn inline-flex items-center rounded-full transition",
                                          absencesPlanningSettings.vacationsMode === "auto"
                                            ? "bg-neutral-900 text-white"
                                            : "bg-transparent text-neutral-700 dark:text-neutral-300 hover:bg-amber-100/70 dark:hover:bg-[var(--night-hover)]"
                                        )}
                                      >
                                        Auto
                                      </button>
                                      <button
                                        type="button"
                                        onClick={() =>
                                          updateAbsencesPlanning(absencesSchoolYear, selectedClassIdForSuivi, (cur) => ({
                                            ...cur,
                                            vacationsMode: "manual",
                                          }))
                                        }
                                        className={classNames(
                                          "suivi-btn inline-flex items-center rounded-full transition",
                                          absencesPlanningSettings.vacationsMode === "manual"
                                            ? "bg-neutral-900 text-white"
                                            : "bg-transparent text-neutral-700 dark:text-neutral-300 hover:bg-amber-100/70 dark:hover:bg-[var(--night-hover)]"
                                        )}
                                      >
                                        Manuel
                                      </button>
                                    </div>
                                  </div>

                                  {absencesPlanningSettings.vacationsMode === "auto" ? (
                                    <div className="space-y-2">
                                      <div className="space-y-1">
<label className="text-neutral-900 dark:!text-neutral-50">Zone scolaire</label>

<select
  className="w-full rounded-md border border-neutral-200 bg-white px-3 py-2 text-sm text-neutral-900
             dark:border-sky-400/35 dark:bg-[var(--night-panel)] dark:text-neutral-300"
  value={absencesPlanningSettings.zone}
  onChange={(e) => {
    if (!selectedClassIdForSuivi) return;
    updateAbsencesPlanning(absencesSchoolYear, selectedClassIdForSuivi, (cur) => ({
      ...cur,
      zone: e.target.value as PlanningZone,
    }));
  }}
>
  <option value="A">Zone A</option>
  <option value="B">Zone B</option>
  <option value="C">Zone C</option>
</select>


                                      </div>

                                      <div className="text-xs text-neutral-500 dark:text-neutral-300">
                                        Vacances auto ‚Äî zone {absencesPlanningSettings.zone}.
                                        <div className="mt-1">
                                          {absencesAutoVacIsLoading
                                            ? "Chargement en cours‚Ä¶"
                                            : `${vacationRanges.length} p√©riode(s) charg√©e(s).`}
                                        </div>
                                        {absencesAutoVacErrorForKey && (
                                          <div className="mt-1 text-[11px] text-red-700 dark:text-red-300">
                                            Erreur: {absencesAutoVacErrorForKey}
                                          </div>
                                        )}
                                      </div>

                                      <Button
                                        type="button"
                                        variant="outline"
                                        onClick={() => {
                                          // Force reload
                                          setAbsencesAutoVacCache((prev) => {
                                            const n = { ...prev };
                                            delete n[absencesAutoVacKey];
                                            return n;
                                          });
                                        }}
                                        className="h-9 px-3 text-xs border border-neutral-300 dark:border-sky-400/35 bg-white hover:bg-amber-100/70 dark:bg-[var(--night-surface)] text-neutral-300 dark:text-white"
                                      >
                                        Charger ou recharger les vacances scolaires
                                      </Button>
                                    </div>
                                  ) : (
                                    <div className="space-y-2">
                                      {(absencesPlanningSettings.vacationsManual || []).length === 0 ? (
                                        <p className="text-xs text-neutral-500 dark:text-neutral-300">
                                          Aucune p√©riode saisie.
                                        </p>
                                      ) : (
                                        <div className="space-y-2">
                                          {(absencesPlanningSettings.vacationsManual || []).map((r, idx) => (
                                            <div
                                              key={String(idx)}
                                              className="rounded-lg border border-neutral-200 dark:border-sky-400/35 p-2 space-y-2"
                                            >
                                              <div className="grid grid-cols-2 gap-2">
                                                <Input
                                                  type="date"
                                                  value={r.startYmd}
                                                  onChange={(e) =>
                                                    updateAbsencesPlanning(absencesSchoolYear, selectedClassIdForSuivi, (cur) => {
                                                      const next = (cur.vacationsManual || []).slice();
                                                      next[idx] = { ...next[idx], startYmd: e.target.value };
                                                      return { ...cur, vacationsManual: next };
                                                    })
                                                  }
                                                  className="h-9 text-xs bg-white dark:bg-[var(--night-surface)]"
                                                />
                                                <Input
                                                  type="date"
                                                  value={r.endYmd}
                                                  onChange={(e) =>
                                                    updateAbsencesPlanning(absencesSchoolYear, selectedClassIdForSuivi, (cur) => {
                                                      const next = (cur.vacationsManual || []).slice();
                                                      next[idx] = { ...next[idx], endYmd: e.target.value };
                                                      return { ...cur, vacationsManual: next };
                                                    })
                                                  }
                                                  className="h-9 text-xs bg-white dark:bg-[var(--night-surface)]"
                                                />
                                              </div>

                                              <div className="flex items-center gap-2">
                                                <Input
                                                  value={r.label || ""}
                                                  onChange={(e) =>
                                                    updateAbsencesPlanning(absencesSchoolYear, selectedClassIdForSuivi, (cur) => {
                                                      const next = (cur.vacationsManual || []).slice();
                                                      next[idx] = { ...next[idx], label: e.target.value };
                                                      return { ...cur, vacationsManual: next };
                                                    })
                                                  }
                                                  placeholder="Label (ex: Vacances No√´l)"
                                                  className="h-9 text-xs bg-white dark:bg-[var(--night-surface)] flex-1"
                                                />
                                                <Button
                                                  type="button"
                                                  variant="outline"
                                                  onClick={() =>
                                                    updateAbsencesPlanning(absencesSchoolYear, selectedClassIdForSuivi, (cur) => {
                                                      const next = (cur.vacationsManual || []).slice();
                                                      next.splice(idx, 1);
                                                      return { ...cur, vacationsManual: next };
                                                    })
                                                  }
                                                  className="h-9 px-2 text-xs border border-neutral-300 dark:border-sky-400/35 bg-white hover:bg-amber-100/70 dark:bg-[var(--night-surface)] text-neutral-300 dark:text-white"
                                                  title="Supprimer"
                                                >
                                                  <X className="h-4 w-4" />
                                                </Button>
                                              </div>
                                            </div>
                                          ))}
                                        </div>
                                      )}

                                      <Button
                                        type="button"
                                        variant="outline"
                                        onClick={() =>
                                          updateAbsencesPlanning(absencesSchoolYear, selectedClassIdForSuivi, (cur) => ({
                                            ...cur,
                                            vacationsManual: [
                                              ...(cur.vacationsManual || []),
                                              { startYmd: cur.startYmd, endYmd: cur.startYmd, label: "Vacances" },
                                            ],
                                          }))
                                        }
                                        className="h-9 px-3 text-xs border border-neutral-300 dark:border-sky-400/35 bg-white hover:bg-amber-100/70 dark:bg-[var(--night-surface)] text-neutral-300 dark:text-white"
                                      >
                                        Ajouter une p√©riode
                                      </Button>
                                    </div>
                                  )}
                                </div>


                                <div className="space-y-2 border-t border-neutral-200 dark:border-sky-400/35 pt-3">
                                  <div className="flex items-center justify-between gap-2">
                                    <Label className="text-xs">PFMP</Label>
                                    <Button
                                      type="button"
                                      variant="outline"
                                      onClick={() =>
                                        updateAbsencesPlanning(absencesSchoolYear, selectedClassIdForSuivi, (cur) => ({
                                          ...cur,
                                          stages: [
                                            ...(cur.stages || []),
                                            { startYmd: cur.startYmd, endYmd: cur.startYmd, label: "PFMP" },
                                          ],
                                        }))
                                      }
                                      className="h-8 px-3 text-xs border border-neutral-300 dark:border-sky-400/35 bg-white hover:bg-amber-100/70 dark:bg-[var(--night-surface)]  text-neutral-300 dark:text-white"
                                    >
                                      Ajouter
                                    </Button>
                                  </div>

                                  {(absencesPlanningSettings.stages || []).length === 0 ? (
                                    <p className="text-xs text-neutral-500 dark:text-neutral-300">
                                      Aucune p√©riode de stage.
                                    </p>
                                  ) : (
                                    <div className="space-y-2">
                                      {(absencesPlanningSettings.stages || []).map((r, idx) => (
                                        <div
                                          key={String(idx)}
                                          className="rounded-lg border border-neutral-200 dark:border-sky-400/35 p-2 space-y-2"
                                        >
                                          <div className="grid grid-cols-2 gap-2">
                                            <Input
                                              type="date"
                                              value={r.startYmd}
                                              onChange={(e) =>
                                                updateAbsencesPlanning(absencesSchoolYear, selectedClassIdForSuivi, (cur) => {
                                                  const next = (cur.stages || []).slice();
                                                  next[idx] = { ...next[idx], startYmd: e.target.value };
                                                  return { ...cur, stages: next };
                                                })
                                              }
                                              className="h-9 text-xs bg-white dark:bg-[var(--night-surface)]"
                                            />
                                            <Input
                                              type="date"
                                              value={r.endYmd}
                                              onChange={(e) =>
                                                updateAbsencesPlanning(absencesSchoolYear, selectedClassIdForSuivi, (cur) => {
                                                  const next = (cur.stages || []).slice();
                                                  next[idx] = { ...next[idx], endYmd: e.target.value };
                                                  return { ...cur, stages: next };
                                                })
                                              }
                                              className="h-9 text-xs bg-white dark:bg-[var(--night-surface)]"
                                            />
                                          </div>

                                          <div className="flex items-center gap-2">
                                            <Input
                                              value={r.label || ""}
                                              onChange={(e) =>
                                                updateAbsencesPlanning(absencesSchoolYear, selectedClassIdForSuivi, (cur) => {
                                                  const next = (cur.stages || []).slice();
                                                  next[idx] = { ...next[idx], label: e.target.value };
                                                  return { ...cur, stages: next };
                                                })
                                              }
                                              placeholder="Label (ex: PFMP 1)"
                                              className="h-9 text-xs bg-white dark:bg-[var(--night-surface)] flex-1"
                                            />
                                            <Button
                                              type="button"
                                              variant="outline"
                                              onClick={() =>
                                                updateAbsencesPlanning(absencesSchoolYear, selectedClassIdForSuivi, (cur) => {
                                                  const next = (cur.stages || []).slice();
                                                  next.splice(idx, 1);
                                                  return { ...cur, stages: next };
                                                })
                                              }
                                              className="h-9 px-2 text-xs border border-neutral-300 dark:border-sky-400/35 bg-white hover:bg-amber-100/70 dark:bg-[var(--night-surface)] text-neutral-300 dark:text-white"
                                              title="Supprimer"
                                            >
                                              <X className="h-4 w-4" />
                                            </Button>
                                          </div>
                                        </div>
                                      ))}
                                    </div>
                                  )}
                                </div>
                                <div className="rounded-lg border border-neutral-200 dark:border-sky-400/35 bg-white dark:bg-[var(--night-surface)] p-3 space-y-2">
                                  <div className="text-xs font-semibold text-neutral-900 dark:text-neutral-300">
                                    Alertes Absences et retards
                                  </div>
                                  <div className="text-[11px] text-neutral-500 dark:text-neutral-300">
                                    Seuils en pourcentage calcul√©s sur les <b>{effectiveCourseDaysSoFar}</b> jours de cours effectifs (hors vacances et PFMP), du d√©but de l'ann√©e jusqu‚Äô√† aujourd‚Äôhui.
                                  </div>
                                  <div className="grid grid-cols-1 sm:grid-cols-2 gap-3">
                                    <div className="space-y-2">
                                      <div className="text-xs font-medium text-neutral-800 dark:text-neutral-300">Absences</div>
                                      <div className="grid grid-cols-2 gap-2">
                                        <div className="space-y-1">
                                          <Label className="text-xs">Orange (%)</Label>
                                          <Input
                                            type="number"
                                            min={0}
                                            max={100}
                                            step={0.5}
                                            value={String(absencesWarnAbsPct)}
                                            onChange={(e) => {
                                              const raw = (e.target.value || "0").replace(",", ".");
                                              const n = parseFloat(raw);
                                              if (!Number.isFinite(n)) return;
                                              setAbsencesWarnAbsPct(n);
                                            }}
                                            className="h-9 text-xs bg-white dark:bg-[var(--night-panel)]"
                                          />
                                        </div>

                                        <div className="space-y-1">
                                          <Label className="text-xs">Rouge (%)</Label>
                                          <Input
                                            type="number"
                                            min={0}
                                            max={100}
                                            step={0.5}
                                            value={String(absencesAlertAbsPct)}
                                            onChange={(e) => {
                                              const raw = (e.target.value || "0").replace(",", ".");
                                              const n = parseFloat(raw);
                                              if (!Number.isFinite(n)) return;
                                              setAbsencesAlertAbsPct(n);
                                            }}
                                            className="h-9 text-xs bg-white dark:bg-[var(--night-panel)]"
                                          />
                                        </div>
                                      </div>
                                      <div className="text-[11px] text-neutral-500 dark:text-neutral-300">
                                        Vert = &lt; Orange ‚Ä¢ Orange = ‚â• Orange ‚Ä¢ Rouge = ‚â• Rouge
                                      </div>
                                    </div>

                                    <div className="space-y-2">
                                      <div className="text-xs font-medium text-neutral-800 dark:text-neutral-300">Retards</div>
                                      <div className="grid grid-cols-2 gap-2">
                                        <div className="space-y-1">
                                          <Label className="text-xs">Orange (%)</Label>
                                          <Input
                                            type="number"
                                            min={0}
                                            max={100}
                                            step={0.5}
                                            value={String(absencesWarnRtPct)}
                                            onChange={(e) => {
                                              const raw = (e.target.value || "0").replace(",", ".");
                                              const n = parseFloat(raw);
                                              if (!Number.isFinite(n)) return;
                                              setAbsencesWarnRtPct(n);
                                            }}
                                            className="h-9 text-xs bg-white dark:bg-[var(--night-panel)]"
                                          />
                                        </div>

                                        <div className="space-y-1">
                                          <Label className="text-xs">Rouge (%)</Label>
                                          <Input
                                            type="number"
                                            min={0}
                                            max={100}
                                            step={0.5}
                                            value={String(absencesAlertRtPct)}
                                            onChange={(e) => {
                                              const raw = (e.target.value || "0").replace(",", ".");
                                              const n = parseFloat(raw);
                                              if (!Number.isFinite(n)) return;
                                              setAbsencesAlertRtPct(n);
                                            }}
                                            className="h-9 text-xs bg-white dark:bg-[var(--night-panel)]"
                                          />
                                        </div>
                                      </div>
                                      <div className="text-[11px] text-neutral-500 dark:text-neutral-300">
                                        Vert = &lt; Orange ‚Ä¢ Orange = ‚â• Orange ‚Ä¢ Rouge = ‚â• Rouge
                                      </div>
                                    </div>
                                  </div>
                                </div>
                                <div className="pt-3 flex justify-end">
                                  <Button
                                    type="button"
                                    onClick={() => setAbsencesSettingsOpen(false)}
                                    className="h-9 px-4 text-xs"
                                  >
                                    Fermer
                                  </Button>
                                </div>
                              </>
                            )}
                          </div>
                        </Drawer>
                          {/* Drawer R√©cap absence/retard */}
                        <Drawer
                          open={absencesRecapOpen}
                          onClose={() => setAbsencesRecapOpen(false)}
                          side="right"
                          className="w-[360px] sm:w-[860px]"
                        >
                          <div className="px-4 py-3 border-b border-neutral-200 dark:border-sky-400/35">
                            <div className="flex items-center justify-between gap-2">
                              <div className="min-w-0">
                                <div className="text-sm font-semibold text-neutral-900 dark:text-neutral-300">
                                  R√©cap absence/retard{classLabel ? ` ‚Äî ${classLabel}` : ""}
                                </div>
                                <div className="text-xs text-neutral-500 dark:text-neutral-300 mt-0.5">
                                  Ann√©e scolaire : {absencesSchoolYear} ‚Ä¢ Zone : {absencesPlanningSettings.zone} ‚Ä¢
                                  {" "}S1 ({formatSemesterRangeShort(semS1)}) ‚Ä¢ S2 ({formatSemesterRangeShort(semS2)})
                                </div>
                                <div className="text-[11px] text-neutral-500 dark:text-neutral-300 mt-0.5">
                                  Semestres calcul√©s automatiquement : S1 = d√©but d‚Äôann√©e ‚Üí d√©but des vacances d‚Äôhiver (zone) ; S2 = fin des vacances d‚Äôhiver ‚Üí d√©but des vacances d‚Äô√©t√©.
                                </div>
                              </div>

                              <button
                                type="button"
                                onClick={() => setAbsencesRecapOpen(false)}
                                className="h-8 w-8 inline-flex items-center justify-center rounded-md border border-neutral-200 dark:border-sky-400/35 bg-white dark:bg-[var(--night-panel)] text-neutral-900 dark:text-neutral-300 hover:bg-amber-100/70 dark:hover:bg-[var(--night-hover)] text-neutral-300 dark:text-white"
                                aria-label="Fermer"
                              >
                                <X className="h-4 w-4" />
                              </button>
                            </div>
                          </div>

                          <div className="p-4 space-y-4 text-neutral-900 dark:text-neutral-300">
                            <div className="grid grid-cols-1 sm:grid-cols-[1fr_auto] gap-3 items-end">
                              <div className="space-y-1">
                                <Label className="text-xs">P√©riode</Label>
                                <select
                                  className="block w-full border border-neutral-300 dark:border-sky-400/35 rounded-md bg-white dark:bg-[var(--night-surface)] text-neutral-900 dark:text-neutral-300 px-2 py-2 text-xs"
                                  value={absencesRecapSemesterKey}
                                  onChange={(e) => setAbsencesRecapSemesterKey(e.target.value as any)}
                                >
                                  <option value="ALL">Ann√©e scolaire</option>
                                  <option value="S1">Semestre 1</option>
                                  <option value="S2">Semestre 2</option>
                                </select>
                              </div>

                            </div>

                            {(() => {
                              const mode = absencesRecapSemesterKey;

                              const denomEffS1 = effectiveCourseDaysBySemesterSoFar.S1 || 0;
                              const denomEffS2 = effectiveCourseDaysBySemesterSoFar.S2 || 0;

                              const denomPlannedS1 = plannedCourseDaysBySemester.S1 || 0;
                              const denomPlannedS2 = plannedCourseDaysBySemester.S2 || 0;

                              const pct = (n: number, d: number) => (d > 0 ? (n / d) * 100 : null);

                              const rows = studentsAbs
                                .map((st) => {
                                  const sc = studentSemesterCounts[st] || { S1: { ab: 0, rt: 0 }, S2: { ab: 0, rt: 0 } };

                                  const abPctS1 = pct(sc.S1.ab, denomEffS1);
                                  const rtPctS1 = pct(sc.S1.rt, denomEffS1);
                                  const abPctS2 = pct(sc.S2.ab, denomEffS2);
                                  const rtPctS2 = pct(sc.S2.rt, denomEffS2);

                                  const tooAbS1 = absencesAlertAbsPct > 0 && abPctS1 != null && abPctS1 >= absencesAlertAbsPct;
                                  const tooRtS1 = absencesAlertRtPct > 0 && rtPctS1 != null && rtPctS1 >= absencesAlertRtPct;
                                  const tooAbS2 = absencesAlertAbsPct > 0 && abPctS2 != null && abPctS2 >= absencesAlertAbsPct;
                                  const tooRtS2 = absencesAlertRtPct > 0 && rtPctS2 != null && rtPctS2 >= absencesAlertRtPct;

                                  const midAbS1 = absencesWarnAbsPct > 0 && abPctS1 != null && abPctS1 >= absencesWarnAbsPct;
                                  const midRtS1 = absencesWarnRtPct > 0 && rtPctS1 != null && rtPctS1 >= absencesWarnRtPct;
                                  const midAbS2 = absencesWarnAbsPct > 0 && abPctS2 != null && abPctS2 >= absencesWarnAbsPct;
                                  const midRtS2 = absencesWarnRtPct > 0 && rtPctS2 != null && rtPctS2 >= absencesWarnRtPct;

                                  const maxAb = Math.max(abPctS1 ?? -1, abPctS2 ?? -1);
                                  const maxRt = Math.max(rtPctS1 ?? -1, rtPctS2 ?? -1);

                                  return {
                                    st,
                                    S1: { ...sc.S1, abPct: abPctS1, rtPct: rtPctS1, tooAb: tooAbS1, tooRt: tooRtS1, midAb: midAbS1, midRt: midRtS1 },
                                    S2: { ...sc.S2, abPct: abPctS2, rtPct: rtPctS2, tooAb: tooAbS2, tooRt: tooRtS2, midAb: midAbS2, midRt: midRtS2 },
                                    anyRed: tooAbS1 || tooRtS1 || tooAbS2 || tooRtS2,
                                    anyOrange: (midAbS1 || midRtS1 || midAbS2 || midRtS2) && !(tooAbS1 || tooRtS1 || tooAbS2 || tooRtS2),
                                    maxAb,
                                    maxRt,
                                  };
                                })
                                .sort((a, b) => {
                                  if (mode === "S1") {
                                    const ap = (b.S1.abPct ?? -1) - (a.S1.abPct ?? -1);
                                    if (ap !== 0) return ap;
                                    const rp = (b.S1.rtPct ?? -1) - (a.S1.rtPct ?? -1);
                                    if (rp !== 0) return rp;
                                  } else if (mode === "S2") {
                                    const ap = (b.S2.abPct ?? -1) - (a.S2.abPct ?? -1);
                                    if (ap !== 0) return ap;
                                    const rp = (b.S2.rtPct ?? -1) - (a.S2.rtPct ?? -1);
                                    if (rp !== 0) return rp;
                                  } else {
                                    const ap = (b.maxAb ?? -1) - (a.maxAb ?? -1);
                                    if (ap !== 0) return ap;
                                    const rp = (b.maxRt ?? -1) - (a.maxRt ?? -1);
                                    if (rp !== 0) return rp;
                                  }
                                  return a.st.localeCompare(b.st);
                                });

                              const fmtPct = (v: number | null) => (v == null ? "‚Äî" : `${Math.round(v * 10) / 10}%`);

                              const rowBg = (r: any) =>
                                r.anyRed
                                  ? "bg-red-50 dark:bg-red-950/25"
                                  : r.anyOrange
                                    ? "bg-amber-50 dark:bg-amber-950/25"
                                    : "bg-white dark:bg-[var(--night-panel)]";

                              const infoLine = () => {
                                if (mode === "S1") {
                                  return (
                                    <div className="text-[11px] text-neutral-600 dark:text-neutral-300">
                                      Jours de cours effectifs (jusqu‚Äô√† aujourd‚Äôhui) : <b>{denomEffS1}</b>{" "}
                                      <span className="text-neutral-500 dark:text-neutral-300">
                                        (pr√©vu : {denomPlannedS1})
                                      </span>
                                    </div>
                                  );
                                }
                                if (mode === "S2") {
                                  return (
                                    <div className="text-[11px] text-neutral-600 dark:text-neutral-300">
                                      SJours de cours effectifs (jusqu‚Äô√† aujourd‚Äôhui) : <b>{denomEffS2}</b>{" "}
                                      <span className="text-neutral-500 dark:text-neutral-300">
                                        (pr√©vu : {denomPlannedS2})
                                      </span>
                                    </div>
                                  );
                                }
                               };

                              return (
                                <div className="space-y-2">
                                  {infoLine()}

                                  <div className="rounded-lg border border-neutral-200 dark:border-sky-400/35 overflow-hidden">
                                    <div className="max-h-[70vh] overflow-auto">
                                      <table className="w-full border-collapse text-xs">
                                        <thead className="sticky top-0 bg-white dark:bg-[var(--night-panel)] z-10">
                                          {mode === "ALL" ? (
                                            <>
                                              <tr>
                                                <th className="text-left px-2 py-2 border-b border-neutral-200 dark:border-sky-400/35 w-[240px]" rowSpan={2}>
                                                  √âl√®ve
                                                </th>
                                                <th className="text-center px-2 py-2 border-b border-neutral-200 dark:border-sky-400/35" colSpan={4}>
                                                  Semestre 1 (S1)
                                                </th>
                                                <th className="text-center px-2 py-2 border-b border-neutral-200 dark:border-sky-400/35" colSpan={4}>
                                                  Semestre 2 (S2)
                                                </th>
                                              </tr>
                                              <tr>
                                                <th className="text-center px-2 py-2 border-b border-neutral-200 dark:border-sky-400/35 w-[70px]">AB</th>
                                                <th className="text-center px-2 py-2 border-b border-neutral-200 dark:border-sky-400/35 w-[80px]">AB %</th>
                                                <th className="text-center px-2 py-2 border-b border-neutral-200 dark:border-sky-400/35 w-[70px]">RT</th>
                                                <th className="text-center px-2 py-2 border-b border-neutral-200 dark:border-sky-400/35 w-[80px]">RT %</th>

                                                <th className="text-center px-2 py-2 border-b border-neutral-200 dark:border-sky-400/35 w-[70px]">AB</th>
                                                <th className="text-center px-2 py-2 border-b border-neutral-200 dark:border-sky-400/35 w-[80px]">AB %</th>
                                                <th className="text-center px-2 py-2 border-b border-neutral-200 dark:border-sky-400/35 w-[70px]">RT</th>
                                                <th className="text-center px-2 py-2 border-b border-neutral-200 dark:border-sky-400/35 w-[80px]">RT %</th>
                                              </tr>
                                            </>
                                          ) : (
                                            <tr>
                                              <th className="text-left px-2 py-2 border-b border-neutral-200 dark:border-sky-400/35 w-[260px]">
                                                √âl√®ve
                                              </th>
                                              <th className="text-center px-2 py-2 border-b border-neutral-200 dark:border-sky-400/35 w-[80px]">
                                                ABSENCE
                                              </th>
                                              <th className="text-center px-2 py-2 border-b border-neutral-200 dark:border-sky-400/35 w-[90px]">
                                                ABSENCE %
                                              </th>
                                              <th className="text-center px-2 py-2 border-b border-neutral-200 dark:border-sky-400/35 w-[80px]">
                                                RETARD 
                                              </th>
                                              <th className="text-center px-2 py-2 border-b border-neutral-200 dark:border-sky-400/35 w-[90px]">
                                                RETARD %
                                              </th>
                                            </tr>
                                          )}
                                        </thead>

                                        <tbody>
                                          {rows.map((r) => {
                                            const bg = rowBg(r);

                                            if (mode === "S1") {
                                              return (
                                                <tr key={r.st} className={bg}>
                                                  <td className="px-2 py-2 border-b border-neutral-200 dark:border-sky-400/35 whitespace-nowrap">
                                                    <span className="truncate inline-block max-w-[260px]" title={r.st}>
                                                      {r.st}
                                                    </span>
                                                  </td>
                                                  <td className="px-2 py-2 text-center border-b border-neutral-200 dark:border-sky-400/35 tabular-nums">{r.S1.ab}</td>
                                                  <td className="px-2 py-2 text-center border-b border-neutral-200 dark:border-sky-400/35 tabular-nums">{fmtPct(r.S1.abPct)}</td>
                                                  <td className="px-2 py-2 text-center border-b border-neutral-200 dark:border-sky-400/35 tabular-nums">{r.S1.rt}</td>
                                                  <td className="px-2 py-2 text-center border-b border-neutral-200 dark:border-sky-400/35 tabular-nums">{fmtPct(r.S1.rtPct)}</td>
                                                </tr>
                                              );
                                            }

                                            if (mode === "S2") {
                                              return (
                                                <tr key={r.st} className={bg}>
                                                  <td className="px-2 py-2 border-b border-neutral-200 dark:border-sky-400/35 whitespace-nowrap">
                                                    <span className="truncate inline-block max-w-[260px]" title={r.st}>
                                                      {r.st}
                                                    </span>
                                                  </td>
                                                  <td className="px-2 py-2 text-center border-b border-neutral-200 dark:border-sky-400/35 tabular-nums">{r.S2.ab}</td>
                                                  <td className="px-2 py-2 text-center border-b border-neutral-200 dark:border-sky-400/35 tabular-nums">{fmtPct(r.S2.abPct)}</td>
                                                  <td className="px-2 py-2 text-center border-b border-neutral-200 dark:border-sky-400/35 tabular-nums">{r.S2.rt}</td>
                                                  <td className="px-2 py-2 text-center border-b border-neutral-200 dark:border-sky-400/35 tabular-nums">{fmtPct(r.S2.rtPct)}</td>
                                                </tr>
                                              );
                                            }

                                            return (
                                              <tr key={r.st} className={bg}>
                                                <td className="px-2 py-2 border-b border-neutral-200 dark:border-sky-400/35 whitespace-nowrap">
                                                  <span className="truncate inline-block max-w-[260px]" title={r.st}>
                                                    {r.st}
                                                  </span>
                                                </td>

                                                <td className="px-2 py-2 text-center border-b border-neutral-200 dark:border-sky-400/35 tabular-nums">{r.S1.ab}</td>
                                                <td className="px-2 py-2 text-center border-b border-neutral-200 dark:border-sky-400/35 tabular-nums">{fmtPct(r.S1.abPct)}</td>
                                                <td className="px-2 py-2 text-center border-b border-neutral-200 dark:border-sky-400/35 tabular-nums">{r.S1.rt}</td>
                                                <td className="px-2 py-2 text-center border-b border-neutral-200 dark:border-sky-400/35 tabular-nums">{fmtPct(r.S1.rtPct)}</td>

                                                <td className="px-2 py-2 text-center border-b border-neutral-200 dark:border-sky-400/35 tabular-nums">{r.S2.ab}</td>
                                                <td className="px-2 py-2 text-center border-b border-neutral-200 dark:border-sky-400/35 tabular-nums">{fmtPct(r.S2.abPct)}</td>
                                                <td className="px-2 py-2 text-center border-b border-neutral-200 dark:border-sky-400/35 tabular-nums">{r.S2.rt}</td>
                                                <td className="px-2 py-2 text-center border-b border-neutral-200 dark:border-sky-400/35 tabular-nums">{fmtPct(r.S2.rtPct)}</td>
                                              </tr>
                                            );
                                          })}
                                        </tbody>
                                      </table>
                                    </div>
                                  </div>

                                </div>
                              );
                            })()}
                          </div>
                        </Drawer>
</div>
                    );
                  })()
                )
              )}

              {/* === VUE CLASSE === */}
              
              {suiviElevesMode === "docs" && (
                <>
              {!isTauriRuntime() && (
                <div className="rounded-lg border border-amber-200 bg-amber-50 dark:bg-amber-950/35 px-3 py-2 text-xs text-amber-800">
                  L&apos;enregistrement des PDF est disponible uniquement dans la version install√©e (Tauri).
                </div>
              )}

              {!ready ? (

              <p className="text-sm text-neutral-600 dark:text-neutral-300">
                S√©lectionnez une classe puis un √©l√®ve pour afficher ses documents.
              </p>
            ) : (
                            <div className="flex gap-3 items-start">
                <div className="flex-1 min-w-0">
                  <div className="grid grid-cols-1 gap-3">
                    {folders.map((f) => {
                      const files = docsFilesByFolder[f.key] || [];
                      return (
                        <div
                          key={f.key}
                          className="rounded-xl border border-neutral-200 dark:border-sky-400/35 bg-neutral-50 dark:bg-[var(--night-base)] p-3"
                        >
                          <div className="flex items-start justify-between gap-2">
                            <div>
                              <div className="text-sm font-semibold">{f.label}</div>
                            </div>

                            <Button
                              type="button"
                              className="h-7 px-2 text-xs border border-neutral-200 dark:border-sky-400/35 !bg-white dark:!bg-[var(--night-topbar)] !text-neutral-900 dark:!text-neutral-50 hover:!bg-amber-100/70 dark:hover:!bg-[var(--night-hover)]"
                              onClick={() => handleUploadPdf(f.key)}
                              disabled={!isTauriRuntime()}
                              title="Ajouter un PDF"
                            >
                              <Plus className="w-4 h-4 mr-1" /> Ajouter
                            </Button>
                          </div>

                          {files.length === 0 ? (
                            <p className="mt-3 text-xs text-neutral-500 dark:text-neutral-300">
                              Aucun PDF dans ce dossier.
                            </p>
                          ) : (
                            <div className="mt-3 space-y-2">
                              {files.map((it) => (
                                <div
                                  key={it.path}
                                  className="flex items-stretch rounded-lg border border-neutral-200 dark:border-sky-400/35 bg-white dark:bg-[var(--night-panel)] overflow-hidden"
                                >
                                  <button
                                    type="button"
                                    className="flex-1 text-left px-3 py-2 text-xs text-neutral-900 dark:text-neutral-300 hover:bg-amber-100/70 dark:hover:bg-[var(--night-hover)]"
                                    onClick={() => handleViewPdf(it.path)}
                                    title="Ouvrir"
                                  >
                                    <div className="font-medium text-[12px] line-clamp-1">{it.name}</div>
                                  </button>
                                  <Button
                                    type="button"
                                    variant="ghost"
                                    className="h-auto px-2 rounded-none btn-ghost-danger"
                                    title="Supprimer"
                                    onClick={(e) => {
                                      e.stopPropagation();
                                      handleDeletePdf(it.path);
                                    }}
                                  >
                                    <Trash2 className="w-4 h-4" />
                                  </Button>
                                </div>
                              ))}
                            </div>
                          )}
                        </div>
                      );
                    })}
                  </div>
                </div>

                {pdfViewer ? (
                  <aside className="w-[650px] h-[700px] shrink-0 hidden lg:flex flex-col rounded-xl border border-neutral-200 dark:border-sky-400/35 bg-white dark:bg-[var(--night-panel)] shadow-sm overflow-hidden">
                    <div className="flex items-center justify-between gap-2 px-3 py-2 border-b border-neutral-200 dark:border-sky-400/35">
                      <div className="min-w-0">
                        <div className="text-[11px] text-neutral-500 dark:text-neutral-300">Aper√ßu PDF</div>
                        <div className="text-xs font-semibold truncate" title={pdfViewer.name}>{pdfViewer.name}</div>
                      </div>
                      <div className="flex items-center gap-2">
                        <button
                          type="button"
                          className="px-2 py-1 rounded-md border border-neutral-200 dark:border-sky-400/35 text-[11px] bg-white dark:bg-[var(--night-surface)] hover:bg-amber-100/70"
                          onClick={() => window.open(pdfViewer.url, "_blank", "noopener,noreferrer")}
                          title="Ouvrir dans une nouvelle fen√™tre"
                        >
                          Ouvrir
                        </button>
                        <button
                          type="button"
                          className="h-8 w-8 inline-flex items-center justify-center rounded-md border border-neutral-200 dark:border-sky-400/35 bg-white dark:bg-[var(--night-surface)] hover:bg-amber-100/70"
                          onClick={() => setPdfViewer(null)}
                          aria-label="Fermer l'aper√ßu"
                          title="Fermer"
                        >
                          <X className="h-4 w-4" />
                        </button>
                      </div>
                    </div>

                    <div className="flex-1 bg-white dark:bg-[var(--night-surface)] overflow-auto p-3">
                      <div className="mx-auto w-full max-w-[660px] aspect-[148/210] bg-white rounded-xl shadow-sm border border-neutral-200 dark:border-sky-400/35 overflow-hidden">
                        <iframe
                          title={pdfViewer.name}
                          src={pdfViewer.url}
                          className="w-full h-full"
                        />
                      </div>
                    </div>
                  </aside>
                ) : (
                  <aside className="w-[420px] shrink-0 hidden lg:flex flex-col items-center justify-center rounded-xl border border-dashed border-neutral-200 dark:border-sky-400/35 bg-white/50 dark:bg-[var(--night-panel)] text-xs text-neutral-500 dark:text-neutral-300">
                    Cliquez sur un PDF pour l&apos;afficher ici.
                  </aside>
                )}
              </div>
            )}
                </>
              )}

            </div>

          </div>
          </>
        );
      })()}
    </section>
  </>
) : (

  <>
{/* üßÆ VUE NOTATION */}
<section className="space-y-4 px-2 sm:px-3 lg:px-4 pt-2 pb-12">
  {/* üîù BANDEAU STICKY : en retrait comme SUIVI */}
  <div className="sticky top-[67px] z-50 backdrop-blur border-b border-black dark:border-sky-400/35 bg-white/70 dark:bg-[var(--night-panel)]/70 dark:bg-[var(--night-panel)]/95 dark:border-[var(--night-border-strong)] dark:text-white night-banner">
    <div className="flex flex-col gap-4 sm:flex-row sm:items-end py-2 px-2 sm:px-4 lg:px-6">
      {/* üîÅ Mode NOTE : Devoirs / Tableau / Notation */}
      <div className="flex-1 space-y-1">
        <div className="suivi-tabs inline-flex rounded-full border border-neutral-200 dark:border-sky-400/35 bg-neutral-50 dark:bg-[var(--night-surface)] p-1">
          <button
            type="button"
            onClick={() => setNotesMode("devoirs")}
            className={classNames(
              "suivi-btn inline-flex items-center rounded-full transition",
              notesMode === "devoirs"
                ? "bg-neutral-900 text-white"
                : "bg-transparent text-neutral-700 dark:text-neutral-300 hover:bg-amber-100/70 dark:bg-[var(--night-surface)] dark:hover:bg-[var(--night-hover)]"
            )}
          >
          <span className="suivi-icon" aria-hidden="true">üìÅ</span>
          <span className="suivi-label sm:hidden">Devoirs</span>
          <span className="suivi-label hidden sm:inline">Devoirs par classe</span>
          </button>

          <button
            type="button"
            onClick={() => setNotesMode("tableau")}
            className={classNames(
              "suivi-btn inline-flex items-center rounded-full transition",
              notesMode === "tableau"
                ? "bg-neutral-900 text-white"
                : "bg-transparent text-neutral-700 dark:text-neutral-300 hover:bg-amber-100/70 dark:bg-[var(--night-surface)] dark:hover:bg-[var(--night-hover)]"
            )}
          >
          <span className="suivi-icon" aria-hidden="true">üìä</span>
          <span className="suivi-label sm:hidden">R√©cap.</span>
          <span className="suivi-label hidden sm:inline">R√©capitulatif des notes</span>
          </button>

          <button
            type="button"
            onClick={() => setNotesMode("notation")}
            className={classNames(
              "suivi-btn inline-flex items-center rounded-full transition",
              notesMode === "notation"
                ? "bg-neutral-900 text-white"
                : "bg-transparent text-neutral-700 dark:text-neutral-300 hover:bg-amber-100/70 dark:bg-[var(--night-surface)] dark:hover:bg-[var(--night-hover)]"
            )}
          >
          <span className="suivi-icon" aria-hidden="true">üéØ</span>
          <span className="suivi-label sm:hidden">Not.</span>
          <span className="suivi-label hidden sm:inline">Notation des comp√©tences</span>
          </button>
        </div>
      </div>

      {/* Ann√©e / Classe / √âl√®ve */}
      <div className="flex flex-wrap items-end gap-2 sm:ml-auto sm:justify-end">
        {/* Ann√©e : 1√®re / 2√®me */}
        <div className="suivi-tabs inline-flex rounded-full border border-neutral-200 dark:border-sky-400/35 bg-neutral-50 dark:bg-[var(--night-surface)] p-1">
          <button
            type="button"
            onClick={() => switchTrainingYear("premiere")}
            className={classNames(
              "suivi-btn inline-flex items-center rounded-full transition",
              trainingYear === "premiere"
                ? "bg-neutral-900 text-white"
                : "bg-transparent text-neutral-700 dark:text-neutral-300 hover:bg-amber-100/70 dark:hover:bg-[var(--night-hover)]"
            )}
          >
            1√®re
          </button>
          <button
            type="button"
            onClick={() => switchTrainingYear("deuxieme")}
            className={classNames(
              "suivi-btn inline-flex items-center rounded-full transition",
              trainingYear === "deuxieme"
                ? "bg-neutral-900 text-white"
                : "bg-transparent text-neutral-700 dark:text-neutral-300 hover:bg-amber-100/70 dark:hover:bg-[var(--night-hover)]"
            )}
          >
            2√®me
          </button>
        </div>

        {/* Classe */}
        <select
          className="h-8 w-[170px] sm:w-[220px] border border-neutral-300 dark:border-sky-400/35 rounded-md bg-white dark:bg-[var(--night-surface)] px-2 text-xs"
          value={selectedClassIdForSuivi ?? ""}
          onChange={(e) => {
            const next = e.target.value || null;
            setSelectedClassIdForSuivi(next);
            setSelectedStudentForSuivi(null);
            setSelectedEvalIdForClasse(null);
          }}
        >
          <option value="" disabled>Classe‚Ä¶</option>
          {classGroups.map((c) => (
            <option key={c.id} value={c.name}>
              {c.name}
            </option>
          ))}
        </select>

        {/* √âl√®ve */}
        {(() => {
          const classe = classGroups.find((c) => c.name === selectedClassIdForSuivi);
          const students = classe
            ? (classe.students || "")
                .split("\n")
                .map((s) => s.trim())
                .filter(Boolean)
            : [];
          const disabled = !classe || students.length === 0;

          return (
            <select
              className="h-8 w-[130px] sm:w-[160px] border border-neutral-300 dark:border-sky-400/35 rounded-md bg-white dark:bg-[var(--night-surface)] px-2 text-xs disabled:opacity-60"
              value={selectedStudentForSuivi ?? ""}
              onChange={(e) => setSelectedStudentForSuivi(e.target.value)}
              disabled={disabled}
            >
              <option value="" disabled>√âl√®ve‚Ä¶</option>
              {students.map((st) => (
                <option key={st} value={st}>
                  {st}
                </option>
              ))}
            </select>
          );
        })()}
      </div>
    </div>
  </div>

  {/* üëâ Contenu sous le bandeau */}
  {(() => {
    const classe = classGroups.find((c) => c.name === selectedClassIdForSuivi);

    if (!classe) {
      return (
        <p className="text-sm text-neutral-600 dark:text-neutral-300 px-2 sm:px-4 lg:px-6">
          Choisissez une classe pour afficher le tableau des notes.
        </p>
      );
    }

    if (notesMode === "devoirs") {
      return (
        <div ref={suiviClassePdfRef} className="mt-4 space-y-4">
          <div className="no-print flex items-center justify-between">
            <div>
              <h2 className="text-sm font-semibold text-neutral-900 dark:text-neutral-300">
                Devoirs par classe ‚Äì {classe.name}
              </h2>
            </div>
          </div>

          <div className="flex gap-2 items-start overflow-x-auto pb-6">
            {/* Colonne de boutons (T√¢ches) */}
            <div className="flex flex-col items-center mt-10 space-y-2">
              <button
                type="button"
                onClick={() => setShowTasksVolet((prev) => !prev)}
                className="w-8 h-16 flex items-center justify-center rounded-r-lg border border-neutral-300 dark:border-sky-400/35 bg-white hover:bg-amber-100/70 dark:bg-[var(--night-surface)] shadow-sm"
                title={
                  showTasksVolet
                    ? "Masquer le volet des t√¢ches"
                    : "Afficher le volet des t√¢ches"
                }
              >
                <span
                  className={
                    "text-[10px] font-semibold tracking-wide " +
                    (showTasksVolet ? "text-neutral-900 dark:text-neutral-300" : "text-neutral-500") +
                    " app-verticalHeaderWrap"
                  }
                  
                >
                  T√ÇCHES
                </span>
              </button>
            </div>

            {/* Volet T√¢ches TOTAL repliable */}
            <div className="flex flex-col gap-2">
              <div
                className={`transition-all duration-200 ease-in-out ${
                  showTasksVolet
                    ? "opacity-100 translate-x-0 w-auto min-w-[260px]"
                    : "opacity-0 -translate-x-4 w-0 pointer-events-none"
                }`}
              >
                {showTasksVolet && (
                  <TasksVoletTotal selectedClassId={selectedClassIdForSuivi} />
                )}
              </div>
            </div>

            {/* Zone principale : tableau combin√© S1 + S2 */}
            <div className="flex flex-col gap-4 flex-1 min-w-[600px]">
              <DoubleSemesterMatrix
                allCompetences={allCompetencesForSuivi}
                evalMetaList={evalMetaList}
                selectedClassId={selectedClassIdForSuivi}
                compsByEvalId={compsByEvalId}
                onAddDevoirS1={() => {
                  setClasseSemesterForSuivi("S1");
                  handleOpenDevoirDatabase();
                }}
                onAddDevoirS2={() => {
                  setClasseSemesterForSuivi("S2");
                  handleOpenDevoirDatabase();
                }}
                onRemoveDevoir={(ev) => {
                  handleRemoveEvalFromClasseSemester(ev.id);
                }}
                onOpenDevoir={handleOpenClasseDevoir}
              />
            </div>
          </div>
        </div>
      );
    }

    const students = (classe.students || "")
      .split("\n")
      .map((s) => s.trim())
      .filter(Boolean);

    const evalsForClass = evalMetaList.filter(
      (ev) => ev.group === classe.name && ev.semester !== "Ne pas utiliser de semestre"
    );

    const schoolYear = getCurrentSchoolYear();
    const notationsForYear = notationDB[schoolYear]?.[classe.name] || {};

    if (students.length === 0) {
      return (
        <p className="text-sm text-neutral-600 dark:text-neutral-300 px-2 sm:px-4 lg:px-6">
          Aucun √©l√®ve n&apos;est renseign√© pour cette classe. Ajoutez-les via üìö CLASSE.
        </p>
      );
    }

    if (evalsForClass.length === 0) {
      return (
        <p className="text-sm text-neutral-600 dark:text-neutral-300 px-2 sm:px-4 lg:px-6">
          Aucun devoir n&apos;est encore associ√© √† cette classe.
        </p>
      );
    }

    const evalsS1 = evalsForClass.filter((ev) => ev.semester === "S1");
    const evalsS2 = evalsForClass.filter((ev) => ev.semester === "S2");

    // ‚úÖ Important: orderedEvals reste dispo pour le mode "notation"
    const orderedEvals = [...evalsS1, ...evalsS2];

    if (notesMode === "tableau") {
      const renderNotesTable = (label: string, evals: EvalMeta[]) => {
        if (evals.length === 0) return null;

        return (
          <div className="space-y-2">
            <div className="text-xs font-semibold text-neutral-700 dark:text-neutral-300">
              {label}
            </div>

            <div className="border rounded-xl bg-white dark:bg-[var(--night-panel)] shadow-sm overflow-x-auto">
              <table className="w-full border-collapse table-fixed">
                <thead>
                  <tr className="bg-neutral-50 dark:bg-[var(--night-panel)]">
                    <th className="border px-2 py-1 text-left min-w-[160px]">
                      √âl√®ves
                    </th>

                    {evals.map((ev) => (
                      <th
                        key={ev.id}
                        className="border px-2 py-1 text-center min-w-[120px]"
                      >
                        <div className="font-semibold truncate">{ev.name}</div>
                      </th>
                    ))}
                  </tr>
                </thead>

                <tbody>
                  {students.map((st) => (
                    <tr
                      key={st}
                      className="odd:bg-white dark:bg-[var(--night-panel)] even:bg-neutral-50/60 dark:bg-[var(--night-panel)]/60"
                    >
                      <td className="border px-2 py-1 text-xs">{st}</td>

                      {evals.map((ev) => {
                        const evalBucket = (notationsForYear as any)[ev.id] || {};
                        const entry = evalBucket[st] as NotationEntry | undefined;
                        const mark = entry?.markOn20;
                        const engagement = entry?.engagementLevel ?? null;
                        const status = entry?.status;

                        const display =
                          status === "AB"
                            ? "AB"
                            : status === "N.NOT"
                            ? "N.NOT"
                            : typeof mark === "number"
                            ? mark.toFixed(2).replace(".", ",")
                            : "‚Äî";

                        const cellMarkBgClass =
                          status === "AB" || status === "N.NOT"
                            ? "bg-neutral-200 dark:bg-[var(--night-topbar)] text-neutral-800 dark:text-neutral-300 font-semibold"
                            : getMarkCellBg4Classes(mark);

                        const cellEngagementRingClass = engagement
                          ? engagement === "volontaire"
                            ? "ring-2 ring-emerald-500/70"
                            : engagement === "engage"
                            ? "ring-2 ring-emerald-400/60"
                            : engagement === "normal"
                            ? "ring-2 ring-neutral-400/50"
                            : engagement === "attente"
                            ? "ring-2 ring-amber-400/60"
                            : "ring-2 ring-red-400/60"
                          : "";

                        return (
                          <td
                            key={ev.id + "-" + st}
                            className={classNames(
                              "border px-2 py-1 text-center text-[11px] relative transition-colors",
                              mark != null
                                ? "text-neutral-800 dark:text-neutral-300"
                                : "text-neutral-400",
                              cellMarkBgClass,
                              cellEngagementRingClass,
                              engagement ? "ring-inset" : ""
                            )}
                          >
                            {display}
                          </td>
                        );
                      })}
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          </div>
        );
      };

      return (
        <div className="px-2 sm:px-4 lg:px-6 space-y-6 pb-20">
          {renderNotesTable("SEMESTRE 1", evalsS1)}
          {renderNotesTable("SEMESTRE 2", evalsS2)}
        </div>
      );
    }

    // üß© Mode NOTE = "notation"
    return (
      <div className="border rounded-xl bg-white dark:bg-[var(--night-panel)] shadow-sm p-4 text-sm text-neutral-600 dark:text-neutral-300 space-y-4 mx-6 sm:mx-6 lg:mx-auto lg:max-w-8xl">
        {/* S√©lecteurs √âL√àVE + DEVOIR */}
        <div className="grid gap-4 sm:grid-cols-2">
          {/* √âl√®ve */}
          <div className="space-y-1">
            <select
              className="block w-full border border-neutral-300 dark:border-sky-400/35 rounded-md bg-white dark:bg-[var(--night-surface)] px-2 py-1 text-xs"
              value={selectedNoteStudent ?? ""}
              onChange={(e) => setSelectedNoteStudent(e.target.value || null)}
            >
              <option value="">S√©lectionner un √©l√®ve</option>
              {students.map((st) => (
                <option key={st} value={st}>
                  {st}
                </option>
              ))}
            </select>
          </div>

          {/* Devoir */}
          <div className="space-y-1">
            <select
              className="block w-full border border-neutral-300 dark:border-sky-400/35 rounded-md bg-white dark:bg-[var(--night-surface)] px-2 py-1 text-xs"
              value={selectedNoteEvalId ?? ""}
              onChange={(e) => setSelectedNoteEvalId(e.target.value || null)}
            >
              <option value="">S√©lectionner un devoir</option>
              {(() => {
                const s1 = orderedEvals.filter((ev) => ev.semester === "S1");
                const s2 = orderedEvals.filter((ev) => ev.semester === "S2");
                const other = orderedEvals.filter(
                  (ev) => ev.semester !== "S1" && ev.semester !== "S2"
                );

                return (
                  <>
                    {s1.length > 0 && (
                      <optgroup label="Semestre 1">
                        {s1.map((ev) => (
                          <option key={ev.id} value={ev.id}>
                            {ev.name}
                          </option>
                        ))}
                      </optgroup>
                    )}

                    {s2.length > 0 && (
                      <optgroup label="Semestre 2">
                        {s2.map((ev) => (
                          <option key={ev.id} value={ev.id}>
                            {ev.name}
                          </option>
                        ))}
                      </optgroup>
                    )}

                    {other.length > 0 && (
                      <optgroup label="Autres">
                        {other.map((ev) => (
                          <option key={ev.id} value={ev.id}>
                            {ev.name}
                          </option>
                        ))}
                      </optgroup>
                    )}
                  </>
                );
              })()}
            </select>
          </div>
        </div>

        {/* Petit rappel (notation √©l√®ve) */}
        <div className="flex items-center justify-between gap-2 mt-1 min-h-[1.5rem]">
          <div className="text-xs text-neutral-500">
            {selectedNoteStudent && selectedNoteEvalId && (
              <span>
                Tu notes actuellement <strong>{selectedNoteStudent}</strong> sur le devoir{" "}
                <strong>
                  {orderedEvals.find((ev) => ev.id === selectedNoteEvalId)?.name}
                </strong>
                .
              </span>
            )}
          </div>
          <div />
        </div>

        {selectedNoteEvalId ? (
          <div className="mt-2">{renderNotationCriteree({ lockWeights: true })}</div>
        ) : (
          <div className="mt-2 text-xs text-neutral-500">
            Choisis un devoir pour afficher la grille de notation.
          </div>
        )}
      </div>
    );
  })()}
</section>
  </>
)}

      {/* Drawer Base des devoirs */}
      <Drawer
        open={devoirDBOpen}
        onClose={() => setDevoirDBOpen(false)}
        side="right"
        className="w-[380px] sm:w-[460px] bg-neutral-50 dark:bg-[var(--night-base)]"
      >
        <div className="px-4 py-3 border-b border-neutral-200 dark:border-sky-400/35 font-semibold bg-white dark:bg-[var(--night-panel)] text-neutral-900 dark:text-neutral-300">
          Base des devoirs
        </div>

        <div className="p-3 space-y-3 bg-neutral-50 dark:bg-[var(--night-base)]">
          {!isTauriRuntime() && (
            <p className="text-xs text-red-600">
              La base des devoirs est disponible uniquement dans la version install√©e (Tauri).
            </p>
          )}

{isTauriRuntime() && (
  <>
    <div className="flex items-center justify-between gap-2">
      <p className="text-xs text-neutral-600 dark:text-neutral-300">
        Liste des devoirs enregistr√©s dans le dossier <code>devoir</code>.
      </p>
      <Button
        type="button"
        className="h-7 px-2 text-xs border border-neutral-200 dark:border-sky-400/35 !bg-neutral-100 dark:!bg-[var(--night-topbar)] !text-neutral-900 dark:!text-neutral-50 hover:!bg-amber-100/70 dark:hover:!bg-[var(--night-hover)]"
        onClick={handleOpenDevoirDatabase}
      >
        üîÑ Actualiser
      </Button>
    </div>

    {/* ‚úÖ ICI : on met directement les Tabs (pas besoin du if savedDevoirs.length) */}
<div className="w-full">
  <Tabs
    value={devoirDBTab}
    onValueChange={(v) => setDevoirDBTab(v as "devoirs" | "corbeille")}
  >
      <TabsList className="suivi-tabs inline-flex rounded-full border border-neutral-200 dark:border-sky-400/35 bg-neutral-50 dark:bg-[var(--night-surface)] p-1 w-fit">
        <TabsTrigger
          value="devoirs"
          className="suivi-btn inline-flex items-center rounded-full transition !bg-transparent !text-neutral-700 dark:!text-neutral-300 hover:!bg-amber-100/70 dark:hover:!bg-[var(--night-hover)] data-[state=active]:!bg-neutral-900 data-[state=active]:!text-white"
        >
          Devoirs
        </TabsTrigger>
        <TabsTrigger
          value="corbeille"
          className="suivi-btn inline-flex items-center rounded-full transition !bg-transparent !text-neutral-700 dark:!text-neutral-300 hover:!bg-amber-100/70 dark:hover:!bg-[var(--night-hover)] data-[state=active]:!bg-neutral-900 data-[state=active]:!text-white"
        >
          Corbeille
        </TabsTrigger>
      </TabsList>

      <TabsContent value="devoirs" className="mt-2">
        {savedDevoirs.length === 0 ? (
          <p className="text-xs text-neutral-500 dark:text-neutral-300 mt-2">
            Aucun devoir enregistr√© pour l‚Äôinstant.
          </p>
        ) : (
          <div className="space-y-2 mt-2">
            {savedDevoirs.map((dv) => (
              <div
                key={dv.fileName}
                className="w-full border border-neutral-200 dark:border-sky-400/35 rounded-lg bg-white dark:bg-[var(--night-panel)] shadow-sm hover:bg-amber-100/70 dark:hover:bg-[var(--night-hover)] flex items-stretch"
              >
                <button
                  type="button"
                  onClick={() => handleSelectDevoirFromDatabase(dv)}
                  className="flex-1 text-left px-3 py-2 text-xs text-neutral-900 dark:text-neutral-300"
                >
                  <div className="font-medium text-[13px]">{dv.title}</div>
                  <div className="text-[11px] text-neutral-500 dark:text-neutral-300">
                    Fichier : {dv.fileName}
                  </div>
                  {dv.group && (
                    <div className="text-[11px] text-neutral-500 dark:text-neutral-300">
                      Classe : {dv.group}
                    </div>
                  )}
                  {dv.evaluationType && (
                    <div className="text-[11px] text-neutral-500 dark:text-neutral-300">
                      Type : {dv.evaluationType}
                    </div>
                  )}
                </button>

                <Button
                  type="button"
                  variant="ghost"
                  className="h-auto px-2 rounded-none rounded-r-lg btn-ghost-danger"
                  title="Mettre √† la corbeille"
                  onClick={(e) => {
                    e.stopPropagation();
                    moveDevoirToTrash(dv);
                  }}
                >
                  <Trash2 className="w-4 h-4" />
                </Button>
              </div>
            ))}
          </div>
        )}
      </TabsContent>

      <TabsContent value="corbeille" className="mt-2">
        {savedDevoirsTrash.length === 0 ? (
          <p className="text-xs text-neutral-500 dark:text-neutral-300 mt-2">Corbeille vide.</p>
        ) : (
          <div className="space-y-2 mt-2">
            {savedDevoirsTrash.map((dv) => (
              <div
                key={dv.fileName}
                className="w-full border border-neutral-200 dark:border-sky-400/35 rounded-lg bg-white dark:bg-[var(--night-surface)] shadow-sm hover:bg-amber-100/70 dark:hover:bg-[var(--night-hover)] px-3 py-2 text-xs text-neutral-900 dark:text-neutral-300"
              >
                <div className="font-medium text-[13px]">{dv.title}</div>
                <div className="text-[11px] text-neutral-500 dark:text-neutral-300">
                  Fichier : {dv.fileName}
                </div>

                <div className="mt-2 flex items-center gap-2">
                  <Button
                    type="button"
                    variant="outline"
                    className="btn-outline btn-xs"
                    onClick={() => restoreDevoirFromTrash(dv)}
                  >
                    Restaurer
                  </Button>

                  <Button
                    type="button"
                    className="btn-danger-solid btn-xs"
                    onClick={() => deleteDevoirPermanently(dv)}
                  >
                    Supprimer d√©finitivement
                  </Button>
                </div>
              </div>
            ))}
          </div>
        )}
      </TabsContent>
    </Tabs>
    </div>
  </>
)}

        </div>
      </Drawer>

      {/* Drawer de gestion de biblioth√®que */}
      <Drawer
        open={!!manageKey}
        onClose={() => setManageKey(null)}
        side="right"
        className="w-full max-w-lg p-6 bg-white dark:bg-[var(--night-panel)] dark:bg-neutral-950"
      >
        <div className="flex items-center justify-between">
          <h3 className="text-lg font-semibold text-neutral-900 dark:text-neutral-300">G√©rer les exigences</h3>
          <Button
            variant="ghost"
            className="h-9 w-9 p-0"
            onClick={() => setManageKey(null)}
            aria-label="Fermer"
          >
            <X className="w-5 h-5" />
          </Button>
        </div>

        {manageKey &&
          (() => {
            const { task, comp, item } = parseScopedCritKey(manageKey!);
            return (
              <div className="mt-2 text-xs text-neutral-500">
                {task && (
                  <div>
                    <span className="font-medium">T√¢che :</span> {task}
                  </div>
                )}
                <div>
                  <span className="font-medium">Comp√©tence :</span> {comp}
                </div>
                <div>
                  <span className="font-medium">√ätre capable :</span> {item}
                </div>
              </div>
            );
          })()}

        <div className="mt-4 flex items-center gap-2">
          <Input
            placeholder="Nouvelle exigence"
            value={drawerInput}
            onChange={(e) => setDrawerInput(e.target.value)}
          />
          <Button onClick={addDrawerExigence}>
            <Plus className="w-4 h-4 mr-1" />
            Ajouter
          </Button>
        </div>

        <div className="mt-4 space-y-2">
          {(manageKey ? (customExigences[manageKey] ?? []) : []).length === 0 ? (
            <div className="text-sm text-neutral-500">
              Aucune exigence personnalis√©e pour ce sous-crit√®re.
            </div>
          ) : (
            (manageKey ? (customExigences[manageKey] ?? []) : []).map((ex, idx) => (
              <div key={idx} className="flex items-center gap-2">
                <div className="flex-1 text-sm">{ex}</div>
                <Button
                  className="btn-danger-icon"
                  onClick={() => removeDrawerExigence(idx)}
                  title="Supprimer d√©finitivement de ma biblioth√®que"
                >
                  <Trash2 className="w-4 h-4" />
                </Button>
              </div>
            ))
          )}
        </div>

        <div className="mt-6 text-xs text-neutral-500">
          Ici, la corbeille supprime de votre <strong>biblioth√®que personnelle</strong> la
          s√©lection de la <strong>cellule</strong>, sans toucher √† la biblioth√®que.
        </div>
      </Drawer>

      <footer className="no-print fixed bottom-0 left-0 right-0 h-12 border-t bg-white/60 dark:bg-[var(--night-panel)]/60 backdrop-blur z-40">
        <div className="w-full px-2 py-4 text-xs text-neutral-500 flex items-center justify-between">
          <div>
            ¬© {new Date().getFullYear()} ¬∑ Prototype - P.Lecouillard ‚Äî √âvaluation CAP Ma√ßonnerie
          </div>
        </div>
      </footer>
    </div>
  );
}
